<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01-线程和进程</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/01-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/01-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li>并行：物理上的实现，在同一时间点上发生</li><li>并发：两个事件在一个时间段内发生，如单片机的单核多线程</li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul><li>进程：一个应用程序可以有多个进程，每一个进程有一个独立的内存空间</li><li>线程：一个进程可以并发运行多个线程，多个线程共享一个内存空间</li><li>进程调度：获得CPU使用权的线程才能执行，有分时调度和抢占式调度两种</li></ul><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="1-使用-Runtime-类的-exec-方法"><a href="#1-使用-Runtime-类的-exec-方法" class="headerlink" title="1.使用 Runtime 类的 exec() 方法"></a>1.使用 Runtime 类的 exec() 方法</h3><pre><code class="hljs java">Runtime runtime = Runtime.getRuntime();Process process = runtime.exec(<span class="hljs-string">&quot;notepad&quot;</span>);</code></pre><h3 id="2-使用-ProcessBuilder-类的-start-方法"><a href="#2-使用-ProcessBuilder-类的-start-方法" class="headerlink" title="2.使用 ProcessBuilder 类的 start() 方法"></a>2.使用 ProcessBuilder 类的 start() 方法</h3><pre><code class="hljs java">ProcessBuilder pb = <span class="hljs-keyword">new</span> ProcessBuilder(<span class="hljs-string">&quot;notepad&quot;</span>);pb.start();</code></pre><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>实现多线程的3种方式，更多高级用法见<a href="../02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/">线程的创建</a></p><ol><li>继承Thread类：只能单继承</li><li>实现Runnable接口：可以多实现, 无返回值, 需要获得返回值可以通过传递引用数据类型参数来实现（适合继承和实现，不适合匿名内部类和Lambda）</li><li>实现Callable接口：有异常，有返回值</li></ol><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;继承Thread&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;实现Runnable&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;实现Callable&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回值&quot;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ThreadDemo thread1 = <span class="hljs-keyword">new</span> ThreadDemo();        thread1.start();        Thread thread2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> RunnableDemo());        thread2.start();        FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> CallableDemo());        Thread thread3 = <span class="hljs-keyword">new</span> Thread(ft);        thread3.start();        System.out.println(ft.get());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-二叉树</title>
    <link href="/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="一、二叉树的遍历"><a href="#一、二叉树的遍历" class="headerlink" title="一、二叉树的遍历"></a>一、二叉树的遍历</h2><p><img src="../images/2019-12-24-17-07-29.png"></p><p>先来改个好听的名字 先序 = 跟节点先序；中序 = 跟节点中序；后序 = 根节点后序</p><ul><li>先序 ABDEGHCF </li><li>中序 DBGHEACF</li><li>后序 DHGEBFCA</li></ul><p><img src="../images/2019-12-24-16-53-08.png"></p><h2 id="二、二叉查找树（二叉搜索树、二叉排序树）"><a href="#二、二叉查找树（二叉搜索树、二叉排序树）" class="headerlink" title="二、二叉查找树（二叉搜索树、二叉排序树）"></a>二、二叉查找树（二叉搜索树、二叉排序树）</h2><p>在有序情况下，二分法可以将搜索元素的时间复杂度降低为O(log n)</p><p><img src="../images/94cad1c8a786c9179df9bed6c93d70cf3ac75763.jpg"></p><p>规则（左等、右等、不等都是合理的）</p><ol><li>左子树上所有结点的值均小于它的根结点的值；</li><li>右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树</li></ol><p>通过二叉查找树去查找元素，时间复杂度是O(log n) == 二叉树的深度</p><p>但是，最差情况为O(n)，二叉树退化成链表</p><p><img src="../images/%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.drawio.png"></p><h2 id="三、AVL完全平衡二叉树"><a href="#三、AVL完全平衡二叉树" class="headerlink" title="三、AVL完全平衡二叉树"></a>三、AVL完全平衡二叉树</h2><p>每增加/删除一次元素，当左右子树高差大于1，需要通过一次或多次树旋转来重新平衡这个树，使得二叉树重新平衡</p><h2 id="四、红黑树"><a href="#四、红黑树" class="headerlink" title="四、红黑树"></a>四、红黑树</h2><p>红黑树的底层数据结构是一棵特殊自平衡二叉查找树</p><ol><li>若一棵二叉查找树是红黑树，则它的任一子树必为红黑树.</li><li>红黑树不是严格意义上的平衡二叉树（AVL），左右子树高差有可能大于 1</li><li>根节点是黑色</li><li>所有叶子都是黑色</li><li>个红色节点的两个子节点都是黑色</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol><div class="note note-danger">            <p>插入的点一定为红色</p>          </div><h3 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1. 左旋"></a>1. 左旋</h3><p><img src="../images/%E5%B7%A6%E6%97%8B.gif"></p><p>父左下/子左上 中间换</p><h3 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2. 右旋"></a>2. 右旋</h3><ul><li>⚠️注意：右旋父亲和爷爷要变色，以父亲为支点旋转</li></ul><p><img src="../images/%E5%8F%B3%E6%97%8B.gif"></p><p>父右下/子右上 中间换</p><h3 id="3-颜色变换"><a href="#3-颜色变换" class="headerlink" title="3. 颜色变换"></a>3. 颜色变换</h3><p>条件</p><ol><li>插入节点的父节点为红</li><li>当前节点的叔节点为红</li></ol><p>变换</p><ol><li>父亲变</li><li>叔叔变</li><li>爷爷变</li></ol><h3 id="4-变换例子"><a href="#4-变换例子" class="headerlink" title="4. 变换例子"></a>4. 变换例子</h3><p><img src="../images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99.drawio.png"></p><ol><li>颜色变换</li><li>右子树左旋</li><li>左子树右旋</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>10-数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-二分查找</title>
    <link href="/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/04-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/04-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 适合有序 唯一 的搜索</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearch</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;        binarySearch(arr,<span class="hljs-number">8</span>, <span class="hljs-number">0</span>,arr.length+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-keyword">int</span> midIndex = (left+right)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (arr[midIndex] == key)&#123;            <span class="hljs-keyword">return</span> midIndex;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[midIndex] &lt; key)&#123;            <span class="hljs-keyword">return</span> binarySearch(arr,key,midIndex+<span class="hljs-number">1</span>,right);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> binarySearch(arr,key,left,midIndex);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>11-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-类加载机制</title>
    <link href="/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h1><h2 id="JVM的启动"><a href="#JVM的启动" class="headerlink" title="JVM的启动"></a>JVM的启动</h2><ol><li>java 程序启动</li></ol><h2 id="JVM的退出"><a href="#JVM的退出" class="headerlink" title="JVM的退出"></a>JVM的退出</h2><ol><li>进程结束</li><li>程序执行<code>System.exit(0)</code>方法</li><li>运行出现异常，没有捕获</li><li>平台强制退出</li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><img src="../images/2019-05-24-17-17-40.png"></p><ol><li>加载：将class文件加载到内存中，并生成<code>java.lang.Class</code>类的对象(<strong>字节码对象</strong>)，类加载由<code>Classloader</code>类加载器实现，程序员可以通过继承<code>Classloader</code>实现自己的类加载器</li><li>连接：<ol><li>验证：检测class文件的结构</li><li>准备：<strong>将静态成员变量加载到内存并设置默认值(static final变量初始化成指定值，static变量默认值，其他不初始化)</strong></li><li>解析：把类的二进制数据中的<strong>符号引用替换为直接引用</strong></li></ol></li><li>初始化：按行的顺序执行初始化操作<ul><li>遇到父类，初始化直接父类</li><li>执行静态代码块，执行静态成员变量赋值操作</li><li>若使用了其他类，必须先初始化该类</li></ul></li><li>使用：程序运行<ul><li>执行非静态代码块</li><li>初始化成员变量等</li></ul></li><li>卸载：当JVM停止时才发生</li></ol><ul><li>注意：jvm在加载类的过程中，对于静态字段只有直接定义这个字段的类才会被初始化，而<strong>不会触发子类的初始化</strong>（执行类初始化方法），与new 不一样</li></ul><p>构造器在不显示调用的父类构造器时会默认调用父类构造器</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p><a href="https://blog.csdn.net/x1032019725/article/details/81301614">类加载机制面试题分析</a></p><p>在进行分析时，分为<strong>类初始化方法</strong>，<strong>类实例化方法</strong></p><blockquote><p>准备：<br>用到 类初始化方法：静态成员变量 -&gt; 静态代码块<br>new 类实例化方法：普通成员变量 -&gt; 非静态代码块 -&gt; 构造器  </p></blockquote><ol><li>确定类变量的初始值：在类初始化的时候，在准备阶段jvm会为类变量（static修饰的变量）初始化，如对象会被初始化为null，int被初始化为0</li><li>找到入口执行：找到main方法，开始执行，在执行之前会对main方法所在类进行初始化</li><li>执行类初始化方法：jvm 会按顺序收集类变量的赋值语句、静态代码块，组成类初始化方法去执行</li><li>执行对象实例化方法：JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，组成对象实例化方法去执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>04-类加载及反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-线程的创建</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><h2 id="一、菜鸟–实现多线程的3种方式"><a href="#一、菜鸟–实现多线程的3种方式" class="headerlink" title="一、菜鸟–实现多线程的3种方式"></a>一、菜鸟–实现多线程的3种方式</h2><ol><li>继承Thread类：只能单继承</li><li>实现Runnable接口：可以多实现, 无返回值, 需要获得返回值可以通过传递引用数据类型参数来实现（适合继承和实现，不适合匿名内部类和Lambda）</li><li>实现Callable接口：有异常，有返回值</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 1. 继承Thread类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;继承Thread&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 2. 实现Runnable接口</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;实现Runnable&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 3. 实现Callable接口</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;实现Callable&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回值&quot;</span>;    &#125;&#125;<span class="hljs-comment">// 调用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ThreadDemo thread1 = <span class="hljs-keyword">new</span> ThreadDemo();        thread1.start();        Thread thread2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> RunnableDemo());        thread2.start();        FutureTask&lt;String&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> CallableDemo());        Thread thread3 = <span class="hljs-keyword">new</span> Thread(ft);        thread3.start();        System.out.println(ft.get());    &#125;&#125;</code></pre><h2 id="二、入门–匿名内部类实现"><a href="#二、入门–匿名内部类实现" class="headerlink" title="二、入门–匿名内部类实现"></a>二、入门–匿名内部类实现</h2><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;匿名内部类 Runnable&quot;</span>);    &#125;&#125;).start();</code></pre><h2 id="三、进阶–Lambda表达式实现"><a href="#三、进阶–Lambda表达式实现" class="headerlink" title="三、进阶–Lambda表达式实现"></a>三、进阶–Lambda表达式实现</h2><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(()-&gt; System.out.println(<span class="hljs-string">&quot;Lambda Runnable&quot;</span>)).start();</code></pre><h2 id="四、高阶–Executor实现"><a href="#四、高阶–Executor实现" class="headerlink" title="四、高阶–Executor实现"></a>四、高阶–Executor实现</h2><h3 id="1-使用Executor实现"><a href="#1-使用Executor实现" class="headerlink" title="1. 使用Executor实现"></a>1. 使用Executor实现</h3><ul><li><code>execute(Runnable runnable);</code>               // 无返回 无异常 异常无法捕获</li><li><code>Future&lt;?&gt; submit(Runnable task);</code>          // 执行成功返回null 能够捕获异常</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code>   // 执行成功返回&lt;T&gt; 能够捕获异常</li></ul><pre><code class="hljs java">ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);executor.execute(() -&gt; System.out.println(<span class="hljs-string">&quot;Executor execute runnable&quot;</span>));Future&lt;String&gt; future = executor.submit(() -&gt; <span class="hljs-string">&quot;Executor submit callable&quot;</span> );Future&lt;?&gt; future1 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Executor submit runnable&quot;</span>));<span class="hljs-comment">// get()阻塞线程</span>String s = future.get();Object o = future1.get();<span class="hljs-comment">// get(long timeout, TimeUnit unit)限时阻塞 10s未执行完则放弃结果，抛出TimeoutException异常</span><span class="hljs-keyword">try</span> &#123;    String s1 = future.get(<span class="hljs-number">10</span>, TimeUnit.SECONDS);&#125; <span class="hljs-keyword">catch</span> (TimeoutException e)&#123;    System.out.println(<span class="hljs-string">&quot;取值超时&quot;</span>);&#125;<span class="hljs-comment">// 异常捕获</span><span class="hljs-keyword">try</span> &#123;    executor.execute(() -&gt; System.out.println(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>));&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.println(<span class="hljs-string">&quot;捕获异常1&quot;</span> + e.getMessage());  <span class="hljs-comment">// 不会执行</span>&#125;Future&lt;?&gt; future = executor.submit(() -&gt; System.out.println(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<span class="hljs-keyword">try</span> &#123;    future.get();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.println(<span class="hljs-string">&quot;捕获异常2&quot;</span> + e.getMessage());  <span class="hljs-comment">// 会执行</span>&#125;</code></pre><h3 id="2-关闭Executor"><a href="#2-关闭Executor" class="headerlink" title="2. 关闭Executor"></a>2. 关闭Executor</h3><ul><li><code>void shutdown();</code>                              – <strong>非阻塞</strong>，执行完已经提交的任务后关闭<ul><li>线程池状态：SHUTDOWN</li><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li></ul></li><li><code>List&lt;Runnable&gt; shutdownNow();</code>                 – <strong>非阻塞</strong>，<strong>企图</strong>停止所有任务并返回未执行列表<ul><li>线程池状态：STOP</li><li>停止接收外部submit的任务</li><li>调用<code>Thread.interrupt()</code>方法停止正在执行线程【注1】</li><li>返回未执行的任务列表</li></ul></li></ul><blockquote><p>注1: 调用<code>Thread.interrupt()</code>方法停止正在执行线程, 如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</p></blockquote><pre><code class="hljs java">executor.shutdown();executor.shutdownNow();</code></pre><h3 id="3-监控Executor状态"><a href="#3-监控Executor状态" class="headerlink" title="3. 监控Executor状态"></a>3. 监控Executor状态</h3><ul><li><code>boolean awaitTermination(long t, TimeUnit u);</code> – <strong>阻塞</strong>，不会关闭线程池，返回线程池状态 一般结合shutdown使用<ul><li>awaitTermination 不会改变线程状态</li><li>继续接收外部submit的任务</li><li>两种情况下阻塞结束<ul><li>线程池关闭 – 返回true</li><li>超时 – 返回false</li></ul></li></ul></li></ul><pre><code class="hljs java">executor.awaitTermination(<span class="hljs-number">10</span>,TimeUnit.SECONDS);</code></pre><h2 id="五、晋级-ThreadPoolExecutor创建线程池"><a href="#五、晋级-ThreadPoolExecutor创建线程池" class="headerlink" title="五、晋级-ThreadPoolExecutor创建线程池"></a>五、晋级-ThreadPoolExecutor创建线程池</h2><div class="note note-success">            <p>唯一符合阿里巴巴规范开发的线程创建方法</p>          </div><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,                                    keepAliveTime, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 完整构造器</span>ThreadPoolExecutor( <span class="hljs-keyword">int</span> corePoolSize,                       <span class="hljs-comment">// 核心corePoolSize</span>                    <span class="hljs-keyword">int</span> maximumPoolSize,                    <span class="hljs-comment">// 最大池大小maximumPoolSize</span>                    <span class="hljs-keyword">long</span> keepAliveTime,                     <span class="hljs-comment">// 保持活动时间 当大于corePoolSize 空闲时间大于keepAliveTime的线程就会被关闭</span>                    TimeUnit unit,                          <span class="hljs-comment">// 时间单位TimeUnit.X</span>                    BlockingQueue workQueue,                <span class="hljs-comment">// 线程等待队列 1.少于corePoolSize直接加线程 2.达到corePoolSize加到队列排队 3.队列满了创建新的线程 4.大于maximumPoolSize拒绝</span>                    ThreadFactory threadFactory,            <span class="hljs-comment">// ThreadFactory线程工厂，提供创建新线程的功能。</span>                    RejectedExecutionHandler handler);      <span class="hljs-comment">// 被拒异常处理</span></code></pre><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>继承Thread/实现Runnable/实现Callable<ul><li>缺点：线程数量不可控</li></ul></li><li>Executors工厂创建线程池<ol><li>newCachedThreadPool：创建一个可缓存线程池<ul><li>优点：很灵活，弹性的线程池线程管理，用多少线程给多大的线程池，不用后及时回收，用则新建</li><li>缺点：一旦线程无限增长，会导致内存溢出。</li></ul></li><li>newFixedThreadPool ：<ul><li>优点：创建一个固定大小线程池，超出的线程会在队列中等待。</li><li>缺点：不支持自定义拒绝策略，大小固定，难以扩展</li></ul></li><li>newScheduledThreadPool ：<ul><li>优点：创建一个固定大小线程池，可以定时或周期性的执行任务。</li><li>缺点：任务是单线程方式执行，一旦一个任务失败其他任务也受影响</li></ul></li><li>newSingleThreadExecutor ：<ul><li>优点：创建一个单线程的线程池，保证线程的顺序执行</li><li>缺点：不适合并发</li></ul></li></ol></li><li>ThreadPoolExecutor 完美</li></ol><p>以上，就是多线程的创建方法了，如今你拥有了能力，但是能力是很危险的。程序员为了解决多线程问题引入多线程，然后程序员又要开始解决引入多线程问题带来的问题了</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-jwt验证</title>
    <link href="/99-Others/01-JWT/01-jwt%E9%AA%8C%E8%AF%81/"/>
    <url>/99-Others/01-JWT/01-jwt%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h1><p>json web tokens加密认证协议，用json和base64(字符压缩)，实现的验证方式</p><p>优点：</p><ul><li>支持跨域验证，解决cookies在快于问题场景表现不好的问题</li><li>无状态，Token中已经存储足够的信息，无需会话</li><li>性能高，HMACSH256算法的速度还是很利索的</li><li>这个Token不一定是唯一的</li></ul><h2 id="JWT格式说明"><a href="#JWT格式说明" class="headerlink" title="JWT格式说明"></a>JWT格式说明</h2><h3 id="Signature用于说明协议类型和加密算法"><a href="#Signature用于说明协议类型和加密算法" class="headerlink" title="Signature用于说明协议类型和加密算法"></a><strong>Signature</strong>用于说明协议类型和加密算法</h3><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>,    <span class="hljs-attr">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>&#125;</code></pre><h3 id="payload消息体，以下是一些参考标准，可以自定义-反正自己解析"><a href="#payload消息体，以下是一些参考标准，可以自定义-反正自己解析" class="headerlink" title="payload消息体，以下是一些参考标准，可以自定义(反正自己解析)"></a><strong>payload</strong>消息体，以下是一些参考标准，可以自定义(反正自己解析)</h3><ul><li>iss：Issuer，发行者</li><li>sub：Subject，主题</li><li>aud：Audience，观众</li><li>exp：Expiration time，过期时间</li><li>nbf：Not before</li><li>iat：Issued at，发行时间</li><li>jti：JWT ID</li></ul><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;iss&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>,    <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-string">&quot;80&quot;</span>&#125;</code></pre><h3 id="Signature加密部分，用于算法验证这个Token的合法性，类似校验"><a href="#Signature加密部分，用于算法验证这个Token的合法性，类似校验" class="headerlink" title="Signature加密部分，用于算法验证这个Token的合法性，类似校验"></a><strong>Signature</strong>加密部分，用于算法验证这个Token的合法性，类似校验</h3><p>包含三个部分：</p><ul><li>header</li><li>payload</li><li>secret:这是一个密码</li></ul><p>(header的base64位码 + . + payload的base64位码) 和 (secret)进行<strong>HMACSHA256</strong>算法计算</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> encodedString = base64UrlEncode(header) + <span class="hljs-string">&quot;.&quot;</span> + base64UrlEncode(payload);HMACSHA256(encodedString, <span class="hljs-string">&#x27;secret&#x27;</span>);</code></pre><p>将上述三个部分用**”.”**连起来就是我们的JWT协议了</p><pre><code class="hljs sh">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</code></pre><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="../images/01-01.jpg"></p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="Token生成"><a href="#Token生成" class="headerlink" title="Token生成"></a>Token生成</h3><pre><code class="hljs python"></code></pre><h3 id="Token验证"><a href="#Token验证" class="headerlink" title="Token验证"></a>Token验证</h3><pre><code class="hljs python"></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>01-JWT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Java面试题</title>
    <link href="/99-Others/00-%E9%9D%A2%E8%AF%95/01-Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/99-Others/00-%E9%9D%A2%E8%AF%95/01-Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面试100问"><a href="#Java面试100问" class="headerlink" title="Java面试100问"></a>Java面试100问</h1><h2 id="一、非技术问题"><a href="#一、非技术问题" class="headerlink" title="一、非技术问题"></a>一、非技术问题</h2><h3 id="01-自我介绍"><a href="#01-自我介绍" class="headerlink" title="01-自我介绍"></a>01-自我介绍</h3><h3 id="09-项目中遇到什么难题"><a href="#09-项目中遇到什么难题" class="headerlink" title="09-项目中遇到什么难题"></a>09-项目中遇到什么难题</h3><ol><li>问题还是有得，但Google和StackoverFlow和Github issuse基本都是能找到解决方案的<ol><li>从Tomcat换成Glassfish的payara 各种不兼容的问题，字符串编码问题</li><li>Dubbo的版本兼容问题，不同版本之间的Dubbo微服务之间的沟通</li><li>Elasticsearch同步问题，用过触发器，用过canal</li></ol></li><li>难题还是有的，而且找不到解决方案，于是我们公司都就这两个问题提交了专利申请，<ol><li>NLP的三元组溯源问题</li><li>客户想要自然语言搜索</li></ol></li></ol><h2 id="二、技术问题"><a href="#二、技术问题" class="headerlink" title="二、技术问题"></a>二、技术问题</h2><h3 id="01-Java跨平台原理"><a href="#01-Java跨平台原理" class="headerlink" title="01-Java跨平台原理"></a>01-Java跨平台原理</h3><p>Java 的设计理念是<strong>一次编译到处运行</strong>，编译指的是编译成字节码文件，字节码文件运行在JVM上，JVM负责与不同的操作系统指令集进行对接，程序员无需理会不同硬件和操作系统的差别，提供了统一的API.</p><h3 id="02-搭建一个Java开发环境"><a href="#02-搭建一个Java开发环境" class="headerlink" title="02-搭建一个Java开发环境"></a>02-搭建一个Java开发环境</h3><ol><li>下载JDK</li><li>下载Tomcat</li><li>下载Maven</li><li>【下载Tomcat】</li><li>设置环境变量</li><li>下载开发工具</li></ol><h3 id="03-int-占几个字节"><a href="#03-int-占几个字节" class="headerlink" title="03-int 占几个字节"></a>03-int 占几个字节</h3><table><thead><tr><th>基本数据类型</th><th>字节</th><th>二进制位</th><th>范围</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>-128~127</td></tr><tr><td>sort</td><td>2</td><td>16</td><td></td></tr><tr><td>int</td><td>4</td><td>32</td><td></td></tr><tr><td>long</td><td>8</td><td>64</td><td></td></tr><tr><td>float</td><td>4</td><td>32</td><td></td></tr><tr><td>double</td><td>8</td><td>64</td><td></td></tr><tr><td>char</td><td>2</td><td>16</td><td>‘\u0000-\uffff’</td></tr><tr><td>boolean</td><td></td><td>1</td><td></td></tr></tbody></table><h3 id="04-面向对象的特性"><a href="#04-面向对象的特性" class="headerlink" title="04-面向对象的特性"></a>04-面向对象的特性</h3><ol><li>封装：降低耦合</li><li>继承：提高代码重用</li><li>多态：用父类变量接收子类对象，具体调用时表现子类的特性（带例子）</li></ol><h3 id="05-jdk和Jre"><a href="#05-jdk和Jre" class="headerlink" title="05-jdk和Jre"></a>05-jdk和Jre</h3><p>jdk 包含 JRE </p><p>jdk: Java Development kits<br>jre: java run envelopment</p><h3 id="06-有了基本数据类型，为什么还需要包装类型？"><a href="#06-有了基本数据类型，为什么还需要包装类型？" class="headerlink" title="06-有了基本数据类型，为什么还需要包装类型？"></a>06-有了基本数据类型，为什么还需要包装类型？</h3><p>基本数据类型</p><ol><li>没有方法</li><li>不能当范型</li></ol><h3 id="07-‘-’和’equles’"><a href="#07-‘-’和’equles’" class="headerlink" title="07-‘==’和’equles’"></a>07-‘==’和’equles’</h3><p>==:<br>    1. 基本数据类型比较值<br>    2. 引用数据类型比较地址<br>equels:<br>    1. 如果对象重写equels, 调用对象的equals()方法进行比较 否则比较</p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>00-面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-继承</title>
    <link href="/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02-%E7%BB%A7%E6%89%BF/"/>
    <url>/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>关于继承中的构造器调用问题</p><pre><code class="hljs java"><span class="hljs-comment">// 1. 啥都没写自动有无参构造器</span><span class="hljs-comment">// 2. 写了无参构造器，调用你写的</span><span class="hljs-comment">// 3. 只写了有参构造器，子类在继承时必须显式调用父类的有参构造器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span></span>&#123;    <span class="hljs-comment">// do...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassA</span></span>&#123;    <span class="hljs-function">publci <span class="hljs-title">ClassB</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">super</span>();  <span class="hljs-comment">// 如果没有 写 super()，系统会自动添加 super();</span>        <span class="hljs-comment">// do...</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>02-面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-Http&amp;Https</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/06-Http&amp;Https/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/06-Http&amp;Https/</url>
    
    <content type="html"><![CDATA[<h1 id="Http-amp-Https"><a href="#Http-amp-Https" class="headerlink" title="Http&amp;Https"></a>Http&amp;Https</h1><p><img src="../images/5ab5c9ea15ce36d35970c9af6c2dc282e850b119.png"></p><h2 id="一、Http"><a href="#一、Http" class="headerlink" title="一、Http"></a>一、Http</h2><p>影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p><ul><li>安全：</li><li>带宽：增加缓存机制</li><li>延迟<ul><li>浏览器阻塞（HOL blocking）：浏览器请求数量限制</li><li>DNS 查询（DNS Lookup）：浏览器DNS缓存</li><li>建立连接（Initial connection）：减少频繁的三次握手</li></ul></li></ul><h3 id="Http1-x"><a href="#Http1-x" class="headerlink" title="Http1.x"></a>Http1.x</h3><ol><li>HTTP0.9：是HTTP协议的第一个版本，只允许发送get请求，并且不支持请求头。一次请求对应一次响应。是短连接。</li><li>HTTP1.0：<ol><li>请求与响应支持头域（支持请求头）</li><li>响应对象以一个响应状态行开始</li><li>响应对象不只局限于超文本</li><li>开始支持客户端通过post方法向web服务器提交数据，支持GET、HEAD、POST方法</li><li>支持长连接（但是默认还是使用短连接）</li></ol></li><li>Http1.1<ol><li>缓存</li><li>请求头增加Host</li><li>keeplive长链接(减少不必要的三次握手)</li></ol></li><li>Http2.0<ol><li>多路复用，会将传输的信息分割成小的信息和帧，降低延迟，提高吞吐量。</li><li>可以终端TCP连接。</li></ol></li></ol><h3 id="Http2-x"><a href="#Http2-x" class="headerlink" title="Http2.x"></a>Http2.x</h3><h2 id="二、Https"><a href="#二、Https" class="headerlink" title="二、Https"></a>二、Https</h2><p>网站需要申请CA证书</p><p><img src="../images/0.png"></p><p>解决了运营商劫持的问题，传输内容加密</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/heluan/p/8620312.html">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-详解TCP&amp;IP</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/02-%E8%AF%A6%E8%A7%A3TCP&amp;IP/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/02-%E8%AF%A6%E8%A7%A3TCP&amp;IP/</url>
    
    <content type="html"><![CDATA[<h1 id="详解TCP-amp-IP"><a href="#详解TCP-amp-IP" class="headerlink" title="详解TCP&amp;IP"></a>详解TCP&amp;IP</h1><h2 id="一、网络三要素"><a href="#一、网络三要素" class="headerlink" title="一、网络三要素"></a>一、网络三要素</h2><div class="note note-info">            <p>协议-IP-端口</p>          </div><p><code>http://hostname:port</code></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">百度百科</a></p><p>协议三要素</p><ol><li>语义:语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应</li><li>语法:语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>时序:时序是对事件发生顺序的详细说明。（也可称为“同步”）。</li></ol><p><img src="../images/2019-05-24-10-32-47.png"></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>传输层协议，TCP面向连接，UDP面向无连接</p><ul><li>特点：可靠，速度慢</li><li>三次握手</li></ul><p>报文格式</p><p><img src="../images/64380cd7912397ddb480a4110c5c4ab2d1a28709.jpg"></p><p>其中比较重要的字段有：</p><ol><li>序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li>确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</li><li>标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：<ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：发起一个新连接。</li><li>FIN：释放一个连接。</li></ul></li></ol><p>需要注意的是：</p><p>不要将确认序号ack与标志位中的ACK搞混了。确认方Ack=发起方Seq+1，两端配对</p><p><img src="../images/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpg"></p><ol><li>首先客户端向服务器端发送一段TCP报文，其中：<ul><li>标记位为SYN=1，表示“请求建立新连接”;</li><li>序号为Seq=X（X一般为1）；<br>随后客户端进入SYN-SENT阶段。</li></ul></li><li>服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：<ul><li>标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</li><li>序号为Seq=y；</li><li>确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。</li></ul></li><li>客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：<ul><li>标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；</li><li>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</li><li>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；<br>随后客户端进入ESTABLISHED阶段。</li></ul></li></ol><p>【例子1】快递员送货  </p><ol><li>您有个快递XXXX需要派送 你在家吗  </li><li>哦，XXXX到了，我在家，可以收快递  </li><li>我待会会把XXXX送给你  </li></ol><p>【例子2】考驾照</p><ol><li>安全员：准备好了吗</li><li>考生：准备好了</li><li>安全员：准备好了我们开始考试</li></ol><p><img src="../images/861fa058f2da35f8efa70b29bf7c45fd8689.gif"></p><h4 id="为什么两次握手不行"><a href="#为什么两次握手不行" class="headerlink" title="为什么两次握手不行"></a>为什么两次握手不行</h4><p>因为在server接收到client的连接请求后，client可能已经掉线了，这时候给client回了信息，client无法收到，而Server不应该处于等待状态。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="../images/48540923dd54564e5260495ce0006487d0584fb6.jpg"></p><p>第二次和第三次不能合并的原因，Server接到Client发来的关闭请求，需要回应，但是不表示Server已经具备关闭条件（比如说数据没收完），需要等待Server也准备好了再通知client，由Client发起关闭</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>特点：不可靠，可能会丢包，速度快</li></ul><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc">详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-集合框架总结</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/99-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/99-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="集合框架总结"><a href="#集合框架总结" class="headerlink" title="集合框架总结"></a>集合框架总结</h1><p><img src="../images/2019-05-04-20-04-36.png"></p><ul><li>Collection表示一组纯数据</li><li>Map表示K-Y</li></ul><p>本身线程安全的：Vector Stack HashTable<br>通过工具类同步原理：通过给每个方法加一个<code>synchronized&#123;&#125;</code>包围</p><h2 id="Collection–Interface"><a href="#Collection–Interface" class="headerlink" title="Collection–Interface"></a>Collection–Interface</h2><ul><li>set 无序，不重复</li><li>List 有序，重复</li><li>Queue 队列，FIFO，主要用于存储数据</li></ul><p><img src="../images/06-01.jpg"></p><h3 id="List–Interface"><a href="#List–Interface" class="headerlink" title="List–Interface"></a>List–Interface</h3><p>有序，重复，索引定位</p><ol><li>ArrayList <strong>动态数组</strong>，在插入时检查容量，不够时扩容。允许随机访问，查询快，插入慢，<strong>非同步</strong></li><li>LinkedList <strong>双向链表</strong>，不能随机访问，查询需遍历慢，插入快，<strong>非同步</strong></li><li>Vector <strong>动态数组</strong>，线程安全的ArrayList, <strong>同步</strong> 一般使用<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code></li><li>Stack继承于Vector，实现LIFO的堆栈，<strong>同步</strong> 一般使用<code>ArrayQueue</code>代替</li></ol><ul><li>ArrayList和LinkedList的大致区别：<ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li></ol></li></ul><h3 id="set–Interface"><a href="#set–Interface" class="headerlink" title="set–Interface"></a>set–Interface</h3><ol><li>HashSet <strong>HashMap</strong>中的Key实现，Hash算法存取和查找性能好，无序（内部排序）<strong>非同步</strong></li><li>LinkedHashSet 继承自<strong>HashSet</strong>，其底层是基于<strong>LinkedHashMap</strong>来实现的，有序(插入顺序)，<strong>非同步</strong></li><li>TreeSet <strong>TreeMap</strong>实现，有序，<strong>非同步</strong>，通过compareTo方法比较的是对象的ID，其他通过equals()方法。因此自定义对象必须实现<code>Comparable</code>接口</li></ol><p>LinkedHashSet 和 TreeSet 的有序是不同概念，LinkedHashSet的有序是插入顺序，TreeSet是元素的大小，这个特性由数据结构决定。</p><ul><li><p>Comparable 和 Comparator的区别</p><ol><li>Comparable 是指元素可排序，其方法<code>compareTo(Object o)</code>只需提供一个参数</li><li>Comparator 表示一个比较器功能，用于比较任意东西，其方法<code>compare(Object o2, Object o2)</code>需提供2个参数</li></ol></li><li><p>HashSet 的实现原理 详见<a href="06-Map/01-HashMap/">HashMap</a></p><ol><li>put函数的实现<ol><li>对key的hashCode()做hash，然后再计算在bucket中的index;</li><li>如果没碰撞直接放到bucket里，Bucket是一个最基础的存储单元, int hash, K key, V value, Node&lt;K,V&gt; nextkey是index，value是hashCode；</li><li>如果HashCode()相等，且equal()为false，以链表的形式存在buckets后；</li><li>如果hashCode()相等，且equal()而true, 替换old value(保证key的唯一性)</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol></li><li>get函数的实现<ol start="7"><li>bucket里的第一个节点，如果有冲突，则通过key.equals(k)去查找对应的entry</li><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ol></li></ol></li></ul><h2 id="Map–Interface"><a href="#Map–Interface" class="headerlink" title="Map–Interface"></a>Map–Interface</h2><p><img src="../images/06-02.jpg"></p><ol><li>HashMap <strong>AbstractMap</strong>实现，<strong>非同步</strong> 包含多种数据结构，<strong>数组、链表、红黑树</strong></li><li>HashTable <strong>Dictionary</strong>实现，<strong>同步</strong></li><li>LinkedHashMap <strong>HashMap</strong>的一个子类,<strong>非同步</strong></li><li>TreeMap <strong>红黑树</strong>实现</li></ol><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol><li>LinkedList 是List的实现 也是Queue的实现 <strong>双向链表</strong>，不能随机访问，查询需遍历慢，插入快，<strong>非同步</strong></li></ol><p>参考1：<a href="https://www.cnblogs.com/xiaoxi/p/6089984.html">java集合框架综述，详细比较</a><br>参考2：<a href="http://www.importnew.com/16658.html?yyue=a21bo.50862.201879">Java集合框架综述</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-OSI7层模型</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/01-OSI7%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/01-OSI7%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI7层网络模型"><a href="#OSI7层网络模型" class="headerlink" title="OSI7层网络模型"></a>OSI7层网络模型</h1><p><img src="../images/2019-05-24-10-03-45.png"></p><div class="note note-info">            <p>应用 表示 会话 传输 网络 数据 物理</p>          </div><h2 id="常见协议所属层级"><a href="#常见协议所属层级" class="headerlink" title="常见协议所属层级"></a>常见协议所属层级</h2><ul><li>HTTP 应用层</li><li>TCP UDP 传输层</li><li>IP 网络层</li><li>ping本身属于应用层 使用的ICMP协议是网络层</li></ul><p><img src="../images/2019-05-24-10-32-47.png"><br>来自<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-HashMap</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/05-Map/01-HashMap/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/05-Map/01-HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>map严格来说不是集合，不继承Collection接口,Map是顶层接口</p><ul><li>实现：HashMap是Map接口的实现之一(TreeMap,Hashtable等)，<strong>只允许一个key为null</strong>，<strong>允许多个value为null</strong>；</li><li>线程安全：HashMap本身线程不安全，ConcurrentHashMap是桶级线程安全的，Collections.synchronizedMap()和Hashtable()是Map级线程安全的</li></ul><p>map的Key是一个<code>Set</code>，value是一个<code>Collection</code>，因此<code>HashMap</code>的key就是<code>HashSet</code></p><h2 id="一、遍历方法"><a href="#一、遍历方法" class="headerlink" title="一、遍历方法"></a>一、遍历方法</h2><pre><code class="hljs java">Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<span class="hljs-keyword">for</span> (String k:map.keySet())&#123;    Object v = map.get(k);    <span class="hljs-comment">// TODO</span>&#125;<span class="hljs-keyword">for</span> (Object v:map.values())&#123;    <span class="hljs-comment">// TODO</span>&#125;map.forEach((k,v)-&gt;&#123;    <span class="hljs-comment">// TODO</span>&#125;);<span class="hljs-keyword">for</span> (Map.Entry&lt;String,Object&gt; entry:map.entrySet())&#123;    String k = entry.getKey();    Object v = entry.getValue();    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="二、源码解读"><a href="#二、源码解读" class="headerlink" title="二、源码解读"></a>二、源码解读</h2><p>注意，读HashMap的源码需要解析HashSet一起读</p><p>HashSet其实是依赖HashMap实现的，对，你没有听错，Set是由Map实现的，使用常量PRESENT作为Map的值</p><ul><li><p>put()</p><p>  <img src="../../images/Hashmap.drawio.png"></p>  <pre><code class="hljs java"><span class="hljs-comment">// HashSet</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.remove(o)==PRESENT;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">HashMap -- HashMap的Put算法,请结合HashSet食用，效果更佳</span><span class="hljs-comment">    1. 根据hash值计算index，判断在hash表是是否碰撞</span><span class="hljs-comment">    2. 如果没碰撞直接放到bucket里；</span><span class="hljs-comment">    3. 如果hashCode()相等，且key.equal()而true, 替换old value(保证key的唯一性)</span><span class="hljs-comment">    4. 如果HashCode()相等，且key.equal()为false，以链表的形式存在buckets后；</span><span class="hljs-comment">    5. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD 默认 8)，就把链表转换成红黑树；</span><span class="hljs-comment">    6. 如果bucket满了(超过load factor*current capacity)，就要resize。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-comment">// 1. 根据hash值计算index</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 2. 如果没碰撞直接放到bucket里；</span>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        Node&lt;K,V&gt; e; K k;        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-comment">// 3. 如果hashCode()相等，key.equals()相同 当前元素e=已经存在的元素p</span>            e = p;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            <span class="hljs-comment">// 已经存在的元素p是Tree 当前元素e=保存到Tree中的元素</span>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 4. 如果hashCode()相等，key.equals()不同</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// 4. 以链表的形式存在buckets后；</span>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        <span class="hljs-comment">// 5. 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            <span class="hljs-comment">// 3. 替换old value(保证key的唯一性)</span>            V oldValue = e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;    <span class="hljs-comment">// 6. 如果bucket满了(超过load factor*current capacity)，就要resize。</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></li><li><p>get()</p>  <pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">1. bucket里的第一个节点开始检查，如果有冲突，则通过key.equals(k)去查找对应的entry</span><span class="hljs-comment">2. 若为树，则在树中通过key.equals(k)查找，O(logn)；</span><span class="hljs-comment">3. 若为链表，则在链表中通过key.equals(k)查找，O(n)。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></li></ul><h2 id="三、总结及Hashtable对比"><a href="#三、总结及Hashtable对比" class="headerlink" title="三、总结及Hashtable对比"></a>三、总结及Hashtable对比</h2><p>1） 历史原因: Hashtable继承Dictonary类, HashMap继承自abstractMap<br>2） HashMap允许空的键值对, 但最多只有一个空对象，而HashTable不允许。<br>3） HashTable同步，而HashMap非同步，效率上比HashTable要高</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>05-Map</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Arrays</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/06-%E5%B7%A5%E5%85%B7%E7%B1%BB/01-Arrays/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/06-%E5%B7%A5%E5%85%B7%E7%B1%BB/01-Arrays/</url>
    
    <content type="html"><![CDATA[<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p><a href="../../../../01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03-%E6%95%B0%E7%BB%84/">数组</a></p><h2 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);&#125;</code></pre><p>对应Collection接口的<code>&lt;T&gt; T[] toArray(T[] a);</code>方法</p><p>值得注意的是，<strong>这个返回的对象与我们常见的ArrayList是不一样的,返回的是<code>Arrays.ArrayList</code>对象</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@serial</span> include</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-comment">///...</span>&#125;<span class="hljs-comment">// 正确的接收方式</span>List&lt;String&gt; list = Arrays.asList(args);<span class="hljs-comment">// 错误的接收方式</span>ArrayList&lt;String&gt; list = Arrays.asList(args);</code></pre><p>且，内部类的ArrayList是不可变长度的，也就是说，<code>list.add(&quot;a&quot;)</code>是错误的</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>06-工具类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-ArrayList</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/03-ArrayList/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/03-ArrayList/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ul><li>使用的数据结构：数组</li><li>使用建议：建议使用<ul><li>在非多线程环境下，使用<code>ArrayList</code></li><li>在多线程环境下使用<code>List list = Collections.synchronizedList(new ArrayList(...));</code></li></ul></li></ul><p><code>ArrayList</code>是在集合框架中用于替代<code>Vector</code>的存在，其功能和<code>Vector</code>一致，实现方式也相同</p><ul><li><p>与Vector的区别：</p><ul><li><code>Vector</code>中的方法是同步的，线程安全，性能较低</li><li><code>ArrayList</code>中的方法是非同步的，性能较高</li></ul></li><li><p>源码分析</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">// 在java6时与Vector基本一致，只是非同步</span><span class="hljs-comment">// java7开始，默认构造器默认值为0</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<span class="hljs-comment">// 使用了常量长度为0的数组作为默认值，减少开销</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="hljs-comment">// 在第一次add()时初始化为长度10</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="hljs-number">0</span> : EFAULT_CAPACITY;    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;        ensureExplicitCapacity(minCapacity);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">// 在源码中的grow()函数可以看到，oldCapacity &gt;&gt; 1 也就是0.5倍</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>与Vector区别：</p><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>ArrayList在new ArrayList()时，数组长度为0（第一次add时为10），Vector在new Vector()时，数组长度为10</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>01-List</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Vector</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/01-Vector/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/01-Vector/</url>
    
    <content type="html"><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li>使用数据结构：数组</li><li>使用建议：不建议使用<ul><li>在非多线程环境下，使用<code>ArrayList</code></li><li>在多线程环境下使用<code>List list = Collections.synchronizedList(new ArrayList(...));</code></li></ul></li></ul><p><code>Vector</code>类是java集合框架出现之前就存在的容器类，可以实现可增长的对象数组</p><ul><li>源码分析：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">// Vector中的元素</span>    <span class="hljs-keyword">protected</span> Object[] elementData;    <span class="hljs-comment">// 定义元素数量</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> elementCount;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 完整构造器</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> initialCapacity 数组初始长度</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> capacityIncrement 每次长度不足时增加的长度，为0时为加倍</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                            initialCapacity);        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];        <span class="hljs-keyword">this</span>.capacityIncrement = capacityIncrement;    &#125;    <span class="hljs-comment">// 构造器，指定数组长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// 无参构造器，默认长度为10</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);    &#125;    <span class="hljs-comment">// jdk1.2之前添加元素的方法，同步</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(E obj)</span> </span>&#123;        modCount++;        ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);        elementData[elementCount++] = obj;    &#125;    <span class="hljs-comment">// jdk1.2加入集合框架后添加元素的方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        modCount++;        ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);        elementData[elementCount++] = e;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p><strong>分析结果</strong>：</p><ol><li>Vector是一个基于数组实现的集合类，其方法是同步的，线程安全的</li><li>数组扩容，默认数组长度为10，可以通过构造器<code>Vector(5)</code>改变，默认数组长度不足时，进行翻倍处理（10-20-40-80）,由于数组长度不可变，实际实现是创建新的Array，然后将旧的拷贝到新的Array中</li><li>集合中只能存储对象类型不能存储基本数据类型，但是在jdk1.5会进行自动装箱，因此<code>vector.add(123)</code>会自动装箱成Integer类型</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><code>Vector</code>是线程安全的可变长度数组，是JAVA集合框架List接口的实现，增加长度通过数据复制实现</p><p>与Arraylist区别：</p><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>ArrayList在new ArrayList()时，数组长度为0（第一次add时为10），Vector在new Vector()时，数组长度为10</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>01-List</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-面向对象总结</title>
    <link href="/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/99-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h1><p>知识点：</p><ul><li>面向对象的三大特性：封装、继承、多态</li><li>public private protect abstract static final 关键字的作用</li><li>重载和重写（复写、覆盖）</li><li>抽象类和接口的区别</li><li>int 和 Integer区别</li><li>String与StringBuffer、StringBuilder的区别</li></ul><h2 id="1-面向对象的三大特性"><a href="#1-面向对象的三大特性" class="headerlink" title="1. 面向对象的三大特性"></a>1. 面向对象的三大特性</h2><h3 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1 封装"></a>1.1 封装</h3><ul><li>概念：隐藏对象的实现细节，对外提供公共的访问方法</li><li>好处：降低复杂性，降低耦合度，提高鲁棒（健壮）性</li><li>原则：<ol><li>private 私有方法</li><li>private 所以属性，提供公共访问方法getter setter</li></ol></li></ul><p>⚠️提示：在反射时，private不一定安全</p><h3 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2 继承"></a>1.2 继承</h3><ul><li>概念：继承包括 类的继承 接口的继承 接口的实现</li><li>好处：提高代码重用性，让类之间有了联系</li><li>特点：<ol><li>JAVA中类单继承，接口多继承, 一个类可以实现多个接口</li><li>所有类都是Object的子类</li></ol></li></ul><p>继承 “Is a”<br>实现 “Like a”</p><h3 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3 多态"></a>1.3 多态</h3><ul><li>概念：一个引用在不同情况下表现不同的状态，父类对象的引用调用子类的方法</li><li>好处：提高鲁棒性，</li><li>特点：<ol><li>该引用对象最终类型为实际类型 如 Object s = “S”; =&gt; s instanceof String = true</li><li>常用于单个接口多种实现类，如List Set Collection等  </li></ol></li></ul><h2 id="2-修饰关键字"><a href="#2-修饰关键字" class="headerlink" title="2. 修饰关键字"></a>2. 修饰关键字</h2><h3 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1 作用域"></a>2.1 作用域</h3><table><thead><tr><th>作用域</th><th>当前类</th><th>包内</th><th>子类</th><th>包外</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>不写</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h3 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h3><ol><li>静态方法：通过类名调用的方法(也可以import static)，不能直接调用<strong>非static变量/方法</strong>(需通过对象调用)</li><li>静态变量：通过类名调用的变量，加载类的时候就加载到内存，开辟内存空间(不需要显式初始化)</li><li>静态代码块：加载类时执行初始化方法</li><li>静态子类：<strong>其实子类只是在类中存放，子类的调用并不会导致原本的类被初始化</strong></li></ol><p>类加载到<strong>方法区</strong>不等于初始化，类在被调用时才会执行初始化，详见<a href="../../06-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">JVM内存模型</a></p><p>代码初始化顺序 详见<a href="../../04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">类加载机制</a></p><div class="note note-success">            <p>父类静态变量 -&gt; 父类静态代码块 -&gt; 子类静态变量 -&gt; 子类静态代码块 -&gt;<br>父类成员变量 -&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt;<br>子类成员变量 -&gt; 子类非静态代码块 -&gt; 子类构造器 -&gt; </p>          </div> <h3 id="2-3-final"><a href="#2-3-final" class="headerlink" title="2.3 final"></a>2.3 final</h3><ul><li>fianl修饰的类：不能作为父类被继承</li><li>final修饰的变量：<ol><li>必须显式初始化(可以在变量中、代码块、构造器任意一个地方初始化)</li><li>基本数据类型值不能改变</li><li>引用数据类型指针不能改变，值可以改变（注意String Long等赋值会改变指针, 详见源码<code>valueOf</code>）</li><li>创建值不能改变的Collection <code>Collections.unmodifiableList(new ArrayList&lt;&gt;());</code></li></ol></li><li>fianl修饰的方法：不能被重写</li></ul><p>⚠️提示：区别finally finalize</p><ul><li>finally: try… catch… finally</li><li>finalize: GC在删除对象之前调用对象的finalize()方法</li></ul><h3 id="2-4-private"><a href="#2-4-private" class="headerlink" title="2.4 private"></a>2.4 private</h3><ul><li>private修饰的类：private不能修饰外部类，只能修饰内部类</li><li>private修饰的变量：<ol><li>类访问权限，子类也不可访问</li></ol></li><li>private修饰的方法：<ol><li>类访问权限，子类不能重写</li></ol></li></ul><h2 id="3-重写和重载"><a href="#3-重写和重载" class="headerlink" title="3. 重写和重载"></a>3. 重写和重载</h2><ul><li>方法签名：方法名 返回类型 参数（参数类型和顺序）</li><li>重写：Override复写 覆盖 是指子类覆盖父类相同方法签名的方法，从而实现自己的方法 注意不能缩小父类方法的访问权限</li><li>重载：参数不同，方法名和返回类型必须相同</li></ul><h2 id="4-抽象类和接口"><a href="#4-抽象类和接口" class="headerlink" title="4. 抽象类和接口"></a>4. 抽象类和接口</h2><h3 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h3><ol><li>接口中的方法<ol><li>抽象方法不能使用static修饰</li><li>默认 abstract public 修饰</li><li>1.8 支持static修饰的默认方法，需有方法体</li></ol></li><li>接口中的变量<ol><li>1.8支持静态变量，默认 static public final</li></ol></li></ol><h3 id="4-2-抽象类和接口的区别"><a href="#4-2-抽象类和接口的区别" class="headerlink" title="4.2 抽象类和接口的区别"></a>4.2 抽象类和接口的区别</h3><ol><li>继承方面：抽象类是类，只能继承一个类；而一个类可以实现多个接口</li><li>成员变量方面：抽象类可以有抽象成员变量，也可以有非抽象成员变量；接口只有常量（默认public static final修饰）</li><li>方法：抽象类可以有抽象方法，非抽象方法；接口方法都是抽象方法（默认 public abstract修饰），在JDK8之后允许接口有默认（default）实现</li></ol><blockquote><p>根据阿里巴巴编程规范 public static final abstract均不写</p></blockquote><h2 id="5-int-和-Integer的区别"><a href="#5-int-和-Integer的区别" class="headerlink" title="5. int 和 Integer的区别"></a>5. int 和 Integer的区别</h2><p><a href="../../01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">基本数据类型</a></p><ol><li>int是基本数据类；Integer是包装数据类型</li><li>int默认值0；Integer默认值null</li></ol><pre><code class="hljs java">Integer i9 = Integer.valueOf(<span class="hljs-number">1</span>);Integer i10= Integer.valueOf(<span class="hljs-number">1</span>);System.out.println(i9 == i10);         <span class="hljs-comment">// true</span>System.out.println(i9.equals(i10));    <span class="hljs-comment">// true</span><span class="hljs-comment">// 解释：由源码得知，默认情况下[-128,128)范围那的值来自缓存区 这个范围可以配置</span>Integer i11 = Integer.valueOf(<span class="hljs-number">128</span>);Integer i12 = Integer.valueOf(<span class="hljs-number">128</span>);System.out.println(i11 == i12);         <span class="hljs-comment">// false</span>System.out.println(i11.equals(i12));    <span class="hljs-comment">// true</span><span class="hljs-comment">// 解释：由源码得知，默认情况下[-128,128)范围那的值来自缓存区 这个范围可以配置</span>Integer i7 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);Integer i8 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);System.out.println(i7 == i8);         <span class="hljs-comment">// false</span>System.out.println(i7.equals(i8));    <span class="hljs-comment">// true</span><span class="hljs-comment">// 解释：无论数值大小，new 出来的都是新对象</span>Integer i1 = <span class="hljs-number">1</span>;Integer i2 = <span class="hljs-number">1</span>;System.out.println(i1 == i2);         <span class="hljs-comment">// true</span>System.out.println(i1.equals(i2));    <span class="hljs-comment">// true</span><span class="hljs-comment">// 解释：自动包装，实际为Integer.valueof(1)</span>Integer i3 = <span class="hljs-number">200</span>;Integer i4 = <span class="hljs-number">200</span>;System.out.println(i3 == i4);         <span class="hljs-comment">// false</span>System.out.println(i3.equals(i4));    <span class="hljs-comment">// true</span><span class="hljs-comment">// 解释：自动包装，实际为Integer.valueof(1)</span></code></pre><h2 id="6-String与StringBuffer、StringBuilder的区别"><a href="#6-String与StringBuffer、StringBuilder的区别" class="headerlink" title="6. String与StringBuffer、StringBuilder的区别"></a>6. String与StringBuffer、StringBuilder的区别</h2><p><a href="../01-String/">String</a></p><p>String 在创建后是不可变的，重新赋值是新的对象<br>StringBuffer、StringBuilder是可变的，StringBuffer线程安全，StringBuilder线程不安全<br>（线程不安全效率就更高）</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>02-面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-运算符</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="一、常见运算符和优先级"><a href="#一、常见运算符和优先级" class="headerlink" title="一、常见运算符和优先级"></a>一、常见运算符和优先级</h2><ul><li>优先级从上到下降低</li></ul><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>expr++ expr–</td><td>从左到右</td></tr><tr><td>一元</td><td>++expr –expr + - ～ ！</td><td>从右到左</td></tr><tr><td>乘性</td><td>*/％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>|</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>||</td><td>左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ =</td><td>=</td></tr><tr><td>逗号</td><td>,</td><td>左到右</td></tr></tbody></table><h2 id="二、特殊运算符说明"><a href="#二、特殊运算符说明" class="headerlink" title="二、特殊运算符说明"></a>二、特殊运算符说明</h2><h3 id="1-a-和-a"><a href="#1-a-和-a" class="headerlink" title="1. ++a 和 a++"></a>1. ++a 和 a++</h3><pre><code class="hljs java"><span class="hljs-comment">// a++ 本轮运算结束后+1</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;System.out.println(a++);        <span class="hljs-comment">// 0</span><span class="hljs-comment">// ++a +1后执行本轮运算</span><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;System.out.println(++a);        <span class="hljs-comment">// 1</span></code></pre><h3 id="2-三目运算符"><a href="#2-三目运算符" class="headerlink" title="2. 三目运算符"></a>2. 三目运算符</h3><pre><code class="hljs java"><span class="hljs-comment">// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30</span><span class="hljs-keyword">int</span> b = (a == <span class="hljs-number">1</span>) ? <span class="hljs-number">20</span> : <span class="hljs-number">30</span>;</code></pre><h3 id="3-amp-amp-和-amp-和-｜"><a href="#3-amp-amp-和-amp-和-｜" class="headerlink" title="3. &amp;&amp; 和 &amp; || 和 ｜"></a>3. &amp;&amp; 和 &amp; || 和 ｜</h3><h4 id="3-1-位运算-amp-｜-gt-gt-lt-lt-gt-gt-gt"><a href="#3-1-位运算-amp-｜-gt-gt-lt-lt-gt-gt-gt" class="headerlink" title="3.1 位运算 &amp; ｜ ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt;"></a>3.1 位运算 &amp; ｜ ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt;</h4><ul><li>位运算应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型</li><li>数字以补码展示<ul><li>正数：本身</li><li>负数：反码+1</li></ul></li><li>移位操作<ul><li>&gt;&gt; 有符号位移</li><li>&gt;&gt;&gt; 无符号位移(高位补0)</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 0000 1010</span><span class="hljs-keyword">byte</span> b = <span class="hljs-number">5</span>;     <span class="hljs-comment">// 0000 0101</span><span class="hljs-keyword">byte</span> c = -<span class="hljs-number">10</span>；  <span class="hljs-comment">// 1111 0110</span>a&amp;b = <span class="hljs-number">0</span>         <span class="hljs-comment">// 0000 0000</span>a|b = <span class="hljs-number">15</span>        <span class="hljs-comment">// 0000 1111</span>a^b = <span class="hljs-number">15</span>        <span class="hljs-comment">// 0000 1111 同为0 异为1</span>~a = <span class="hljs-number">245</span>        <span class="hljs-comment">// 1111 0101</span>c&gt;&gt;<span class="hljs-number">2</span> = -<span class="hljs-number">3</span>       <span class="hljs-comment">// 1111 1101</span>a&lt;&lt;<span class="hljs-number">2</span> = <span class="hljs-number">40</span>       <span class="hljs-comment">// 0010 1000</span>c&gt;&gt;&gt;<span class="hljs-number">2</span> = <span class="hljs-number">61</span>      <span class="hljs-comment">// 0011 1101</span></code></pre><h4 id="3-2-逻辑运算-amp-amp-和"><a href="#3-2-逻辑运算-amp-amp-和" class="headerlink" title="3.2 逻辑运算 &amp;&amp; 和 ||"></a>3.2 逻辑运算 &amp;&amp; 和 ||</h4><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> a = <span class="hljs-keyword">true</span>;<span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">false</span>;a&amp;&amp;b = <span class="hljs-keyword">false</span>;a||b = <span class="hljs-keyword">true</span>;</code></pre><h3 id="4-instanceof-运算"><a href="#4-instanceof-运算" class="headerlink" title="4. instanceof 运算"></a>4. instanceof 运算</h3><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> result = <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">instanceof</span> String;</code></pre><h3 id="5-equles-和"><a href="#5-equles-和" class="headerlink" title="5. equles 和 =="></a>5. equles 和 ==</h3><ul><li>equles<ul><li>对象比基本：自动装箱，比较类型，比较值</li><li>对象比对象：比较类型，比较值</li></ul></li><li>==<ul><li>对象比基本：自动拆箱，比较值</li><li>对象比对象：比较引用地址</li><li>基本比对象：自动拆箱，比较值</li><li>基本比基本：比较值</li></ul></li></ul><pre><code class="hljs java">Integer a=<span class="hljs-number">1</span>;Integer b=<span class="hljs-number">2</span>;Integer c=<span class="hljs-number">3</span>;Integer d=<span class="hljs-number">3</span>;Integer e=<span class="hljs-number">321</span>;Integer f=<span class="hljs-number">321</span>;Long g=<span class="hljs-number">3L</span>;System.out.println(c==d);           <span class="hljs-comment">// true  ==对象比对象，比较引用，小于127 引用相同</span>System.out.println(e==f);           <span class="hljs-comment">// false ==对象比对象，比较引用，大于127 引用不同</span>System.out.println(c==(a+b));       <span class="hljs-comment">// true  (a+b)自动拆箱，c==3，==对象比基本，自动拆箱，值相同</span>System.out.println(c.equals(a+b));  <span class="hljs-comment">// true  (a+b)自动拆箱，c.equal(3)，equal对象比基本，自动装箱，类型相同，值相同</span>System.out.println(g==(a+b));       <span class="hljs-comment">// true  (a+b)自动拆箱，g==3，==对象比基本，自动拆箱，值相同</span>System.out.println(g.equals(a+b));  <span class="hljs-comment">// false (a+b)自动拆箱，g.equal(3)，equal对象比基本，自动装箱，类型不同，值相同</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-流程控制</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h2 id="直到型循环-for"><a href="#直到型循环-for" class="headerlink" title="直到型循环 for"></a>直到型循环 for</h2><pre><code class="hljs java"><span class="hljs-comment">// for</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 增强for</span><span class="hljs-keyword">for</span>(i : ints)&#123;   <span class="hljs-comment">// ...</span>&#125;</code></pre><h2 id="当到型循环-do-While"><a href="#当到型循环-do-While" class="headerlink" title="当到型循环 do While"></a>当到型循环 do While</h2><pre><code class="hljs java"><span class="hljs-comment">// while</span><span class="hljs-keyword">while</span> (i&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// do while 至少执行一遍</span><span class="hljs-keyword">do</span> &#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>);</code></pre><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (i)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        <span class="hljs-comment">// ...</span>&#125;</code></pre><h2 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h2><ul><li>break结束整个循环</li><li>continue结束当前循环</li></ul><h2 id="try-catch-finally-异常处理"><a href="#try-catch-finally-异常处理" class="headerlink" title="try catch finally 异常处理"></a>try catch finally <a href="../../08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/01-JAVA%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/">异常处理</a></h2><ul><li>try不能单独存在，必须加catch/finally</li><li>finally是无论有没有异常发生</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-Java的第一行代码</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/00-Java%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/00-Java%E7%9A%84%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java的第一行代码"><a href="#Java的第一行代码" class="headerlink" title="Java的第一行代码"></a>Java的第一行代码</h1><h2 id="一、环境安装"><a href="#一、环境安装" class="headerlink" title="一、环境安装"></a>一、环境安装</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>从oracle官网/openjdk下载jdk</p><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">JDK8下载</a></p><h3 id="2-配置环境变量-Linux"><a href="#2-配置环境变量-Linux" class="headerlink" title="2. 配置环境变量(Linux)"></a>2. 配置环境变量(Linux)</h3><p><code>$ vim /etc/profile</code></p><pre><code class="hljs sh"><span class="hljs-comment"># JAVA_HOME</span><span class="hljs-built_in">export</span> JAVA_HOME=<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin</code></pre><ul><li><code>$JAVA_HOME</code>替换成真正的解压目录，</li></ul><p>更新环境变量<code>$ source /etc/profile</code></p><h3 id="3-校验安装"><a href="#3-校验安装" class="headerlink" title="3. 校验安装"></a>3. 校验安装</h3><pre><code class="hljs sh">$ java -versionjava version <span class="hljs-string">&quot;1.8.0_261&quot;</span>Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><h2 id="二、运行HelloWorld"><a href="#二、运行HelloWorld" class="headerlink" title="二、运行HelloWorld"></a>二、运行HelloWorld</h2><h3 id="1-新建文件HelloWorld-java"><a href="#1-新建文件HelloWorld-java" class="headerlink" title="1. 新建文件HelloWorld.java"></a>1. 新建文件<code>HelloWorld.java</code></h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);    &#125;&#125;</code></pre><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h3><pre><code class="hljs sh">$ javac HelloWorld.java</code></pre><p>生成<code>HelloWorld.class</code>文件</p><h3 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h3><pre><code class="hljs sh">$ java HelloWorldHello World!</code></pre><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a><strong>难点</strong></h2><h3 id="1-JVM如何实现跨平台"><a href="#1-JVM如何实现跨平台" class="headerlink" title="1. JVM如何实现跨平台"></a>1. JVM如何实现跨平台</h3><p>通过为不同的操作系统提供不同的JVM实现，屏蔽了操作系统层，由JVM执行字节码的解释工作，再交由各自平台下的JVM生成该平台可执行的二进制文件。</p><p><img src="../images/JAVA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%89%B9%E6%80%A7.drawio.png"></p><h3 id="2-Java是什么类型的语言-解释型-amp-编译型"><a href="#2-Java是什么类型的语言-解释型-amp-编译型" class="headerlink" title="2. Java是什么类型的语言 解释型&amp;编译型"></a>2. Java是什么类型的语言 解释型&amp;编译型</h3><p>什么是解释型和编译型</p><ul><li>解释型：源代码由上到下依次执行<ul><li>Java</li><li>javascript</li><li>Python</li></ul></li><li>编译型：源代码<strong>直接编译成</strong>二进制可执行文件（机器码），可直接执行<ul><li>C</li><li>C++</li><li>Delphi</li></ul></li></ul><p>为什么Java是解释型呢？</p><ul><li>第一阶段，.java -&gt; .class 编译，但编译出来的class文件不能直接执行，  </li><li>第二阶段，.class -&gt; 机器码 翻译，所以，从宏观来看，<strong>JAVA是解释型语言</strong></li></ul><h3 id="3-JVM版本不同，支持的class文件也不同"><a href="#3-JVM版本不同，支持的class文件也不同" class="headerlink" title="3. JVM版本不同，支持的class文件也不同"></a>3. JVM版本不同，支持的class文件也不同</h3><p>不同的版本编译的字节码文件不一定能在其他版本运行。</p><h3 id="4-关键字-保留字-标识符-变量名"><a href="#4-关键字-保留字-标识符-变量名" class="headerlink" title="4. 关键字 保留字 标识符(变量名)"></a>4. 关键字 保留字 标识符(变量名)</h3><ul><li>关键字：private class if for int 等，<strong>关键字都是小写</strong></li><li>保留字：goto const null <strong>保留字都是小写</strong></li><li>标识符(变量名)：以下均为合法变量名 FOR $123asd _123 Asd<ol><li>a～z A～Z _ $ 0～9</li><li>除了关键字、保留字（大写不是关键字）</li><li>数字不能作为开头</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-分布式事务</title>
    <link href="/03-Database/01-MySQL/10-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/03-Database/01-MySQL/10-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><a href="../09-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/">什么是事务</a></p><h2 id="一、什么是分布式事务"><a href="#一、什么是分布式事务" class="headerlink" title="一、什么是分布式事务"></a>一、什么是分布式事务</h2><p>需求：当订单和库存位于不同的节点上时，只能分布式事务才能达到ACID的业务要求</p><p>如图，<code>methodA()</code>和<code>methodB()</code>虽然各自实现了事务，但一旦<code>methodA()</code>中的<code>other()</code>方法出现异常，<code>methodA()</code>中的<code>localSql()</code>执行了回滚，而<code>methodB()</code>中没有执行回滚，会导致数据不一致，这样的情况即使是同一套DB也会有同样的问题</p><p><img src="../images/%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.drawio.png" alt="什么是分布式事务"></p><h2 id="二、分布式框架"><a href="#二、分布式框架" class="headerlink" title="二、分布式框架"></a>二、分布式框架</h2><ul><li>seata – 阿里巴巴开源</li><li>lcn</li></ul><h2 id="三、技术原理"><a href="#三、技术原理" class="headerlink" title="三、技术原理"></a>三、技术原理</h2><p>分布式事务的核心原理就是通过两个程序之间进行确认，确认执行状态，以保证数据一致性</p><ol><li>通过网络连接，确定其他事务参与者的事务提交状态，并能够指导其他参与者回滚等</li><li>通过业务层的约定，事务参与者各自实现这些约束，达到业务层的统一</li><li>通过MQ实现最终一致性，被动方的结果并不重要，但是发出消息很重要的场景</li></ol><h3 id="1-两阶段提交（2PC）"><a href="#1-两阶段提交（2PC）" class="headerlink" title="1. 两阶段提交（2PC）"></a>1. 两阶段提交（2PC）</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><p><img src="../images/2PC.drawio.png"></p><p>缺点：</p><ul><li><strong>同步阻塞</strong> 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li><li><strong>单点问题</strong> 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。即使选举了新的协调者，当前事务参与者一直处于等待反馈状态</li><li><strong>数据不一致</strong> 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li><strong>太过保守</strong> 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li></ul><h3 id="2-三阶段提交（3PC）"><a href="#2-三阶段提交（3PC）" class="headerlink" title="2. 三阶段提交（3PC）"></a>2. 三阶段提交（3PC）</h3><p>针对上述缺点，PC3协议提出，将准备阶段一分为二，分为CanCommit、PreCommit、DoCommit三个阶段</p><ol><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ol><p><img src="../images/3PC.drawio.png"></p><p>由于超时机制的加入，一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit，导致一致性降低，但可用性提高了</p><p>2pc 一致性好、可用性较低，3pc 一致性较低、可用性高</p><h3 id="3-补偿事务TCC"><a href="#3-补偿事务TCC" class="headerlink" title="3. 补偿事务TCC"></a>3. 补偿事务TCC</h3><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><p><img src="../images/20190409113546636.png"></p><ol><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ol><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用</p><ol><li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li></ol><p>缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以<strong>需要程序员在实现的时候多写很多补偿的代码</strong>，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h3 id="4-XA-数据库协议"><a href="#4-XA-数据库协议" class="headerlink" title="4. XA 数据库协议"></a>4. XA 数据库协议</h3><p>XA 协议采用两阶段提交方式来管理分布式事务。<br>XA 接口提供资源管理器与事务管理器之间进行通信的标准接口。 </p><p>基于2PC协议的数据库规范实现。</p><h3 id="5-基于MQ的最终一致性"><a href="#5-基于MQ的最终一致性" class="headerlink" title="5. 基于MQ的最终一致性"></a>5. 基于MQ的最终一致性</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/zcjcsl/p/7989792.html">分布式理论基础（一）一致性及解决一致性的两种方式：2PC和3PC</a></li><li><a href="https://blog.csdn.net/sinat_29774479/article/details/91038902">Seata简介(附带与其他分布式事务解决方案对比)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-数据库事务</title>
    <link href="/03-Database/01-MySQL/09-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/03-Database/01-MySQL/09-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="一、什么是事务"><a href="#一、什么是事务" class="headerlink" title="一、什么是事务"></a>一、什么是事务</h2><p>事务是什么，Transaction ，是指数据库中的一组逻辑操作单元。<br>需求场景：订单、库存、转账等重要数据必须使用事务来保证业务上的数据准确</p><p>事务的四大原则ACID原则：(并不是所有都隔离级别都完全符合ACID的)</p><ul><li>**原子性(Atomicity)**：保证整个事务操作不可切分，commit or rollback</li><li>**一致性(Consistency)**：<ul><li>业务一致性：此消彼长</li><li>数据库完整性：约束关系不变，如索引、外键等</li></ul></li><li>**隔离性(Isolation)**：沙盒操作，事务未commit之前，其他session读到的都是旧的数据，不受其他事务/操作影响</li><li>**持久性(Durability)**：事务一旦被提交，对数据库的数据的改变是永久的</li></ul><p>事务的两个状态</p><ul><li>commit: 事务执行成功，数据被固化，释放锁</li><li>rollback: 事务提交失败, 释放锁</li></ul><h2 id="二、如何提交一个事务"><a href="#二、如何提交一个事务" class="headerlink" title="二、如何提交一个事务"></a>二、如何提交一个事务</h2><ul><li>不是所有的引擎支持事务，只有<code>InnoDB</code>支持</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># ROLLBACK 回退 -- 仅在`Start TRANSACTION`之后有效</span><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">-- 即使执行成功，回退后删除的部分会恢复</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># COMMIT 显式提交</span><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">-- 假设这句执行失败，面那句也会被回退</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment"># SAVEPOINT 保存点 -- 这玩意就是个占位符，跟Goto一个样</span><span class="hljs-keyword">SAVEPOINT</span> savepoint_name; <span class="hljs-comment">-- 建立保存点</span><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> savepoint_name; <span class="hljs-comment">-- 回滚到保存点</span></code></pre><ul><li><code>CREATE</code>和<code>DROP</code>操作不会被回退（可以写在事务中）</li></ul><h2 id="三、使用事务会导致别的问题-脏读-幻读-不可重复读"><a href="#三、使用事务会导致别的问题-脏读-幻读-不可重复读" class="headerlink" title="三、使用事务会导致别的问题 脏读 幻读 不可重复读"></a>三、使用事务会导致别的问题 脏读 幻读 不可重复读</h2><ul><li>脏读：事务B读取了事务A的更新的数据，但是事务A回滚了，导致B读取的为脏数据。<br><img src="../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9-%E8%84%8F%E8%AF%BB.drawio.png"></li><li>不可重复读：事务A读取同一数据两次，但是在两次之间事务B对该数据进行了修改并提交，导致事务A读取两次读取不一致<br><img src="../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.drawio.png"></li><li>幻读：数据行新增或删除，导致数据行数不一致<br><img src="../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E7%89%A9-%E5%B9%BB%E8%AF%BB.drawio.png"></li></ul><div class="note note-warning">            <p>注意：不可重复读和幻读很容易混淆，<strong>不可重复读</strong>针对的时数据的<strong>修改</strong>，<strong>幻读</strong>针对的时数据的<strong>新增和删除</strong>。解决<strong>不可重复读</strong>问题只需要给对应记录上<strong>行锁</strong>，而解决<strong>幻读</strong>需要<strong>对表加锁</strong>。</p>          </div><h2 id="四、事务的隔离级别"><a href="#四、事务的隔离级别" class="headerlink" title="四、事务的隔离级别"></a>四、事务的隔离级别</h2><p>针对上述问题，因为应用场景不尽相同，数据库提供了四种隔离级别，数据库在进行高并发操作时，由于数据库的存在，使得行锁可能无法保证数据的线程安全问题，因此引入事务的隔离等级。</p><ul><li><strong>READ_UNCOMMITTED（未提交读）</strong>: 就是不做隔离控制，可以读到“脏数据”，比如A和B转账，当A账户修改后，在执行B账户修改时，事务还未提交，其他事务同样需要读取A账户的数据，那么这个时候是可以读到A账户修改后数据的。但是这个时候如果处理失败，则会导致其他事务读取的A账户的数据是错误的，这个问题就叫做脏读。显然这个隔离级别没有太大意义，现实中没有人会用，除非这个应用只有读取，没有任何写入。</li><li><strong>READ_COMMITTED（提交读）</strong>: 提交读就是不允许读取事务没有提交的数据。显然这种级别可以<strong>避免了脏读</strong>问题。例如A和B转账，当A账户修改后，在执行B账户修改时，事务还未提交，其他事务同样读取A账户的数据，那么这个时候读取的应该是事务开始前的数据（也就是A账户修改前的数据）。<strong>这个隔离级别是大多数数据库（除了mysql）的默认隔离级别</strong>。但是当其他事务在事务开始前读取，同时在事务结束后读取，这样会造成两次读取数据不一致的情况即<strong>不可重复读</strong>仍有可能发生</li><li><strong>REPEATABLE_READ（可重复读）</strong>: 与提交读（不可重复读）相对应，为了避免提交读级别不可重复读的问题，在事务中对查询记录上共享锁，对符合条件的修改记录上排他锁，这样其他事务不能对该事务的查询数据和修改数据上排他锁（共享锁特性），那么就不能对事务涉及到的数据进行修改。可避免不可重复读的问题产生。<strong>此种隔离级别为Mysql默认的隔离级别。</strong>由于只对操作数据进行上锁的操作，所以当其他事务插入或删除数据时，会出现<strong>幻读</strong>的问题，。</li><li><strong>SERIALIZABLE（串行）</strong>: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><p>这里需要注意的是：Mysql 默认采用的 <code>REPEATABLE_READ</code>（可重复读） 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code>（授权读取） 隔离级别.</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><table><thead><tr><th>事务隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（No repeatable redad）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/corbin_zhang/article/details/80578005">事务的ACID特性</a></li><li><a href="https://www.cnblogs.com/balfish/p/8298296.html">数据库事务隔离级别 - 分析脏读 &amp; 不可重复读 &amp; 幻读</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-数据库锁</title>
    <link href="/03-Database/01-MySQL/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <url>/03-Database/01-MySQL/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><p>Innodb支持行级锁、页锁和表级锁；MyISAM 支持表锁。</p><ul><li>表级锁：粒度大，开销小，不会死锁，并发低</li><li>页锁：粒度中，开销中，会死锁，并发中</li><li>行级锁：粒度小，会死锁，并发高</li></ul><p>行锁基于索引实现，Innodb就是通过锁机制实现了数据库的事务，和事务的隔离级别</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-python类定义</title>
    <link href="/02-Python/10-python%E7%B1%BB%E5%AE%9A%E4%B9%89/"/>
    <url>/02-Python/10-python%E7%B1%BB%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>###定义一个类</p><pre><code>class people():    &#39;我是一个人类&#39;    str = &#39;我是公有属性&#39;    __str2 = &#39;我是私有属性&#39;    def __init__(self,name,age):        super(people, self).__init__()        #调用父类构造函数，非必须        self.name = name        self.age = age    def printinfo(self):    #实例方法都需要至少有一个self参数，即使没有使用到self        print(&#39;self.name&#39; + self.name)        #print(&#39;name&#39; + name)        #报错，没有定义name变量        print(&#39;没有self&#39;)    @classmethod    def classfun(cla):        #需要参数cla,控制类属性        print(&#39;我是一个类方法&#39;)    @staticmethod    def staticfun():    #静态方法无需参数        print(&#39;我是静态方法&#39;)    def __add__(self,other):        &#39;加法运算符重载实现逻辑&#39;        return people(self.name + other.name,self.age + other.age)    def __str__(self):        &#39;字符串运算符重载实现逻辑&#39;        return &#39;name = &#39; + self.name + &#39;\nage = &#39; + self.age    def __cmp__(self,other):        &#39;比较重载&#39;    def __myfun():        &#39;私有方法定义，无法被外部调用&#39;class peopleson(people):def __init__(self):        #在执行子类构造函数之前先执行父类构造函数,构造函数也可以不写    super(peopleson,self).__init__(&#39;null&#39;,&#39;null&#39;)    #调用父类构造函数    people(&#39;null&#39;,&#39;null&#39;)                            #调用父类构造函数    print(&#39;子类构造函数执行&#39;)if __name__ == &#39;__main__&#39;:        #意思是在本函数中执行，不作为模块时    print(&#39;自己用&#39;)    czm = people(&#39;czm&#39;,&#39;1&#39;)    czm.staticfun()    czm.classfun()    czm.printinfo()    people.staticfun()else:    print(&#39;欢迎使用czm的模块&#39;)</code></pre><p>####类的自带属性</p><pre><code>__dict__  返回下面属性的dict__name__  类名__doc__  文档__module__  模块    __bases__  父类</code></pre><p>####类的继承</p><pre><code>class Father():    def __init__()</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Python文件与异常处理</title>
    <link href="/02-Python/05-Python%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/02-Python/05-Python%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>使用python的BIF(build in function)open()进行文件读写操作</p><pre><code># 1.打开文件data = open(file_name,&#39;w&#39;)    # 读取模式有很多种，主要有&#39;w&#39;写入 &#39;r&#39;只读 &#39;a&#39;在尾部添加,&#39;w+&#39;可读可写,不存在新建,&#39;r+&#39;可读可写，不存在报错 &#39;a+&#39; 可读可写，不存在创建# 2.操作文件data.readline()    # 按行读取data.seek(0)       # 返回文件首for line in data:  # 直接使用for函数实现遍历    print(line)# 3.关闭文件（必须记得）data.close()</code></pre><h3 id="字符串序列解包"><a href="#字符串序列解包" class="headerlink" title="字符串序列解包"></a>字符串序列解包</h3><p>使用BIF split()函数进行序列解包</p><pre><code>split([&#39;:&#39;],[分隔次数])     # 默认以空格作为分隔符号，参数1为分隔识别符，参数2为分割次数1次分两段</code></pre><p>split()方法返回一个目标识别符列表</p><pre><code>(a,b,c)= data.split()data.fine(&#39;:&#39;)    # 查找字符: 若存在返回索引，否则返回-1</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code>try:    #todo...except:     # 所有错误类型    pass    # 忽略错误finally:    #todo...        #必须执行的代码except IOError as err:    # 指定错误类型的处理    print(&#39;打印错误信息&#39; + str(err))    # 需要强转</code></pre><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><pre><code>file.closed         是否已关闭file.name           文件名file.mode           打开方式</code></pre><h3 id="文件的读写指针位置"><a href="#文件的读写指针位置" class="headerlink" title="文件的读写指针位置"></a>文件的读写指针位置</h3><pre><code>file = open(&#39;data.txt&#39;,&#39;w+&#39;)file.write(&#39;0123456789&#39;)   #执行后指针指向index -1file.flush()               #把缓存读入磁盘file.read()                # 结果：&#39;&#39;     原因：指针在 -1file.seek(0)               #使索引为0file.read()                #结果：&#39;0123456789&#39;,此时指针在 -1file.write(&#39;新添加&#39;)       #文件状态：&#39;0123456789新添加&#39;file.seek(0)               file.write(&#39;新新添加&#39;)     #文件状态：&#39;新新添加0123456789新添加&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-python编码问题</title>
    <link href="/02-Python/08-python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/02-Python/08-python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-理清一些知识点："><a href="#1-理清一些知识点：" class="headerlink" title="1.理清一些知识点："></a>1.理清一些知识点：</h2><h3 id="python默认的编码格式：-ASCII-py2-unicode-py3"><a href="#python默认的编码格式：-ASCII-py2-unicode-py3" class="headerlink" title="python默认的编码格式：     ASCII(py2) unicode(py3)"></a>python默认的编码格式：     ASCII(py2) unicode(py3)</h3><ul><li>查看默认编码：sys.defaultencoding</li><li>修改默认编码：#coding = utf-8</li></ul><h3 id="unicode是一种编码标准-其实就是还没编码-具体的实现标准可能是utf-8，utf-16，gbk-……"><a href="#unicode是一种编码标准-其实就是还没编码-具体的实现标准可能是utf-8，utf-16，gbk-……" class="headerlink" title="unicode是一种编码标准      其实就是还没编码        具体的实现标准可能是utf-8，utf-16，gbk ……"></a>unicode是一种编码标准      其实就是还没编码        具体的实现标准可能是utf-8，utf-16，gbk ……</h3><h3 id="python中str的编码格式：-unicode-str不能再解码-解码，把别的编码格式变成unicode"><a href="#python中str的编码格式：-unicode-str不能再解码-解码，把别的编码格式变成unicode" class="headerlink" title="python中str的编码格式：    unicode                 str不能再解码(解码，把别的编码格式变成unicode)"></a>python中str的编码格式：    unicode                 str不能再解码(解码，把别的编码格式变成unicode)</h3><h2 id="2-encode和decode-都跟unicode有直接关系"><a href="#2-encode和decode-都跟unicode有直接关系" class="headerlink" title="2.encode和decode(都跟unicode有直接关系)"></a>2.encode和decode(都跟unicode有直接关系)</h2><p>看个例子</p><pre><code>str1.encode(&#39;utf-8&#39;)    #把unicode对象按照utf-8格式进行**编码**                    unicode对象  --&gt;   utf-8str2.decode(&#39;utf-8&#39;)    #把utf-8编码格式的一段东西进行**解码**成unicode对象        utf-8        --&gt;   unicode对象</code></pre><h2 id="3-requests中的输出问题"><a href="#3-requests中的输出问题" class="headerlink" title="3.requests中的输出问题"></a>3.requests中的输出问题</h2><p>来自官方的中文文档<br>    请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它<br>这意味着：他会自己尝试解码，你也可以自己设置</p><pre><code>r.encoding = &#39;utf-8&#39;</code></pre><h2 id="4-文件保存问题"><a href="#4-文件保存问题" class="headerlink" title="4.文件保存问题"></a>4.文件保存问题</h2><pre><code>#错误示范file = open(&#39;data&#39;,&#39;w&#39;)        #在window中，会默认以gbk格式保存编码，这是错误的，毕竟我们使用utf-8的#正确示范file = open(&#39;data&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;)    </code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysqld-master.cnf</title>
    <link href="/99-Docker/docker-mysql/config/mysqld-master.cnf/"/>
    <url>/99-Docker/docker-mysql/config/mysqld-master.cnf/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs cnf">[mysqld]log-bin&#x3D;mysql-binbinlog-format&#x3D;ROWserver_id&#x3D;1</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-mysql</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysqld-slave.cnf</title>
    <link href="/99-Docker/docker-mysql/config/mysqld-slave.cnf/"/>
    <url>/99-Docker/docker-mysql/config/mysqld-slave.cnf/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs cnf">[mysqld]server_id&#x3D;2</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-mysql</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch-master.yml</title>
    <link href="/99-Docker/docker-elasticsearch/config/elasticsearch-master.yml/"/>
    <url>/99-Docker/docker-elasticsearch/config/elasticsearch-master.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># es分布式多节点的主节点配置文件</span><span class="hljs-comment"># 集群名，master和slave要相同</span><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">docker-cluster</span><span class="hljs-comment"># 节点名</span><span class="hljs-attr">node.name:</span> <span class="hljs-string">es-master</span><span class="hljs-comment"># 主节点</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 作为数据节点 </span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 服务监听的范围，所有</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-comment"># 设置主节点的数量和主机</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment">#discovery.zen.ping.unicast.hosts: [&quot;es-master:9300&quot;]</span><span class="hljs-comment"># es7新特性</span><span class="hljs-attr">cluster.initial_master_nodes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">es-master</span><span class="hljs-attr">gateway.recover_after_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">gateway.recover_after_time:</span> <span class="hljs-string">5m</span><span class="hljs-attr">gateway.expected_nodes:</span> <span class="hljs-number">2</span><span class="hljs-comment"># 搜索机制</span><span class="hljs-comment">#script.engine.groovy.inline.search: on</span><span class="hljs-comment">#script.engine.groovy.inline.aggs: on</span><span class="hljs-attr">indices.recovery.max_bytes_per_sec:</span> <span class="hljs-string">20mb</span><span class="hljs-comment"># 安全机制</span><span class="hljs-comment">## 允许跨域请求</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-comment"># 允许reindex的白名单</span><span class="hljs-attr">reindex.remote.whitelist:</span> []</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-elasticsearch</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch-slaver.yml</title>
    <link href="/99-Docker/docker-elasticsearch/config/elasticsearch-slaver.yml/"/>
    <url>/99-Docker/docker-elasticsearch/config/elasticsearch-slaver.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># es分布式多节点的主节点配置文件</span><span class="hljs-comment"># 集群名，master和slave要相同</span><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">docker-cluster</span><span class="hljs-comment"># 节点名</span><span class="hljs-comment">#node.name: es-datanode-1</span><span class="hljs-comment"># 主节点</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># 作为数据节点 </span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 服务监听的范围，所有</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-comment"># 设置主节点的数量和主机</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># discovery.zen.ping.unicast.hosts: [&quot;es-master:9300&quot;]</span><span class="hljs-comment"># es7新特性</span><span class="hljs-attr">discovery.seed_hosts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">es-master:9300</span><span class="hljs-attr">gateway.recover_after_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">gateway.recover_after_time:</span> <span class="hljs-string">5m</span><span class="hljs-attr">gateway.expected_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 搜索机制</span><span class="hljs-comment">#script.engine.groovy.inline.search: on</span><span class="hljs-comment">#script.engine.groovy.inline.aggs: on</span><span class="hljs-attr">indices.recovery.max_bytes_per_sec:</span> <span class="hljs-string">20mb</span><span class="hljs-comment"># 安全机制</span><span class="hljs-comment">## 允许跨域请求</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-comment"># 允许reindex的白名单</span><span class="hljs-attr">reindex.remote.whitelist:</span> []</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-elasticsearch</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kibana.yml</title>
    <link href="/99-Docker/docker-elasticsearch/config/kibana.yml/"/>
    <url>/99-Docker/docker-elasticsearch/config/kibana.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-attr">server.name:</span> <span class="hljs-string">kibana</span><span class="hljs-attr">server.host:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-attr">elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;http://es-master:9200&quot;</span>,<span class="hljs-string">&quot;http://es-datanode-1:9200&quot;</span> ]<span class="hljs-attr">i18n.locale:</span> <span class="hljs-string">&quot;zh-CN&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-elasticsearch</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx.conf</title>
    <link href="/99-Docker/docker-nginx/config/nginx.conf/"/>
    <url>/99-Docker/docker-nginx/config/nginx.conf/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs conf"># Host跳转proxy_set_header Host $http_host;# gitlab.czm.comserver &#123;    listen       22;    listen  [::]:22;    server_name  gitlab.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;gitlab:22;    &#125;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  gitlab.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;gitlab:80;    &#125;&#125;# portainer.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  portainer.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;portainer:9000;    &#125;&#125;# maven.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  maven.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;nexus:8081;    &#125;&#125;# redis.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  redis.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;redis:6379;    &#125;&#125;# jenkins.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  jenkins.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;jenkins:8080;    &#125;&#125;# kibana.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  kibana.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;kibana:5601;    &#125;&#125;# nacos.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  nacos.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;nacos1:8848&#x2F;nacos&#x2F;;    &#125;    location &#x2F;nacos&#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;nacos1:8848&#x2F;nacos&#x2F;;    &#125;&#125;# eureka.czm.comserver &#123;    listen       80;    listen  [::]:80;    server_name  eureka.czm.com;    location &#x2F; &#123;       proxy_pass   http:&#x2F;&#x2F;localhost:8761;    &#125;&#125;# registry.czm.comserver &#123;    listen 80;    server_name registry.czm.com;    rewrite ^(.*)$ https:&#x2F;&#x2F;$host$1 permanent;&#125;server &#123;    listen 443;    server_name registry.czm.com;    location &#x2F; &#123;       proxy_pass https:&#x2F;&#x2F;registry:5000;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-nginx</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-consul/docker-compose.yml/"/>
    <url>/99-Docker/docker-consul/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.comversion: &#x27;3.6&#x27;</span><span class="hljs-comment"># 未完成 - 暂未验证 1. 短时间重启服务重复注册，2. Service只在一个Client注册Client下线会导致服务全部中断</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">consul-1:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">consul</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">consul-1</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8500</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">agent</span> <span class="hljs-string">-server</span> <span class="hljs-string">-client=0.0.0.0</span> <span class="hljs-string">-bootstrap-expect=3</span> <span class="hljs-string">-node=consul-1</span> <span class="hljs-string">-datacenter=dc1</span> <span class="hljs-string">-ui</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>  <span class="hljs-attr">consul-2:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">consul</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">consul-2</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8500</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">agent</span> <span class="hljs-string">-server</span> <span class="hljs-string">-client=0.0.0.0</span> <span class="hljs-string">-retry-join=consul1</span> <span class="hljs-string">-node=consul-2</span> <span class="hljs-string">-datacenter=dc1</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile</title>
    <link href="/99-Docker/docker-payara/Dockerfile/"/>
    <url>/99-Docker/docker-payara/Dockerfile/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs /Users/cenzhongman/OneDrive/Documents/99-Docker/docker-payara/Dockerfile"># docker build . -t datainsights&#x2F;maven:3-jdk-8-payaraFROM maven:3-jdk-8ENV PAYARA_PATH &#x2F;opt&#x2F;payaraRUN   apt-get update &amp;&amp; apt-get -y install wget &amp;&amp; \ mkdir -p $PAYARA_PATH&#x2F;deploymentsENV PAYARA_PKG https:&#x2F;&#x2F;s3-eu-west-1.amazonaws.com&#x2F;payara.fish&#x2F;payara-5-micro-prerelease.jarENV PAYARA_VERSION prereleaseENV PKG_FILE_NAME payara-micro.jarRUN wget --quiet -O $PAYARA_PATH&#x2F;$PKG_FILE_NAME $PAYARA_PKGENV DEPLOY_DIR $PAYARA_PATH&#x2F;deploymentsENV AUTODEPLOY_DIR $PAYARA_PATH&#x2F;deploymentsENV PAYARA_MICRO_JAR&#x3D;$PAYARA_PATH&#x2F;$PKG_FILE_NAME# Default payara ports to exposeEXPOSE 4848 8009 8080 8181USER rootWORKDIR $PAYARA_PATH#ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;&#x2F;opt&#x2F;payara&#x2F;payara-micro.jar&quot;]#CMD [&quot;--deploymentDir&quot;, &quot;&#x2F;opt&#x2F;payara&#x2F;deployments&quot;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-payara</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-postgres/docker-compose.yml/"/>
    <url>/99-Docker/docker-postgres/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># Postgresql database</span><span class="hljs-comment"># author:cenzhongman</span><span class="hljs-comment"># email:cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">bmw-pgsql-service:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:9.6</span>      <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;bmw-pgsql-service&quot;</span>      <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>      <span class="hljs-attr">environment:</span>        <span class="hljs-attr">POSTGRES_USER:</span> <span class="hljs-string">user</span>        <span class="hljs-attr">POSTGRES_PASSWORD:</span> <span class="hljs-string">password</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">5432</span><span class="hljs-string">:5432</span>      <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./backup.sh:/usr/lib/postgresql/9.6/backup.sh&quot;</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./crontab:/etc/crontab&quot;</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./db_backup:/var/lib/postgresql/data_backup&quot;</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./db_data:/var/lib/postgresql/data&quot;</span>      <span class="hljs-comment"># command: &quot;/etc/init.d/cron start &amp;&amp; postgres&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-postgres</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>logstash.conf</title>
    <link href="/99-Docker/docker-logstash/pipeline/logstash.conf/"/>
    <url>/99-Docker/docker-logstash/pipeline/logstash.conf/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs conf">input &#123;tcp &#123;        port &#x3D;&gt; 4560        codec &#x3D;&gt; &quot;json&quot;    &#125;&#125;output &#123;    elasticsearch &#123;        action &#x3D;&gt; &quot;index&quot;        hosts &#x3D;&gt; [&quot;es-master:9200&quot;]        index &#x3D;&gt; &quot;%&#123;[app_name]&#125;&quot;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-logstash</category>
      
      <category>pipeline</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile</title>
    <link href="/99-Docker/docker-elasticsearch/Dockerfile/"/>
    <url>/99-Docker/docker-elasticsearch/Dockerfile/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs /Users/cenzhongman/OneDrive/Documents/99-Docker/docker-elasticsearch/Dockerfile">FROM elasticsearch:7.9.0RUN yum -y install unzip &amp;&amp; yum -y install wgetRUN mkdir -p &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins&#x2F;ikRUN cd &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins&#x2F;ik &amp;&amp; wget https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.9.0&#x2F;elasticsearch-analysis-ik-7.9.0.zipRUN unzip &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins&#x2F;ik&#x2F;elasticsearch-analysis-ik-*.zip -d &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins&#x2F;ik&#x2F;</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-elasticsearch/docker-compose.yml/"/>
    <url>/99-Docker/docker-elasticsearch/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">es-master:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch-ik:7.9.0</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-master</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;node.name=es-master&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;bootstrap.memory_lock=true&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;TZ=Asia/Shanghai&quot;</span>    <span class="hljs-attr">ulimits:</span>      <span class="hljs-attr">memlock:</span>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9200</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9300</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/es-master/:/usr/share/elasticsearch/data</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/elasticsearch-master.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./plugins/:/usr/share/elasticsearch/plugins/</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>  <span class="hljs-attr">es-datanode-1:</span>   <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch-ik:7.9.0</span>   <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>   <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>   <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-datanode-1</span>   <span class="hljs-attr">environment:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;node.name=es-datanode-1&quot;</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;bootstrap.memory_lock=true&quot;</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;TZ=Asia/Shanghai&quot;</span>   <span class="hljs-attr">ulimits:</span>     <span class="hljs-attr">memlock:</span>       <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>       <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>   <span class="hljs-attr">ports:</span>     <span class="hljs-bullet">-</span> <span class="hljs-number">9200</span>     <span class="hljs-bullet">-</span> <span class="hljs-number">9300</span>   <span class="hljs-attr">volumes:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/es-datanode-1/:/usr/share/elasticsearch/data</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">./config/elasticsearch-slaver.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">./plugins/:/usr/share/elasticsearch/plugins/</span>   <span class="hljs-attr">networks:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>  <span class="hljs-attr">kibana:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.9.0</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kibana</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/kibana.yml:/usr/share/kibana/config/kibana.yml</span>    <span class="hljs-attr">environment:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;TZ=Asia/Shanghai&quot;</span>    <span class="hljs-attr">depends_on:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">es-master</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5601</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile</title>
    <link href="/99-Docker/docker-mysql/Dockerfile/"/>
    <url>/99-Docker/docker-mysql/Dockerfile/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs /Users/cenzhongman/OneDrive/Documents/99-Docker/docker-mysql/Dockerfile">FROM mysql:8RUN apt-get update &amp;&amp; apt-get install -y percona-toolkit</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/99-Docker/docker-mysql/README/"/>
    <url>/99-Docker/docker-mysql/README/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql主从数据库安装"><a href="#Mysql主从数据库安装" class="headerlink" title="Mysql主从数据库安装"></a>Mysql主从数据库安装</h1><p>⚠️注意：配置文件的权限不能是777（docker文件映射直接使用宿主主机的权限这设置）</p><pre><code class="hljs sh">chmod 644 mysqld*.cof</code></pre><h2 id="数据库主从同步"><a href="#数据库主从同步" class="headerlink" title="数据库主从同步"></a>数据库主从同步</h2><h3 id="1-主数据库配置"><a href="#1-主数据库配置" class="headerlink" title="1. 主数据库配置"></a>1. 主数据库配置</h3><p>mysql<code>/etc/mysql/conf.d/mysqld.cnf</code>配置</p><pre><code class="hljs cnf">[mysqld]log-bin&#x3D;mysql-bin   #开启二进制日志binlog-format&#x3D;ROW   #设置binlog格式server-id&#x3D;1         #设置server-id</code></pre><h3 id="2-主库创建同步账号"><a href="#2-主库创建同步账号" class="headerlink" title="2. 主库创建同步账号"></a>2. 主库创建同步账号</h3><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;repl&#x27;</span>@<span class="hljs-string">&#x27;mysql-slave&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;Mysql679077&#x27;</span>;<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">REPLICATION</span> <span class="hljs-keyword">SLAVE</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;repl&#x27;</span>@<span class="hljs-string">&#x27;mysql-slave&#x27;</span>;<span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;</code></pre><h3 id="3-查看主库同步状态"><a href="#3-查看主库同步状态" class="headerlink" title="3. 查看主库同步状态"></a>3. 查看主库同步状态</h3><pre><code class="hljs SQL"><span class="hljs-keyword">show</span> <span class="hljs-keyword">master</span> <span class="hljs-keyword">status</span>;</code></pre><pre><code class="hljs sh">+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000003 |      156 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+</code></pre><p>记住<code>File</code>,<code>Position</code>两个值</p><h3 id="4-从库配置"><a href="#4-从库配置" class="headerlink" title="4. 从库配置"></a>4. 从库配置</h3><pre><code class="hljs cnf">[mysqld]server_id&#x3D;2</code></pre><h3 id="5-从库增加主库信息"><a href="#5-从库增加主库信息" class="headerlink" title="5. 从库增加主库信息"></a>5. 从库增加主库信息</h3><pre><code class="hljs SQL"><span class="hljs-keyword">CHANGE</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">TO</span> MASTER_HOST=<span class="hljs-string">&#x27;mysql-master&#x27;</span>,MASTER_USER=<span class="hljs-string">&#x27;repl&#x27;</span>,MASTER_PASSWORD=<span class="hljs-string">&#x27;Mysql679077&#x27;</span>,MASTER_LOG_FILE=<span class="hljs-string">&#x27;binlog.000005&#x27;</span>,MASTER_LOG_POS=<span class="hljs-number">156</span>;</code></pre><h3 id="6-从库查看同步状态"><a href="#6-从库查看同步状态" class="headerlink" title="6. 从库查看同步状态"></a>6. 从库查看同步状态</h3><pre><code class="hljs SQL"><span class="hljs-keyword">show</span> <span class="hljs-keyword">slave</span> <span class="hljs-keyword">status</span>;</code></pre><h3 id="7-从库开启同步"><a href="#7-从库开启同步" class="headerlink" title="7. 从库开启同步"></a>7. 从库开启同步</h3><pre><code class="hljs SQL"><span class="hljs-keyword">start</span> <span class="hljs-keyword">slave</span>;</code></pre><h3 id="8-从库查看同步状态"><a href="#8-从库查看同步状态" class="headerlink" title="8. 从库查看同步状态"></a>8. 从库查看同步状态</h3><pre><code class="hljs SQL"><span class="hljs-keyword">show</span> <span class="hljs-keyword">slave</span> <span class="hljs-keyword">status</span>;</code></pre><h2 id="测试主从同步"><a href="#测试主从同步" class="headerlink" title="测试主从同步"></a>测试主从同步</h2><p>在主库创建数据库并在从库查看即可</p>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-mysql/docker-compose.yml/"/>
    <url>/99-Docker/docker-mysql/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># E-mail:cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">mysql-master:</span>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-master</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-number">33061</span><span class="hljs-string">:3306</span>    <span class="hljs-attr">volumes:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/mysql-master:/var/lib/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/init-master.sql:/docker-entrypoint-initdb.d/init.sql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/mysqld-master.cnf:/etc/mysql/conf.d/mysqld.cnf</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">ZT:</span> <span class="hljs-string">Asia/Shanghai</span>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">Mysql679077</span>    <span class="hljs-attr">networks:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>  <span class="hljs-attr">mysql-slave:</span>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-slave</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-number">33062</span><span class="hljs-string">:3306</span>    <span class="hljs-attr">volumes:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/mysql-slave:/var/lib/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/init-slave.sql:/docker-entrypoint-initdb.d/init.sql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/mysqld-slave.cnf:/etc/mysql/conf.d/mysqld.cnf</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">ZT:</span> <span class="hljs-string">Asia/Shanghai</span>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">Mysql679077</span>    <span class="hljs-attr">networks:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/99-Docker/docker-nexus/README/"/>
    <url>/99-Docker/docker-nexus/README/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/jk418756/article/details/88663646">https://blog.csdn.net/jk418756/article/details/88663646</a></p><h2 id="在项目中使用-Maven-私服"><a href="#在项目中使用-Maven-私服" class="headerlink" title="在项目中使用 Maven 私服"></a>在项目中使用 Maven 私服</h2><h3 id="1-配置认证信息"><a href="#1-配置认证信息" class="headerlink" title="1. 配置认证信息"></a>1. 配置认证信息</h3><p>在 Maven settings.xml中添加 Nexus 认证信息(servers节点下)：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre><h3 id="Snapshots-与-Releases-的区别"><a href="#Snapshots-与-Releases-的区别" class="headerlink" title="Snapshots 与 Releases 的区别"></a>Snapshots 与 Releases 的区别</h3><p>nexus-releases: 用于发布 Release 版本<br>nexus-snapshots: 用于发布 Snapshot 版本（快照版）<br>Release 版本与 Snapshot 定义如下：</p><blockquote><p>Release: 1.0.0/1.0.0-RELEASE<br>Snapshot: 1.0.0-SNAPSHOT</p></blockquote><p>在项目pom.xml中设置的版本号添加SNAPSHOT标识的都会发布为 SNAPSHOT 版本，没有SNAPSHOT标识的都会发布为 RELEASE 版本。</p><p>Release版本的发布号1.0.0不能改变,只能换新的<br>SNAPSHOT版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar。如果再发布第二次，就会变成 1.0.0-SNAPSHOT-20180522.123456-2.jar<br>这里注意，idea 的 maven 设置中Always update snapshots要打上勾，总是使用最新的快照版本</p><h3 id="2-配置自动化部署"><a href="#2-配置自动化部署" class="headerlink" title="2. 配置自动化部署"></a>2. 配置自动化部署</h3><p>在 pom.xml中添加如下代码：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Release Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Snapshot Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span></code></pre><p>注意事项：</p><p>ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致。<br>项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository, 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号。<br>部署到仓库</p><pre><code class="hljs sh">mvn deploy</code></pre><h3 id="3-配置代理仓库"><a href="#3-配置代理仓库" class="headerlink" title="3. 配置代理仓库"></a>3. 配置代理仓库</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Plugin Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-nexus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-nexus/docker-compose.yml/"/>
    <url>/99-Docker/docker-nexus/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">nexus:</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">sonatype/nexus3</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nexus</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8081</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/nexus/data:/nexus-data</span>    <span class="hljs-attr">networks:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>    <span class="hljs-attr">docker:</span>        <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-nexus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-nginx/docker-compose.yml/"/>
    <url>/99-Docker/docker-nginx/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">nginx:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">./config/nginx.conf:/etc/nginx/conf.d/default.conf</span>    <span class="hljs-attr">ports:</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">22</span><span class="hljs-string">:22</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span>    <span class="hljs-attr">networks:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>    <span class="hljs-attr">docker:</span>        <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-pgsql/docker-compose.yml/"/>
    <url>/99-Docker/docker-pgsql/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">datainsights-postgresql:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:11</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">POSTGRES_USER:</span> <span class="hljs-string">datainsights</span>      <span class="hljs-attr">POSTGRES_DB:</span> <span class="hljs-string">bmw</span>      <span class="hljs-attr">POSTGRES_PASSWORD:</span> <span class="hljs-string">Data*2019*</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">datainsights-postgresql</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/home/czm/data/datainsights-postgresql:/var/lib/postgresql/data</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5432</span><span class="hljs-string">:5432</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">datainsights-framework-net</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">datainsights-framework-net:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-pgsql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-portainer/docker-compose.yml/"/>
    <url>/99-Docker/docker-portainer/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># E-mail:cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">portainer:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">portainer/portainer</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">-H</span> <span class="hljs-string">unix:///var/run/docker.sock</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">portainer</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">ZT:</span> <span class="hljs-string">Asia/Shanghai</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9000</span>    <span class="hljs-attr">networks:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>    <span class="hljs-attr">docker:</span>        <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-portainer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-registry/docker-compose.yml/"/>
    <url>/99-Docker/docker-registry/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">registry:</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">registry</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5000</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">REGISTRY_HTTP_TLS_CERTIFICATE:</span> <span class="hljs-string">/certs/registry.crt</span>      <span class="hljs-attr">REGISTRY_HTTP_TLS_KEY:</span> <span class="hljs-string">/certs/registry.key</span>      <span class="hljs-attr">REGISTRY_AUTH:</span> <span class="hljs-string">htpasswd</span>      <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_PATH:</span> <span class="hljs-string">/auth/htpasswd</span>      <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_REALM:</span> <span class="hljs-string">Registry</span> <span class="hljs-string">Realm</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/registry/data:/var/lib/registry</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./certs:/certs</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./auth:/auth</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-registry</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>README</title>
    <link href="/99-Docker/docker-registry/README/"/>
    <url>/99-Docker/docker-registry/README/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个带密钥带的docker-registry"><a href="#创建一个带密钥带的docker-registry" class="headerlink" title="创建一个带密钥带的docker-registry"></a>创建一个带密钥带的docker-registry</h1><p><a href="https://docs.docker.com/registry/deploying/">docker-registry</a></p><h2 id="1-创建一个存放密码的文件"><a href="#1-创建一个存放密码的文件" class="headerlink" title="1. 创建一个存放密码的文件"></a>1. 创建一个存放密码的文件</h2><p><code>./auth/htpasswd</code></p><pre><code class="hljs sh">mkdir authhtpasswd -Bbn admin Registry679077 &gt; auth/htpasswd</code></pre><h2 id="2-使用ssl创建一个自签名密钥-购买一个ssl密钥"><a href="#2-使用ssl创建一个自签名密钥-购买一个ssl密钥" class="headerlink" title="2. 使用ssl创建一个自签名密钥/购买一个ssl密钥"></a>2. 使用ssl创建一个自签名密钥/购买一个ssl密钥</h2><p><code>./registry/certs/</code></p><pre><code class="hljs sh">mkdir -p certsopenssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/registry.key -x509 -days 99999 -out certs/registry.crt</code></pre><p>⚠️注意：需要填入诸多信息，最重要的是<code>Common Name</code>应输入被保护的完整域名如：<code>test.example.cn</code></p><h2 id="3-创建容器"><a href="#3-创建容器" class="headerlink" title="3. 创建容器"></a>3. 创建容器</h2><pre><code class="hljs yml"><span class="hljs-attr">registry:</span>  <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2</span>  <span class="hljs-attr">container_name:</span> <span class="hljs-string">registry</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span>  <span class="hljs-attr">environment:</span>    <span class="hljs-attr">REGISTRY_HTTP_TLS_CERTIFICATE:</span> <span class="hljs-string">/certs/registry.crt</span>    <span class="hljs-attr">REGISTRY_HTTP_TLS_KEY:</span> <span class="hljs-string">/certs/registry.key</span>    <span class="hljs-attr">REGISTRY_AUTH:</span> <span class="hljs-string">htpasswd</span>    <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_PATH:</span> <span class="hljs-string">/auth/htpasswd</span>    <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_REALM:</span> <span class="hljs-string">Registry</span> <span class="hljs-string">Realm</span>    <span class="hljs-attr">REGISTRY_HTTP_ADDR:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:443</span>  <span class="hljs-attr">volumes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/registry/data:/var/lib/registry</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">./certs:/certs</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">./auth:/auth</span></code></pre><h2 id="4-修改DNS-hosts"><a href="#4-修改DNS-hosts" class="headerlink" title="4. 修改DNS/hosts"></a>4. 修改DNS/hosts</h2><pre><code class="hljs sh">127.0.0.1   registry.czm.com</code></pre><h2 id="5-注册和登录"><a href="#5-注册和登录" class="headerlink" title="5. 注册和登录"></a>5. 注册和登录</h2><pre><code class="hljs sh">docker login registry.czm.com:443</code></pre><h2 id="6-push-pull"><a href="#6-push-pull" class="headerlink" title="6. push/pull"></a>6. push/pull</h2><pre><code class="hljs sh">docker tag elasticsearch-ik:7.9.0 registry.czm.com:443/elasticsearch-ik:7.9.0docker push registry.czm.com:443/elasticsearch-ik:7.9.0</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-registry</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-gitlab/docker-compose.yml/"/>
    <url>/99-Docker/docker-gitlab/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>    <span class="hljs-attr">gitlab:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;gitlab/gitlab-ce&#x27;</span>      <span class="hljs-attr">container_name:</span> <span class="hljs-string">gitlab</span>      <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>      <span class="hljs-attr">environment:</span>        <span class="hljs-attr">TZ:</span> <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>        <span class="hljs-attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="hljs-string">|</span>          <span class="hljs-string">external_url</span> <span class="hljs-string">&#x27;http://gitlab.czm.com&#x27;</span>          <span class="hljs-string">gitlab_rails[&#x27;time_zone&#x27;]</span> <span class="hljs-string">=</span> <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>          <span class="hljs-string">gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;]</span> <span class="hljs-string">=</span> <span class="hljs-number">22</span>      <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/gitlab/config:/etc/gitlab</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/gitlab/data:/var/opt/gitlab</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/gitlab/log:/var/log/gitlab</span>      <span class="hljs-attr">networks:</span>         <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>      <span class="hljs-attr">ports:</span>         <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-gitlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-jenkins/docker-compose.yml/"/>
    <url>/99-Docker/docker-jenkins/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">jenkins:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">jenkinsci/blueocean</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">jenkins</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/jenkins:/var/jenkins_home</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">ZT:</span> <span class="hljs-string">Asia/Shanghai</span>    <span class="hljs-attr">networks:</span>       <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>    <span class="hljs-attr">docker:</span>        <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-logstash/docker-compose.yml/"/>
    <url>/99-Docker/docker-logstash/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.comversion: &quot;3&quot;</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">logstash:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">logstash:7.9.0</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">logstash</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">MONITORING_ELASTICSEARCH_HOSTS=http://es-master:9200</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">XPACK_MONITORING_ENABLED=false</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4560</span><span class="hljs-string">:4560</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9600</span><span class="hljs-string">:9600</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./pipeline/:/usr/share/logstash/pipeline/</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-logstash</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-nacos/docker-compose.yml/"/>
    <url>/99-Docker/docker-nacos/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.comversion: &quot;3&quot;</span><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">nacos1:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">nacos1</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nacos1</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server:1.3.1</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/nacos/cluster-logs/nacos1:/home/nacos/logs</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/custom.properties:/home/nacos/init.d/custom.properties</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8848</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9555</span>    <span class="hljs-attr">env_file:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/nacos-hostname.env</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>    <span class="hljs-attr">depends_on:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos-mysql</span>  <span class="hljs-comment"># nacos2:</span>  <span class="hljs-comment">#   hostname: nacos2</span>  <span class="hljs-comment">#   image: nacos/nacos-server:1.3.1</span>  <span class="hljs-comment">#   container_name: nacos2</span>  <span class="hljs-comment">#   volumes:</span>  <span class="hljs-comment">#     - ~/docker/nacos/cluster-logs/nacos2:/home/nacos/logs</span>  <span class="hljs-comment">#     - ./config/custom.properties:/home/nacos/init.d/custom.properties</span>  <span class="hljs-comment">#   ports:</span>  <span class="hljs-comment">#     - 8848</span>  <span class="hljs-comment">#   env_file:</span>  <span class="hljs-comment">#     - ./config/nacos-hostname.env</span>  <span class="hljs-comment">#   restart: always</span>  <span class="hljs-comment">#   depends_on:</span>  <span class="hljs-comment">#     - nacos-mysql</span>  <span class="hljs-comment">#   networks:</span>  <span class="hljs-comment">#     - docker</span>  <span class="hljs-comment"># nacos3:</span>  <span class="hljs-comment">#   hostname: nacos3</span>  <span class="hljs-comment">#   image: nacos/nacos-server:1.3.1</span>  <span class="hljs-comment">#   container_name: nacos3</span>  <span class="hljs-comment">#   volumes:</span>  <span class="hljs-comment">#     - ~/docker/nacos/cluster-logs/nacos3:/home/nacos/logs</span>  <span class="hljs-comment">#     - ./config/custom.properties:/home/nacos/init.d/custom.properties</span>  <span class="hljs-comment">#   ports:</span>  <span class="hljs-comment">#     - 8848</span>  <span class="hljs-comment">#   env_file:</span>  <span class="hljs-comment">#     - ./config/nacos-hostname.env</span>  <span class="hljs-comment">#   restart: always</span>  <span class="hljs-comment">#   depends_on:</span>  <span class="hljs-comment">#     - nacos-mysql</span>  <span class="hljs-comment">#   networks:</span>  <span class="hljs-comment">#     - docker</span>  <span class="hljs-comment"># 使用自己的数据库需要执行初始化 https://github.com/alibaba/nacos/blob/develop/distribution/conf/nacos-mysql.sql</span>  <span class="hljs-attr">nacos-mysql:</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nacos-mysql</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-mysql:8.0.16</span>    <span class="hljs-attr">env_file:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config/nacos-mysql.env</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/nacos-mysql:/var/lib/mysql</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-nacos</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-redis/docker-compose.yml/"/>
    <url>/99-Docker/docker-redis/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:5.0.3</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/redis/conf:/conf</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">--requirepass</span> <span class="hljs-string">Redis679077</span> <span class="hljs-string">--notify-keyspace-events</span> <span class="hljs-string">Eglx</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">ZT:</span> <span class="hljs-string">Asia/Shanghai</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose.yml</title>
    <link href="/99-Docker/docker-registry-frontend/docker-compose.yml/"/>
    <url>/99-Docker/docker-registry-frontend/docker-compose.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">frontend:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">konradkleine/docker-registry-frontend:v2</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">docker-registry-frontend</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">ENV_DOCKER_REGISTRY_HOST=registry</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">ENV_DOCKER_REGISTRY_PORT=5000</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Docker</category>
      
      <category>docker-registry-frontend</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JAVA命名规范.html</title>
    <link href="/01-Java/01-JAVA%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/01-Java/01-JAVA%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1>Java命名规范</h1><p>1:包名</p><p>　　package com.cenzhongman.模块名.组件</p><p>　　<strong>必须全部小写，作为java文件第一行代码</strong></p><p>2：类名</p><p>　　名词，表示一类实物，如：人类</p><p>　　<strong>首字母大写</strong></p><p>3.接口名</p><p>　　形容词/副词，表示一种能力，如:IWalkable</p><p>　　<strong>一般以 I 打头，表示接口<br /></strong></p><p>4.方法名</p><p>　　动词，表示一种行为，如：save()</p><p>　　<strong>首字母小写</strong></p><p>5:变量</p><p>　　名词</p><p><strong>　　首字母小写</strong></p><p>6：常量</p><p>　　名词，使用final 修饰的变量</p><p>　　全部使用大写字母组成，多个单词组合用下划线分割，如：Integer类的：MAX_VALUE</p><p>　　<span style="color: #3366ff;">在方法中的final修饰的变量，用于被局部内部类/匿名内部类访问的变量无须大写</span></p><p>&nbsp;</p><p>　　</p><p><strong>&nbsp;</strong></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-Java知识点</title>
    <link href="/99-Others/00-%E9%9D%A2%E8%AF%95/00-Java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/99-Others/00-%E9%9D%A2%E8%AF%95/00-Java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>复习大纲</p><ol><li>JavaSE<ol><li>面向对象</li><li>数据结构</li><li>集合</li><li>多线程</li><li>设计模式<ol><li>单例模式</li><li>工厂模式</li><li>建造者模式</li><li>过滤器模式</li><li>适配器模式</li></ol></li><li>JVM内存模型</li><li>JVM调优</li><li>异常处理<ol><li>常见异常</li><li>统一异常处理</li></ol></li><li>垃圾回收</li><li>序列化</li><li>类加载机制</li><li>I/O NIO</li><li>简单算法<ol><li>排序算法</li><li>取最大值算法</li></ol></li><li>注解开发</li><li>反射</li></ol></li><li>Database<ol><li>SQL</li><li>SQL调优</li><li>分表分库</li><li>索引</li><li>JDBC</li><li>连接池<ol><li>Druid</li><li>DBCP</li></ol></li><li>主从数据库</li><li>数据库引擎</li><li>数据库事务（概念）</li><li>数据库并发 锁</li><li>数据库范式</li><li>NoSQL<ol><li>HBase</li><li>MongoDB</li></ol></li><li>RDBS<ol><li>MySQL</li><li>Oracle</li><li>PgSQL</li><li>SQLServer</li></ol></li></ol></li><li>J2EE<ol><li>Servlet<ol><li>生命周期</li></ol></li><li>Spring<ol><li>AOP</li><li>IOC</li><li>流程</li></ol></li><li>Spring MVC</li><li>SpringBoot</li><li>SpringCloud<ol><li>注册中心<ol><li>Nacos</li><li>Consul</li></ol></li><li>熔断器</li><li>负载均衡</li><li>网关</li><li>Dubbo</li><li>Zookeeper</li></ol></li><li>DAO层框架<ol><li>ORM<ol><li>MyBatis</li><li>iBatis</li></ol></li><li>JPA<ol><li>Hiberate</li><li>SpringData JPA</li></ol></li></ol></li><li>数据库事务</li><li>Cookies Session</li><li>多数据源</li><li>Web容器<ol><li>Tomcat</li><li>Jboss</li><li>WebSphere</li><li>WebLogic</li><li>Jetty</li><li>Payara</li></ol></li><li>Struts2</li></ol></li><li>前端<ol><li>模版引擎<ol><li>Thyneleaf</li><li>FreeMaker</li></ol></li><li>js</li><li>Juery</li><li>jsp</li><li>Html</li><li>CSS</li><li>Vue</li><li>Angular</li></ol></li><li>计算机网络<ol><li>TCP</li><li>HTTP HTTPS HTTP2</li><li>七层模型</li><li>Socket</li><li>DNS</li></ol></li><li>Linux<ol><li>WebServer<ol><li>Apache</li><li>Nginx</li></ol></li><li>ELK<ol><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li></ol></li><li>Jenkins</li><li>Docker &amp;.K8s</li><li>线程和进程</li><li>监控</li></ol></li><li>Project<ol><li>宝马</li><li>优专</li><li>香港机场（大数据）</li></ol></li><li>Other<ol><li>缓存<ol><li>Redis</li></ol></li><li>消息队列<ol><li>Kafka</li><li>RebbitMQ</li></ol></li><li>代码管理工具<ol><li>SVN</li><li>GIT</li></ol></li><li>Maven</li><li>开发工具<ol><li>IDEA</li><li>Eclipse</li></ol></li><li>大数据<ol><li>Hadoop</li><li>Spark</li><li>Storm</li></ol></li><li>RPC<ol><li>RESTAPI</li><li>JsonRPC2.0</li></ol></li><li>UML<ol><li>PowerDesigner</li><li>Navicate</li></ol></li><li>Minio</li><li>Canal</li><li>Swagger</li><li>Security<ol><li>Oauth2</li><li>XSS 注入攻击</li><li>Cors跨域请求 过滤器的使用</li><li>SQL注入</li><li>Jwt</li><li>密码明文保存</li></ol></li><li>POI</li><li>Dom4j</li><li>Json<ol><li>FastJson</li><li>Gson</li><li>EasyJson</li></ol></li><li>Log<ol><li>Slf4j</li><li>Log4j</li><li>Logback</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>00-面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-Mysql数据类型</title>
    <link href="/03-Database/01-MySQL/07-Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/03-Database/01-MySQL/07-Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h1><h2 id="字符串-必须使用引号-两种都支持，建议单引号"><a href="#字符串-必须使用引号-两种都支持，建议单引号" class="headerlink" title="字符串 - 必须使用引号 两种都支持，建议单引号"></a>字符串 - 必须使用引号 两种都支持，建议单引号</h2><ul><li>定长字符串：长度固定，长度不够，将填充空格，并且返回时候<strong>不带空格</strong></li><li>变长字符串：长度由字符串本身决定</li></ul><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>CHAR()</td><td>定长字符串，1-255，固定占用空间</td></tr><tr><td>VARCHAR()</td><td>变长字符串，0-255，占用空间更少</td></tr><tr><td>TEXT</td><td>变长文字，64k</td></tr><tr><td>MEDIUMTEXT</td><td>变长文字，16k</td></tr><tr><td>LONGTEXT</td><td>TEXT升级版，4G</td></tr></tbody></table><h2 id="数值-不使用引号"><a href="#数值-不使用引号" class="headerlink" title="数值 - 不使用引号"></a>数值 - 不使用引号</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整数，-2147483648～2147483647</td></tr><tr><td>BIGIINT</td><td>大整数，好大</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td></tr><tr><td>FLOAT</td><td>单精度浮点数</td></tr><tr><td>BOOLEAN</td><td>布尔形，0-1</td></tr></tbody></table><h2 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>DATE</td><td>yyyy-MM-dd</td></tr><tr><td>TIME</td><td>hh:mm:ss</td></tr><tr><td>DATETIME</td><td>yyyy-MM-dd hh:mm:ss</td></tr><tr><td>TIMESTAMP</td><td>功能和DATETIME一样，范围小</td></tr><tr><td>YEAR</td><td>yyyy</td></tr></tbody></table><h2 id="二进制-可以存储任意数据类型、图片、Office文件等"><a href="#二进制-可以存储任意数据类型、图片、Office文件等" class="headerlink" title="二进制 - 可以存储任意数据类型、图片、Office文件等"></a>二进制 - 可以存储任意数据类型、图片、Office文件等</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>BITARY()</td><td>64</td></tr><tr><td>VARBINARY()</td><td>64k</td></tr><tr><td>BIT()</td><td>64</td></tr><tr><td>BLOB</td><td>变长64k</td></tr><tr><td>MEDIUMBLOB</td><td>变长16MB</td></tr><tr><td>LONGBLOM</td><td>变长4G</td></tr><tr><td>TINYBLOB</td><td>变长255b</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-MySQL配置</title>
    <link href="/03-Database/01-MySQL/02-MySQL%E9%85%8D%E7%BD%AE/"/>
    <url>/03-Database/01-MySQL/02-MySQL%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h1><h2 id="配置的读取"><a href="#配置的读取" class="headerlink" title="配置的读取"></a>配置的读取</h2><p><a href="https://dev.mysql.com/doc/refman/5.6/en/option-files.html">官方解释</a></p><ul><li>描述：Mysql中有很多配置文件</li></ul><p>mysql配置文件为my.cnf，它所在位置根据安装时设定的。<br>当mysqld服务启动的时候，默认会按一定的顺序读取配置文件的。</p><pre><code class="hljs sh"><span class="hljs-comment"># /opt/mysql/libexec/mysqld --verbose --help</span>    Default options are <span class="hljs-built_in">read</span> from the following files <span class="hljs-keyword">in</span> the given order:    /etc/my.cnf /etc/mysql/my.cnf /opt/mysql/etc/my.cnf ~/.my.cnf</code></pre><p>可以发现，系统默认是按<br><code>/etc/my.cnf --&gt; /etc/mysql/my.cnf --&gt; /usr/local/mysql/my.cnf</code>的顺序读取配置文件的，当有多个配置文件时，mysql会以读取到的最后一个配置文件中的参数为准</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-索引优化</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/02-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/02-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>索引是一种数据结构，如B+树、二叉树，用于特定的查找算法能够高效查找数据</p><ul><li>优点：<ul><li>提高查询速率，降低IO成本</li><li>缩短排序时间，降低CPU消耗</li></ul></li><li>缺点：<ul><li>占用一定的磁盘空间(存放在磁盘中)</li><li>降低更新表效率（insert update delete）时也要维护索引</li></ul></li></ul><h3 id="1-索引的数据结构"><a href="#1-索引的数据结构" class="headerlink" title="1. 索引的数据结构"></a>1. 索引的数据结构</h3><h2 id="二、创建索引"><a href="#二、创建索引" class="headerlink" title="二、创建索引"></a>二、创建索引</h2><h3 id="1-哪些列需要创建索引"><a href="#1-哪些列需要创建索引" class="headerlink" title="1. 哪些列需要创建索引"></a>1. 哪些列需要创建索引</h3><ol><li>需要建立索引的列<ul><li>where</li><li>group by</li><li>order by</li><li>or</li></ul></li><li>索引字段越小越好</li><li>离散度大的列放在联合索引的前面（离散度指的是可能性越多），联合索引用于AND查询</li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><pre><code class="hljs sql"><span class="hljs-comment">-- 在创建数据库时创建</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(    <span class="hljs-keyword">id</span> <span class="hljs-built_in">bigint</span> primay <span class="hljs-keyword">key</span>,              <span class="hljs-comment">-- 主键索引</span>    user_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),    c1 <span class="hljs-built_in">int</span>,    c2 <span class="hljs-built_in">int</span>,    c3 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>),    FULLTEXT idx_c3 (c3),              <span class="hljs-comment">-- 全文索引</span>    <span class="hljs-keyword">unique</span> idex_user_name (c1 <span class="hljs-keyword">desc</span>),   <span class="hljs-comment">-- 唯一索引</span>    <span class="hljs-keyword">index</span> idx_c1_c2 (c1,c2)            <span class="hljs-comment">-- 普通索引（key）</span>);<span class="hljs-comment">-- 创建一个列的索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> INDEX_NAME <span class="hljs-keyword">on</span> TABLE_NAME(COLUMN_NAME);<span class="hljs-comment">-- 创建联合索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> INDEX_NAME <span class="hljs-keyword">on</span> TABLE_NAME(COLUMN_NAME_1, COLUMN_NAME_2);</code></pre><h2 id="显示索引"><a href="#显示索引" class="headerlink" title="显示索引"></a>显示索引</h2><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">indexes</span>;</code></pre><h2 id="索引的适可而止"><a href="#索引的适可而止" class="headerlink" title="索引的适可而止"></a>索引的适可而止</h2><p>一般来说索引会增加查询效率，降低插入/修改效率，但是过多的索引同样也会导致SQL语句分析时间变长</p><p>冗余索引</p><ul><li>主键所在的列，本自带索引，无需手动创建</li><li>联合索引的第一列相同</li><li>联合索引包含主键索引（因为Innodb默认在每个索引后面加上主键）</li></ul><p>查找冗余索引</p><pre><code class="hljs sql"><span class="hljs-keyword">use</span> information_schema;<span class="hljs-keyword">select</span> a.table_schema <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数据名&#x27;</span>,   a.table_name <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;表名&#x27;</span>,a.index_name <span class="hljs-keyword">as</span>  <span class="hljs-string">&#x27;索引1&#x27;</span>,b.index_name <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;索引2&#x27;</span>,a.column_name <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;重复列名&#x27;</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">statistics</span> a <span class="hljs-keyword">join</span> <span class="hljs-keyword">statistics</span> b <span class="hljs-keyword">on</span> a.table_schema = b.table_schema <span class="hljs-keyword">and</span> a.table_name = b.table_name<span class="hljs-keyword">and</span> a.seq_in_index = b.seq_in_index <span class="hljs-keyword">and</span> a.column_name = b.column_name<span class="hljs-keyword">where</span> a.seq_in_index = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> a.index_name &lt;&gt; b.index_name;</code></pre><p>显示了索引重复列（不会显示主键重复的冗余情况）</p><p>使用<code>pt-duplicate-key-cheker</code>可以查询冗余索引，甚至可以显示修改建议。</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>检查不用的索引</p><p><code>pt-index-usage</code>工具，通过慢查询日志 检查不实用的索引</p><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> INDEX_NAME <span class="hljs-keyword">on</span> TABLE_NAME;</code></pre><h2 id="索引的实现"><a href="#索引的实现" class="headerlink" title="索引的实现"></a>索引的实现</h2><p>BTREE</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-String</title>
    <link href="/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01-String/"/>
    <url>/01-Java/01-JavaSE/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01-String/</url>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="一、String常量池"><a href="#一、String常量池" class="headerlink" title="一、String常量池"></a>一、String常量池</h2><p>String.intern()方法是一个Native方法，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象;否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;        String s2 = <span class="hljs-string">&quot;abc&quot;</span>;        String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);        String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);        String s5 = String.valueOf(<span class="hljs-string">&quot;abc&quot;</span>);        String s6 = String.valueOf(<span class="hljs-string">&quot;abc&quot;</span>);        System.out.println(s1 == s2); <span class="hljs-comment">// true</span>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span>        System.out.println(s5 == s6); <span class="hljs-comment">// true</span>    &#125;&#125;</code></pre><p>实验证明，直接赋值使用的是<code>intern</code>, <code>String.valueOf(&quot;string&quot;)</code> 使用的是<code>intern</code>, <code>String.valueOf(int)</code> 则使用的是<code>new String()</code></p><p>值得说明的是，任何情况下 <code>&quot;string&quot;</code>这样的操作在编译器眼里都是一个常量，因此，<code>String s3 = new String(&quot;abc&quot;);</code>是将一个String常量池中的常量‘abc’重新新建了一个对象</p><h2 id="二、String与StringBuilder"><a href="#二、String与StringBuilder" class="headerlink" title="二、String与StringBuilder"></a>二、String与StringBuilder</h2><p>String不可变，每一次执行“+”都会新生成一个新对象，所以频繁改变字符串的情况中不用String而使用StringBuilder，<strong>特别是在循环中</strong>。</p><h2 id="三、StringBuilder与StringBuffer"><a href="#三、StringBuilder与StringBuffer" class="headerlink" title="三、StringBuilder与StringBuffer"></a>三、StringBuilder与StringBuffer</h2><ul><li>相同：功能和用法均相同</li><li>不同：StringBuffer线程安全</li></ul><div class="note note-success">            <p>提示：在非多线程情况下还是使用StringBuilder，性能更好</p>          </div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/rese-t/p/8024166.html">Java String 面试题以及答案</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>02-面向对象</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-数组</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03-%E6%95%B0%E7%BB%84/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种对象，不是基本数据类型</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> String[]&#123;&#125;;  <span class="hljs-comment">// 长度为0的数字</span>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];  <span class="hljs-comment">// 长度为10的数组</span>String[] strings = &#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>&#125;;     <span class="hljs-comment">// 长度为2的数组</span></code></pre><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><pre><code class="hljs java"><span class="hljs-comment">// 数组复制 - 底层通过反射实现</span>System.arraycopy(srcArr, <span class="hljs-number">0</span>, destArr, <span class="hljs-number">0</span>, srcArr.length);Arrays.copyOf(srcArr, <span class="hljs-number">10</span>);<span class="hljs-comment">// 数组转List</span>List&lt;T&gt; list = Arrays.asList(arr);<span class="hljs-comment">// 数组toString</span>Arrays.toString(arr);<span class="hljs-comment">// 直接调用</span><span class="hljs-keyword">int</span> i = arr[<span class="hljs-number">1</span>];<span class="hljs-comment">// 通过数组类调用 - 一般用于反射时候用</span><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;Array.getInt(arr,<span class="hljs-number">1</span>);</code></pre><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><pre><code class="hljs java"><span class="hljs-comment">// 初始化</span>String[][] s = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 赋值</span>s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;1-1&quot;</span>;<span class="hljs-comment">// 取值</span>System.out.println(s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-基本数据类型</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java中一共有8种数据类型：</p><ul><li>六种数字类型：byte、short、int、long、float、double  </li><li>一种字符类型：char  </li><li>一种布尔型：boolean  </li></ul><h2 id="一、数字类型"><a href="#一、数字类型" class="headerlink" title="一、数字类型"></a>一、数字类型</h2><h3 id="1-byte-8"><a href="#1-byte-8" class="headerlink" title="1. byte 8"></a>1. byte 8</h3><ul><li>8位</li><li>范围：-128～127 (-2^7 ～ 2^7-1)</li><li>byte a = 10;</li></ul><h3 id="2-short-16"><a href="#2-short-16" class="headerlink" title="2. short 16"></a>2. short 16</h3><ul><li>16位</li><li>范围：-32768~32767 (-2^15 ～ 2^15-1)</li><li>short a = 10;</li></ul><h3 id="3-int-32"><a href="#3-int-32" class="headerlink" title="3. int 32"></a>3. int 32</h3><ul><li>32位</li><li>范围：-2,147,483,648~2,147,483,647 (-2^31 ～ 2^31-1) 21亿</li><li>int a = 10;</li></ul><h3 id="4-long-64"><a href="#4-long-64" class="headerlink" title="4. long 64"></a>4. long 64</h3><ul><li>64位</li><li>范围：-9,223,372,036,854,775,808~9,223,372,036,854,775,807 (-2^31 ～ 2^31-1) 9千万亿</li><li>long a = 10; long a = 10L;</li></ul><h3 id="5-float-32"><a href="#5-float-32" class="headerlink" title="5. float 32"></a>5. float 32</h3><p>⚠️注意：所有的整形都是精确的，所有的浮点型都是不精确的<br>⚠️注意：float转double，数字完全不变，double转float数值会变（即使没涉及到精度）如：2.2f-&gt;2.200000033123d</p><ul><li>32位</li><li>1bit（符号bai位） 8bits（指数位） 23bits（尾数位）</li><li>范围：-2^128 ~ 2^128</li><li>精度：2^23 = 8388608 即能保证6～7位精确</li><li>float a = 10;(int转float) float a = 10f; float a = 10.0f;</li></ul><h3 id="6-double-64"><a href="#6-double-64" class="headerlink" title="6. double 64"></a>6. double 64</h3><ul><li>64位</li><li>1bit（符号bai位） 11bits（指数位） 52bits（尾数位）</li><li>范围：-2^1024 ~ 2^1024</li><li>精度：2^52 = 4503599627370496 即能保证15～16位精确</li><li>double a = 10;(int转double) double a = 10.0; double a = 10d; double a = 10.0d;</li></ul><h2 id="二、字符类型char-ASCII码"><a href="#二、字符类型char-ASCII码" class="headerlink" title="二、字符类型char ASCII码"></a>二、字符类型char ASCII码</h2><ul><li>16位</li><li>范围：0～65535 (\u0000～\uffff)</li><li>char a = ‘A’; char a = 65;</li></ul><h2 id="三、boolean类型"><a href="#三、boolean类型" class="headerlink" title="三、boolean类型"></a>三、boolean类型</h2><ul><li>1位</li><li>范围：0～1 (true~false)</li></ul><h2 id="四、基本数据类型转换"><a href="#四、基本数据类型转换" class="headerlink" title="四、基本数据类型转换"></a>四、基本数据类型转换</h2><h3 id="1-低转高自动转"><a href="#1-低转高自动转" class="headerlink" title="1. 低转高自动转"></a>1. 低转高自动转</h3><ul><li>byte &gt; short &gt; int &gt; long &gt; float &gt; double</li></ul><pre><code class="hljs java"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">short</span> b = a;</code></pre><h3 id="2-高转低强制转"><a href="#2-高转低强制转" class="headerlink" title="2. 高转低强制转"></a>2. 高转低强制转</h3><pre><code class="hljs java"><span class="hljs-keyword">short</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) a;</code></pre><ul><li>转换后数值的变化<ol><li>double &gt; float</li><li>浮点转整型（舍弃小数位）</li></ol></li></ul><h3 id="3-隐含类型转换"><a href="#3-隐含类型转换" class="headerlink" title="3. 隐含类型转换"></a>3. 隐含类型转换</h3><ul><li>10默认表示int 10</li><li>10.0默认表示double 10.0</li></ul><pre><code class="hljs java"><span class="hljs-keyword">float</span> a = <span class="hljs-number">10</span>;      <span class="hljs-comment">// int转float</span></code></pre><h2 id="三、考点"><a href="#三、考点" class="headerlink" title="三、考点"></a>三、考点</h2><h3 id="1-自动装箱和自动拆箱"><a href="#1-自动装箱和自动拆箱" class="headerlink" title="1. 自动装箱和自动拆箱"></a>1. 自动装箱和自动拆箱</h3><ul><li>基本数据类型不是对象，在很多场景下需要被作为对象使用，这时候就会涉及自动装箱/拆箱 如：<code>Integer i = 10;</code></li><li>自动装箱/拆箱其实是语法糖，底层实际为：<code>Integer.valueOf()</code> 和 <code>i.intValue()</code></li></ul><table><thead><tr><th>基本数据类型</th><th>包装数据类型</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><ul><li>自动装箱</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 赋值</span>Integer a = <span class="hljs-number">1</span>;<span class="hljs-comment">// 传参</span>Arrays.asList(<span class="hljs-number">1</span>);       <span class="hljs-comment">// List&lt;T&gt; asList(T... a) &#123;...&#125;</span><span class="hljs-comment">// 语法糖 Integer.valueOf()</span>Integer a = Integer.valueOf(<span class="hljs-number">1</span>);     <span class="hljs-comment">// Integer valueOf(int i) &#123;...&#125;</span>Arrays.asList(Integer.valueOf(<span class="hljs-number">1</span>));</code></pre><ul><li>自动拆箱</li></ul><pre><code class="hljs java">Integer a = <span class="hljs-number">1</span>;<span class="hljs-comment">// 赋值</span><span class="hljs-keyword">int</span> b = a;<span class="hljs-comment">// 传参</span>Integer.valueOf(a);     <span class="hljs-comment">// Integer valueOf(int i) &#123;...&#125;</span><span class="hljs-comment">// 语法糖 intValue()</span>Integer a = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b = a.intValue();Integer.valueOf(a.intValue);</code></pre><h3 id="2-Integer常量池"><a href="#2-Integer常量池" class="headerlink" title="2. Integer常量池"></a>2. Integer常量池</h3><ul><li>相关知识<a href="../../02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01-String/">String常量池</a></li></ul><p>先观察一个现象(对于引用数据类型==比较引用地址)，详见<a href="../02-%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符</a></p><pre><code class="hljs java">Integer a=<span class="hljs-number">1</span>;Integer b=<span class="hljs-number">1</span>;System.out.println(a==b);       <span class="hljs-comment">// true</span>Integer c=<span class="hljs-number">321</span>;Integer d=<span class="hljs-number">321</span>;System.out.println(c==d);       <span class="hljs-comment">// false</span>Integer e= Integer.valueOf(<span class="hljs-number">1</span>);Integer f= Integer.valueOf(<span class="hljs-number">1</span>);System.out.println(e==f);       <span class="hljs-comment">// true</span>Integer g= <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);Integer h= <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);System.out.println(g==h);       <span class="hljs-comment">// false</span></code></pre><p>原因在自动装箱的时候，使用到了常量池的概念，阅读<code>Integer.valueOf()</code>的源码发现，</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = <span class="hljs-number">127</span>;    <span class="hljs-comment">// 默认情况下是127</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);&#125;</code></pre><div class="note note-warning">            <p>在<code>-128～127</code>范围内，通过<code>Integer.valueOf()</code>方法创建出来的对象，都是相同引用的。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-30分钟搞懂Spring-Security原理</title>
    <link href="/01-Java/06-Security/02-Oauth2/02-30%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82Spring-Security%E5%8E%9F%E7%90%86/"/>
    <url>/01-Java/06-Security/02-Oauth2/02-30%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82Spring-Security%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="30分钟搞懂Spring-Security原理和实战"><a href="#30分钟搞懂Spring-Security原理和实战" class="headerlink" title="30分钟搞懂Spring-Security原理和实战"></a>30分钟搞懂Spring-Security原理和实战</h1><p>本文基于上文<a href="../01-10%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82Oauth2/">01-10分钟读懂Oauth2</a>基础上，使用Spring-Security实现</p><h2 id="一、Spring-Security-Authorization-Server"><a href="#一、Spring-Security-Authorization-Server" class="headerlink" title="一、Spring-Security Authorization-Server"></a>一、Spring-Security Authorization-Server</h2><div class="note note-warning">            <p>⚠️声明：本项目不是一个长久可用的项目，目前已经是被标记过期</p>          </div><p>详见<a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide">OAuth-2.0-Migration-Guide</a></p><div class="note note-success">            <p>好消息是2020-04SrpingSecurity团队许诺再造Spring Authorization Server</p>          </div><p><a href="https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server">Announcing the Spring Authorization Server</a></p><p>在新的Spring-Authorization-Server问世之前，本文实现的功能为OAuth2中定义的Authorization Server角色，负责<strong>认证</strong>和<strong>授权</strong>功能。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>02-Oauth2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Collections</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/06-%E5%B7%A5%E5%85%B7%E7%B1%BB/02-Collections/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/06-%E5%B7%A5%E5%85%B7%E7%B1%BB/02-Collections/</url>
    
    <content type="html"><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><h2 id="一、常用操作"><a href="#一、常用操作" class="headerlink" title="一、常用操作"></a>一、常用操作</h2><h3 id="1-获得空集"><a href="#1-获得空集" class="headerlink" title="1. 获得空集"></a>1. 获得空集</h3><pre><code class="hljs java"><span class="hljs-comment">// jdk6之前，需要这样获得空集</span>Collections.emptyList();Collections.EMPTY_LIST;<span class="hljs-comment">// jdk7开始 从底层源码可以看到 默认创建其实是赋予了一个static的EMPTY_LIST</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><pre><code class="hljs java"><span class="hljs-comment">// 二分查找</span>Collections.binarySearch()</code></pre><h3 id="3-线程安全Collection"><a href="#3-线程安全Collection" class="headerlink" title="3. 线程安全Collection"></a>3. 线程安全Collection</h3><pre><code class="hljs java"><span class="hljs-comment">// synchronized</span>List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<span class="hljs-comment">// 如果需要使用迭代器，需要再次同步</span><span class="hljs-keyword">synchronized</span>(list)&#123;    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4. 排序"></a>4. 排序</h3><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Collections.sort(list);</code></pre><p>源码：Collections.sort(list) -&gt; list.sort() -&gt; Arrays.sort(list.toArray())</p><p><code>Arrays.sort()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Object[] a)</span> </span>&#123;    <span class="hljs-keyword">if</span> (LegacyMergeSort.userRequested)        <span class="hljs-comment">// MergeSort 归并排序 v1.6之前</span>        legacyMergeSort(a);    <span class="hljs-keyword">else</span>        <span class="hljs-comment">// TimSort v1.7以后</span>        ComparableTimSort.sort(a, <span class="hljs-number">0</span>, a.length, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;</code></pre><p>TimSort 是JDK7以后引入的一种一种起源于<strong>归并排序</strong>和<strong>插入排序</strong>的混合排序算法，设计初衷是为了在真实世界中的各种数据（<strong>部分有序数据</strong>）中可以有较好的性能。</p><p>基本工作过程是：</p><ol><li>扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转；</li><li>定义最小基本片段长度，短于此的单调片段通过插入排序集中为长于此的段；</li><li>反复归并一些相邻片段，过程中避免归并长度相差很大的片段，直至整个排序完成。<br>原则上TimSort是归并排序，但小片段的合并中用了插入排序，所用分段选择策略可以保证O(<code>nlogn</code>)时间复杂性</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>06-工具类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-更新日志</title>
    <link href="/01-Java/13-EasyCode/02-MybatisPlus/00-%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    <url>/01-Java/13-EasyCode/02-MybatisPlus/00-%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p>2020年09月13日 增加多主键支持</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>13-EasyCode</category>
      
      <category>02-MybatisPlus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chrome书签2020-09-12.html</title>
    <link href="/99-Others/99-Others/Chrome%E4%B9%A6%E7%AD%BE2020-09-12/"/>
    <url>/99-Others/99-Others/Chrome%E4%B9%A6%E7%AD%BE2020-09-12/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE NETSCAPE-Bookmark-file-1><!-- This is an automatically generated file.     It will be read and overwritten.     DO NOT EDIT! --><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"><TITLE>Bookmarks</TITLE><H1>Bookmarks</H1><DL><p>    <DT><H3 ADD_DATE="1599298828" LAST_MODIFIED="1599890447" PERSONAL_TOOLBAR_FOLDER="true">书签栏</H3>    <DL><p>        <DT><A HREF="https://www.google.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACIklEQVQ4jYWSS0iUURTHf/fe8RvHooE2VlT2FNqUGWmNEYUR9lhEEVJhUIsoXOQuap1Rq6KHNQt3LaPAIOxhlNTChUwLMU3NR1CklUzg6xvPd1ro2KhTHjjcA/e8/uf/hzmmqsUiEheRLhHxp/2TiDxQ1aK5+ZmFeSJSrwuYiMRVNZKuMxnFz51zu9T3GX/6iPGmRqS/F5WAUMEawuUVRI5UYjwPEWl2zlUYY8YMgIjUW2vPBkPfSV6uYbKvJ+uW3rZSojfuABAEQdw5d96oajHQqr7P8IUqpL8X43lEjp3EK4mBtfgt75l4+4po7U3cytWZPbcyjUlTidv642ipDu7foX7bh2zgs92jDhHpUlWdbNmuEw15OvqweqE7ZjboCAEFADrSjs1LkRM7NAt3+bWRebfYudFx9XguwFqbwePs9z/mT/6NLdAHMBpex28W0/C1Y1Zy05VFM75nUwiAZVGT/v5sgdcA3UurOPUrxvXOFhJD7fOmdn4LeNc5NbpkfWimv5mWZ8KXFKdfXqInOYBnc6gsPEjZ8mKssbQOtvEkMczYl0oK8z3un4lgppbYkhZS3Fp7bnD0Jxeba+lODmTFviFcxq29NeRHDUEQ1DnnqtNSjohIo3Nutx+keNz9gmf9zfQkB0ChYMkK9q2KcaLwMJFQGFV9Y4w5YIwZzyBBI2lRLcD9PVXN/SdFqlokInUi0iEiE9P+UUTuqurmufl/AKTzsFGmvUNUAAAAAElFTkSuQmCC">Google</A>        <DT><A HREF="https://www.baidu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACP0lEQVQ4jVWSS0jUYRTFf983M5qmMw4+UYsS0zAKKjdimkHgogcRNIGryijJRZs2UW1sWRIJQZBBbazcRGZCZA9FKoOCGlTMkbSHOj4QZ3TGceb/3RbzN+iuLpfDPffcc5QxIoLWGAFBa5JljN2LIIJS9lwrhVLIOvrhR5oe8XMRrQnM8uwrRlAKsfE4kwssg9KMTtP6mpklcjNo3s+5DoamuVzPxQM2iQj2BS4nTs1MCCMUeFiK0DvCr0WKvfSOEk+AILLOoBQPPhCNU19BVhr+KXYW4U5jeY3IGg2VpLhsVUrhVIr+MVp6iMQRaDvBQICz1awlOL+PNCfVJVzvoaaUujIsgxKRO320vSMjlfJ8Ok4DDE2RvZECD4Cvnb4xCj10NlKahxahLI9Ygt+LVBQgwoXH+O5z9C4v/FiGYJiSHKIJxudRCqcIB7dz4xjzKzTVcPstL4fJcxOJcaWLLTmU5tL1jUIPW7MRQf0zDmjt5epzWg4TXePee7zpZKbScoRgiOIsardhDMoyghBLcOkpgVlOVbG7mL7vjAQZnOTQDgYnuHmc8nwSFg6NNoLWdH6h20+bj1cjfJokz01dGaEoDZWEVvG1M7GAQyeNE0Tw/8G9gRQHc2EcihQH3nR2FWEZMlMJxxieRilM0mml2LOZqSWuddNYTU4GTz4zMM6ZKgLzzC2jFUVZICiFMkaA1Ti33tAfwOXAm84mLysxfiwQDJPi4ORemmvtFP73JcsAONYTblksRnFpPOl2kIC/BsEA9PPta4oAAAAASUVORK5CYII=">百度</A>        <DT><H3 ADD_DATE="1599889163" LAST_MODIFIED="1599890285">官网</H3>        <DL><p>            <DT><A HREF="https://git-scm.com/" ADD_DATE="1599889952" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACjUlEQVQ4jX2Tz0tUURTHv/fed+9749QMOmZq4ug402AJUREhQmkQji2qRbQNB2qhm2xf/0KS40AGUZtoI24iDQMXlZt+EFKLnMkpJYwif6SO7707990W5qDieOBuLt/Pl+85nENQonINsA4cbXoM7en56dy1WBbObjqjBE9qj0QeCFNchQbC8dhaBpme3Uzozo/M6YrA0rmqiEfoLDQAAnCTJ8PxWHqiAdaeBpN18NVVVqSFL/hydV0OL9myz3EKr5VS4CZPtrXEBnM7TEix53ZYtWXRtDB5NwhBPu9O+seybV9Plgerq0Nfyjg/CEogHfnwx+dMb+M32MUEk63wVZVF00Kwbrug4CoFwnBsPtHQ3vR+cZlCD4EA0BrcNJK1LdFiEjbXCl99eXTQL1i3rTSwoYNPGEI63vztwxWHHCnfck9/V1qHCUi5wY3j/opAzY3KxXHyuzMyErTMy9JT2/ryGQw/8vYdS8MUBk0W3IXmFdujwUDlSNAyz0Jr5G05TD1C17QGNAg0UHzQADxAEe3uM80ajVBnYZ16TJMNIQAFtUrnxrLdrpQpi9LiTPX/GCYjzCCUEqohBB5VVYemLMHOABrSLQxMj+auEwCYAIwTiWi/3xS9tqfAiEZBYXFF2uc9l/JyP3vBDSPAQEEpgZRu6s2zbF8HUKAA0AEUno5l+9aknbYoAwWB8tSvjzOzn36uuFNakz8EAKVA3nEHN+FtewAA7wAeuxDp93Orx/EUbOW8oh6hFudtFmP469qDH57nbm7CAMC2GgwBXmNmcTwe3h/yCX7KZDwsDFrPKcO6I1NPRmduXdkCl6z7AF9ORFPuxWYtL8X1Sld0YKL04ZU2WUjE7i13Re7uBf8DNZgMfT0tE+UAAAAASUVORK5CYII=">Git</A>            <DT><A HREF="http://nginx.org/" ADD_DATE="1599889279" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABoElEQVQ4ja2TT0iUURTFf/c1o4GMMaHiIoYi0GZctdCFCzcKOSmFQbgRRQcpKKGBaTWgCxcpom4kLNA2gRDUIkhUBENo4cKNC0EU3fQHtMjJMedz7D0XjtM3fz5J6Ozeefeee+7lXsEBRc9vNSiREUAbZcLxB7ML+eIkm7j0Inhdaz0syF07bwzvkm4dSXTPbeUVKJm447EsK4rIE4HCfNUMJMCM7GnrGY8+xtMCxeONbWiGEMqdWsp0Y76KksivhzNTF3hzv6Dw9+Eyggeg6vJVOgNB1ne/sH+USCd1BW5j/Umyc7CLiHiAFqu6YECxuqPsrYSqmolWt/O2qZ8i10UA3MrFaF0PHf6g3YiCMqWy7Z0q3fD6eFn/FBFBUmzOxE9U8iO8OEbztVp6azrOnIfL6eP12hyVXh/hm61sxb6dXwCgb2mSCu8VhuseO8bktGAAgwFAG01ofpD1n59P3ik+00GgVPNjz5Ca0avVaVa+b6QD4skD7n2I0u5v5P3mJ3uuhm39d5EMQ3D+Rfo/q2zHWcek3DoSczqmbPzrOR8DeFyiYu0KFwEAAAAASUVORK5CYII=">Nginx</A>            <DT><A HREF="https://nacos.io/" ADD_DATE="1599889366" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB9UlEQVQ4jc2SzUuUYRTFz32e9/Wd0Up0aqohBEtiFjJ9KFaLWbQo0L1tktrlv9BADLpoCFokZsW4iNqV7QMrCDcSOKlRuAn6AENo0KYYx/freU+LqUycdhEduJvL757FuQf4T0TBFDVIwQgVRqi2I1Q/RkBqgLJ53NDz9/2fGQsQ9k0w4TgYpoNsqLEaRrhfEnn6y0iEB+fCAXH0UNjC1sAyM7W16mRFpCI9RXbsDDEtO5D2gIXI5gFJyB4vxKi7jsLSOfHTJVOQdpXz1s2KiUuZCZUxfvjK2/D7VYuLO0qzo/YVp2YvyvHap8+dwQaKykJeVbE3/cLk7YTKmS9R4d3z950fu/SRcNk7iybVbWv7Ok7fJrNjvAEAGKQGAExRdz9wD2WecCwzT6ZnzeUtYQLY98G7m1r2/e1pA8ASqC0nRh1pIQBBQ46gKBPgsR3jpRPjPIlHYnqKbO49ilt2G94E5eCmcXGlab+6enjeFDD+1oFIlHrtntG7rAugPKyHGGFampH2wUVjSUp2I+ka5FUS1172SpAuBQW0Wzm/alaimJSjpMoYL1z0a16/AEDfBBNOHMORRtY0YdUQ9+bOy7Mtb1xwB8R2hsI4WwOLM7W1b5OVY22Vv1OkepWhMIgIo6jDItEmKfyZPgACUBBEEGFD43+q7wDS8apIz4VIAAAAAElFTkSuQmCC">Nacos</A>            <DT><A HREF="https://cn.vuejs.org/" ADD_DATE="1599889876" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACfUlEQVQ4ja2RTUhUcRTFz73//3tvZhQVZkASUmrVB7mpMMu0sQg1WrRxI7Ro0zpoVZHPDCohImiR0CaxVdCuFGmhGblxIoyiVV+EkoiEqNO89/73tvCjtKJNv9VdHO45nEMNT8KKxE0nQA1mzhbgciWqBjA1NbKEX6ivP1425wUKAFvCvcD0NOzWGkstw1fuG+b9wkiisVmUns+pKQs8cfH1yaHBAQDY1376DBtz3i3FcdCSI78pCxay4vQFHR7qOWrJjHDasnyLsDz4CbqkEHLTWlreZTSxGpS/IfWqqYKR6aoFV/qQYiwQbTWfH4x+qOvK54yxDeIjJlZE7xacl/KrFOTE+k3W+G1JMYqDfA5cl3EMNuLc7dH2y/0MAKSuz0XRVxKy3p4qmNq0TYqRgOg8gc4lxUhsXdp6uytBQtaV4hkH0wcAjBA82hF+EeAGGyZ4pEFjFiBlqAYQDWDA/qEcYAnMTCq4Nt52cQYhmBFCANBi5Prle/ySyRq7vVzsjgrVSFRjUW9nhdptZY7JGFeKCtHi/D0AhBDCAIAQVDgZLseMbnECEME/mFNKGaKMIb8xq1AiFXUQujTReasIXZmX1odWEAh6ZKjnkUkFp0QTV3o6y2AgaK0WZmOSYunhWHt355oWACw2IZJ0U2SOEVOZdyCrIIAcSOJ4QdQLN+t5/SIoQvCzE72vRdxd9i1TwEIeCfuWRfXOeMeFtwjBa+4bH6x0oQCwmNK+pBh/JGZD1hi3XHofQW6uauTPCdaaCMGFfDgnIr3ETEREiaB3oi2c39DZXx6sORCnZUDi5JVEbtJkZBAKAn5G/xcEAC3DPfnmx1ebV7P95v5f+AEr9CGUuVbbiQAAAABJRU5ErkJggg==">Vue.js</A>            <DT><A HREF="https://spring.io/" ADD_DATE="1599889190" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACvUlEQVQ4jX3T20tUcRAH8O/8ztl117Pretk9665tZVtWW0lgtgRGmC9GBpFUQikUFBRFFyLozX+hG6J0D30wiHxR6CUTu1BtD9JNM0w0V9dbarqtnvObHkwpM+dtGD4MM/P7Ef6IyvqQddDu3U7gcoALAHh/l6IgaiFJ9xP+8ec1WyIzpxtXJ13d1TlNc/hMQ5FXCuMigAoG3Fg8YgBuSkm3ki32QihmHc1hU8xcB2gfAPoPBgBINg2fY+WHrYFi5fHnBwfUyvqQdUiYlwAqXQoyGFKacGt+ZW/oZK7XsTzRMRwJqzFN3ykkH17QBcw8nwtS2GF1IaSHuShYRlkpQfw0JpN8zmCBKpgrAGQAALOEIiwccOWw37kKLlsGklQ7Um06Aq41pGsBoQgVzBJWxYY0m2ezCkbBbFcJd7KP96w7xhu828iuaovuwmQDQ5NRU9eyFKc1NaAC0BkMzerkstwLvN6TL5baRe9Yp5wxE+R1BECkaGJu5pAnzGvdeUvi/h/d/D72mv0pQQIAUxrTAkA/GMhKCZKg//svI22yqeOu3OgNi2SLg2ZH6e1TCWgBUB43Jv9BDMb3eIxf9DRx+1CEd+ccoeWuHAKA4ako2ocjT1UQ3SMSxW39zzzhZcWcZtcxEh9Az1gHtw9F0P39E2c6VqBs03nhc2YTACSMOFq+Pur7MPC6Vs3Q0Dw4Lu78mB690PCxmicSIxhPjMCmapydvhGlG05RMD2XVGGhuDHJ/RNdeNr1UL6NNt8YN9+8JADYX5/pOZF/7bICcfDBuyuUbtdlml0nhzUNFsVKkiUSZpzH4oNicOqbOTU9UQuFzlaVtI7O3/pN3xN3Y8ftc7GJ7qPMnMmQf71GACBBUSFFjanIy1UlraPAgo9zvDrPovqcYUHyEEA7wPDPSvQSqJlI1qVr4lVlYbMxZ34BeHEn8QqSwzsAAAAASUVORK5CYII=">Spring</A>            <DT><A HREF="https://www.docker.com/" ADD_DATE="1599889204" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACE0lEQVQ4jbWTu2tUURDGf3P23JvdKxvRGIwEA1okmNSWAcFCBIs0+QfEF0hsFFtPwNIHKFosWGhhYbCzEERMQCIoiBYJCpEYAxJNk6e5u3vOGYtdkvVBsPGDYZhhHh/fnAPbwTmDU7Ntzf/Fva/XqMzfBmQz9xsj2/SCKoyOClP9wsC0MtUvxHgAKIETuAKI4iS2DpDWgMr8LXxtEGNnIOxDzCJSSDiz/wQAR15YhjqPsjTwDCcRp8bi1NDxsYtAmVp1FfQLhG8QFJF1qCdcf9dLVlonD3sp736K/XQWqOAkNhjcmbmKMILyHGO6sckc3ndTsMugBqULa2dZWRtlR+kN+foiWft7fHW8wN2Z40AvsIzIEkoOugaaI6wSwwYavhPjEhI68dVBitkuNPbg/RML5j7W7EHjDzQmiEQ0GiASQ1MjUTQakmJKqEP0F1nJH3J5YMFC/EyIHfhahgioyqa82qqw1kmzgJjXnDt4o3FSZywhvKSteJh6rYaQILLVJpvbA6ZgEfGE/BIgDKvBSTBAhRBWSNtSotYBj2qLRUizhDTboFo9xflDk6AwJgHAMNL3Ae9PkhQXyMoppfaErD0h29nwSRoQM0EtH+JC3wOcM7DF0qIqiDzm5vQkxdIxfN6HUqYgG2DnSJNXnO55i5tta9b+8hKb+qj8mfw3tDSq8IjmRxkDhmF6XGAi4txftjbwE2NZ43Pq//CoAAAAAElFTkSuQmCC">Docker</A>            <DT><A HREF="https://www.python.org/" ADD_DATE="1599889245" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACN0lEQVQ4jWWTP2gUQRSHv907zSVRxIBiIjaCTRobKwuLQLARosKBtqKNoqnTCIKFIEI6IxY2wSaFGJSIIioGMaeetkbEGKNJxJPjLrszO/Nm1uJ2zSYZeAzMfL/3fvPnBWwaI7dePrCJOead6RObIMYgidJG67u12xfHAA24nA83J3BOTj4eG+5zYnHW4sXivauAvwwcACpFfmsCazl+bRondj2szbf7gZ4iXwYYGZ+96q09aIwKjFaTRrXKouOSM4Zwe1c1TX3OdwGlDQlOj7957pwd8k4IvCcgpVTe3kGDEk5skSddrC57G2lJoptdg69uhD51Qx2rZqPtLPIhuj0DWCQmdKpSTtUlYKCcg74g8oVzp6nXLole1O+N3flTHx5GFEhM6FUf0F/eILaWZK0583Nu+v5S/VkTECAFzOLr4cHdvTKKU+BikBiguywm0V5sxYlFtRpTtYkrk+2F0TM93YdOhU5V/sMSkVdHFF60BoJQRBZy679qTx9GP0Yv7Oh1Z0NfFMcFcQxOE8fpO8CEXkcTYox2YlmqP2r2VNyJdUFBVBADfJxPngDtIPtZ/cB+IEmXz9Vy+Pdqcyr0UYpTYBU4BcCX7/bT0fONt8C3MmCAFaAFpMVqe3dJFXHgLIglOLIyBKwBKuMbIeCzhQbw19tYd6wW4vA8Pk119iLLwNdsjrf0QtRqVa2OPngT6dyJnRv4PPteXwcsEGcFLZAGmxNkd7IH2AfsBLZlLttZ1VU6LQ3AP75vsPXueofxAAAAAElFTkSuQmCC">Python</A>            <DT><A HREF="https://github.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACrElEQVQ4jW2SzWucVRTGf+fe9847SW2n+WioIdZkJkzGWLMsQvBjpRv1H1BcqSB166aUbgQXLkpEEGnF7ty5Edw0orULtS5DjNOZ5qvEKkMzEUuS6bz33tPFvCNj6LM653LO8/A85wpHUJmbW0QKbwMvAU8BCHpXkZshhK+2mmu3BudloC5UagsfI7wvIsOooqoKID2gqvuqfLFeX7kAdPsEBmZdea74beLcKxoj+R4iPf7BXozBZ9n1jdudN+BOZgEtV5/8pJAW3/JZ90ZU/UiF0yAnVbWpUVvAMLASo7+oUYuFQvrqiRFT2NttLctUtXouleIN62whZNm19dur7wLFiZmzpdbmahvQyWr15L2Dg312dg5n5s5+6lzhvPfZQ59lLyapce+IkSGNkSjaASzQaW2udvrh3Gs07ud2LUqmMVhrzLA4+55RNS+IqsYYO91u+AwIvVz+F3C/DkEffh5i3FdFwSwaEaYUBKT950Z9Ox+MgA4QaL+/22xuCWzl708bwGkv6mMj5XLxiPJRCJOTRYXx3pw6A9wRVRUjpZIZej5Xso+xkAB65lhp0YhM5H9k3ajqrxgD8MAm5sp0tVrLczhqwZ+ZfXbeJckSoGJEUH42MYQvUZXgw5Kq3nRu+I/KMwvLM9X5c/3tqXLtuUpt4WuXyC+CzANRo4audq/Yf9r3d0pjp0atTT7M/OGbxpg9VE5nofPNv+32HsDQ+MgTqXVXRSRV5dAmNo3eL2036tekf7JKbeEngbEY/QcKDzYba7/9Z2B6ulhJj2+LkQljLD5k1zfq8XVY8yY/WVivr7wcNf5oE/e9Mcmt0dnZE/398TR1COMi4n3wlzfqq6/BWheIdiCouLfb+u742KllVP/+q+l/gHYAONgdkdHRxIbgL202fr+aiwLwCG7VPT6fvRxuAAAAAElFTkSuQmCC">GitHub</A>            <DT><A HREF="https://www.mysql.com/" ADD_DATE="1599889673" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACtklEQVQ4jW2SS0hUURjHf+fOzPU6D81pjAx6kFYLe0wkVBRSRtmDntKTiAp6bISIWrSIXPVaGARBBREV9IBetMmKCLM2lmGl0TjhaI6W2YxpMznOvXNPi3GuGn2bA+c7/Ph9//OJzefvyAdvWjF0A/4MgmmCx0mmhCL4X+W5s1k7twjh218tT1eUUlJYQDSW4MLzBmoDYTSHRs/vfgaj/ZDlANVhAaUpAfDmOLHnu91M8eXgP36Vcn8Rx8pLOLJqPikjRYHXw4eOH5yqeUN9UwhwgDZs1RsbQFBxQlbvWkF3/x/OXH8CWSq4NBhIYs91sbNkBofWzKet5xcHrj2luysCLs2C2PAvr3ryLsie0jlMmjiO+uY2ykums2VhMS+bQjS2hLn4ohFfbhY3D66n9VeMzy1hhKamAWLOsioUhUfvWji9dSk1Xzp5395NT1+cqG6kjew26htbeRzo4G7lRmIJnbfNbaA6sInZy6qEEJA00KXOjgXFPH7VRMSUCDHiBzSVnh+93G4IcatyHcHobwLBMAqQTlV1cLPuEz5XNqtLZ0NSt9K2OE6NcHuYdececnnvKly+3LQBcihZU6HmU4gre1ZS19pFJJawwhJiCKQ66Pz6nckFY9m3xJ82sJbFDvGffQS6IthtNsteyuFJhCLA46TyxjOmjfemAaOaLg2hKLT/7AMDpJFKb2dm1Mw73aDi/L0RGWROI2UBPR6VTfMKQTdGrbU0JUJTaf4W/Y/BoE4kPkBhfi5ls6Zy7+gOJowbg0wkR78bKuXfC7Kc3G8IsnvxLMbYbXwIdlK9rQy7U0Oa0rLNmCh57uxRDaEJXjWHiCeSnN1exrXXTVys+8jJDYtAUUcK481xIgC8B6plb2xgmJwyQUpW+4uoDXQQ7+5lZvFk8jUbde0RUqZJnjub6KXD4i9MiR1sPkM8xgAAAABJRU5ErkJggg==">MySQL</A>            <DT><A HREF="https://nodejs.org/en/" ADD_DATE="1599889296" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACQUlEQVQ4jX2TPWiVZxSAn/d9v597Q5IOIiWFGJBSWlDa4pShTh0dsli6FRTuqDgUOpR4K26CpY4tzdIlxMW9InTuoBAXtyYZUjW5JPfn+3l/znGwSkhvcrYD5zw853COYUrc2rjaLTuzKymY1XoSadpwZ+6D+Ojnbx7Wx2vN0aTf79vB8rMvC5m5maViRbyba1uhmrQj4FGW8cuH/3zytN/vy/8AvT+/PlfYvOekuJan7kIWO4h3hKA0tSeEhLN21zi7Vhh+ffDdH9sA5lKvl39xZevbzpx+b7AXXCpNHrscBYQQaeqAAZyzajP7XFK697d/sW6XPttbbAfFbUnm4vGRjk5qnUFUEVEjSS8O6vHt7qC7aPNcM1+Z3I/c9N53CGsQFBGl8i37o1GOklmKFpxSH1okmpMUAEgqBEkcVGNCigBYSjC5kALUQ4OeAlCUia9pYyCzlpISC2CcolZ4vdvS1nKqhZeINYbSFVD+Z2AzpQme4dCz/9qfagEgqjiXvTUoC4gamYwDqjDYb6iqcCogSEQ0UZZgo7ZxNAwheMEY8F54+WqC6skeqkodfPChjXZ272CnHqY+sAmoMTA4rBmOG4yZug01mE2R+NO/Mwc77ysu3728iJUemOuqunBmfpaPFz5CEviQCDFSte3uqG5+HzfNb49/eLwN8P56tp5sDbe+2v7rnF16gjEzPsTznbIoO3lBFB0llQ0iNz7d+3x97ce1g3d9Ux2X7y93XeVWzszPry6dPYsqd7KsmvrObwA+tTchrleiRQAAAABJRU5ErkJggg==">Node.js</A>            <DT><A HREF="https://www.jenkins.io/" ADD_DATE="1599889826" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACzElEQVQ4jX2RO0xTcRjFz73331tuH7cPHral1IKxhWKIJBjFR7VRFGMndPA1OuhgnFwcDAmbiQNxUBN1MMTJAWOclAhEJKBBMGAiaCko0trbNm3pvb2l7d8BiVDRM33DOb/kO4fBFgoGg65KUbzatMN2bpfHbYvGpJ/jE5967/c97QWQ2+gl5WGv1+tw2uwPThxuPbbb42B0FQQVvMdur7bc/Bpeir16M/poo58tBzR7my4LOqHDZqlgpHgcipIDpRTNHpfudPDQeQDCPwFH6uraNDn5bD4nQ9By2Ol2QEquYCkiIZ5Mg6WMb5/P17IlwOHwVHWaxFv+etvOFo8NAq8BABj1PCxmEYlUBpXFgj2gYXucTqf1L8ApkQ3ureD91nQKjW47aqotYBgGBr0OM5/DiCVSKMWS2E+4gF+vP1kOYBoICVgJy7lnw1h6/Q6yWkB6RYaUSCG0+AOgFPi6iFqOJfUaEti8gtut1bGMgwVFgiMYn5dg+LQALpcFBYW9yoKhkWnk4ypqwcDMohYADyC/BgiHi+quZmW0xKHf5kFcMGHm+QSOZyKokiKYNxjgTCvoNzuxJ6WgiJIMoLTxhdVosTAVBYuE1oCCqiCmlDC9UoRc7USlvwPRg0dhoEWIpSKW83QKQGFTiR/V1WdElSPmXAYUAAHFpGDGi20NCIHHnFqEWcnguyCszBAyvJ7j1o9QMhmxiCY2a7D4c0RL7EYeHQfa4HPZkI4uI/zlC9r97Wi9cJGHXpwcHBoc+1PimkqDybm7rrqmTgoEGhu9uHHtCjhC8HbsPebv3KO12105VqMRtDzn2LzCb0kSMjWx5YdUkU0/vpm8sqLojUYjRL0AvqTO9j1+cr2+wWWIJRJj+J9EUbSe6eq6NB8KyZRSuhAO057u7mGr1SqWe7mtAKqqKoJOtywajcez2ax9ZnpaHng5cPvD1ORIufcXlJMSQuAcUrUAAAAASUVORK5CYII=">Jenkins</A>            <DT><A HREF="https://ubuntu.com/" ADD_DATE="1599889924" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADOklEQVQ4jVWTX2gcVRTGv3Pnzmx29k8S3HV3yWpaCcWHoiQBjQarxYSWTUQJ9a0WH6QEVMSCohSxUkHEWg2CpQhSUEQUrVrJi6lVQ1HabhMJGIw1Jm3adFPadJPdmZ2Ze+/xwYTG3+t3fk/f+QhrMEAE8OzQ5nYZeLsJpk+x6AQYkmiC7aYf7ZbWTwrHJufWbwGAsIGFUu5FC/olgAuKBCJDTARYKiDLrwF27Conm98pfrd4eN0RDAgAuDSQ/SAh9OGGQcEzImpUl3W0fA1BZQkqdZtO7T8WiZ5S3vWr7y483nYEAA4AQhJg5gdzLyShnruuKIQKLeN7MvnwE4h3b4deXUa0OC9SO3Zbwk3ryz8f17e7avhiKTdz52jlPZodKrRLLyyzEK2RV2fZ1iHc+/sR79qORO8AmYaHcGaSG7//itr41whmysZ2U0Tgakwmu2luILu/CXhzNQgVjLKKI2NwtnRifk8XwVthVgHc3sco88wbHMxPY/GVIcB2dEqS9GEdEGDRH4UhE0DxrkepaWsPVd4eJnVxmnWjTkZrqn75MV/76HVK3NdPiUeGiGtVUiRYEPqs54t43976QKz44U8EBkyjjpUvRmCMJiEdEBEoESe98BfLTB5q6RKCC1Nk7BggRFb8VwYBwgIDBGasVfw/GACbtYxu/Y6wE8lJM/0b5nZ1GO/0CXY7t1HsnocI3iqzUWBm6Mp1dh8sUbq0h4zSBK2NIwgSpiwU65PSdoiNZv/cSfh/nOHcq0dZ3nE3iZjLAsTpXU9Tdu9Brp8d4/qpr5iSzWzDEDON0T8785sEojKEaIm8Ostih3B7diB+7za4vQPEfh3h31PsT55Gffw4gj/Lxk6kSICrjpTd1siF2s19W9JRWuidvrCVqd4gf2KcoCOY1RtoTIzDP38K2WffItmcMSs/fK4z6aQMmF5r+35plBgQBJiFwfyRBKLhm4pgQJGpLQvWWpiQ4Wy6y2T2HjTeL9/YzplRhG7L0fy3l4fX3FtcGSzsI45eBnNufUwgQKqApF8DbKfCidZDbSeuHFp3aENNRABffbJ9c1DznyLBfZpFNxPIBp+D44w58dZPc59NzW6c87/NMpPlLrZ/hwAAAABJRU5ErkJggg==">Ubuntu</A>            <DT><A HREF="https://www.jhipster.tech/" ADD_DATE="1599889738" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABvElEQVQ4jbWSvWtTcRSG3/d3b5qmJhHSJkMxrQZpReIXolAoFIoKOomTiIO46X/g7D/g6OLgJrg6igUFQXDRoq0fFRXSaBraNB833uTe8zokZix08GzvOc9w4HkpCfsZty8agA9IggRyL07A4O4kkHSOJAHEEgByGE0YRPdv40i2u70v1UajE5L0nSMZxRbFIuk5ktwNel9r7Va3T9JvBuHthy8+VrZz6fETxdzFkzMXyoeyE0kAQRi9+lxf+bS1Vm3udPql/IEH10/x+erPu49eJnxnpj/9CMKRQubm4nw2k3n6tvJtKyAxnvAcEUZ2/+px/933ehTHqTHfaFk/6RwqO8G9J28mp6Zz6eTBlG+ADM4hNn3YbLr1zYbnOUCOBNAK+rHp1tL8jYWZ2NQJIwgkJPiOG7WOX291zRSbgl4k6ezh/J1L5eVyEcDS3NTj1z9WK00AqYQHoN4O/StnZjd+74753rlS4dr50uXTs57nYjMAi3P5haOTK2u1Z+9/rVdbAJaPFSipst0iOJ1LA4AUa/ieCR4xMFptdCNTMTdBMxsYkWTSSNBQsGSCI0YMzQY2sWczMGL439v6F+3K1rYzGmfVAAAAAElFTkSuQmCC">JHipster</A>            <DT><A HREF="https://swagger.io/" ADD_DATE="1599889749" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADKElEQVQ4jXWTzWtcZRTGn3Pe996ZyXQ+MjOZ0pqmOlJim6aaaImIlhYXTYVCu1DIzq9WEHEjFvwHXKgQ/FqoreJGkFqhVGTUSBWK1Upo1VYbSUvzYTGZZDKTaWfuve+973ExiQmCZ3UWh3Oe5/lxCP8t57GhbG94pLjN7Et32c0igkZF35yf1GdrV90TCL84v36c1trHVarv1qs79jZf3HXQi2/e3oJ2BQIgCgg3/0jglzNxf+LbxNv1q+VXAISrCxi4X3Xtzn26/6Xm4XsP1sSJS9haYi2ycoWAeNqGYUD60pksfTOaPD1/IfMEcDJUACR1z87Xho+1nh4aqQaNiuK/JxyVSMm/+sQSanOaiUVKQ03jdjh9N36TVFC9VlZwDgwMjjQ/ePSFGvwGq/LrnTw1HqPevS2CgFZU0ldvZGnmYpx6BgLq7vfs4g1n9+zF7WXO7wiPDh7yXWIrzWWmyjUte44sCyvAWoKNCKyBh55qyF+XXWktM5GyMnDYc3J99lmd2xrtKZR8iQzYjVsYjymVj+AmLJRue2At6NwUEiBw41aiANxV8iW3JXpEb8hHJe1YsoYw9laGegZ8zF6JwYYAKwFAsBZgBrp3BRh7M0vDx5agXUupQtTDtAqSAOMxAIHYlfBkjTIRYHyC8daRJ0t6eUFNh4a3xZJWhl9ewkfPFGnf83V05CysWbPQqjO+Hs3iyeNzwlokNIxGRU9xddr5YeF6jJQLazwGM6Q+p8W0GP5tht9kGI9xa1GJExMJA4ZyYReux6g6o89xdYKPj59KhGJBibSVrYM+/fRJiiRqZ8AssBHw/XtpKpQMJdJWJGQaPxU31Sv6fYVwcqZe6+1Kb9QPloZumzv6Au7uN3Bibd9EACwhf6fBzv0tSW+Mwp9P5pxzJzreCSrlDxUAChaL381Nb3g4ntZ3d/d7NtlprTXg1fBYAcVSGLIDNf5ZTo+Ndpxeupw5Cvwuqh3nbNj0Cp9PXcpsmf8zdp+KEScyEYFA1hIZj2nyx6Q6+246OP9xcrT6q/8c8KUBIOsgov06+QOHct0yUrgreCBVjDZBQI2K+t93/gcExXGIAOhW+gAAAABJRU5ErkJggg==">Swagger</A>            <DT><A HREF="https://www.jetbrains.com/" ADD_DATE="1599889329" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABf0lEQVQ4jZVSu6oCMRCdSdYHrAF/QBsLQQikECu/QOzsRbCztPIHxD/wA2wsBRs7OxEEbWwsBLGx2MLHLuIa2Mwtcp/ivVxPEcLMnEeYAPwDiIiI7/fvjVgslkwmr9crALiua4whImNMGIaPGpxzAGg2m77vFwoFKaXv+1prIoqiaDQaZTIZa+V8mgJAIpEQQnDOEVEIMRwOp9NpLpfrdDq73a7dbjPG2Hcfm8HGIKLVajUYDCaTSRAEm83mx5vi8ThjrNVqGWOklEopy4yiiIg8z8tms3aSAQARaa2NMff73crbuX6/X61Wa7Wa53nj8ZhzTkQMAJRSvV5PSlmpVBhjh8PBcRxE3O/3s9lssVhcLpd8Pv+Vv16v0we63S4AlMtlm+d2u2mtT6dTo9F4X4jlKKVKpdJ6vZ7P5wAghJBSIiLnPAzD7XZ7PB5/Xerf9edti8/QNu0PQjqdftAmovP5/MQKAFzXXS6XqVSKiBDRnkEQFItF+68eCS85vIw3GN3cFvFSSoIAAAAASUVORK5CYII=">JetBrains</A>            <DT><A HREF="https://www.elastic.co/" ADD_DATE="1599890048" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADAUlEQVQ4jXVTS2wTBxB9s7uON16MvY4NhpAP/0AKiqKoBClV+UjQClAUhChSzwjEBcEtJxBwpCUCCU6cEBJEVLS0aaVIiI8QcEBp0roISFriEOwkjr3rtRev17s7HAjBgDrneW/evHkD/E8xcwPbyT5P/3nSy14ue8bAK66kzzLz0uo+qgJEPa10wMubK6S60N+Mh/s42/ctm48IbAGCAlqwhSl67BYFOg4R0TQASHNgnzuePW3dGD7kjs2S3LPaldZdENj4nUDSuzmuDtZ/IrDTTfXnhgCcAgBhTsASZ2jym8q9UfJSebA7LaKcIJBYJZIAEsHFu2Dz0W5mDs8rcIDl5QY1IH3ZDEGzIMUNsJOr3vADiWcC9kQUQBCALlkO77o6VugbMP2Llm5rR7tfxK74fag5G/yZsy4EeSVyaFNdE1uZ+Zq480hv/5mR3PqRnI1/DAe3dQf1oRjalQRgjwPsASQAcCEqbXjinsDRQUF+mc1tb6uPvJFeGHbrVMmFTyC4DDQFRDg+Gb/5TmBT3RbESr+ASwmw8hUGjePovW1hNJNGIp1b2Nm06LgUrxXTiiQ0amUXX6h+7F1FuKk9RWKiiNbgZuyt68Luxa/weGIJegczmCoUIQkCiraDKaMUlzbF5B++W77g1FPdDn3d4OD67HM8KxYgEuHPfBbDhoC70RVYrUnIFJJgBiqeh+ZIEOvioQQxs8+0sf+eNnP+5NhIJFl6A5E+uM8AagQBp5vXwkpnMZwqI21UsKe18cX3HSuPSURUYeY7/5by2qRVilSD30dVJBGymIISvoKdkQjW1nVnWmJrDhLR/fdBKi6TazMBUfzsdB4Yqq8GCs8gVXiOcf0hzErSBJCcTyIRGZ3h6K9daoxd5nkSBuAyo0UJ8mK/31HlJrREd3BzuPMPAKlPnyk2lNcvXUyO9jzQZgXTdSALIjpCKh9uXDXQFfb3a3ZmY0CK/Bfwqf1ElP2IYI4knraso38V9APTZSseqamZ2RAM3WiqVX4kotefBhMA3gKdnWGyPnzI1wAAAABJRU5ErkJggg==">Elasticsearch</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599890236">学习</H3>        <DL><p>            <DT><A HREF="http://www.imooc.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACIElEQVQ4jX2TP2hTURTGv3PvffljE5omDWoFI2J1EBWNbra+aAOpFB1KROlSBB2cRBdxsTrp4CoICk6CZBDEqQ5V0UkXRSoShApiaiPakDTJ+3ePy0tN22e+7V6+87vnu+deIEAMEAAsjU6ef77v6ECQpyMRuGuaEgCUgTMHU8lbPjTQGwxIp/k9skbFaib+uPbU493ZQQI0/M56AhgQVCp5g8fSE1FJh6RAXzGT2dMdrSeAAP17bGK7NMT9FhyDhG7+dOorQcUbAAwIBsQy23ctdtNSgi32Kg8WyosEsB8jGMCAIEBXCvnTcUNOWuxZhgCFFcIzCwvVb7nciUahsL/j3QAgQLNpKghct8khJbV0hK1DindWTuZnVUQ+cSSu/DtvLYAA4Gmztjcs6XBTex9I8HJISHjQnoY+3mYv1YJ77nU2u5XWA2Z8wHAiNiql5h1xdTUZlY2wYkFCOxZckNAuCy80tLnvlF8jVgE3fFpMIdbSzqc3v5xXbc++ORA1dKZ/UySqaJEIbkSRToZksrtG+f0zANTd9ttUPDGSe/bCBfCoOZUvKwNDSZJfGraeE9CRr7X6x+57WDNbvmTGqjV153O1dnt09t337qwrZ3NlT3MizkvbqDRvB42R6N7LBrWshwf6o8MEMGdhsGmqOUCFw3KXoeQ1Ks3b/3tUq2pMH9nCRciO8cf02AXrYr7npwoUA8TFkTRfHh/vrNd7/gLmRdGEfuN8KwAAAABJRU5ErkJggg==">慕课网</A>            <DT><A HREF="http://www.cnki.net/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAB10lEQVQ4jZVSP8hpcRj+nZs6oiPkpFBkoCxnQCeT0rdQyiCZDAwYTOQsBsOR/aRshlMymsSK/JkMysDgz3KOZDmO8t/vDu79fO51b33P9r71vO/7PO+DwKIbfAuw6Ia/IQhCPB6nKEoURfgWRbfkK/l0OrXb7dlsZrPZIpHI2wU/vha322273fp8Pq/X+6+LXgij0Wi32+VyueVymc1m1+v1/zRsNhuCIFQqVSwWUyqVarV6Op1+Hs9xnCiKsOh+Emia/pyi0+mazSaE8HK59Pv9TCbjcDjy+fyL6FAohGEYwzD3+73RaJjN5mq1utlsptOpxWK5Xq/dbhd8vNq63+8ZhjEajbVabbFYGAyGRCJxPB5Pp1MwGOx0Os8Nk8mE4zipVDoYDFarVblcdjqdBEFgGIaiaKVSQRDE5XKBHpAAAHie93g85/PZbrfP53OKotLptEajsVqtrVZLJpPRNO33+w+HAwaABAAAISRJEsfxbDZbr9f1er1Go0EQJJVKDYfDXq9XKpU8Ho9cLn/aKgjCw9lAIFAoFMLh8Gw2e3T2+/2baCgUCp7no9EoSZLRaNRkMkEIWZbFcfyPv/0ijMfjh6HJZFKr1bIsi6KoRCIBfwH5brx/AseDLUJKQoGcAAAAAElFTkSuQmCC">中国知网</A>            <DT><A HREF="https://ke.qq.com/" ADD_DATE="1599887423" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACPklEQVQ4jY2TTUhUYRSGn++73/xkY9ZEaiIlgRVRgpOLCIkKFwXRKmbRKsqNy9YR3hAJadGqQCg3QaFIkP1gbooITVKnRZm1aGE6ioLZONbovfc7LcbEv6R3ec57Xt7zB5ugpl9aat5Ly2YctVGwukfKnCLbhKMvAiD2YbCgr6dqVXotV68NJPrltN5BOxGdXPCJSkCUkE7qCO3VfVL3TwcnX0ksE6NeQYPSVBAQ3heFL79AKTCGRbGMCtzZluXe61MquyxwdEAOKstVQpwRjz1513CrEobn4dEkZC2ENRBiFI9u8bk9eFyNqESfJJXhinKokYA4Nu/ICnQcgZgD/Rm4+x2mPHAcUA4zEjAgwn0tCoulWCniyPr+SiJQ6ICFfFpAKeJYSsViNWF6ldAsAS9QLK4s/uFD1zQ8mICfPhgHRJMDeSaWZnx6dSqh0ue6eSw+NxGmcAAnP7gn09CWhsE5CBzAMGZydNlAtZx/SWeqVqWXt+C6op+eJUWE/QhjeFQoMJ6A0fgYhosm+br7MyOVGRpdV9lVd/DpEEZg1pljaPs4b7XHBzFkHENGBwzt+sa7AynCsVnqVtaZZQGgwOd55SB7d2aoSJfY3vHDesYKlA/zsXRCjqmQSvhaekDZdYeEK/oSFEcDWkOFnAiy5H5vpQNgyzxJXUB0MceAgqZWV71ZL7CEelfKFfaaCekL4hMXwDHMeJ7tDNBNbe7qf9jwmVxXdFpzGeHGEquxzNL2d3D/jQZXqhpcqdqM8wfP8+y5SfEaZwAAAABJRU5ErkJggg==">腾讯课堂</A>            <DT><A HREF="https://www.runoob.com/" ADD_DATE="1599889981" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC9klEQVQ4jV2TX2jWZRTHP9/n+b3/9qbbnGukc206nWOEUGhjhDcuw4tmF9WFUUh30U0bFlaXUYvChIgugigqCjLCJUWmFv2hZEJdFjbXHG/mRUhue/f++f2e53SxzaRzdTh8z+Gcw+cr1sIQwl767kBnqVh4UFGjKPYLgnAzkXguhvqJiZHT19a0AFptF2DHvh97PFf0z8hpQBIxGAicExYNM37LGuGFiXumPlwborXktR/vn2ztKBwNIZI1YpDAJAHIzMwgV3DeENWF8Nz48MlJjBXB69MPHM4Vc+9ULpLVqkgOJ4HdtCJAjIRSGW3eZr7RyA6N333yI714dqxrfbubrl733e++gtWX5Z03LMqcTPVM7Ohs2Pq+Ns1fbmWo+Wc2dNT7dYXs0mIt3ZO0lP0jzltPKSmHI4cPOEiAaCunCcmRKJPPe0vTRAlL/m++MFzW35LLPZQ4x30xRmtd18LB/XvxylsucTIgyzJqjSblUgsSCiHaclhk6o8zlrmaSRpNgG6LEBR1fXFJ5eIt/PzrHAvVZXb2buHc+V/o6minq6Odgd4eVevLZhgxGIbrdxgyDAPKLSU+++Yn3ps6w2BvD7OVq9y6oZ3BbT289cnnfPnDBcqlIma29lfvcKo4L2RYmgXbfceA7RrYysX5Cr9frjC4tYeZ+SvcNbSdOwe3WzNNAeG8MLOZxKK+NnSvECEENnVu0KNjozZbuarF6jLtbWV2+E0M79ppDq+FxjWTpBhMzvmzzmEfpPVwRYUo73wMmafZMPXdttn27dmNJ8/Gto0WUilkDq9cTAqONA2zTdc8IYDj02NPlMulN1tDX5pQckZwIEmyVZ9gREQSU1viHzfna9XaY+PDp96/gfLx8wdfzZftSKOeElILErCKMqsoJ3nnc/mE5pK9PDFy6tkbKK/FGxcefhIXn3Zet2NGjCt15wQYMepS1giTT418+vZ/ZvqfnY99u39Lrlg+FM32Ad0Iw5iT46uleu3j5/ee/utmO/8LnwFof3hW+HsAAAAASUVORK5CYII=">菜鸟教程</A>            <DT><A HREF="http://study.163.com/" ADD_DATE="0">网易云课堂</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599890379">娱乐</H3>        <DL><p>            <DT><A HREF="http://youku.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJUlEQVQ4jaWSP2hTURTGv3Nf3muT1oLJoENxaEHrnyFFiIoOlaLSSRwi0lEUnYq4iOBQRIuLDh0j2kFQsOjQSYWmtmCx2iIK9U8HhYoEpcY2f8x7L+/ezyGxaW2jg2e855zv/s53DvCPIPoVAamXX5Ng98UYbPsCysFGaPeWPL3xvCKUtATDuq4AARGAPHIpBTtyGl4R8DwDjZtw/QGZGZxfj0CtUGLlRdqhPbDsFkEDKDkDW6aY6DtPdIXqCizP6ZWvEpKRhqYmCkRrvwyjNwPWdcS3j7A1Gf4rgaSvpSWX3Yuvn1PiurTKrk2lAhOUfCirB7FoT/VDtUpgBYmSZ4Pzkro909V7bnF0045AirmQ8ktOpYAbVvpX2wIpECFec5soDomWfSYPYAH6xPQLfWVmzGnPfPqAEg/IXGphHT9ZEXvHB5gjMcGfatT4mCAxTrbdzd7J7u7b8mdXzVVWeQwUHAA2wqZBABfjzUX38sfeaDpaQ+c6ABSiX+ENOzDLJ/LKTGGSJ3+nk8n7Vt2LJCBcdVSt4dUF1fHGuOYOQpXGpEJ32ykSTmBJBMqOsOyZXGPzI3z/Ejs+NLvn8Uu+hzYdmOQ9WEigGQ+xUwpKAAqGNQqlaeP6naFC0eDHUoYl71DLYnZ/Sz6fWDSNB1HAMbUEIo/DyCGObzVDqtjJMLY27YITmkfIOQuaEa3QaQJtnIHUWxAOAjgIIw4f0zgqE8ub+5/4BaDR9u3byh/uAAAAAElFTkSuQmCC">优酷</A>            <DT><A HREF="http://le.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACBklEQVQ4ja1Tv2uTURQ9576Xn41NIlbEfNYUW+jmIIgIXZQiODipm7g4ufgfSCAuOvoPFP8CJ0W7dBAVoeAi6BCw9ftSrdo0piHB5H3vOjQJUQoG8Qxveufcc+89F/gfUEAqgEzwj/8izj+JOlaMzXy+2C6YRTjfKdWb7wjE42QCCgBfZ5D7YXKZhS/tb+Ni0i7I7bToSyS4VpvNLQ6FB4/Wgun5z+XCips6XEun7futcvFteDJ/ayhglThkSEKRydKkhhYJxGGQWrDWrKaE5a7HQypXAeRFTCWaKxwLPjbvCdXHqqpQ9eqcH7dHk717xEp5T/3N0kbjzqvN3WfOI4RqD8pqGEzPW1AIkiBImxhajxtF5DvE0m7svXicjcrFyyQuqnIK1BcGvuLQqtuB5eHYOFxnJwuL/VYg5A0Prov6asLFT49GrdpoBlCvVFEqPPu+UwE8AFTq2Inm9E3BmKvbzj8/sdG4Pt5efTa/3HW9D/stAFCq1aQ5tx0Ukx2NsxkxbXXxgx1gqWDkWlQuPlH1jy0l4YArqlw/tdVds1CNRYSiSCmw0jdwCRrrgJ+x92ekHy+3bPI+iAuEXCLxSZSPjm82qgQ8wyBTgkmfBmIFQMIQBvR99jLdxuuZ79gDgDDIlIBENkQrOh+h+7cEj3DQjfwW5UHODzwSDgY6II3SOXH1SfALm6DXEK+cXSUAAAAASUVORK5CYII=">乐视</A>            <DT><A HREF="http://iqiyi.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVQ4jVWTz2tcZRiFn/e7353cZu6kk6uJDYWCdFUQBV3pRkFroKWgC+sPdNGuuyr+ByruuuiqFMRVgmJdNYXEjVpoq+hC24XVQlOIRGYmMzeT6Uwyc7/vfV0MXfRsDhzOWT0cSbb4yCVc4oAFFATEmDpPy2yaGAJkdDRyUfwmPRHmXeVUQFQUNTBD1KZLJyCCCZDgMMM0VWdQiv8bE0MrQ1DAwQxeUudJxAEQVakIjC3Yk07qMMB5p2ilyMn8Tc41z1NQSCNpWMPNSY0UASoLDG1ofe1Lz7q2srfC2uCGpIKKu4fVpc5vz//OT+XPrO1et8c2kK2wRUWFYSQkFK6gcIWdmjstZxff45WHL9OOO3hVrOkP82D/AV+Wn3Nx4VM5nh7n68FX7IaSRf8cucu5PbzN3ExDfhivW6PMaUqTlu3gJSDRAv8M77M8u8zrs2+wtnOdc83zbB484hlf0J60OXvkfY74Jb7Y/kxOzi9zpbwCFThTqDHDC/mLRI10Qoee9RiEx/Rjn0jk8n+Xeav5Nq1Jm43dDVJSYgxg4FBItcaJQydILSVqIEbFi8eikckhHg4fcX/vLzZ2N9jTwRRlBAI4AqCQSIJTx9HsKMeyY4yqEXVXp/AFEoWJmzBmjJiQJzmiAgoew0ZhxK3uLa61vyeOTE49e5p/J1usd9a5W/6JiXF18yp3RncIE7Vvt79hL/TBQOQm1rCcX176lbXBDVa3VyxWQQo/z93qHsEqDmdNkpCwVFuyMwtn5IPiQ17741Va2kH8TWKMyLuz7/Dx4icsZIvSmGkYZpL7HBGh0kDUYN1xT7rjrl3rfMfqYBXvMXE/YiJorBDGkIiQkUnmMjwpAJVNOLADJkwsTLGR1DAM53GUBvM159TqSEQZsW/DuP/0GxPMASkOFFNRZ0LpFC7gaUVTNKhJBBfAK3gTEhO8QhKBCDGoRVMsoaVw4X8NnnogDzJVhwAAAABJRU5ErkJggg==">爱奇艺</A>            <DT><A HREF="https://www.mgtv.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABTElEQVQ4jY2T0XXCMAxFr3L4bzwBbEA7AdkAuoFHyAbNCBnBnaAZIUzQsAFMEGeBuB+WwXBOoPqyZenpPUkWgNFyEGiBNdEuAv0MPdAZh2fBRJN/9D4FaABfQBWgUtCTAnbG0d8BeMs5VQ7wAZwBC3i4Bh8UcA9MiZ1xtKuM9sk4htHSCHxlRY6loyJKZLRUooBAW2SBSzp3o+WQLsZFKXOUSrGQlGzSIJsco6UU6AR+vWV4CiDgAALsR8tG3TXwpuftU4BZdatZrV4r+PdLCcZxBo6aYLPql1nZveoBQQOBdZqO7gr/AjAOhzZTbQK6RYACykef3FgQoDUOnyYj3hKyR6PHWqs3EEcHbHTRSqBWORfxFs9tLKf0F4hM3pXVJnAd4y4r+LkK0Garu80+Flngo00BGuPoRCk2cr8gEJs1aA+G+bbqPTCkL/4HG1p4H6d2CsQAAAAASUVORK5CYII=">芒果TV</A>            <DT><A HREF="https://v.qq.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADKUlEQVQ4jV2TX2iVdRzGn+/v/b3nPWc7c9I8DcOViGAFsWBzMlFiRURGgtW8EQXxXzeB7iIaIhy6GCHhxW5KLXZRUVhRLMfKosCgGGjBnMqyuRO65tGdnZ1z3vOe3/v+/ny70Gjrc/PcPDw8F89DDBAxAAIfuHr1oVq08XU2smyEOPfVFioBAJgFAH7gXAHdF6aRkf3BJ7mRC6sfw3YoAMbOOdBnxoqzo9toGgBwjj3sJrsigL/Dw9B4f7E1++h76wef/muhD/PVXrYE2dQCuMhEDPFhnIiT4310G2AC49/eIDuOIdGCwYKfiy53k5Qm7RfDHr5+px837r7sYpuRza0AJ3bOOu/tse10BgCQZ4E8OTJf04RH3PX72nXq0pPZdLOtCCfLHJBP5XoPTf59kKeLu40j4WeygIl4XMf0xo87aAZ5FoISdCCCcFanw2RR5Nxz1EnDxKqTpPyFe9cfppee2OWvyUy4UhGwPr0oAr74zJh6HnlyAgoZRCBrtQhVFTmvl5/KHKKdq86jSw6TURu4KRjnFx5/hTrXDXOtxDrW9IjzUqNbvzGvCShKQwEN47RSIGsYjg1SIovO7EH0t12gtdhHlUihp+MtbGj7yF9ago2VSWvDZyQUCJpglKNIOSitwEywrJDymqGdhootGsrAZ0Yj9qASQHgEtq4hEZOG5gARyzDRXNdVeMLjYjRLU5XzuFz+gBXPQCKHb2fewbX5PdoP4DcSEZLDAckKVVg067p0SZISN8q/UmSO82+lL1Czf3AgCXcrO+jSrbwrVjaLdCt8q+2cjfXeuSOZnyQ0FeC4neoiZp0NrjUuiqml7zklgEq0ha7cOco3S68aeL5MBYAKk9E4bAxU3lw9gzwLyQl+RsrbmqupIGPrbG2AheqzmL63jwuLu2ziVskgCyl0XFARnageDT5ePiSZODMsy15Xu3Mdk7PHNhWqO+29Wi8sAs9vghBJWEtC/3S8VHkXQ+3FZVN2y84EnOo/lhnYeGoMbehDoiE4vgWmT52xZ5Fv/RMA0M8ePv//mQAigAGgZeiHthp3H4bzF2CbvkSeFv+rC75vX8k/4uy1kf0oZ6kAAAAASUVORK5CYII=">腾讯视频</A>            <DT><A HREF="https://movie.douban.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABQElEQVQ4jWO0mOh64tkZBuKAhZQJI0O5IJGqYaBc0GNW8H8igMesYIZyQRYGBoZbr+7Ub28naPKtV3cYGBigThL4z0mMaz4wfmeBsLSldI/k7/j//z8jI+N/VEWMDAwMDAw2Ez2OPj/FwMDAgix3792Dok1lv39+ZWBhZ/jPwPD/N8O/f5NDpyoLK0IUCPznRNHAzsZ58NoxNGd8/fMTmYui4eev7woSSmgauFnYcWpQFla8UHwYm28xNFx9dtljVsiOtDV///8z6rLlYOVkYGD48fv7xfKj337/CJofc/XZZYj3ETacvHv8/ruHcgIyD988QDby5eeXO+/tE2DghAQ9E0T0A+P3D4zf117azMzEHGkaARGEMNZe2gxRADOhXHDy4VnEJI3Jh2dBk8aRByeEOYXw+xWijIGBgZHU5A0Arsa8Mw6SBsUAAAAASUVORK5CYII=">豆瓣电影</A>            <DT><A HREF="https://www.bilibili.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACaElEQVQ4jY2SP2gUQRSHvzcze5c977jDiBhQTGEngqIBAyIkRYKNIJggYiOCImprJXiWNnYiEaJoIXIKgiBIIImFqGCMQv7YiWIjGjS62c1lb2fGYs0ZG8kPBh7vzbz38XsDqxqZCrg7f47R6V4Ahhq6XVuNR6d7uTt/jpGpYLUk1L2CK7Dt6C4qlXe00gWa8RFO7X7OWo2+O0DHhkcEhU1E0W4+P5yBy0j7wu23NaR4g7B8jJXkO5kdwuvX+Rjbg9EPKJY2srx0H79ylpN7FnOCay9CNtXqoI7jfQWhig7AWbBZAoA2JZQG2wLPT0QicPdYWKwbOqtXqXReIPoB3iV4iXCpQxDAAODsL6z1gEIwIFupdF7ESyjcmY/RgaLVOoxTrwBoWk+HFirWAxBpaecAlNtPEDzGtaxB6RKt9CfdXyfp68tYjyYnJ/m4eQVjqgbwKBE+dIU0GgnLu8bw3rOSHOL03rzhzTeGQvgUpSCcGeBDV4hxAniD9wIIsU5RPQGFrB/vwTY7crOAxlyRNOhHBOKegDhLqToBUH+gPLXE8Kk7JUsnyLJxPreW28jzX5tk2ThZOsGn7pRakpPnrkpulCpp6uII5wZ4MjtIvS8Dcrp6X0ZpdpBwboC6OFSp/UsNIDjvCXfEAAwP2zV2+Xa0Nl94G5Ps9IAYnE0ICkXi9/005l7ypaDYYH17hauKtBBrYUvqiKWXICjisiWD97coV88T/RgjyRKqrXzXy/LPe4yDqoMEj9ElylVYXLiuOXjiGcpqUNuBAHD/PaIsyDeayQ2+L176O2ZkqoQpa9ajbMlyZl8C8BsqkQfT9fYhAwAAAABJRU5ErkJggg==">哔哩哔哩</A>            <DT><A HREF="https://y.qq.com/" ADD_DATE="1599887548" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC1UlEQVQ4jV2TS2icZRSGn/f7/8xMkqZJRpEiUoMJtcFLWxUKbSgiiotmo64s7UIXFkQUVARtREU3orhwqbiwaPESipcWKragoEWQIGgDaZLWWLOo1NyamUwy+b/vdZEpFM/icBbnnPdwXh7RChtJGMDnGQL2kbiTVdpoMEUnXw82R295qXt09oljn/2q1zCtfvw6AcDn2JEucGJ9Ol8t/urw1Us3eWJmu0en93to7KOlQ+NvJ093vdASzAB0TdmTDFPmY8pUn778It83d8VExlzaxJKrVMN8NnbjM+6LM0trKX+8sr04ZaMgYU9wH2U+AVVZJg5lf/jPohrmUh7qiTAQpsK3Xa+4L86IinrK5eKYJ9kp4WBTJuc9Sur2GoWlcKDynQ6Wz+BiXY+1/ayTPa+yp/S7UghmzetU1EvgXY9TCkzxIIG91J0UnKWEEDzfflxbWODlzi/Yll9S4cxyEiJnxQlxPxX2BQLDlCTAgLNgxyTuLl3k0cpZ3lkexg6IJKSNzxtTUkZif8D0g9mwRLIRiMLiua4TnG/ewKmVHWTBpIQw2sg20B8QoeWmaBWZErnMlnyRw5t+4P3lB6jFCpIBGSMAAsox/yCBbZCFVXeFo8u7+WWtj6bbmG528WltN4c3/4jVWoEg+UqOOU3hA1jBshou8ez8I/5qZVDtahIwGWt8ULvHD7efU19pTkZB6xZwJhD5hoJpWheebgzwZf02dYZFiwaJVaKanlzv0Gj9DkigskTBBDVOBg0yB4wgiRxfjp2x7uhGiqqRXCd5NRWqObmeQiTb4IbAEe1iMdhIA3xe1HmDCuGhrotZb6inf2MlLke4GuFKrMRqqKWD1fGMCoqraUT9HLeRriexmOLJLOPNsbj15pGFPfzW6EHAve3zvNV7lp1hdjYWHMlv5+i1Gf0fZ19gK4s8FTdne6eK7lsl2JYtzGjJPzXKfNhxF39fj/5/w6NzMWFQNHUAAAAASUVORK5CYII=">QQ音乐</A>            <DT><A HREF="https://music.163.com/" ADD_DATE="1599887511" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC4klEQVQ4jXWTT2ibdRzGP9/v702a2C4Jcd2WYGYVPQ2tSkF0azEgnpyiFxFx3RS2oTjq8LKT7OKpIJMderAijBUHClNBmIdtLR5EFPw37Gw7ndloZmub9m2avsn7/r4eOnGge+4PPPB5PgJgIAIGMMuOqkP2exgCqQCISk3QqcR3PryP+oVbO8LNXKK3p4f0KNiraTSIVEi8B0DYIIPSIR2DH18jfmsXC2sAYiAL9HY3SX2WR6sNwXuLvbHulG4gId3fjw/DJL4yq0Wy2iC50E3nmV4WmipgIcFoAa0uQTuxdZF0Juh5+jlIQf7IIcoXP6Y8dTZIPfCgLNJsFySohgSjAiZXKA0KchFR89YSvbtPy19MmLUiuTrwGJXzX9Ka/Jrw/Q/Mt0xsackrapvr7Qk1OJhBNbHYyGalfO6MRd/9LLWBKsUjI6Qf2kXu0Evkjx0VdWJGLB6xDKIGBxVkT9upGQ3NHRgW0imZ3/cixePHyB89zMqJcXCOrof7KU2eFc0XBGJtb4LYowKV2LyAk+xTg9b86FNEMuQOD1N/9hX+Ov42fqnBwv4R/GpI4c3XLWFFYudEoKIAZgAOzXRhzdYmG+8JSttx2V50axGcY+3M52QefwQhhd1ErAa1lKpBZNFP05J5chDvQxrvvMe2iZNUfjhP+9sfaU1/RerenSQrqwKxBSJmUGOO0ql5qdgMd3b+uOdR7zciX3/hNfsF7Or9u+3a0PN2mcB+7xsw32z5+t4D/ld6OvO60+YonXIjbFn02LBKmnj5Op3f5nX76ZOW2tYn7UvT+BuLbHl5Hzsmxiw8/Yk03j1hgeRIzAP2BgBzlMaWuctmtRLNkPPXdu+19XOTPr5e93H9T7/xzff+xvCIzVD0s5SjZSo2R2nstldOLPQgLrhjKwSOZHUZTzMJpKAFU1255cr/L5O6IDIjtg4AAY4uF9BO4hhkfI32vzLdTmeDIftHZ6gJNpVg/9H5b2EOb208w3giAAAAAElFTkSuQmCC">网易云音乐</A>        </DL><p>        <DT><H3 ADD_DATE="1599885271" LAST_MODIFIED="1599890397">工具</H3>        <DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">正则</H3>            <DL><p>                <DT><A HREF="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACg0lEQVQ4jY2TTUgUcRiHn5l1x91t/Nxdcye10jQDNY0o1OwgSadudgiKDoIlgXSoY0VUl251yINdgiIoqksfNyUwCTxk+ZWuYur6OeP6Neu4685OB1EcLfA5vv/3+fH/egV2oEfj1rtuleed03SHdIz1BG6nSNkBmcbqABcrsvBIDmGzX9gut36bsq6/Gcbn9RLIzkaW9yGKIolEAj0SYXp6BlXTaL1USEOlItgC7n8etR5/VSkuKkSW5Z0b22JF1xkKDnOz2svDC/mCAPCya8ZqfDvG8dISJEn6r7zJ+nqcXz09PDgfQFiNmZZ8q4Oy0hLSUlNtjZZlEY1GkSQJURRta4ZhsDg+QFLb0AIZ6em7ZFXTGBufwDAM3C4Xebm5ZGX5AVhcXCK8EKa5KkDSx955MjMzd52zf+A3bc3lVB1OpWtshbNPupkPh4lEIpw6IHH5pJemGoWk7pCOnO63BczOzvG0vpDaooytS46bCevtD5VS5RAliiy0A7cB0eXceKbtOJ1OVD1mq00txZhZjiEnO2x14d6nUetFf4KDeXlbxVhsnR8/f3K3TuFMQRrf/yxz50sIv8+Lps1zKtfN1dP7aahUBKFrbNmqbRnkREW5LTkajTIRCqFHIng8HvJycnC5XJimia7rzMzO8ehc+sZHuvZ60Gqf9RAIZLNXNG2eo5KGCNBUozAyOkp4YWFP8uLSEoPBIE01ykZAeU6K8L7hGL19/YQmJzFN859iPB4nFJqkp7ePV1eKqCvOFGzDFJxbtVo6pnjWqeLzefG43DgcDkzTxFhbQ9U0blT5aapROOL32IdpOyPqqvXhl0ZwzmAlapKS7KDA76a+3E++z21z/gKQSgdYTvI84gAAAABJRU5ErkJggg==">正则表达式手册</A>                <DT><A HREF="https://cenzhongman.github.io/99-Others/08-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/03-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACcklEQVQ4jVWSTWsaURSGzzleR21mVKwOJkQDVZPUNgsh8ScU0qW/IJv+oPyGUNpFNyUENzGbQkFcJIxQTTRWS4k1qK2T0WE+7r1dTD/Iu34PB97nQc45IgECAnie5/s+ABALKywkpQREhEdhiOisrB/GZfb5C4vD6OuACx7PFUvZFIJE+N8PbhkCuq7z8ezda+1N8WUlEmYhxogxKQQRCSGISEqJiFJKAAAhhM/90fj70l7Kx3FdV0rJOeecCyGEEJxzBgjz2c8Pb99TKERE7XZ7a2vL9zki6LpeLpdns1mv1yOio6OjdDpNIMFz3f7tbbfb9TwvmUymUikAORwOpZQXFxeTyaTf7w8GA845IpKUMpVK7ezsaJqm63qtVlsul91Op1godLvX6+vro9GoWq1ub2/btv1nJdM0J5NJpVKZzWaNRqNYKDxNZ9bW1jRNOzk52d/fPz8/L5VKiURCSskQMRwO393d5fP56XSa29x8dXjojb/FotHer+L1zc1wOKzVaqZpOo4DACyY7ODgoNPp6Lrueq65MA2jFY0oU1tJJBPlcvnq6kpV1VgsBgAEALZtz+fz3d3d6XRqWcuz09P6p8vP7eGTqBJRIq1Wy/f9dDodcKCAXzKZZIzlcjlVVbW49iyfv/nS4UI4jpPNZhVFub+/VxRFSkkBu2azWa/XM5nMeDw+Pj72OdfiWqPRsG3bMAwAyOfzrusCAAohLMtqNpsAsLe3ZxgGY2xjY8OyrMVisVqtotGoqqoPDw/VajUejyPnnIgCvXzfZ4wBQKCDoijB/38FIQQKIaSU4m8CbYjI87xwOBy4FIvFiIiIEPE3vDRwiDVVyqsAAAAASUVORK5CYII=">正则-岑忠满</A>                <DT><A HREF="http://tool.oschina.net/regex/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADP0lEQVQ4jV1TTWxUVRg933fve2+m02k7M+2UdKQtsVQpUlnUlUiCiQYLxKgYE40LgSAbV25cjgviAleuTGQBmi40ceNPK5QEExJ/EtFEK1CgLcSx7bQz0mlnOm/eu/d+LgpGPetzTk5yziH8H8em9sEPTpDHB5j4IRAYQrEVO48w/Bpx/CHOHbkFCAEk9B/xyYun/XT67UL/jiDb0QZfaxABIoIwMqisrWOx9MeKrTfO4KNn3gdACigycBk4+eS53ODwW3t2Dal8tst5WpPSCoqZlNaSTATSnel02VwuvW7o2eiRQylcnZjeSnDiwjuZwZ3v7R0eiABoYw2DSJgZikisCDnnABHyPM+GrUh+mbmum6vLryq8/kW/6mg/v2dkV8LzNBlrFBHBU1paUcSbrZgIQoHni0DgxFEq8Kkt1W6XyuV9Glq91lPoz7UnAxuZmIkIzCQLpUUu3VkIjTFzge89Ojg0rArbeuxmM1Qr9xpUWdtgKP5NI+Hvz3R1CSAQceR5vl2urvHCjWs3UDcvIZW/FW4uPzE7O/t5pVbfVqsshXEzvoioOQmb+FRD6e2Bp+BEiMACkKvW6gqR+QAT49fw3GSAqcPfyakLj1du/j4GF/+Ij1+sPiiOIdh0TkAAQAIikO9pQGEUADA13tqiqheQTI8B3jBe/kw9MNCIWzP1MBrLZ9iJIWWsVYXuLlntyp4Kj00yIN+D1cGOvoFXcrkerJbm3q2v167izenLIH2ecPyrQ+newpdje0edFcfiHCmtJQxDWqxuIGzU0Z5Oo6+70wZBIFEU6XoYo1xrYvH2zBWN7T9NbSwlrpSqtf0DvRnTakXaGkOJREJ29rdZcXkiIhhruRXFICLJd6bcvfUNRmwW7g/p0iinkt/ufmx3pjfbaWJjlBP5Z+ECgAAws2il7N3lind75tc7iPkpBQjh54fLMnL0h9Va7aDTyY72pE++9sTzlGilRLMSJkYYxTz354q6e3N2HrEcwdmn57YSFIVRJIfj3wxBq9NBOn04k+1u85Mp3H8TwkYNf1WrK6bR+ASueQZnny8DQv96Y5GBogMAvHFpBK51ACR9ICIAFsA8IprGxHhpi15kFIvub19ffkPkn02jAAAAAElFTkSuQmCC">正则表达式</A>            </DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599887718">翻译</H3>            <DL><p>                <DT><A HREF="https://translate.google.cn/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACOUlEQVQ4jX2ST0hUURTGf/e+Ny/nn4ma05BOlIYFTZsGoj9Gi2gTRLUoCIpA3bRq1SpoIGpXSyFpWVCrNpFQG1GCiHBRGJkSKISmpM6Yo857954W8ydngrlw4HIv3znf951PXX28+tRop18ELICAACIQNiunX9xJjdPg6EA5/aBBaVRdbZimgUZgAC2UJ9ZNF0BcdS2bnfQaNXClcpP/P5WOuK2HI5+npqanPc+1ruuKtWCMRWuRQiF46VaAu+LQ3+fTHoX5HDx6GyIQmFmN9p4p/u6NRiM4jkZECIUcRIR43LnoVigP9Pm8+eIwMaeJN0FgS++zuQjL+QU8r0A8FkEpVeuBLevtaBYm5jRnD1nunvd5eMkHwIji21KE4laRe8PPERFESrRFhKqExbzi6F7Lu6+a3Aac7LFVY8dnLKsLExzs6uTZyCjLa+t0Jdq5cCrzz8QnYyEG+3xunDAs5RVDo051K2sk2RlvI92T4MfPedLdKY4c2Ie1FrfMhoUc3H8dqtmIlGn6othUnYy8/0C4yeN4uhff93EcBy1SMottJdvAFRnfcy1sFQNQCmMM1lqCIKgNkgC2bJLdBhZgNt/MuWMZ0t0pXo19xBhbkhBsbg1pz7tVnycRUAqU0oiAweVXsZVMqpmWWAQRCzjULrXuZLOfIuOTi+sAsZjD7ZsJkokwSoHWGqUUunGDTGH/Hnc2vEMzeKWN9tZQNQOVHDRsAJDcbR9cv9xMssNBxCJS0m6MYWnlz/BfVT0X3fHmE3AAAAAASUVORK5CYII=">Google</A>                <DT><A HREF="http://youdao.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABIUlEQVQ4jc1SMU4DMRCc9R2kQSinRFREuqAEKJMn8Im0kBfwFMQLQktJSwO8gKNAikIR90fEtSHBQ3Gx4zNcDVvt7O6MZ20Dfx3ig/e0fwGRyQYWEdUw0VO96J6MCN7aens+SyxH+QJt/XbjwaYb4vL+t/oPgUWvd+hBneipBgATx3t+vVbArHDgLffo8hU62ynWCyig4fhGXraNyDmjyJPPiX0AifcBs8l5nqenmeJ6CWEHtMLIagUM17lIaYrAQMQ8UBQsGQAiqIpAZYViB68CGaEabmcBMnuxXq0+PtK0+SW7zwDS0hbHwVNXBfKj/hVMdFda44DCS0sWIGvNZ8PwkOpP7B4zHLBkxc+zROsi7MUBLuD9NAEyktetwPb/im/0ymD3Z/29KwAAAABJRU5ErkJggg==">有道</A>                <DT><A HREF="http://fanyi.baidu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACyElEQVQ4jU2SS2hdZRSFv7XPOffePJoYG8WSjBq1SqvViqDoJCBVBwWhKo6kDoITUVBwKjgQnCjiQDEjgyKCM0VECq0YldQipcUigrVqYkN85nkf5/7/cnBb6Z6vtfbe69MLH3dvObGS55c3fF9KJgJsBAbE1RPC2RAhpsf01exUzOnQ2+0vL2y37i96O9lCKVlFQGggtk32wKqTIEJuBa4bwzEz0lnU9a9uO2VnkKoCjTTk7a7Vy6ZOMFSJoQrqZA7uKbzRsc6u2s3SDinKZFyEYr2TeXR/5feONnX43TajDfHUoYqf/8nUCcZaYu6uUmdW7QcX2upnZHBIA3cTPrua9PLJHqtb5uSFzLfLiekx8dZSn5mJYGXDPPNJR9lyaHCWrnlly5PDYnJYtGuztmN6fagzbGyad442eeL2kirgyPsdjv+YaDTFrgZIQuVLm3767opjd5QUATMT4t75Dn+3zWMHSp48WLLeNTftDkYqOL+W+eJi5o2lGhtivCU++j5xeKHD85/1ADHWgkduLSkDnv20hw2vf13z5lKNJX74K9PtgwQhiZRNuzbdZIzZ6sGplQTAQzcWPDBT8viBgkYhPjzX54NzfZol2KK0TUhc6V5ANvzyr7m0aX7fMCnD0m+ZhTN9dg+LPaNBuzYRppSEL5Nmm3QZmiP7CvZNBs0SQua2G4Jjd5bsvy44cTExf7rPUIgSsBh0WoQ00RIh+O5S5td1Y8Nz91ScWs689k3NroaoLbcqlMHllfSqQKtb+MXPa2124Y8dc34tMzUmQmKzZ/7cNOySU84KDUD4H2WFlJK10ZPHmlYl0c9mvCUevrng+E+JtR1cabCtbRehiOnxWEyNkXC2i0KeHEKFRLKJEOtdM3+6z9q2Ka8Sp8ZITI/HYsxOxdze0e5iUYScIXnwU0lcaejaIVGGGIihKEJ7RzqLs1Mx9x8pzHQf8XbkHAAAAABJRU5ErkJggg==">百度</A>            </DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599888773">设计</H3>            <DL><p>                <DT><A HREF="http://image.baidu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACP0lEQVQ4jVWSS0jUYRTFf983M5qmMw4+UYsS0zAKKjdimkHgogcRNIGryijJRZs2UW1sWRIJQZBBbazcRGZCZA9FKoOCGlTMkbSHOj4QZ3TGceb/3RbzN+iuLpfDPffcc5QxIoLWGAFBa5JljN2LIIJS9lwrhVLIOvrhR5oe8XMRrQnM8uwrRlAKsfE4kwssg9KMTtP6mpklcjNo3s+5DoamuVzPxQM2iQj2BS4nTs1MCCMUeFiK0DvCr0WKvfSOEk+AILLOoBQPPhCNU19BVhr+KXYW4U5jeY3IGg2VpLhsVUrhVIr+MVp6iMQRaDvBQICz1awlOL+PNCfVJVzvoaaUujIsgxKRO320vSMjlfJ8Ok4DDE2RvZECD4Cvnb4xCj10NlKahxahLI9Ygt+LVBQgwoXH+O5z9C4v/FiGYJiSHKIJxudRCqcIB7dz4xjzKzTVcPstL4fJcxOJcaWLLTmU5tL1jUIPW7MRQf0zDmjt5epzWg4TXePee7zpZKbScoRgiOIsardhDMoyghBLcOkpgVlOVbG7mL7vjAQZnOTQDgYnuHmc8nwSFg6NNoLWdH6h20+bj1cjfJokz01dGaEoDZWEVvG1M7GAQyeNE0Tw/8G9gRQHc2EcihQH3nR2FWEZMlMJxxieRilM0mml2LOZqSWuddNYTU4GTz4zMM6ZKgLzzC2jFUVZICiFMkaA1Ti33tAfwOXAm84mLysxfiwQDJPi4ORemmvtFP73JcsAONYTblksRnFpPOl2kIC/BsEA9PPta4oAAAAASUVORK5CYII=">百度图片</A>                <DT><A HREF="http://iconfont.cn/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACYklEQVQ4jVXTTYjXZRAH8M88+9YaW6jZLu5BgoKCkmUzD1qw7UYHk+hNiOog9oZIHTzVJco6bEngoTq5RBgs0bFDRAV1ieggUoRFZpoZJCZsm27/t2c6/P6r+IVhhmeemWee78xEzjqKKSmlYrBUrVpcQiL6+hqsKVWvFlQhcCxyVkoVoQRLycR42L6TW6YZGOD343zzGb/+lMYuJ02UyHv1ECJYTh58mucPhA0bXYWViyweSguvMJxEatLMyJyLzC0y5/fmZbT+y2y3MzvtzHYrs9tpzj9+J3OrzNnInJFyNmpuU/Px22rNzGyv1GyszF6vkVWsLDeelx6ueZeac6UWEWFFeHRfxOeL7Noc9j/An781f4WVSxzcx67bI959mR17QomQGUWvcv0Ia67jrec4/wtffsrCqw1bEXyxyJH3+Pc0C/Oc+J6N47RTkRgaZHiETocBFLRbzesRdFpNKwf6LR0IhkepFINYusjaG9h7kJEJprfx7IEmGHbs5qEnsI5H9rD1fs6dZQh5X8m8U+bbLzREXfgrs9ttZP6ZzBd3Zp483vjO/dHojw5lTsucK9lwMIZP3ufH71h7I5n8c4HxTdyxnaW/6XbZMMmZE3wwz7XIFDmjKkErWb+J1z5k6u5V/q/GD9+mN3Zz5mdGUYmckfSJa2FgkHse48n93LqlqebsSQ6/zleLdDuMBr0m7MooN5PdL18YHePw10zezFObOX2KdVIUenV1RnJQKLK/XTUbx/ohzi9z5E0mb+LUKSaGaHeoV4KFEjnrqDTV368i1EYHtSlT6e90qGr/DiEc+x+mo1RUJDZSsAAAAABJRU5ErkJggg==">iconfont</A>                <DT><A HREF="http://www.58pic.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACgklEQVQ4jV2Sv09TURzFz/fe+/peKaW2auSXxJpg8AdRS4qLITExGAcXQzSasBg3BSfjP2B0NY44mRgmnYyRqlUH0ZAgJBrKpBUQDNiWYgvc9r17vw6oUc98hpPP+RCyQwAACJBlg0CDBGQIAEwdbKE8QdKCt2oKAIiJhTXak95A2/FT2w+2uzEGFmvlsULu4ffpmtEkPSYLJkJ2iIjY30xt2zvSdbGnqQP/ZqqycDn3YHotT06YmQURcaBTsWTmyNWepg5jDYCKr1fqlWJ9fUmXU9Hd2dS1o7EkB5qICC+uNJB8m75+ONoeWFOzwc3807HiTES6JxNdgy3HqqbW5saX6z/SE7c32SoEm2fb+w5H2wNjNAcDH+5lViahwmAeL+YmK/Ojhy4t6NXdbvxcc/r+wisBiNOJ/ZZZSXnry1hmeVK5cZIhoVzlxp58mxj5On6wsaUYrJ+Id4KUgAy1utsIqPr6ceEjqbCFZbBlCzBkKFOaYeYdTqRBhpTjKeAX4Q3rR2UY4N/EKbC+R6pROAAiMuSzsWAFU1+qlRkQJPoTXe+KM1KFCczW721K7vUS/dsPABAk5vWqDeoCsE+LOUHkW3+wpfdMc2+gS8bfsMZPeonRhdePlqeIqBLoseIswFtYxbv0je7G1g/VpX0NO0cW3zwv5CSJ883pTHEm7jTmqotztXJel3wYopfDHOijTXuep4YdyDld6o62/v30yfd3sivTcCIQCgzBzKS86bV8/9TdT/p7hxf/tFFY9dettQB++JtzuiyciNjSkUDIDm3Jx0a70ruwq6cv3hmVXt0Gc3r1WWl2fO2zzxZEv9j9r7evIYQjPQs2tg4GpAMSfxb+BGE6QKaqZIOOAAAAAElFTkSuQmCC">千图</A>                <DT><A HREF="http://www.easyicon.net/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACOElEQVQ4jX2T30vTYRTGP1txcttXU77DpQmbyVIpKLELhxdJYBE2MyIiasWUHOzP6Cb7cbcQotSL6raigTUpo8QLozQoAyEXUpJSqV/TWbvwdCEu54YPvPA+vO95znMeOLABp9tOam9vnwIkk5M6NvZek8lJBYjH4yoiyibYN5KGQADVVSzL0h0OF76qPZimG8uy9NXgIA67fXN9Lhrq6zQaiahlWTr+8ZOKiFqWleFbOrgVi+noh3FmZ2cAePL4IQBnTrUCMPJmZOvuA4mEiog2NQY0GomoaTi1qTGgtX5/xkVPT0+Wi+3rl+nvM2o4HUxMfCbSEeJuXx+vh4ZYTv2h0lvBqs2GXZXS0lLyCgCMvnvL/O9Frly9TqGrkOnpr/xNp/ky9Q3TdAOwaC3kz2B32S6br9KP1+cDYMGax2UYANTUVAPQHYtx/kLItlEgi7SHwzr38xcdnZdZWk4BsJJKobrKza4uJqemSKfTWTWZEQYSCT0RDFJulvDIbVJbU43D6eLli+fE+58CsC2dJh6PazAYzBIBQES0LdiaSXvzOXrksK7/yZtBlddLf+IZS6mVHHGAcGd0LZu5H/lDrCgvA+DO7e68ApcuhgA4drwl97G2eq86QEVEH9y/l2M/dO6sioi2NDerp7hI28Ph/2PsLChQ03Cqz+NW03Bq3f59WcXr+xCNRLSpMaAioiKiN651rYk01NepaTjVU1ykIqKHDh7IcTA8PKyekmIVEfV53Oor82RW+x9KpTd/q+CW6AAAAABJRU5ErkJggg==">EasyIcon</A>                <DT><A HREF="http://tool.c7sky.com/webcolor/#character_2" ADD_DATE="0">网页颜色</A>                <DT><A HREF="https://dynamicwallpaper.club/gallery" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABwUlEQVQ4jZWSv2uTURSGn/cmrQhitYiio2RQ66KTToJLHezQ1o+00CI6W0dxEMw/4OKg+C1ioyBEVJJJKVgQ6uBkdZAOusWitFpbU2uS73VIQ9vPn32GO5xzeTjvvUcAzg8cRWEE3AESRsAPxCfQDCF5RXXuvSYnG6QIrVOHEL2gb8BXxBdEA7wffJ4k3GbPrpsejo67UAjrBQLw8OBZrF4OHB5RoZC0mwbR17eVbZ05rAHMaVCRrp03FMd1gGx6pJTdVCo1YBqY9tCZp8A1Fj4vA/FahP9E9x9MYV9FnHMU5TYtAKCr+xkk7wic2hhBiGo14ygSPT0GoFCwwBumiOO689EL5CNrgkQN5GMszt8jg3n7pnV7aLBhMQtM0QgTKpUWAAjJB6yTjqLOtuA5GV2GJOCwA/kKsG/1GQHGyPqxR/svqPjoI9DEEktLUjqiR/t3Uw+ToIOpVoK5jjSBkhNYObZ35//6jSkC4iJ4DCuDuaU4rm9G0JK0WEGaWF/YHKJMbeXJnwWSf1uHBKuCs5dULi/CP1Z5FQPLmBlQkS2NOxovzbWbvwq+Z2tkPI68F2iShHnEazqaL7n7cDa9WD8BXd+lwx7OrEkAAAAASUVORK5CYII=">Gallery</A>            </DL><p>            <DT><H3 ADD_DATE="1599885377" LAST_MODIFIED="1599888789">镜像</H3>            <DL><p>                <DT><A HREF="https://c.163yun.com/hub#/home" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfElEQVQ4jaWTvW5TQRCFv7N3/asgAw0oFaJAIhDRQJDSpaHmRaDmPXgQeiQKKkSCUiAgSgoiqpSBwo7t6zuHwk7iazsSP6famdWe/XZ2RtRkAQI8S8zWMv8vp1VZ1aIH/Scwuk1/sker2aHVeEg5Oubg5pdLwjpNrtulTVRs0mWdghvk/BL7Fo/G7ynPXvFNu4smdSx7AJwir2MqRsM3KP0C7ZDbb9kYbE0PW6sNUILIWEPkNtJ3HB+IwQSiR47X8KlxNcE0MomEHVgdXB4gj4lBYG+xce/pZT2WCOYKm4AUCUcf9BNJqGmS78xfVy8i1ZQAfOEtPPdkiGIF9IWK85SIEIFJaQ35OrbxWCiOz62WDQIgRBCoEJqcQXEf1CR1E/gjX492Z2heQVAZR0VSi6jGUNyFvI26GYpTRn4Bj8urv1HqoNwjfEJKidx+jqs1HO+I8hlHvb3FRlooYvmZSiekcp+q0cKTfcrhDw6vHU73l1v5L/Qnw/QP4/wbR2mhFj3rsDgAAAAASUVORK5CYII=">网易-镜像中心</A>                <DT><A HREF="https://mirrors.ustc.edu.cn/help/docker-ce.html" ADD_DATE="0">USTC镜像</A>                <DT><A HREF="https://hub.docker.com/" ADD_DATE="0">Docker-Hub</A>                <DT><A HREF="https://maven.aliyun.com/mvn/guide" ADD_DATE="1599887844" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABX0lEQVQ4ja3TvU5VURCG4WfW3ptwEjDGWOglGI0WdFZEr+FcgdGAFnSGkk5iR4XReAVcg4TKzkKjsbOVwlAI5BD2z1gAxwYswKnny5p35l1ctZK4SnYazpfm/TQ4MrhmpLIfb7WQzzR6836bmFXcVuK1fahzyT2VDYcWzJlx3Ujrs9Yj7IHevMa2Wx7oTBw6zhc+6a1ELvtq1l3HGHwXPkjvYtOXM7wgc9l94an0WHHHDI58i3wu1Tqtdb+sxZb+n9xjlZvWNFZ16iIMOhMH1mNLn4vqC8OL6tjSO7CuMxGGWgpp0CgQO7pcsqHxUH+yRJVG62O8sQIaRRoQ578WdoUfhlOcWiXsntdaC4miNUzH3PTqQoQdndZgVhGySEVtZM5qjlWxoztbVlKSkmPVFG+sMmdVbSSV/3DGM5FYMJhR/xUp3p+IlE/c0NjWnIpUHHMq0pTvkipf+TNdNjutP6KopyEB/Kx7AAAAAElFTkSuQmCC">阿里云-Maven</A>                <DT><A HREF="http://mvnrepository.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiUlEQVQ4jWNgoBAwMjAwMEiUXPtPlGJGRhT+825NRhZsEiS74PzNx0S5AB0YqsuSbzMKkCy9/h8bHxeNzGbCpYlYy5jwSTIwMDAs27ALQwxZHRO6JDooPiqLVx5uwPNuTUZkmoGBgaHX+jEKjc7G6iR0PjFsigDFCYmFgYGBwWvOF7JdQDAWaA4AfshA0En8tb4AAAAASUVORK5CYII=">Maven Repository</A>            </DL><p>            <DT><A HREF="http://naotu.baidu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADdElEQVQ4jV2PzU9cZRjFz/Pey8ydgWkzUKYwQ2kHpgNMR0qtCkJNiBpMTFeuTKFSEvxo0oUxGA3RuFGLGxddNBr/A2NrisaEhagLi1pbWhQTSzsDFAfkswzzee99n8cFGBNPcnI2v5yTQ41N8We8lueo2Pp2Ds79ao9neyGTSbz3zrsjp7q7u0rlUqnSX5ULR+qXGiKRtXw+b21ubu5f29iorfT7cxRraztvmp7LrHUJwBYR/maWZtMwAgP9/aipCcJxXJimafssa9O27UpXa0tEKlpaWyaM/dUhpRQNEJHPNM0AiOqIyFssFvXaxgbqQgdlJ7cjuVzOfLidrcrnC958PqfyhYJuiR8dN72K74sYW/lCwXIcmy3Lgt/nU5ZlGUsPHmD69jTC4TBYs5RtWxzbhjIUBQL7cgdra2eM9fX1sj8QeLG7qzPS1dkppVKZljMZ8nq9AICtrYfweDxYW11FdTCIZPIYlGGo1Pz84rN9fZ9hdHQ0+evNm9lSqcQrKyu6XC7z+x+OSeRwVFqT7RJPJCWeSMrlTz4Vx3F4bX1d27bNd2Zmih9futQHEbm6sLgoT/U+7TbFW/n1N0ZYRKT/pUE5FG2WQ9FmGRg8JyIib771Nh87foKfe/60u7S0JCJyFSKsz54b4upQvU60d0ggeEBPfvc9f3ltXELhBgmFG+Ta+Ffy7eQkB4IHuO2R4xwM1emhl19hEXEVhERrDaUISikAAle7RABkzyBC2XZIIDAMA4ZScMo2AAhE5EoqlZYnuk+5jU0xPn/hAouInDk7yLsXmmRgcIhFmIdffY0bos38+JM9bjqdFmH+AiOjo8mff7lR3NnZ0an0vC4Wi/zBxTGONEalNdnOrcl2jhyOysWxj7hQKPLc3D3OZrN6auone3h4+CQBQOTwkSs93T0v1NfV2bempyvupVIIVFUBAO0+IMlms4jFYjh5osPJLC97frx+/Zu/FuZPk4hQcyIRs4v2lKvdGq/Ha/t8VgUz418REYgIxVLRKZdsT0WFuR3weXtmZ2f/oL0VSXY81suiPxeRWu26AkDTXoHshmGYJinCJqDOzN65NQFAGXuMWl3JpP37Al8rMiIgOkJKeUGkQKQIUFBUEuYJx3UG/vz9tykACgAT/pMCwAAQa2t7FEK9BMShiMAyp9n9IXX37o3/s/8A6c3QK4LDjPoAAAAASUVORK5CYII=">百度脑图</A>            <DT><A HREF="https://www.processon.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACrElEQVQ4jT2Tz4sURxTHP6+rp7dnZuPsrkYjWRFXYVERQg4hgoh7iXoTQ46BQBDMXxDIJV68CUIQPAuKHkQUEokGIiQIuiYxZKMXYdnEnytxZ3d2pnu6qqteDt3OqfjWe/W+j+L7kSM/LlgAFBAAEAWVkQQERRFAEUQVrYtxcKEBWnWLEFGdGhStH0MYeQAErZQqxGVZqioYqaZnpUcFxkxEJEJQRWpvrX20UggRsbceVBlYjwjsmGhhRFhayyi80k4MISgigqqOhipgTESszks/t8xsaPLt3CzT4ykKdIeO078+4Y+XazQTM9rfBaURVR+ksSEa5o40KN8d2YdzgU8v3eP4xXss93LOfrKXSSO4zOFyx/r6kMlIyPsFw8wSrCfu9oZ8tmcrWzekfHH5Pv++6SMifHNzgTtfzXFgegoBju5+j25umdu5hfmnK3z9w18UQ0fkCsfspjbrueV1d0AKNIH/ugNW+gXb3kkRH/h4+yZ+evSSk1fmOTjzLod3babbGxKXuSXPSxomwhcerwFFCChjcUQ/t+ADK4OCq78tIcByL2NLK8Hmlkis55fHL0iTmAM7NrL0fJXF5132b5uinTb4+e9niCpl6WkDiVesC1hb4rKCuKnKnYVnXJtf5Nzn+/lgehIflC8PzXL9wRK3Hz7l6N736bTHKHKHD4Gp8TFSE2EHBabz4bFTlJ7vf/+H16sZH81sZrKVcP7WI87c+BOjSjM2vOpm3H38guADacPw4Mkyi696yPSJC4oPaFDWcovWiYtE6LQSIhEy6yhcoNNKEGA1sySNiPFmQuwLhwaFEJhITBVXqRjw1uNRUhGaSUxZlIgInYZBVXFDRxyKEpTqwvoRZfKWRYWyzv7b6V5rzKool1W7VHVEEa3hGTGuoyhrjZIgqHr+Bxa4dqntxz3uAAAAAElFTkSuQmCC">processon</A>            <DT><A HREF="http://man.linuxde.net/" ADD_DATE="0">Linux指令</A>            <DT><A HREF="https://app.diagrams.net/" ADD_DATE="1599890379" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACB0lEQVQ4jYWTvW4TQRSFvzueXdsbhyQiICfISIGCABKBAgnS0Fui4AlIgRAPQZcizwAtTxCJNCg8QYJASUMFWCYIFH42ztreXXvnUix2bMzP7ebOnaNz7jkj4YZtgpwFlNFSN9ISEMNvJQgHFqQK2LErYzGVRbDF/NxPcNEBuGwcQqmOPwRwGfb8Hcr1J4gX5HNph+PNR+inl4gpjI1PAqDI9DnM7FJOHZBA6Rdq9CND6dT49ISwAchERyFuWZL2/xiI4MJ3aPsLWS/LOZgC/a/vASFu5QDFqexvEoDkiPRgn++b6yDCbP0xrvMDRIZMRMAPshEJqqAZGIu38oD2/gvSxi7phx3it9tUbt/PrVSHOqXbsiRR4QRAgnnM3EW8S/dgboXu3haIgAidvef4tesE1+5i5y9gKqdRB/GxxaKKlGYo159iF26CVwbjU1ldI9xaB6CyukZx6RZ+7Qbai0kau3x79hAXH2FBEW+KwvwVpFIdKvIWLsMvz73qMuKVEK8E5Rn86jJSDKAbTubzH07+sSwiaBrR+7iDyfIliQhp8/UwumnzDf7iVVQVEUPSeIXGEYgg4YbXA6wz08TdObKeAIrrhGg/yRdsi5hglkEyNYlwSQQQD3NgXAtfjul2LFnP5A4M1PQTsqPPJ7pEhmBWkUNBz4BgfSjPODqhmfh4o49GOoc/AefyxNrXagaDAAAAAElFTkSuQmCC">Draw.io</A>        </DL><p>        <DT><H3 ADD_DATE="1599888593" LAST_MODIFIED="1599888688">文档</H3>        <DL><p>            <DT><A HREF="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACw0lEQVQ4jY2TT2hcZRTFf/f73r+ZlyapSVrQQoxdlGRlKS5Eu7B/FgpGVCpU3bhRbFIQbNGFi4cgIqhBh+wFxUVQUbFglWoLpoJSdJNoSmiwFlKndixNZvLmvfd918UQaRXRu7yXcznnnnOF/6pMDZl4Gj/vI4in65Zd1giK2C1RcDH4X+DZpSMEyQyqUacsAQEJ8L6IblwgzKlh8bTAGc/ChJCJY3Z5mjBuUHQcoCCgro01dWukkB5WBUT/wWB2aZoobZB3PGFkgKu46gRiJkEH0tCeDyAzIJ6ZHwapDT9Kle8krz4kCXYTpw3y9RbWBthgle76C8T1l6iqAcTQLqqVHoM3F26hVvuY4R17ufLrPM59RZy8SFUaVFsYnqHbPUdcbxDGk2xcL4lqlqLzgGH2/Di12jzDo3u5cvEEzr9PXHuOsmtxlWJsHyqjSNyP6t0UnZKkL6Qsnufo+EnhreX70OqetBZ1XbGxmsf974Bauu0SsQYRi+oaSAsRS1LfQb52jKldb5CpkZuOdr/GPPjLPhH/igbhbvJ2BWIQFUwoJCm0/zjO0fHXNy02ZJnhkFr2PB22qtGX9cjtZ/W3sXu34D4jTgPUOzCKtcrG2tSNYOh5Jxf2bO3fPpS+Z737sVnf/vmAy/PB/T8tSrJyVoPgTlRzimIGV3zCtYnvydBN242AjvSFE8ZzslXIRyN58+3VMEQ/HRqyXo8RJh2q8jhRdBdheJhMPHOYTdVGQfrPNL/tFn5+MLbvVk4Oj63//sS1MH2qWrrjm7B16VlUD7L1tgNglgE4xF+hMwJ6df+tB+PEzAW+fMxYecQbu+3hL3e+qg0pTJKOsG1skubKd2A/6IW+px/oUZE4iUtXPR6furzoXHWq/sWlJ09nX3sB7XqxXG8u0AkeYmrscu+T/qX0pmHW0zmzeIDXzo33Wpn5O+ZPPDYreVoYUF4AAAAASUVORK5CYII=">廖雪峰-Git教程</A>            <DT><A HREF="http://spring.io/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACvUlEQVQ4jX3T20tUcRAH8O/8ztl117Pretk9665tZVtWW0lgtgRGmC9GBpFUQikUFBRFFyLozX+hG6J0D30wiHxR6CUTu1BtD9JNM0w0V9dbarqtnvObHkwpM+dtGD4MM/P7Ef6IyvqQddDu3U7gcoALAHh/l6IgaiFJ9xP+8ec1WyIzpxtXJ13d1TlNc/hMQ5FXCuMigAoG3Fg8YgBuSkm3ki32QihmHc1hU8xcB2gfAPoPBgBINg2fY+WHrYFi5fHnBwfUyvqQdUiYlwAqXQoyGFKacGt+ZW/oZK7XsTzRMRwJqzFN3ykkH17QBcw8nwtS2GF1IaSHuShYRlkpQfw0JpN8zmCBKpgrAGQAALOEIiwccOWw37kKLlsGklQ7Um06Aq41pGsBoQgVzBJWxYY0m2ezCkbBbFcJd7KP96w7xhu828iuaovuwmQDQ5NRU9eyFKc1NaAC0BkMzerkstwLvN6TL5baRe9Yp5wxE+R1BECkaGJu5pAnzGvdeUvi/h/d/D72mv0pQQIAUxrTAkA/GMhKCZKg//svI22yqeOu3OgNi2SLg2ZH6e1TCWgBUB43Jv9BDMb3eIxf9DRx+1CEd+ccoeWuHAKA4ako2ocjT1UQ3SMSxW39zzzhZcWcZtcxEh9Az1gHtw9F0P39E2c6VqBs03nhc2YTACSMOFq+Pur7MPC6Vs3Q0Dw4Lu78mB690PCxmicSIxhPjMCmapydvhGlG05RMD2XVGGhuDHJ/RNdeNr1UL6NNt8YN9+8JADYX5/pOZF/7bICcfDBuyuUbtdlml0nhzUNFsVKkiUSZpzH4oNicOqbOTU9UQuFzlaVtI7O3/pN3xN3Y8ftc7GJ7qPMnMmQf71GACBBUSFFjanIy1UlraPAgo9zvDrPovqcYUHyEEA7wPDPSvQSqJlI1qVr4lVlYbMxZ34BeHEn8QqSwzsAAAAASUVORK5CYII=">Spring</A>            <DT><A HREF="https://mybatis.plus/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACpElEQVQ4jXWTT2hcVRjFf999d95LZjqdTJlWmraCxVVqBBcVLZaCSLOoLgQpLnTRQhfShTu3Zt+mCxeFokhBRUVpF0WRgkJRW6MooVZTiU1L/6SdSae8afPmvXl/7uciMzJocuDC5YPz3cM558J/oSr/m61C+mcdnNLS4Do+o0c3n9C91ePaWIdkhraqgOhjM/qyFZ7uae9LX+V1Md4kjgd3Vry3mEZ3757aboyOzD5+ZJEvDhYDngFRgGbzxwuax9edBKWlFf+9wng/EXjP7zq5c/LZndvP+Q//+r3y6O+5qYXpi688uWFfnydryXu3Xi7dr068NKdvfv2+iW6OB835mnaW8Hoh1V4TZ8udGxNHnmtPj1+1Qwa9WK41OppET/mjldeCWz+H+en95AdP19oTU0yOgXqwJ7rUu/zt57X7Xna4De94fbICM57mJxq1jVvr1aqt1xuVSnxvpPjtU2fimKK0SR9JnYp2TZKjrTAa78x+cn6wAOCyc+6NkrVjge8zGvhs3bJNqz6yMndW9I9zqgvfydKdlksza+TGhW+Wr/36ke2/boF5p3ogybKvemm6IUlTunFEpVwRN7pJTdaV4O4v+HdnCUpWNrr0zJ8QDzzIgTHgQJplIytxLCO+Lw+7XW4vL5MkkQZ+YFIJCvzAqPFaHSs/QAsL7AD2A28Dk0VRaBTHZFnGchjiGaOB70ue5ypQ4Dw/zdMPr1xdbAJigReAD/pKksI5a5wzWVEIIhgR8qJQEcmsapCk6Xw3DI8NzPeAK8D3wDPANsCocyLGrNZ0FcYYY4HFvChevdVu3xyYP0jhOvAxcBsoAw1VDfpkjEhTVT9LoujQvTC8NhT9vxEawA218Qlgh4VSydokzvMFoDVUOl2jwUhf0XowrPEz/wGLPywlWZEzfAAAAABJRU5ErkJggg==">MyBatis-Plus</A>            <DT><A HREF="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACOUlEQVQ4jX2TPaudVRCFnzV7n3PMTTAxFjaCVUpJIf4CbWxEJFqIiBiM+QVqFxUULcTCQkyKBBXEIkELsbIynR8/IHaiBBExkdyPs8/esyzeNzfcCJliYDPsNTxrWAJ4/5n+4n1b5eXt4UYohiDlzKp0UAf5t6qvvHuhXgYAC2SAOr9PLIInNASCGlBXwhWaoWWQkS+8eTa/W+/o1Y8+0x+3RQJAEW2TjEzvZtoj+XO3+fLuHhfXLX9Ou/eebVn1VD2c35w546PMFQCIMBTjRYR2ujl17vM4tVlzDviphApy7Oxt1qtlPHb/It+YEBwB4MQYSkRN+7e3v9TV15/1w3XFLwq91no3qEiqrWWmeeX0cz4OyhkBWbMbIcAqq3YkM4/lsEMCMBBjDJfQQ0ce7I/fQQA0N3kyp2g5EEMCJ7KRbZCyFJmIEwcEpv3Ims9TEQIbCCyBpgVIgPPY/wXuKt1reOAKd354QoDeMZ42MyFggyVsEP7ngIDnZk19uJU0C9uaESwJTIxhOXVtX8CJJ3LkFCCrLG+W0F8RwsYzUZYSGmNcv7m+9eO+gGIyLO1NBI+89byffO8LXd/+d/ukzcerRRSg2/TlMgLFJ5cuPXADHHMWSMHA9Bw+FFVfvfOSr6a40ZWP9nS3YWurrnbX/uFWxodzFrJOCLlcRJQIHSIgguN1wdMu0Bw0oAZet3Flr5Wz5y9q57Z3dSb/dZN8b9ywYiS0NcNhRhDd+XusytcffKpvZ8v34/wf28U+ZKxw+i8AAAAASUVORK5CYII=">Dubbo</A>            <DT><A HREF="https://docs.docker.com/" ADD_DATE="0">Docker</A>            <DT><A HREF="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADAUlEQVQ4jXVTS2wTBxB9s7uON16MvY4NhpAP/0AKiqKoBClV+UjQClAUhChSzwjEBcEtJxBwpCUCCU6cEBJEVLS0aaVIiI8QcEBp0roISFriEOwkjr3rtRev17s7HAjBgDrneW/evHkD/E8xcwPbyT5P/3nSy14ue8bAK66kzzLz0uo+qgJEPa10wMubK6S60N+Mh/s42/ctm48IbAGCAlqwhSl67BYFOg4R0TQASHNgnzuePW3dGD7kjs2S3LPaldZdENj4nUDSuzmuDtZ/IrDTTfXnhgCcAgBhTsASZ2jym8q9UfJSebA7LaKcIJBYJZIAEsHFu2Dz0W5mDs8rcIDl5QY1IH3ZDEGzIMUNsJOr3vADiWcC9kQUQBCALlkO77o6VugbMP2Llm5rR7tfxK74fag5G/yZsy4EeSVyaFNdE1uZ+Zq480hv/5mR3PqRnI1/DAe3dQf1oRjalQRgjwPsASQAcCEqbXjinsDRQUF+mc1tb6uPvJFeGHbrVMmFTyC4DDQFRDg+Gb/5TmBT3RbESr+ASwmw8hUGjePovW1hNJNGIp1b2Nm06LgUrxXTiiQ0amUXX6h+7F1FuKk9RWKiiNbgZuyt68Luxa/weGIJegczmCoUIQkCiraDKaMUlzbF5B++W77g1FPdDn3d4OD67HM8KxYgEuHPfBbDhoC70RVYrUnIFJJgBiqeh+ZIEOvioQQxs8+0sf+eNnP+5NhIJFl6A5E+uM8AagQBp5vXwkpnMZwqI21UsKe18cX3HSuPSURUYeY7/5by2qRVilSD30dVJBGymIISvoKdkQjW1nVnWmJrDhLR/fdBKi6TazMBUfzsdB4Yqq8GCs8gVXiOcf0hzErSBJCcTyIRGZ3h6K9daoxd5nkSBuAyo0UJ8mK/31HlJrREd3BzuPMPAKlPnyk2lNcvXUyO9jzQZgXTdSALIjpCKh9uXDXQFfb3a3ZmY0CK/Bfwqf1ElP2IYI4knraso38V9APTZSseqamZ2RAM3WiqVX4kotefBhMA3gKdnWGyPnzI1wAAAABJRU5ErkJggg==">Elasticsearch</A>            <DT><A HREF="http://www.postgres.cn/docs/9.6/index.html" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACdUlEQVQ4jZWSzUtUYRTGf++9c2ccZzCdccaPtJq0HHMUP8KCMI1E+4AgW7gxo01Bf4D7tu3atYuIUAoKotRUqKgmNUs0JbBoKnJALUOdnI97574tJi+GUPQsn3PO857nOa/gN5ZXYxLAk+MWm7lEMkWxzyMA+l+MyWRK0twQsvoEwNU7A7Jv8C26SAJw7kgdhga3h6bQMdFQqN9XQrCijBv3HqOhcP74QS6cOSqU2ci87Hv0Bh0HQjrJ0wzIzeXW0CSGzHCGdDA+u8TgcJiz7fsxpIPrA6OMjE1KZWRiGl26EegA1FbXMD46h266ALBhAiDRWFxTiC4sEwr40aWbyI+f2JyKHYGORAOgwO9lx84CDqvwZX6ZwfAcEg2BTmdbHaW+bFZTaWYiowRLClGCu/0bmSHQcTht3H8wzNzHBQp92RZvw8TplAy8fMXiSiarplC5UEJlAatJopGMG8RSLp68jvDp6wpuJZ3ZTuiYahZLSwniiTiNVT4AFE+OWwRLc601HU6bdY0sh0bCzFxVl27ef47itpv4slUunW7NCADU7i2xbCRjSTxOO1LE8Rd6MFCsgKemo3Qca6ayOJ+qwHZhCbQ3VqCJGABDzyfo6Wqjs6UBJZ1gM9Z1g+i379RXllmcAhAqD4iOljoAerraaD1QJ041VbO+tkLA60aiocs0AMX5Xq71PuRpeFxaP3EDz2Y+yKZQuZiNzMv+8ChVu0roHZzlXXSNlJbCpUvuXrlIkXebNWfbLNAUKheA5Q+g+/LNzEspFbtd+WPYsvA3qKq0QnRlO7fU/yngz1UB0IRKQZ76/wInD9XgzTLZU6TR031iS/0XF47lAgwjgUMAAAAASUVORK5CYII=">PostgreSQL-9.6.0</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">购物</H3>        <DL><p>            <DT><A HREF="http://www.taobao.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABK0lEQVQ4jZWTv07DMBDGf0bpzBLGSn2DdiBs5QEQa3iCSKiVyFqJnSFrBqpIeQGUNYqY2zELK1ulspGFGSQzGMf5YyP4JMuW7+67785nASD3hWRX8C9chohlKEQbfP+kDOsFPL6YswPN8YC/yfHYFfD2CkhAgDcxXt4E0rofWWXwnONPZzRJhNca4gu1p7VyurpV5zjoE2jCcqt2+XAj5WouW9ydq2VD9341l+/Xp/LEWuAwcxyMlfzAEKwXSrqW2K09rce90G2y3upsOsiRva8AVOPiwJ7NocAQ6Le3wREMuoRu8NdnvxdgBkr7VdmAYOhYbs07DxNUWc8m5L6QTRLhT2fuEizQoyxAfaYmiQBaouZ4+JXA3+SIZShGBj1hf1VincSz8mPM7MA3ERmaQnFl1eEAAAAASUVORK5CYII=">淘宝</A>            <DT><A HREF="http://www.jd.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAA8klEQVQ4jWM8IarEQApgIkk1ORpYkDnssjLsctKfjp7kszaHC369cv3vx0/YNYhGBEuX5p0UU9Zcvwwu+PfjpxezFjzpnkjASU+7J50UU77s5PPp2Enp0jz5lhqi/PDtyvVb8Rnvt++WSEskSgMEvF6xloGBAeIxojT8/YTwNFEa2GVlGBgY/nz8hK6BS0cTOQQhgJmfT7o07+fjJ9+uXGeABCszPx+flbmgp6ugpyvEuQwMDGyy0nzW5nxWFiIRQeyyMrfiM6AGnBBVuhYQ+f///z8fPr5avua0isEJUaX/SODdtl3XAiJPiCpBEOPgS3wA205g359INNYAAAAASUVORK5CYII=">京东</A>            <DT><A HREF="http://www.tmall.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAfklEQVQ4jWP8z6DLQApgIkk1AwMDC4L5/xI+hYx6ZNrAiN0PENtgpiIDkm0YmRqCGR6xMVxpZ3iNIsyohxam7Qyv2RiuBDM8Yr7B8PMvA8Nehi+8DMxWDFxYTe1heFPB8OIfA8MNhp+MyBKcDExsDIxoqn8x/P/O8I9Ul1MAADCWHE8/7PPNAAAAAElFTkSuQmCC">天猫</A>            <DT><A HREF="http://www.yihaodian.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVQ4jaWTP0ucQRCHn5nd943nvYJBMYQUIQaEgIIh30KJYGFhmxAIBEsba0mlpQHFLp1WVuniFzBVSOnBpQkonOI/ct7tToq7y3t33h0hTrUz89vfPLvLwj1DehVtD3d5zvMQeC2R97fwcuIDV720vj252GEq1lk/P2XprxlQKGSF8syzpBYvZhO18tPvP0utvrYbhJAcmaRLaIro0Bf88KLLRsZPNx+u3NbPKhbD12C23JcAn40gICobo28qq61yaXpUvTMMUO08dadBUmwwi6tCJRelQDAQ6WLuTn0R0gzSwtr151eP8yl11BlOI17jIIIMAAOpqowBvwDUNyeZoTLIwBXzh5Ucznsws0ar6+Hv3kFL4XKleiBaYz3wEn2Wry0ncB4kNMH+maDNwBNncE2Czv29CBrCxGv8Pf9oUmq8M4sLIoKZgcSbvgbO+bchyHFNqt+KH/dfWIw/WtiiXBJ1K33gttv39PxMADb3ZKoaarti8ikdGj7koHQiItZP/9/xB4tWdX769HQIAAAAAElFTkSuQmCC">1号店</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599890218">云平台</H3>        <DL><p>            <DT><A HREF="https://aws.amazon.com/cn/" ADD_DATE="1599890103" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdUlEQVQ4jc2TO04jQRCGv+rxjDDaFZiAERkSsNqQG7BH4ABIiARENjEiMBIHmAzYZM0NOALcYEMEC7KEQJqAh7HxGM90FwEv29gWZPuH1fV/XV1dJQxQvvdjUZAYQNGosHZy0C9PegP6e27eWhOLsNAVV448z0Wyevq3L0D/TI+7VhAjsjyoqhfSvhlpR7JSvXsD2J2fZUQjYGyo+V01VGJv/bgs9c3ZX2L0ICgVfK/I6Gfcj9eu2TjPMvHNUgFAHWOP1znGlySYMKHxP7QGgPxBqZ9liX3QEMBa1yh0JrhMw1Zi8YqSBCUvFPPy7BzqZ1nSvnEhEHZ6ugCvsqmGaStP/W+m3a450isboN3GoYDnaylmdVdML+3AFAAz9PQT+g8A37f/HYJsAbUv+GoIW1OV6uHbh9+Wp8e93IsFuka5edHTRGE/gKhU6RjlTjU25ubVuBiel+kVoMKRgWiyUu2/TL2635xZFGW3eWFbGKKwUu27zk/aOpGGPDxYiQAAAABJRU5ErkJggg==">AWS</A>            <DT><A HREF="https://www.aliyun.com/?utm_content=se_1000301881" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABX0lEQVQ4ja3TvU5VURCG4WfW3ptwEjDGWOglGI0WdFZEr+FcgdGAFnSGkk5iR4XReAVcg4TKzkKjsbOVwlAI5BD2z1gAxwYswKnny5p35l1ctZK4SnYazpfm/TQ4MrhmpLIfb7WQzzR6836bmFXcVuK1fahzyT2VDYcWzJlx3Ujrs9Yj7IHevMa2Wx7oTBw6zhc+6a1ELvtq1l3HGHwXPkjvYtOXM7wgc9l94an0WHHHDI58i3wu1Tqtdb+sxZb+n9xjlZvWNFZ16iIMOhMH1mNLn4vqC8OL6tjSO7CuMxGGWgpp0CgQO7pcsqHxUH+yRJVG62O8sQIaRRoQ578WdoUfhlOcWiXsntdaC4miNUzH3PTqQoQdndZgVhGySEVtZM5qjlWxoztbVlKSkmPVFG+sMmdVbSSV/3DGM5FYMJhR/xUp3p+IlE/c0NjWnIpUHHMq0pTvkipf+TNdNjutP6KopyEB/Kx7AAAAAElFTkSuQmCC">阿里云</A>            <DT><A HREF="https://cloud.baidu.com/campaign/Promotion-20181212/index.html?track=cp:npinzhuan%7Cpf:pc%7Cpp:npinzhuan-biaoti%7Cpu:wenzineirong%7Cci:1212gej%7Ckw:2086588" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACb0lEQVQ4jVWSX2jNYRjHP8/7++0co5E2LhRFMjbMMMqfrGQiu6BOKWZrm8KFi4kbyUlyIxdcuTAkF9pcmAu1Yi23Lpa1jXGBCyVNVjhnO+f3e78uznbO2XP1vE99//R9v1A+famguL/vOsh49wgT3R8Z62ot3pV2gM0/C4swDBWAbWuh4irOtWMKEeBMxHqOuEFD71g5psjEYMsSVq2+iOMSybCabASVFQWJbB4SIeTif8jfJfK3aXw8XXIw2rERl3hFdXItUxlIBpCLZ4l1D8gQWA/JsIpsBDWVuN8zP7zPHWbLk9GADi1i9VCGDd8mmFpcR2jV5P0AObXR+PAp90eGOb/5BXlbTsLVko0+qKbyMn9m3ulXlITTaqBdQ2zXfj7urWLy3K4Foaos2E9nt/H51FKtWL5PrfVv1Lr5GLSrnk6JCxJtughAqi8gjSslj6WbCQHUsum8UtukEw1Sa90RR4ghphEipIk0jv6USOOLBIauD+NJ4/zicA8YRH6GABwRwgjmPjGzALhwRBrvPFkkYRYSB8w7mG9CAdxcZr80hSxMecwMEMRFByJGGDto1iKGLaKsIwIziAoEth7vBRJmcgSEwDLyeBw7Wcdb2tUCprK6Sse3HNCJrUNgh4h8TGAJpKTRppWEPCLB0TmNOVn/jGnXo0mb9esb7jjzHdicqcBBPh7GW2epyl06iZEmoJYccpWY/0Wnvtp31uwcJD9bAEpfiONbDIz3GqgUVq894ydNRFzDmJIA4YkREmB/ieJbZDO7bWD8gYEEFhYJUgrotz/ATc6oD6d7OAuBUF6vzUdX7OXECIBSBNZPbKD/iDgXl5vkR9QAAAAASUVORK5CYII=">百度云</A>            <DT><A HREF="https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJ0lEQVQ4jZWST0iTcRzGP7+977t/zilJBUJCxLophFBQHcWD0SFjRcFoTREzRcpTReihIiSkQ6c0QlKLFUhEHbp0aoamQmSHpkUXS6ZsYW5ur3u/HTbZ/EN/nt/p++V5Hh5+3we2g1+0f9r9FUFxEhTnnyhq4ygKlNApJ4HLCIcB0Ihgcpd76ulmA9sWcYf04uYZgheLmwg3yOKllDAdcrvALUbLewMRxUU5wRUROrN3tmS9JH1cF6FdziKiqBUjb1bkdkHe0CaTBWMxaFknAu3SRofUF6fOiSMzB3B6r/KdRty2OdzJXg75BjYkGJYmHPjJsBfFBzLc4pyaVkzMHkF3vmbNNNHMESytmvJdR0nEw9gTrdTUxHki/XhoJs4EFh/RaUTHwKReMRadwu6oIP7zIHXVCwC8+9KFx3WN5ZXjzO5rooLzLNFFQPUB0C+78TDOGkvwaVEYi3YDEI066JHcZZ5PVTIio7wQ4aG0AtAjNnryvRiUbkZFdNIpE0uqAPD50gA8kFKWuY+bY8QIEFJDOQNlAav5X6kijamzmhykrLyZyNxb9iw85mu1h28M46SOBEFCaoiwuPiBBYADDQen8RDiFwOKyMwOjJJHeL0NLCaSzFfacTt0VoA0KcCVuxigEBSKEiDJK1IECh2YnmtgvqyGWEUJmpXBsmlo2JH8KyCLwThn1Mv1xaZa/g/WiwQQDmvs9Ofmz5MKarfX7EeIIZxSWYDfa9nVNFgL8gwAAAAASUVORK5CYII=">腾讯云</A>            <DT><A HREF="https://www.163yun.com/product-cloudcompute?cid=ch180302101645682944&utmCampaign=C6781743F6EA4CBA24E8030B3D0C5785F55B0122FB93C051&utmSource=EFF78AC55124544378529F35799B630903E32E41B784B1F1&utmContent=3AD349D77452D4F23208CDCF6D7A42C283A90C49F7643D88&utmMedium=E1F8E20EFF39CD8D40B9CCC0033EA6B7D15C4FDB182F3DD60B20C6AB900317DC&utmTerm=C6781743F6EA4CBA290ED3510B87058E&h=fc" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABfElEQVQ4jaWTvW5TQRCFv7N3/asgAw0oFaJAIhDRQJDSpaHmRaDmPXgQeiQKKkSCUiAgSgoiqpSBwo7t6zuHwk7iazsSP6famdWe/XZ2RtRkAQI8S8zWMv8vp1VZ1aIH/Scwuk1/sker2aHVeEg5Oubg5pdLwjpNrtulTVRs0mWdghvk/BL7Fo/G7ynPXvFNu4smdSx7AJwir2MqRsM3KP0C7ZDbb9kYbE0PW6sNUILIWEPkNtJ3HB+IwQSiR47X8KlxNcE0MomEHVgdXB4gj4lBYG+xce/pZT2WCOYKm4AUCUcf9BNJqGmS78xfVy8i1ZQAfOEtPPdkiGIF9IWK85SIEIFJaQ35OrbxWCiOz62WDQIgRBCoEJqcQXEf1CR1E/gjX492Z2heQVAZR0VSi6jGUNyFvI26GYpTRn4Bj8urv1HqoNwjfEJKidx+jqs1HO+I8hlHvb3FRlooYvmZSiekcp+q0cKTfcrhDw6vHU73l1v5L/Qnw/QP4/wbR2mhFj3rsDgAAAAASUVORK5CYII=">网易云</A>            <DT><A HREF="https://www.huaweicloud.com/" ADD_DATE="1599890141" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACxklEQVQ4jV2SwWvcZRCGn5lv89tkm6ZNMdKakjUhRYoNiDFHMUQPgqCQUkuFWiyevEvBUxXUQ9WD+BfosaC34qFKpaBIqFj0IJF0EyEJSdbN7ia72ez+vu/10ESqAwMzvC/zzuEx/lfrDI7wxNANf/r4rJ8YmO+bm8P7+7/2vuIddVrvHr368dajfj8cBAWARPEiebpMFsoM9s+E4DPeP1i2rHiZmF4H0Oxs4T8HKoycXGX4/TWGxwxNqCenG1GezuX17alUrxJrW552mxNrF6bHNrLND7amy6fgIDUQ3wB7T+iYYYu0orS1Z340O621VYulbTATeW8l9HrXVOu801vcqwKfFQS+THwOnIBdMfQJ3bSUltuTGMMyMxsogvtSqu8Oa6P1ph60YCdOC7xwE+xZ7J7BRYfBBPOGLdDoTaY/dgLN3DgSILCg6v551eMgu3kE7gEWrtL3BVApUdg0eMqx04JFR5lyatS7SX/3cm10qzTyF9hPLeArwYNdSm/bTfz+CNnkCfpuH6GwnsHzhg0Z3DYUwE0oN3gJaAJ3hY0KvSi0GF5BWURzGT7l2JPCfglQAdaAW0K/G/4Y0AA1hL0MeibBvtCn4TW430N/gRULsFfAhkCbCb4pU/9uiM7SDqUU0TmgDFQj/JbQDXH8S38LOsBPVfJmhf20Skd1UrsNFYPcII/klS6p3SbRJKpBr1En/TjOcsd5+NuKkb7vkpo18lu7xA+naCwd0jZGYwnCRx3it23iTof0Q0Zz5VC3A5TtOmQ62B/R/sX9OvjnULwAgYdtNnHq8fMe+VVBZwyTJfsz9zQaUCvh4yRrBNiRpXI01j1p1LDxhC/gOlZwmMc1g6yWpH1Z3HbsrLARS5TNdTdJrwJDJlVw1gUnydMKpksutCzjjinVzKwvyC8p2QBQMmNdpAFBEPaz4XuWwgZQctdZA/0DZelix8BzL+IAAAAASUVORK5CYII=">华为云</A>            <DT><A HREF="https://www.ctyun.cn/h5/home/" ADD_DATE="1599890189" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACbUlEQVQ4jbWSX0iTURjGn/d8mzp0uW/+GUZEZFJJXRhRVAgFQUEQQayM8KKbkC66kKDoIlbdeNFFEQgJQVBGbIGYYCSTQkKCIiicIEU2rcw/3za3ffv+f28X21Sim4geOHA45z3Pw/nxAP9DHIUEBgEAMwSX9n9rQ8W1aspRSL9PlVMIgEQEG2ChT7Z2efxqB+kccBRzXJk2eprOZL7+KYaYQUTgUo7Xntn5UArOn7aS5nuCWJAgHbUy/MNeEnGPf9fn/ET9neDF/hzCEBSDAwDID+4NWclNV8yZLSOsNHI67usuJxgv5R32m4aUPiqneGwbG0NHnq58CyBoidaNzvL6SeYg23O1Ke2TPL4ywBAAkHmAZgDIPq46xy9a2LwfepW6IbcDgJCa0jfhLWw3J7ST0rPlUFW1fbz0kIjgAoCvvfOsmuho8z/Xo7nv6Xu2aW+urhWj85f8++BkAwvWbO3AGpiIRCA4GpYSkYYaY/HJI+Y42x8OzuUGDxwCgKnz/nq1J5jMXg8OC7a5AIfWAUAZZiQCl07FnMaOIInqwKKVNmxbMQMVVr4BDNral1uyVH7tMd0WKsz5L/v8lT3GR/eWNuX266qwimQBuODpq6mfu6euDfCXt/uVobFjfb1qvKs7uEeuwYiad4aJ38HrNMq3JRIXWCFYBYAMwNUBj0Wwdc7bhbpYVWXohKRMyxlF/RYg2mBobjK7XDi80jQzEWhjS7RAhwMNBA1wDDBMrtAXjIyU9y0Jr9vp0dHs5JEwsvrdul5tFmvh/a0YoNWuRyDQWjSKlc7C5cvJItxYAhSOwUUYAjG4hHKD/0G/AIAsM5vSjS4YAAAAAElFTkSuQmCC">天翼云</A>            <DT><A HREF="http://www.west.cn/manager/domain/rsall.asp?domainid=12585514" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACuklEQVQ4jU2TT4jVVRTHP+fe3/u9PzrzGCootFq0jsCFMFg0g4toyiJxEBIhsEUFMRUEUgSBQmSQpkGbFhVhQS5CzAa0msgcoUVtCtpFDSO6UOe9N7/f+93fvee0+PHQL5zN+fc959zvFRoIYAC8dWkekYMgcwjbAcFYA1lB+JyjsytNiQmICRO8fG6Gqa3HcPICvp2RAmhqYs5B1oYYIpa+pCiXOLUwmDDDq+enyd0y7elZig1DSBgemfQ3gAQ4un1HOfyVmBY4tTB0AMTqJOZn2bhWEioIVUYdIIy1sdD4qkrYuFYh2S60+qTZ48Wv9tOZ/roZWUFrBXFgis8bghQSiAcMEcG3IMthc2N/Rq1XSbdeAa0x20crf4JQBPJeTjlcRfDk3Z1URcBnORrXwR3BZ4am67ePCPDUezP07/6N9paHqDb/pMgeJYXAtP+JrL2zOWL9LKdfOj8pERZP/oHzPVL8hTNLh3juw8fpbv2A8WCRqjegXXUYxQEzvR9I8TJnlt5g3/F38e3n0VgIe08YqtDKoRy9xrnDH7H99S5rx0ueOfYj4rYxHs1S/VOw8tmYp9/fTZZfwCEYCE8evYHQQ5wiTrB6D9+9c5GFI5/iWoeaV0yX2Kznqbtd+vF3xD+AxoRZJex++yydqT3U40Ys1egGqt/T7R8gVWAK+RSUN68AY7r9OUIBWQeq0bLw2Js7QA6AREgOkRbQAYZMlGSqOLcFE8NSAWKIeMxOe/69fJV7H7kLjTtIaUiMoDGQkifWjhQdKXlSDMQqktSIYRuxXmX1xHIGix7f/pawWaI6DxQICXG++TAAYphO5N1F3Tfo1EXAefjLWLsSmXn4FmL3gELSHprGkMaYBVJSUswxHaCyzsAu8PfHN7nNcAce3HsfeXYQsTlM7kdMgXVwP1OWX/Df2fU70/8HpIxW0MDpZIYAAAAASUVORK5CYII=">西部数码</A>            <DT><A HREF="https://www.daocloud.io/" ADD_DATE="1599890205" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACIUlEQVQ4jW2SzWsTYRDGn3l33+4mu022LW0a24BUi9CTl0oPBUUR9aQH9SB4Efxn/BM86kU8qBQxvfTmqVQ8KIJV0NY0bfqRZDfNfr77jodqbYPDHGYYBmZ+z0Pzi9dwOkj/q1kMDGEO9GwgPiM780U9JEZW+4VGRjn/Z4E0tCQwHyy6zXsjSVWCsHd9eHLJrywHYIiMmQCCMVWb0TZ1LjnN+15/1nJ+pPZWljvCDPLxlZ7zMz247LZulbQtrD0lUjaJEVflxuMx5ZkAOgvO1Mvu7JMWE/rnrM1HY1FNgii4WJCd3FvrCwBGzCIHmGVbVepB6VNk+rns5u73ZHLJt7cyMJOGEWoAggmyo7zVkBSslpqoB9auAgEE08/HV3rutwRA+UNoNzMWZIIgUq7U/eJG0puzeYg4/YuFoE0yQj39vO19jIxQgyAAMKF1o5SMy+prX8QMOqkJT9QDArbvlNkEAAGAFITG9l2v8WAkLwowjlNL2rld/vVwlE0SKf/RgQC7kZLi/nkrmpbxVNFbC0XMnQXHbqaHF2wQFTZTaIBgHp00+r6vXGP/qqsLYvdmaf/KsBHqqCbPPj0gxdVX3Ynl4ITSBCPS1Tdddz02Qk0ZH87ZAKydzOzltWft4S8RKRz9Zh4DAVD6HGtJ7tcknLFYwFlPCo3MCDULHJM4ZT4WIMXTL9pD+yp3ROVdICI9YNhBt4IgIp586wMA4yTio/gNNxT8LLPI27QAAAAASUVORK5CYII=">DaoCloud</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599885150">大数据</H3>        <DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">Cloudera</H3>            <DL><p>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.12.0/" ADD_DATE="0">hadoop-2.6.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/oozie-4.1.0-cdh5.12.0/" ADD_DATE="0">oozie-4.1.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/sqoop-1.4.6-cdh5.12.0/" ADD_DATE="0">sqoop-1.4.6-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/flume-ng-1.6.0-cdh5.12.0/" ADD_DATE="0">flume-ng-1.6.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/hive-1.1.0-cdh5.12.0/" ADD_DATE="0">hive-1.1.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.12.0/" ADD_DATE="0">hbase-1.2.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/datafu-1.1.0-cdh5.12.0/" ADD_DATE="0">datafu-1.1.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.12.0/" ADD_DATE="0">hue-3.9.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/impala-2.8.0-cdh5.11.1/" ADD_DATE="0">impala-2.8.0-cdh5.11.1/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/mahout-0.9-cdh5.12.0/" ADD_DATE="0">mahout-0.9-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/pig-0.12.0-cdh5.12.0/" ADD_DATE="0">pig-0.12.0-cdh5.12.0/</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/solr-4.10.3-cdh5.12.0/" ADD_DATE="0">solr-4.10.3-cdh5.12.0/</A>            </DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">Apache</H3>            <DL><p>                <DT><A HREF="http://hadoop.apache.org/" ADD_DATE="0">Hadoop</A>                <DT><A HREF="http://zookeeper.apache.org/" ADD_DATE="0">ZooKeeper</A>                <DT><A HREF="http://sqoop.apache.org/" ADD_DATE="0">Sqoop</A>                <DT><A HREF="http://flume.apache.org/" ADD_DATE="0">Flume</A>                <DT><A HREF="http://oozie.apache.org/" ADD_DATE="0">Oozie</A>                <DT><A HREF="https://hive.apache.org/" ADD_DATE="0">Hive</A>                <DT><A HREF="http://archive.cloudera.com/cdh5/cdh/5/" ADD_DATE="0">cdh Download</A>                <DT><A HREF="http://archive.apache.org/dist/" ADD_DATE="0">hadoop Doenload</A>                <DT><A HREF="http://kudu.apache.org/" ADD_DATE="0">Apache Kudu - Fast Analytics on Fast Data</A>                <DT><A HREF="http://impala.apache.org/" ADD_DATE="0">Impala</A>                <DT><A HREF="http://spark.apache.org/" ADD_DATE="0">Apache Spark™ - Lightning-Fast Cluster Computing</A>                <DT><A HREF="http://abloz.com/hbase/book.html" ADD_DATE="0">HBase 官方文档 0.97</A>            </DL><p>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599885245">AI</H3>        <DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">算法</H3>            <DL><p>                <DT><A HREF="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" ADD_DATE="0">神经网络入门 - 阮一峰的网络日志</A>            </DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">工具</H3>            <DL><p>                <DT><A HREF="https://www.2cto.com/kf/201702/604190.html" ADD_DATE="0">Tensorflow实例之使用LSTM预测股票每日最高价</A>                <DT><A HREF="http://www.tensorfly.cn/" ADD_DATE="0">TensorFlow中文社区-首页</A>                <DT><A HREF="http://tensorfly.cn/tfdoc/get_started/introduction.html" ADD_DATE="0">介绍 | TensorFlow 官方文档中文版</A>            </DL><p>            <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">NLP</H3>            <DL><p>                <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">Word2Vec</H3>                <DL><p>                    <DT><A HREF="https://fasttext.cc/docs/en/english-vectors.html" ADD_DATE="0">英语词向量下载</A>                    <DT><A HREF="https://mlln.cn/2018/06/28/%E6%9C%80%E5%85%A8%E4%B8%AD%E6%96%87%E8%AF%8D%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD-%E9%83%BD%E6%98%AF%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E4%BC%98%E8%B4%A8%E5%90%91%E9%87%8F/" ADD_DATE="0">最全中文词向量数据下载-都是训练好的优质向量 - DataScience</A>                    <DT><A HREF="https://github.com/Embedding/Chinese-Word-Vectors" ADD_DATE="0">Embedding/Chinese-Word-Vectors: 100+ Chinese Word Vectors 上百种预训练中文词向量</A>                </DL><p>                <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">知识图谱</H3>                <DL><p>                    <DT><A HREF="http://jena.apache.org/" ADD_DATE="0">Apache Jena</A>                    <DT><A HREF="https://schema.org/" ADD_DATE="0">schema.org</A>                    <DT><A HREF="http://cnschema.org/" ADD_DATE="0">cnSchema</A>                    <DT><A HREF="https://www.omg.org/hot-topics/finance.htm" ADD_DATE="0">金融领域知识本体定义</A>                    <DT><A HREF="http://www.opencalais.com/opencalais-demo/" ADD_DATE="0">汤森路透标注Demo</A>                    <DT><A HREF="https://permid.org/" ADD_DATE="0">PermID</A>                    <DT><A HREF="https://blog.csdn.net/frontend922/article/details/18095037" ADD_DATE="0">Jena TDB的使用简介 - CSDN博客</A>                    <DT><A HREF="https://www.cnblogs.com/yes-V-can/p/5526096.html" ADD_DATE="0">导入本体到Jena TDB数据库 - yes_V_can - 博客园</A>                    <DT><A HREF="https://www.sohu.com/a/193661084_769062" ADD_DATE="0">基于RDF的知识图谱管理</A>                    <DT><A HREF="https://blog.csdn.net/svenhuayuncheng/article/details/78829035" ADD_DATE="0">配置Fuseki服务器管理知识图谱三元组 - CSDN博客</A>                    <DT><A HREF="https://juejin.im/post/5cf936b3e51d4577407b1d02" ADD_DATE="0">[知识图谱] 1.3-知识图谱怎么去做？ - 掘金</A>                    <DT><A HREF="https://protege.stanford.edu/support.php#documentationSupport" ADD_DATE="0">protégé</A>                    <DT><A HREF="https://www.w3.org/TR/owl2-overview/" ADD_DATE="0">OWL 2 Web Ontology Language Document Overview (Second Edition)</A>                    <DT><A HREF="https://blog.csdn.net/zycxnanwang/article/details/86557350" ADD_DATE="0">OWL语言 - zycxnanwang的博客 - CSDN博客</A>                </DL><p>                <DT><A HREF="https://toolbox.google.com/datasetsearch" ADD_DATE="0">Dataset Search</A>                <DT><A HREF="https://cloud.tencent.com/developer/article/1346772" ADD_DATE="0">NLP项目：使用NLTK和SpaCy进行命名实体识别 - 云+社区 - 腾讯云</A>                <DT><A HREF="https://blog.csdn.net/b0Q8cpra539haFS7/article/details/79256475" ADD_DATE="0">阿里小蜜这一年，经历了哪些技术变迁？ - 阿里技术 - CSDN博客</A>                <DT><A HREF="https://www.infoq.cn/article/electricity-supplier-intelligent-assistant" ADD_DATE="0">颠覆传统的电商智能助理-阿里小蜜技术揭秘</A>                <DT><A HREF="https://blog.csdn.net/lhy2014/article/details/82954509" ADD_DATE="0">自然语言处理界的小螺丝钉 - lhy2014的博客 - CSDN博客</A>                <DT><A HREF="https://github.com/liuhuanyong/QASystemOnMedicalKG" ADD_DATE="0">liuhuanyong/QASystemOnMedicalKG: A tutorial and implement of disease centered Medical knowledge graph and qa system based on it。知识图谱构建，自动问答，基于kg的自动问答。以疾病为中心的一定规模医药领域知识图谱，并以该知识图谱完成自动问答与分析服务。</A>                <DT><A HREF="http://www.datagrand.com/chuizhisousuoyinqingzhishitupuyuyifenxi/" ADD_DATE="0">垂直搜索引擎 - 达观数据</A>            </DL><p>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="0">教程</H3>        <DL><p>            <DT><A HREF="https://leetcode.com/" ADD_DATE="0">LeetCode</A>            <DT><A HREF="http://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" ADD_DATE="0">小米笔记本Pro黑苹果</A>            <DT><A HREF="https://lvii.gitbooks.io/outman/content/ss.mac.html" ADD_DATE="0">MAC OS · 科学上网漫游指南</A>            <DT><A HREF="https://www.cnblogs.com/weiyiming007/p/10168733.html" ADD_DATE="0">docker 远程连接设置</A>            <DT><A HREF="https://www.cnblogs.com/yidiandhappy/p/7714489.html" ADD_DATE="0">ElasticSearch调整最大内存</A>            <DT><A HREF="https://www.microsoft.com/zh-cn/software-download/windows10ISO" ADD_DATE="0">Windows 10 光盘映像（ISO 文件）</A>            <DT><A HREF="http://blog.konghy.cn/2017/03/19/git-lf-or-crlf/" ADD_DATE="0">Git 多平台换行符问题(LF or CRLF)</A>            <DT><A HREF="https://safari-extensions.apple.com/" ADD_DATE="0">Safari Extensions Gallery</A>            <DT><A HREF="https://blog.csdn.net/neokekeke/article/details/79775777" ADD_DATE="0">Linux服务器断开SSH连接后，让程序不退出继续在后台执行 - Neokekeke的博客 - CSDN博客</A>            <DT><A HREF="http://velocity.apache.org/" ADD_DATE="0">The Apache Velocity Project</A>            <DT><A HREF="https://blog.payara.fish/creating-rest-web-services-with-spring-boot-hosted-on-payara-micro" ADD_DATE="0">payara运行springboot应用</A>            <DT><A HREF="https://www.jianshu.com/p/a454ab6a7fd9" ADD_DATE="0">GlassFish 配置/部署 - 简书</A>            <DT><A HREF="https://dubbo.apache.org/zh-cn/blog/dubbo-rest.html" ADD_DATE="0">dubbo-rest</A>            <DT><A HREF="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" ADD_DATE="0">理解OAuth 2.0 - 阮一峰的网络日志</A>            <DT><A HREF="https://payara.gitbooks.io/payara-server/content/documentation/payara-micro/configuring/config-sys-props.html" ADD_DATE="0">Via System Properties · Payara Server</A>            <DT><A HREF="http://www.jasypt.org/encrypting-configuration.html" ADD_DATE="0">Jasypt: Java simplified encryption - Jasypt: Java simplified encryption - Encrypting application configuration files</A>            <DT><A HREF="https://gitee.com/makejava/EasyCode/wikis/pages?sort_id=725170&doc_id=166248" ADD_DATE="0">文档预览 - 码云 Gitee.com</A>            <DT><A HREF="https://my.oschina.net/u/220184/blog/1588457/" ADD_DATE="0">JAVA图片相似度判断(2)感知哈希算法 - fhp0917的个人空间 - OSCHINA</A>            <DT><A HREF="https://blog.csdn.net/gui951753/article/details/81543545" ADD_DATE="0">为什么k8s天然适合微服务？ - 小小呆的博客 - CSDN博客</A>            <DT><A HREF="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html" ADD_DATE="0">Java High Level REST Client | Java REST Client [6.7] | Elastic</A>            <DT><A HREF="https://docs.docker.com/compose/compose-file/#reference-and-guidelines" ADD_DATE="0">docker-compose-3</A>            <DT><A HREF="https://www.daocloud.io/mirror#accelerator-doc" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACIUlEQVQ4jW2SzWsTYRDGn3l33+4mu022LW0a24BUi9CTl0oPBUUR9aQH9SB4Efxn/BM86kU8qBQxvfTmqVQ8KIJV0NY0bfqRZDfNfr77jodqbYPDHGYYBmZ+z0Pzi9dwOkj/q1kMDGEO9GwgPiM780U9JEZW+4VGRjn/Z4E0tCQwHyy6zXsjSVWCsHd9eHLJrywHYIiMmQCCMVWb0TZ1LjnN+15/1nJ+pPZWljvCDPLxlZ7zMz247LZulbQtrD0lUjaJEVflxuMx5ZkAOgvO1Mvu7JMWE/rnrM1HY1FNgii4WJCd3FvrCwBGzCIHmGVbVepB6VNk+rns5u73ZHLJt7cyMJOGEWoAggmyo7zVkBSslpqoB9auAgEE08/HV3rutwRA+UNoNzMWZIIgUq7U/eJG0puzeYg4/YuFoE0yQj39vO19jIxQgyAAMKF1o5SMy+prX8QMOqkJT9QDArbvlNkEAAGAFITG9l2v8WAkLwowjlNL2rld/vVwlE0SKf/RgQC7kZLi/nkrmpbxVNFbC0XMnQXHbqaHF2wQFTZTaIBgHp00+r6vXGP/qqsLYvdmaf/KsBHqqCbPPj0gxdVX3Ynl4ITSBCPS1Tdddz02Qk0ZH87ZAKydzOzltWft4S8RKRz9Zh4DAVD6HGtJ7tcknLFYwFlPCo3MCDULHJM4ZT4WIMXTL9pD+yp3ROVdICI9YNhBt4IgIp586wMA4yTio/gNNxT8LLPI27QAAAAASUVORK5CYII=">DaoCloud – 企业级云计算领域的创新领导者</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599890521">品牌</H3>        <DL><p>            <DT><A HREF="https://www.apple.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABLElEQVQ4jb2SMUvEQBCF39vcmhSCxWnhHxCt7MXK1sbGwsrmrKyCkFtSRSHJFVcrCGIncidY2Ata+wf8AYKFgoUQJdyOzR0cueimcrqZx/vmDbtEg8qybMnzvA7JyyiKXqc11cDcVko9iMiJ1vqrqrdcAJJHANZIdsIw/KjqtQl6vd5Cv99fHLeP1tqNoiiGaZouzyyoMUcAIgBzJE9JDqy1WwBiAIGI3IhIGMfx+wwgz/NdkgPHVd8kN7vd7lPdCYcOM0geTMwzAJIrDn9RluX99KCawHMAtO/77b8ALw5AazQaHSdJMv8b4M4BAICdIAguagFKqTMAbw0gt7WA8T+vvsQzgM9JQ3JojLmuBQCAMWYAYA/AlbV22xizKiLrJM9FJNda7zdI+I/1A4bxW6WYfmNUAAAAAElFTkSuQmCC">Apple</A>            <DT><A HREF="http://www.meizu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACLUlEQVQ4jW2TP2xNcRzFP+d37+171WjEi0QsjRCjChMRC4uYxFIxMJRZihKpRFRKQ5oYCRNhMVhowoaIiTD2j0oHBqmB9rXPu/d3DPe2Snynk3zP+f7L+YqVcABFRryBDk4iDmK2AiIwQeQZc9zjmr6tcAFVYoHMdR+izi0CWyiAWNUOQAIUTNHiNBf0dFmjFfENHybjMRDUJkcEVDUwxkRnpEAk5whn9QSskjDqTQQ+ktKgTU4kxX/mw9UUIicjJWeOyHbO60tKuUg/XTRYoE3idPO6SHdNbrYtDJ1Z8M+WNTOvhFxtumjQpB+4koKF2J9EYrGETu2xLu2WX38ttLMRAHj/PdfejYkvv7HuvpWSTmJhDoCHA2PUgR5FRO7Quz54fAodvZPy4rN4PiP6bqeMT6EdjWByB0UE9DBGfXkF2wjJrWiiBYUoIthAIVo5tGyQbBOqyxAYYAmYVYIB14TKsqaWQC2UuJ5CTQjjijvLAEspyNivnLCPQPzUdMgSIA2ani/KPmnC9EJ0qwCC7AQBLysfACPeRgcfEJmwgGDLqvKrcDQy8IuCXgY1GcCBi5ogMkydxFGFowzIUTiKCttRBXUSIsMMahIclq1cHmWUh6yljyZtTIIIlZEiomANGfM8YpBjpc0US0L1GCxynEUe0EmGCJgcV7buJGOJ+zQ5sVqzbNa/Y8zngCESugEo+IEZ5oxu/kv9T4Hqua55Fx1cLd+IIQb1biW3Kn4D5pQDc/G3nv4AAAAASUVORK5CYII=">魅族</A>            <DT><A HREF="http://www.mi.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABXklEQVQ4jbWSPU9UURCGnznn3LssJrgFjSIUJlqQWNrZIx0JDbG3o9uSDn8D4RfQYKj4ESbUUBiN0SyFjSQksHs/zsxQ3Mvaiglv/T4z73xINeZBCg+z/weQem55PXgQLOPBA4Bmvf7am4YroXzKze9Gr6jG2OF7m91aVlNTVTUzy9ZM8/cvuv+qGmNnR1bV+WCrGpMATwsyGPqfCRen4sGpKJb0zWZ4+VY2PnG8Q1rwspB4H0ldE8jlWXO6O89anm/7x8++vNbFE8znQ0cXx/AIlB+Oy71f6fm75tsJgpgCCE5Acw+YqHhAFPDRC0aroXgCgPVrdARc5h0suNB1kFyDGQ5Iz4AEx9x9fgcRB4mAhuhdqU4xAQ4QoqT7O+SMtp5vgdhWWCvaAOSWegZIW7tl2haQ7pfSaF1m07b+WQ5WtFiK15Mm3hSLr6WeNTqJ8VkcDJvpj7/Av+vxn+8OPlupUCWeRe8AAAAASUVORK5CYII=">小米</A>            <DT><A HREF="http://miui.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAClElEQVQ4jS2Tv4tcdRxFz/3+eG9md91sjLiikIBaiFEsAoJISluLiFpHxcYilRZqkUIIsYql/0JWWAtBo6CtyKqVEIImaEAzatg1md2dmffe51rMdrc999yrrau+5gDAOZHDTKYHvHX+vGZXdnwyJd538PKwYDMV9lLh29mcS++9oJ8uXnTS55/ZBhzQNDDv+Pvcqzzyyfc8WyrbJB5fzAkFRqQ6Qimz23W8eeGMtrV91QuMbKJWsoObN49zNq3zhc0zDu4DY6CESA6iFEapMB3Mi6WIjACgFjIdB3WNVyw2Eb+FWLVZGGqCxokaPVNl1uj5sNS85LdRSUCh5sJpZ/7yQFgsZKqghmkCGhI1OgJxtuQEgASRBco0RXRDYmLIybSGxqZR0EhUTGOoNk2pCSQcRk0GBvqU+Z3MSogsMw7T2owQrZa5Go8alJYIRhYuy+wU/FgKD/YDwqwkaGVGfTAG2jp4tes5diodHpaawEAYsoDCaLjNz+lpNos5GbBrsyIzzol2NB82WOAxQ/+875JKPqq34JqgFvTcHWb3j/FlKdwohd1x5d95w+22i3/Sfr/7QD/fe6mbrG3ELJeSwAaztCDw/nHKOw9r+umOvzpxgif+NOunJ/+d2bg329zI3anHdPBUW+ndjG+VFhBg4QLYaL6PAd6+vBXaeu26r/3yhkt7CeaNAlHyXadyR1hltPwBMhwp9ZOryLYkDcPX1y9QyhV1iwFpTkoHpNRJCGWXNrAStnENIgwPrRGS7G9uvEvJHzM7XCAChG3JBggiXNYz2SxNtBXmc1omyN/9+hHj1Q+4twc5NwgIx9HqF0gtUlOq2MGAcIJczK3h0T9ez6mcY3/6AzkLS8iBAsI90pTwHorJ/wC0R9ttUavRAAAAAElFTkSuQmCC">MIUI</A>            <DT><A HREF="https://www.microsoft.com/zh-cn/" ADD_DATE="1599890466" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQklEQVQ4jWP87if3nwEH4Nz0iLF+FwNO+UY3BkYmXJLEglEDqGAAxYCRYcl7nPHMECPI+H8n7nTA6D6aDgaHARQDAKgRDRsLiHU6AAAAAElFTkSuQmCC">Microsoft</A>            <DT><A HREF="https://www.huawei.com/cn/" ADD_DATE="1599890506" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC60lEQVQ4jZ2STWtcVRiAn/ecc+/M3GS+mklTdBGrJRXTqmCL1JWFulAsooLaLiz42bpS6w8Qij9AXVaRurGoCKJBuysS2tJFioJgSkMkqU36Mc3MJHe+7j3ndZHUH+Czf57VI2yhYAC9BvHYtu2fRk82Xlqv6/76U8/hauXLPir8sDz72/u7Pv9lCIhAgE0JAIEgoGVG3ykp7xarpfHIjhzIRwoH3Fhje6FeP37/num3BfSe/F/gTxi9RfX0IhQ95uF84L3vDdWJfcS0m9PcXlFW/wlZ2tm9+DTFtcN7vvirQRnAAVSovDGOfQuqdxS9SM+/l62kGhfNfW5lRfJ2CzHGkKaXqjse+7h2Y/Bm1q79Aa3P3FblmRYhi5EPPeFEX3W+Or8x1c99HbEUR0q0fZh33fVCdHPwwfqVVhZlHAI2AxlhpoJ5PgUEexz0Z9fOT/rfO8a3vSSVSFTyn4a3sxM0s7jWDayhMwDmPPZMi2ypSzgV0GEVs18R10IXjVcxCxvm7pW1xTC37mrLg33S9cMUPRWj19eofS3fwcJDFB4cxX1VwVwt4w730SmBswUkDiAZ2hfkSAHm+4SZHNldQo71CNfkNLw+AWf2kpBj0wTOlrBRRmgOCT8CFHEvxNAIkAXktW1I0sTTR48JwJfwygOYZxsUJ3bgnEcXB2Tf7KR/HuBvRg9WkFdj3M4umiXorSb+10k2vnWAJDB7k/Byk67tYF2ZOLHIwr1ZUvIFixsdkrshhA4hWSWdBcQA9OFugIsWKnfwl1J6J/fSW94aTabpL3XQj1LC5QG+3iO/MAHNzYH/PwZAJhv1o4O8d6Fkkn1B8zRSs+qhnEnWslFxl/q8Q86aK7hJyYeriJ0yYqYH6s+paMMZMUeKheQQQW+grpUTukF41BJVBZ5AzPcSy1FVHfESXUVoW0Oj1W/P1eL6J7aWJI8H1XNIyIyKYM2LYJZFpExgRWFghDEfdM5YgoYwJ2IPFky8JML4v2YmVY+h5RqmAAAAAElFTkSuQmCC">华为</A>            <DT><A HREF="https://www.dji.com/cn" ADD_DATE="1599890521" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABo0lEQVQ4jaVTMYuTURCcmfdxl/iBiY9oo40oqKWNYHUgwomNhXB2WtwfEP+Bllpo7Q8QCwWbQwsLG0WxOUE4sLKwMBYxJoKQ73s7NinCEQLHTfNgd4fZ3TcLHBI8QN6HFVsJLVPu9/u3B4PBTs75GYBjq4ixL24AlHSH5HWSZwD8ntdzgcsKAHLOd0leA9CzfURStG17H8DpiAjbOznnhyQ3IuIFyYbkFoCher3eVZKPAWzaNoBXtp9LygBOAWgi4juAbUmXbK+TvCXpsu21StJN20Gyadv23mQy+Tjv6pGkyvYuyQ7JXillDOCH7fMRUQC8lKQr85n/zGazIYC62+2eBLAJgBHxieQ5SQLwVdKA5FHbf5um+VDZPk4yAThR1/Xnuq4bAJ35Pn5GxNuU0gPbJrkL4KIkRcTedDr9VtneIHnWtmyvpZRQSqHtZHuYUtoCcME227Z9J+lXKeWN7T0AsdSJOecnJLcBdEhWtmH79Wg0ugGgWayt5v+6aCSRXAfwHsC/UsrE9pfxePx0Tk4LXtnvn4Nj1TFx4SWAcmi1ZfgPrYzAHh2fJoYAAAAASUVORK5CYII=">DJI</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599888878">其他</H3>        <DL><p>            <DT><A HREF="https://map.baidu.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC5UlEQVQ4jW2ST4hVZRjGf+93zj1zrjr33hxxBqZoZBwsw2a0yBwpNxFYhiIRLlpFm3ZRW1chtApaFNXQLlwIrdoLZUaKYokjNjmKA1rMXGfuveP9d875vvdtcW+ufODd/XheeJ5HANbW1l6v1GqnHezGOSUEAaAUgwHeA0AkZooz1dutVvez8fHtv1Gv149475v2JBXF4J4g7/3G6ur6vPR6vQtpmr4G5KjGwTknKytafPGl6I1FMEP2z5F88rHxzNPOqao55wWSLMvOSz/P60kcj2EGItiDf8hOvS8s3zFJRyAZwR5twsyMpOfOGhPjoIpEkRVFcc9hFouICJiJSPHtgrB402TqWdy7J0UFkYkJbGnJioXvsSELOEBjbJCPOYeYmV25CvtnJfrwAyinuI0GFIXI5CTh90uUwFREHGAgDhAAs6F3XojMzUJSwup13MsHcIfnkdFtOHEmgIgM3/K/EUgIKIg7dpRw7kfs1hJ2+Sr660Vot9FrfyBvviEK8rhmMLIsb6iqaQiqqhqaTeu+fcLa1R3WnX7eutPPWacyZr3jJy1sbtoACmqmlnu/7FR14DaIEapVku++wr10AIsizEXIwVcoffM1jI7yuC0DDUHoZ3ljuA01M9XhcPyf162zZ5919s6aX7w5AHxhZqpD1rI8X46zfh9f5AAWRZE4EcvbbdzsiyLzByFJyF7YizZblmwpYz6YLzxR7ETViDV4H0clxUViBr08Q0KQvg92ff4tNI6ZC5CEvvT6ZkkpEYkAi9UXuZOH7e7PurV8ZLXlc4wYjF21krvR9vrXpif1PfZVRthTa8vfrV9MxGHgxytTiXQmzsuFlY3DtbHKT3Ecbe92PburMXL/X64s3kPSMneemqIThHemq+ys3ubuo4uUt6T43K83mu1jAnD5/vqhtLLt9A5n0zu3luh9+rmNLPzAw8kZjr93lrt+lI8O5Zw5mrgHxTVr+FvLnfXSmVd3nbr0H6LY3iBW6JJtAAAAAElFTkSuQmCC">百度地图</A>        </DL><p>        <DT><H3 ADD_DATE="1599885150" LAST_MODIFIED="1599888890">个人</H3>        <DL><p>            <DT><A HREF="https://cenzhongman.github.io/" ADD_DATE="1599888878" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACcklEQVQ4jVWSTWsaURSGzzleR21mVKwOJkQDVZPUNgsh8ScU0qW/IJv+oPyGUNpFNyUENzGbQkFcJIxQTTRWS4k1qK2T0WE+7r1dTD/Iu34PB97nQc45IgECAnie5/s+ABALKywkpQREhEdhiOisrB/GZfb5C4vD6OuACx7PFUvZFIJE+N8PbhkCuq7z8ezda+1N8WUlEmYhxogxKQQRCSGISEqJiFJKAAAhhM/90fj70l7Kx3FdV0rJOeecCyGEEJxzBgjz2c8Pb99TKERE7XZ7a2vL9zki6LpeLpdns1mv1yOio6OjdDpNIMFz3f7tbbfb9TwvmUymUikAORwOpZQXFxeTyaTf7w8GA845IpKUMpVK7ezsaJqm63qtVlsul91Op1godLvX6+vro9GoWq1ub2/btv1nJdM0J5NJpVKZzWaNRqNYKDxNZ9bW1jRNOzk52d/fPz8/L5VKiURCSskQMRwO393d5fP56XSa29x8dXjojb/FotHer+L1zc1wOKzVaqZpOo4DACyY7ODgoNPp6Lrueq65MA2jFY0oU1tJJBPlcvnq6kpV1VgsBgAEALZtz+fz3d3d6XRqWcuz09P6p8vP7eGTqBJRIq1Wy/f9dDodcKCAXzKZZIzlcjlVVbW49iyfv/nS4UI4jpPNZhVFub+/VxRFSkkBu2azWa/XM5nMeDw+Pj72OdfiWqPRsG3bMAwAyOfzrusCAAohLMtqNpsAsLe3ZxgGY2xjY8OyrMVisVqtotGoqqoPDw/VajUejyPnnIgCvXzfZ4wBQKCDoijB/38FIQQKIaSU4m8CbYjI87xwOBy4FIvFiIiIEPE3vDRwiDVVyqsAAAAASUVORK5CYII=">岑忠满的随笔</A>            <DT><A HREF="http://www.cnblogs.com/cenzhongman/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACh0lEQVQ4jX2TT2hUVxTGf+fe95LMmLwBI7UxKqWKtmkXSR6TPKOjiBtX1q2CqKhUcZ3SRXddS8GVi7ZQiigtzbr1H4jBSRhHAkEXMhv1hU7EJtFJHJ3Mu8eFbyTa6Le899zv/r5zOMJHVIiGTovYY4BR1Uu3JiZ+er/GrvLOAFqIou/Emu/V6XngjjFmdFNv77pHcXwDkFaxrGJAX19fZ3cu94Bm89CtUukmQD7f35+xHVeXa7XtxXv35lb+9j/lcrkcAv8tLZVTSlsqTU2r8IIg+OJ9XBuGob/ysFgsVkW1ujYIfgASINk9PDwKqHXuxPDWrUGr1gvDsLPD9/cBYytiJc7pKWvNX4WRaKcgTp1uEHWXjeedle7uc1Qq9wEx5XL5mYU9I/l8/0qK8cnJ8lxtcQDhN9T98WR+ftCJ2eZ5XqdC2ErgATh4YjzvDPBtSqCATE9PzwM/AxSGhg6KyDfOuUSMjAC/A2oAXJJcEfRAGIbr3vhBauIBRNHgl8azF6wxRlWtqubT/jkDcLtUuouoZn3/SHrRlpo0C2E02Gbar3u+t345af7qXFKy1n5VGBjobk3BAAlO/gZOpwSNfD7/6a4o+tG2mxsiMld/2Tg0Xpw8kaj7xYjpcG1tW2ghpn340/fs8cKOoVEV0y7wtaosJXCytvTi2tTU1AIgSb3xT5K1iRj9HJiwaVY2wox0de0VMUdRdgLtItRwurbD97f0bt6gjx/PxHG1urB5U+9+g1QfxjPjbwmKcVwnjveEYbimq15PapmMzTQaRoOgOTs726hUKq/SuKrKReCzdyK0mlYul5/xYTmA+sLzsUwQHAZktW0UPrBkLf379OniJz09c9lstvYaxI/3vPRLsl0AAAAASUVORK5CYII=">博客园</A>            <DT><A HREF="https://www.v2ex.com/" ADD_DATE="0" ICON="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACaklEQVQ4jW1TwUrkWhSsOrlJuuMwgrgUe6F/JCjoQobZuXoPXPUb3DgueuUXDAwu3fY/+BNC025aEEU6po1Jbm69hZ3AwJzduVB1zqmqy+l0mkn6mabptxDCVwAkCQCQRHw+aN0DgEgu67r+TfKHk3S1v7//z+7ubnDOfSLXtQaAJEh2Pdu23Xx4ePj3/v6ezjn3fTQahSzLLIQgM/uDZF303iOKIklCmqY2Go3CfD7/7kh+MTN470US7+/vKsuym9ifsLW1xaZpus1kZiT5xQFQCIFrMI6OjjibzTAcDhFCAEmUZcnT01OMx2NWVSVJCCEAgBwAa9sWALBarTCbzZTnOcuy7AmSJMH19TWKotDl5SW991hj6AAIANq2BUns7OxwuVwijuOe4OnpCdvb27i5uWFZlppMJnDOQRJcCIGSUNc1BoMBbm9ve+VDCEiSBHd3d7i6usLGxgam0ynrusZkMvkk6Oxp2xZt26Ku6z9slIQoinpNsixDkiS9xY6kJMHMsFqtcH5+zjzP4ZzriZ6fn5GmKaqqwsHBgcbjMT4+PkDy84QQAiShaRoURaGyLBlFUU+wubmJoihwfHyss7Mz5nmOLq2OZFinC2maYm9vj4+Pj4rjmN1mVVXh8PBQJycnfH19lZkhjuOegADQNA2iKMLFxYXquqaZqQuSmSnLMr68vKjbqnPIJBWSNBwOQwihU15RFNE5B+cczIxvb28yM5DEYDAI6wAW5r3/tVgszHvPNE1lZp2N/TSSStMUcRwjSRJ577lYLKxt21+O5H/z+VyLxeKbpK/rYP3tQ6ELHcml9/43yR//A+mpeW75B7QKAAAAAElFTkSuQmCC">V2EX</A>        </DL><p>    </DL><p></DL><p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-10分钟读懂Oauth2</title>
    <link href="/01-Java/06-Security/02-Oauth2/01-10%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82Oauth2/"/>
    <url>/01-Java/06-Security/02-Oauth2/01-10%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82Oauth2/</url>
    
    <content type="html"><![CDATA[<h1 id="10分钟读懂Oauth2"><a href="#10分钟读懂Oauth2" class="headerlink" title="10分钟读懂Oauth2"></a>10分钟读懂Oauth2</h1><h2 id="一、OAuth2是什么"><a href="#一、OAuth2是什么" class="headerlink" title="一、OAuth2是什么"></a>一、OAuth2是什么</h2><p>OAuth 是一个给自己或第三方应用登录的统一权限验证标准，OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，授权服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p><h3 id="1-OAuth2定义的角色"><a href="#1-OAuth2定义的角色" class="headerlink" title="1. OAuth2定义的角色"></a>1. OAuth2定义的角色</h3><ul><li>Third-party application：第三方应用程序，目的是去获取<code>Resource server</code>中的资源</li><li>Resource server：存放用户资源的服务器，一般来说<code>Resource Owner</code>在网站上的数据，如个人信息，订单数据等</li><li>Authorization server：鉴权服务器，检查token和发出token的服务</li><li>Resource Owner：数据资源的拥有者，用户个人</li><li>User Agent：登录的工具，如浏览器，Postman等</li></ul><h3 id="2-OAuth2支持四种模式进行鉴权"><a href="#2-OAuth2支持四种模式进行鉴权" class="headerlink" title="2. OAuth2支持四种模式进行鉴权"></a>2. OAuth2支持四种模式进行鉴权</h3><ul><li>授权码（authorization-code）：最常用，最复杂，最安全的方式，授权第三方应用通过申请授权码，再通过授权码申请Token使用部分资源，<strong>第三方应用始终没有得到用户的账号密码，</strong>常见如微信、Google、Github登录等</li><li>隐藏式（implicit）：对于无后端应用，隐藏了申请授权码的过程，直接给Token，常用于没有后端的应用</li><li>密码式（password）：账号密码，直接登录，此模式为自己登录时使用，比如<strong>支付宝和淘宝</strong>都是自己用密码登录</li><li>客户端凭证（client credentials）：给一个Client端使用，就像申请API一样，不是给用户使用，而是针对一个Client端，这种模式不存在用户登录，作为<strong>微服务之间</strong>和<strong>API开放</strong>之间</li></ul><h2 id="二、Token发放方式"><a href="#二、Token发放方式" class="headerlink" title="二、Token发放方式"></a>二、Token发放方式</h2><h3 id="1-授权式（最常用）"><a href="#1-授权式（最常用）" class="headerlink" title="1. 授权式（最常用）"></a>1. 授权式（最常用）</h3><ul><li>以用户使用第三方应用时，使用GitHub作为第三方登录为例子说明。</li></ul><p><img src="../images/%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F.drawio.png"></p><ol><li><p>用户通过点击登录链接，如Github登录，跳转到Github登录页面，授权用户信息给当前网站使用</p> <pre><code class="hljs sh">https://github.com/oauth/authorize?  response_type=code&amp;  client_id=bfe378e98cde9624c98c&amp;  redirect_uri=https://www.iconfont.cn/api/login/github/callback&amp;   scope=reader</code></pre><p> 上面 URL 中，<code>response_type</code>参数表示要求返回授权码（code），<code>client_id</code>参数让<strong>Github</strong>知道是谁在请求，<code>redirect_uri</code>参数是<strong>Github</strong>接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）</p></li><li><p>Github直接跳转到</p> <pre><code class="hljs sh">https://www.iconfont.cn/api/login/github/callback?code=AUTHORIZATION_CODE</code></pre></li><li><p>后端根据CALLBACK_URL中的code参数得到授权码，并存储在服务器，以便下次请求直接使用</p></li><li><p>在后端，通过授权码申请Token</p> <pre><code class="hljs sh">https://b.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</code></pre><p> 上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让<strong>Github</strong>确认<strong>iconfont</strong>的身份（client_secret参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，r<code>edirect_uri</code>参数是令牌颁发后的回调网址。</p></li><li><p>授权服务器返回Token到CALLBACK_URL 这次是Post Json数据</p><p> POST CALLBACK_URL</p> <pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,    <span class="hljs-attr">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,    <span class="hljs-attr">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,    <span class="hljs-attr">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,    &quot;info&quot;:&#123;...&#125;&#125;</code></pre></li></ol><h4 id="a-授权式参考RFC-6749标准"><a href="#a-授权式参考RFC-6749标准" class="headerlink" title="a. 授权式参考RFC 6749标准"></a>a. 授权式参考RFC 6749标准</h4><p><img src="../images/15209061-98feec3dbfd354bf.png"></p><p>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。  </p><h3 id="2-隐藏式（最不常用）"><a href="#2-隐藏式（最不常用）" class="headerlink" title="2. 隐藏式（最不常用）"></a>2. 隐藏式（最不常用）</h3><p><img src="../images/2019-08-18-23-39-07.png"></p><ol><li><p>直接向Github申请Token</p> <pre><code class="hljs sh">https://b.com/oauth/authorize?  response_type=token&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=<span class="hljs-built_in">read</span></code></pre></li><li><p>Github直接跳转到</p><pre><code class="hljs sh">   https://www.iconfont.cn/api/login/github/callback<span class="hljs-comment">#token=ACCESS_TOKEN ```</span>        值得注意的是，token使用的是`<span class="hljs-comment">#`，而不是`?`，因为跳转页面通过HTTP协议传输，可能存在中间人攻击风险，而锚点不会发送到服务器，因此通过锚点的方式有利于保护Token不被泄漏</span><span class="hljs-comment">### 3. 密码式（信任的应用）</span>![](../images/2019-08-18-23-48-27.png)1. 直接在GitHub自己的页面中登录GitHub    ```sh    https://oauth.b.com/token?      grant_type=password&amp;      username=USERNAME&amp;      password=PASSWORD&amp;      client_id=CLIENT_ID&amp;      client_secret=secret</code></pre><p> 你应该注意到这个请求中没有CALLBACK_URL，没有回调</p></li><li><p>GitHub直接将JSON作为响应返回</p> <pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,    <span class="hljs-attr">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,    <span class="hljs-attr">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,    <span class="hljs-attr">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,    &quot;info&quot;:&#123;...&#125;&#125;</code></pre></li></ol><h3 id="4-凭证式-无前端应用模式"><a href="#4-凭证式-无前端应用模式" class="headerlink" title="4. 凭证式(无前端应用模式)"></a>4. 凭证式(无前端应用模式)</h3><ol><li><p>（后端）直接请求URL</p> <pre><code class="hljs sh">https://oauth.b.com/token?  grant_type=client_credentials&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET</code></pre><p> 上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让<strong>Github</strong>确认<strong>iconfont</strong>的身份</p></li><li><p>响应JSON</p> <pre><code class="hljs json">&#123;        <span class="hljs-attr">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;token_type&quot;</span>:<span class="hljs-string">&quot;bearer&quot;</span>,    <span class="hljs-attr">&quot;expires_in&quot;</span>:<span class="hljs-number">2592000</span>,    <span class="hljs-attr">&quot;refresh_token&quot;</span>:<span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span>,    <span class="hljs-attr">&quot;scope&quot;</span>:<span class="hljs-string">&quot;read&quot;</span>,    <span class="hljs-attr">&quot;uid&quot;</span>:<span class="hljs-number">100101</span>,    &quot;info&quot;:&#123;...&#125;&#125;</code></pre></li></ol><h2 id="三、使用Token"><a href="#三、使用Token" class="headerlink" title="三、使用Token"></a>三、使用Token</h2><ol><li><p>在请求的头信息，加上一个Authorization字段</p> <pre><code class="hljs sh">curl -H <span class="hljs-string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \<span class="hljs-string">&quot;https://api.b.com&quot;</span></code></pre></li></ol><h2 id="四、刷新TOken"><a href="#四、刷新TOken" class="headerlink" title="四、刷新TOken"></a>四、刷新TOken</h2><ol><li><p>向GitHub发起刷新Token请求</p> <pre><code class="hljs sh">https://b.com/oauth/token?  grant_type=refresh_token&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET&amp;  refresh_token=REFRESH_TOKEN</code></pre><p> 上面 URL 中，<code>grant_type</code>参数为refresh_token表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p></li><li><p>Github直接响应新的Token</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">阮一峰的网络日志-OAuth 2.0 的四种方式</a></li><li><a href="https://zhuanlan.zhihu.com/p/30720675">知乎-OAuth 2 详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>02-Oauth2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-Mysql语句速查</title>
    <link href="/03-Database/01-MySQL/00-Mysql%E8%AF%AD%E5%8F%A5%E9%80%9F%E6%9F%A5/"/>
    <url>/03-Database/01-MySQL/00-Mysql%E8%AF%AD%E5%8F%A5%E9%80%9F%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql语句速查"><a href="#Mysql语句速查" class="headerlink" title="Mysql语句速查"></a>Mysql语句速查</h1><p>database_name 数据库名<br>table_name 表名<br>host_name 主机名<br>user_name 用户名<br>cloumn_name 字段名<br>‘value’ 值</p><h2 id="mysql-连接"><a href="#mysql-连接" class="headerlink" title="mysql 连接"></a>mysql 连接</h2><pre><code class="hljs sh">mysql-u 用户名-p 密码-h 主机名-P 端口</code></pre><p>经典范例</p><pre><code class="hljs sh">mysql -uuser_name -hhost_name -P3306 -p</code></pre><h2 id="USE-使用"><a href="#USE-使用" class="headerlink" title="USE 使用"></a>USE 使用</h2><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> database_name;</code></pre><h2 id="SHOW-显示"><a href="#SHOW-显示" class="headerlink" title="SHOW 显示"></a>SHOW 显示</h2><pre><code class="hljs sql"><span class="hljs-comment"># 显示所有数据库</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">DATABASES</span>;<span class="hljs-comment"># 显示当前数据库的所有表</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLES</span>;<span class="hljs-comment"># 显示当前表的属性</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLUMNS</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 显示创建数据表的属性</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name;<span class="hljs-comment"># 显示支持的字符集</span><span class="hljs-keyword">SHOW</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span>;<span class="hljs-keyword">SHOW</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;utf8&#x27;</span>;<span class="hljs-comment"># 显示支持的校对序列</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span>;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLLATION</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;utf8&#x27;</span>;<span class="hljs-comment"># </span><span class="hljs-comment"># 显示服务器状态</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">STATUS</span>;<span class="hljs-comment"># 显示用户安全权限</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span>;<span class="hljs-comment"># 显示服务器错误</span><span class="hljs-keyword">SHOW</span> ERRPRS;<span class="hljs-comment"># 显示服务器警告以上级别日志</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">WARNINGS</span>;</code></pre><h2 id="SELECT-检索"><a href="#SELECT-检索" class="headerlink" title="SELECT 检索"></a>SELECT 检索</h2><pre><code class="hljs sql"><span class="hljs-comment"># 检索单列</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 检索多列</span><span class="hljs-keyword">SELECT</span> cloumn_name_1,cloumn_name_2 <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 检索所有列</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name;</code></pre><h3 id="DISTINCT-不同"><a href="#DISTINCT-不同" class="headerlink" title="DISTINCT 不同"></a>DISTINCT 不同</h3><pre><code class="hljs sql"><span class="hljs-comment"># 检索不同的行</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 检索多个不同的行（对cloumn_name_1和cloumn_name_2同时生效）</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cloumn_name_1,cloumn_name_2 <span class="hljs-keyword">FROM</span> table_name;</code></pre><h3 id="LIMIT-限制"><a href="#LIMIT-限制" class="headerlink" title="LIMIT 限制"></a>LIMIT 限制</h3><pre><code class="hljs sql"><span class="hljs-comment"># 限制输出前 n 行</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">LIMIT</span> n;<span class="hljs-comment"># 限制输出从 n 开始的 m 行, 如下将输出 m 行 -- 方式1</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">LIMIT</span> n,m;<span class="hljs-comment"># 限制输出从 n 开始的 m 行, 如下将输出 m 行 -- 方式2</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">LIMIT</span> m <span class="hljs-keyword">OFFSET</span> n;</code></pre><h3 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h3><pre><code class="hljs sql"><span class="hljs-comment"># 升序 - 从小到大排序(数字、字符串、时间都支持)</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cloumn_name;<span class="hljs-comment"># 降序 - 从大到小排序(数字、字符串、时间都支持)</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cloumn_name <span class="hljs-keyword">DESC</span>;<span class="hljs-comment"># 多列排序，只有当第一个相同的时候，根据第二列排序</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cloumn_name_1,cloumn_name_2;</code></pre><h3 id="WHERE-过滤"><a href="#WHERE-过滤" class="headerlink" title="WHERE 过滤"></a>WHERE 过滤</h3><pre><code class="hljs sql"><span class="hljs-comment"># 条件过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span>;<span class="hljs-comment"># 两值之间过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;value_2&#x27;</span>;<span class="hljs-comment"># 不在两值之间过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;value_2&#x27;</span>;<span class="hljs-comment"># 空值过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment"># AND操作</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">AND</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_2&#x27;</span>;<span class="hljs-comment"># OR操作</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">OR</span> cloumn_name_2 = <span class="hljs-string">&#x27;value_2&#x27;</span>;<span class="hljs-comment"># AND 和 OR 联合操作，数据库会优先 AND 操作，会导致计算错误</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">OR</span> cloumn_name_2 = <span class="hljs-string">&#x27;value_2&#x27;</span> <span class="hljs-keyword">AND</span> cloumn_name3 = <span class="hljs-string">&#x27;value3&#x27;</span>;<span class="hljs-comment"># AND 和 OR 联合操作 使用括号</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> (cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span> <span class="hljs-keyword">OR</span> cloumn_name_2 = <span class="hljs-string">&#x27;value_2&#x27;</span>) <span class="hljs-keyword">AND</span> cloumn_name3 = <span class="hljs-string">&#x27;value3&#x27;</span>;</code></pre><h3 id="IN-包含"><a href="#IN-包含" class="headerlink" title="IN 包含"></a>IN 包含</h3><pre><code class="hljs sql"><span class="hljs-comment"># 包含过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;value_1&#x27;</span>,<span class="hljs-string">&#x27;value_2&#x27;</span>);<span class="hljs-comment"># 不包含过滤</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;value_1&#x27;</span>,<span class="hljs-string">&#x27;value_2&#x27;</span>);</code></pre><table><thead><tr><th>操作符</th><th>功能</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN…AND…</td><td>在两个值之间</td></tr><tr><td>NOT BETWEEN…AND…</td><td>不在两个值之间</td></tr><tr><td>IN</td><td>含于</td></tr><tr><td>NOT IN</td><td>不含于</td></tr></tbody></table><h3 id="LIKE-通配符"><a href="#LIKE-通配符" class="headerlink" title="LIKE 通配符"></a>LIKE 通配符</h3><pre><code class="hljs sql"><span class="hljs-comment"># 通配符 % == .* 任意字符0-n个</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;value%&#x27;</span>;<span class="hljs-comment"># 通配符 _ == . 任意字符1个</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;value_&#x27;</span>;</code></pre><h3 id="REGEXP-正则"><a href="#REGEXP-正则" class="headerlink" title="REGEXP 正则"></a>REGEXP 正则</h3><ul><li>注意：这里的正则的意思是，一旦匹配中直接返回整个字段</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 使用正则匹配</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name REGEXP <span class="hljs-string">&#x27;.000&#x27;</span>;<span class="hljs-comment"># 支持的正则列表如下:仅供参考</span>.000.+.*.?[a-z]1231000|2000[1|2|3][\w\d]a&#123;1,2&#125;^a[^\d$]<span class="hljs-comment"># 特殊字符转义</span>\\.\\f\\n\\t\\v\\(</code></pre><ul><li>LIKE和正则的区别：若LIKE 100，100这个值在列中不会返回(这不是LIKE是=)，而正则会返回</li></ul><h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><pre><code class="hljs sql"><span class="hljs-comment"># 字符串拼合查询结果</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Concat</span>(cloumn_name,<span class="hljs-string">&#x27;(&#x27;</span>,cloumn_name,<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 字符串拼合查询结果并赋予别名，这个别名将作为新的一列的列名返回给查询的终端</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Concat</span>(cloumn_name,<span class="hljs-string">&#x27;(&#x27;</span>,cloumn_name,<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">AS</span> new_cloumn_name <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 运算拼合查询结果(支持：+-*/)</span><span class="hljs-keyword">SELECT</span> cloumn_name_2 * cloumn_name3 <span class="hljs-keyword">AS</span> new_cloumn_name <span class="hljs-keyword">FROM</span> table_name;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>函数都可以使用别名返回</li></ul><h4 id="计算函数"><a href="#计算函数" class="headerlink" title="计算函数"></a>计算函数</h4><pre><code class="hljs sql"><span class="hljs-comment"># Length计算字段长度</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Length</span>(cloumn_name) <span class="hljs-keyword">AS</span> cloumn_length <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Locate返回1字符串在2字符串的Index</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Locate</span>(cloumn_name_1,cloumn_name_2) <span class="hljs-keyword">AS</span> index_cloumn1_of_cloumn2 <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Left截取字符串左侧一定长度</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Left</span>(cloumn_name,<span class="hljs-number">5</span>) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Right截取字符串右侧一定长度</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Right</span>(cloumn_name,<span class="hljs-number">5</span>) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># LTrim删除右侧空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LTrim</span>(cloumn_name) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># RTrim删除右侧空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RTrim</span>(cloumn_name) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Lower小写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Lower</span>(cloumn_name) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Upper大写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Upper</span>(cloumn_name) <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># Soundex返回谐音，读音相同匹配</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Soundex</span>(Lie) = <span class="hljs-keyword">Soundex</span>(Lee);</code></pre><h4 id="时间日期函数"><a href="#时间日期函数" class="headerlink" title="时间日期函数"></a>时间日期函数</h4><pre><code class="hljs sql"><span class="hljs-comment"># AddDate -- 方式1</span><span class="hljs-keyword">SELECT</span> ADDDATE(<span class="hljs-string">&#x27;1998-01-02&#x27;</span>, <span class="hljs-built_in">INTERVAL</span> <span class="hljs-number">31</span> <span class="hljs-keyword">DAY</span>);<span class="hljs-comment"># AddDate -- 方式2 只有数字时认为是天</span><span class="hljs-keyword">SELECT</span> ADDDATE(<span class="hljs-string">&#x27;1998-01-02&#x27;</span>, <span class="hljs-number">31</span>);</code></pre><table><thead><tr><th>函数</th><th>说明</th><th>简单演示</th></tr></thead><tbody><tr><td>AddDate(),DATE_ADD()</td><td>增加一个日期</td><td>ADDDATE(‘1998-01-02’, INTERVAL 31 DAY)</td></tr><tr><td>AddTime()</td><td>增加一个时间</td><td>Addtime(‘1999-12-31 23:59:59’,’10:10:10’);</td></tr><tr><td>CurDate()</td><td>当前日期</td><td>CurDate() &gt; 2018-10-10</td></tr><tr><td>CurTime()</td><td>当前时间</td><td>CurTime() &gt; 12:12:12</td></tr><tr><td>DateDiff()</td><td>日期之差的天数</td><td>DateDiff(‘2018-10-12’,’2010-08-08’) &gt; 2987</td></tr><tr><td>Date_Formart()</td><td>日期格式化</td><td>不可用</td></tr><tr><td>Now()</td><td>当前日期时间</td><td>Now() &gt; 2018-10-12 12:12:23</td></tr><tr><td>Date()</td><td>获得日期部分</td><td>Date(‘2018-10-12 12:12:23’) &gt; 2018-10-12</td></tr><tr><td>Time()</td><td>获得时间部分</td><td>Time(‘2018-10-12 12:12:23’) &gt; 12:12:23</td></tr><tr><td>Year()</td><td>获得年的部分</td><td></td></tr><tr><td>Month()</td><td>获得月部分</td><td></td></tr><tr><td>Day()</td><td>获得天的部分</td><td></td></tr><tr><td>DayOfWeek()</td><td>获得星期几</td><td>DayOfWeek(‘2018-12-25’) &gt; 3</td></tr><tr><td>Hour()</td><td>获得时间部分</td><td></td></tr><tr><td>Minute()</td><td>获得分钟部分</td><td></td></tr><tr><td>Second()</td><td>获得秒的部分</td><td></td></tr></tbody></table><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><table><thead><tr><th>函数</th><th>说明</th><th>简单演示</th></tr></thead><tbody><tr><td>AVG()</td><td>平均值</td><td>AVG(cloumn_name)</td></tr><tr><td>COUNT()</td><td>行数</td><td>count(cloumn_name)</td></tr><tr><td>MAX()</td><td>最大值</td><td>MAX(cloumn_name)</td></tr><tr><td>MIN()</td><td>最小值</td><td>MIN(cloumn_name)</td></tr><tr><td>SUM()</td><td>求和</td><td>SUM(cloumn_name)</td></tr></tbody></table><h3 id="Group-By-amp-HAVING"><a href="#Group-By-amp-HAVING" class="headerlink" title="Group By &amp; HAVING"></a>Group By &amp; HAVING</h3><ul><li>Group By用于分组计算，协助函数(如Count() Min() Max()等)的计算</li></ul><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> cloumn_name,<span class="hljs-keyword">Count</span>(cloumn_name)<span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cloumn_name;</code></pre><ul><li>分组过滤：有时候我们需要对分组后的结果进行过滤, <code>WHERE</code>不支持分组，使用<code>Having</code>，<code>Having</code>支持所有<code>Where</code>操作</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cloumn_name,<span class="hljs-keyword">Count</span>(cloumn_name)<span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cloumn_name <span class="hljs-keyword">having</span> <span class="hljs-keyword">Count</span>(cloumn_name) &gt;= <span class="hljs-number">1</span>;</code></pre><h2 id="子查询-–-区别于组合查询"><a href="#子查询-–-区别于组合查询" class="headerlink" title="子查询 – 区别于组合查询"></a>子查询 – 区别于组合查询</h2><ul><li>一般符合查询使用<code>IN</code>也可以使用<code>=</code>和<code>&lt;&gt;</code></li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 使用IN的子查询</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> cloumn_name_1 <span class="hljs-keyword">FROM</span> table_name_1 <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value&#x27;</span>)<span class="hljs-comment"># 用于计算的子查询</span><span class="hljs-keyword">SELECT</span> cloumn_name (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Count</span>(*) <span class="hljs-keyword">FROM</span> table_name_1 <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value&#x27;</span>) <span class="hljs-keyword">AS</span> counts    <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span>;</code></pre><h2 id="JOIN-联结"><a href="#JOIN-联结" class="headerlink" title="JOIN 联结"></a>JOIN 联结</h2><ul><li>联结：联结出现在当有多张表拥有相同的字段(外键)，联结避免出现<a href="https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AF/6323173?fr=aladdin">笛卡尔积</a></li></ul><h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><ul><li>内部联结：等值联结又称为内部联结，条件是两个表拥有相同的字段</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># where联结 -- 使用全限定名保证消歧 -- 方式1</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name_1, table_name_2 <span class="hljs-keyword">WHERE</span> table_name_1.cloumn_name = table_name_2.cloumn_name;<span class="hljs-comment"># INNER Join 内部联结 -- 方式2</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name_1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table_name_2 <span class="hljs-keyword">ON</span> table_name_1.cloumn_name = table_name_2.cloumn_name;<span class="hljs-comment"># 自联结</span><span class="hljs-comment">## 不使用自联结</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> Host = (<span class="hljs-keyword">select</span> Host <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">User</span>=<span class="hljs-string">&#x27;mysql.sys&#x27;</span>);<span class="hljs-comment">## 使用自联结 -- 使用别名而不使用子查询 ，这种思想在同时操作同一张表的时候可以用。</span><span class="hljs-keyword">select</span> u1.Use <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">As</span> u1 ,<span class="hljs-keyword">user</span> <span class="hljs-keyword">as</span> u2 <span class="hljs-keyword">where</span> u1.Host = u2.Host <span class="hljs-keyword">And</span> u2.User = <span class="hljs-string">&#x27;mysql.sys&#x27;</span>;</code></pre><p><code>table_name_1.cloumn_name = table_name_2.cloumn_name</code>和<code>u1.Host = u2.Host</code>就是内部联结的特征。</p><h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><ul><li>外部联结：对没有关联行的行进行联结，如，统计<strong>客户</strong> 和<strong>购买数量</strong>，需要统计一件也没买的客户</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 外联结</span><span class="hljs-comment">## 还没使用外联结 -- 只能查到有的客户</span><span class="hljs-keyword">SELECT</span> cust_id,order_id <span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> orders <span class="hljs-keyword">ON</span> customers.cust_id = orders.cust_id;<span class="hljs-comment">## 使用外联结 -- 包括没买过的客户</span><span class="hljs-keyword">SELECT</span> cust_id,order_id <span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders <span class="hljs-keyword">ON</span> customers.cust_id = orders.cust_id;</code></pre><p>注意到<code>LEFT</code>是外联结的特征，还有<code>RIGHT</code>；<code>LEFT</code>指的是<code>OUTER JOIN</code>左边的表<code>customers</code>。这时候没买过的客户将会返回<code>NULL</code></p><h2 id="AS-别名"><a href="#AS-别名" class="headerlink" title="AS 别名"></a>AS 别名</h2><ul><li>别名有利于减少SQL语句长度</li><li>使用别名表可以在一个SQL语句中进行自联结 – 详看<code>联结&gt;自联结</code></li><li>表别名还可以用于子查询中进行删除的操作，<code>delect</code>不能删除</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 字段别名 -- 在结果中体现</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">AS</span> c <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># 表别名 -- 在结果中不体现</span><span class="hljs-keyword">SELECT</span> cloumn_name <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">WHERE</span> t.id = <span class="hljs-number">0</span>;<span class="hljs-comment"># 表别名用于删除 -- 这里的t就是别名？？</span><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> certificate <span class="hljs-keyword">where</span> <span class="hljs-keyword">url</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">url</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">url</span> <span class="hljs-keyword">FROM</span> bmw.certificate <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">url</span> <span class="hljs-keyword">having</span> <span class="hljs-keyword">count</span>(<span class="hljs-number">1</span>)&gt;<span class="hljs-number">1</span>) t) <span class="hljs-keyword">and</span> create_time &gt;= <span class="hljs-string">&#x27;2018-12-26 03:34:45&#x27;</span></code></pre><h2 id="UNION-组合查询"><a href="#UNION-组合查询" class="headerlink" title="UNION 组合查询"></a>UNION 组合查询</h2><pre><code class="hljs sql"><span class="hljs-comment"># UNION</span><span class="hljs-keyword">SELECT</span> cloumn_name_1, cloumn_name_2, cloumn_name_3 <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> cloumn_name_1, cloumn_name_2, cloumn_name_3 <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_2 = <span class="hljs-string">&#x27;value_2&#x27;</span>;<span class="hljs-comment"># UNION ALL包含相同值 -- 不对相同查询结果进行相加</span><span class="hljs-keyword">SELECT</span> cloumn_name_1, cloumn_name_2, cloumn_name_3 <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_1 = <span class="hljs-string">&#x27;value_1&#x27;</span><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> cloumn_name_1, cloumn_name_2, cloumn_name_3 <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name_2 = <span class="hljs-string">&#x27;value_2&#x27;</span>;</code></pre><h2 id="MATCH-…AGAINST…-全文检索"><a href="#MATCH-…AGAINST…-全文检索" class="headerlink" title="MATCH …AGAINST… 全文检索"></a>MATCH …AGAINST… 全文检索</h2><ul><li>需    求：我们有<code>Like</code>可以使用通配符，还有<code>REGEXP</code>可以使用正则，但他们都是有限制的<ul><li>性能：<code>Like</code>和<code>REGEXP</code>是遍历数据库的，而且这种搜索极少使用表索引</li><li>毕竟正则有限制，有时候很难写</li><li>傻，正则就是一种匹配，不会有关联性排序等</li></ul></li><li>注意事项：</li></ul><ol><li><p>Mysql常用的有两种引擎，支持版本如下</p><table><thead><tr><th>版本</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>小于5.6</td><td>支持</td><td>不支持</td></tr><tr><td>大于5.6</td><td>支持</td><td>支持</td></tr></tbody></table></li><li><p>Mysql有一张停词表，可以进行覆盖</p></li><li><p>Mysql对于50%以上的行(表中的行)中都有，这个词将被忽略</p></li><li><p>行数必须大于3，少于3行可能不会返回结果</p></li><li><p>中文需要插件支持(分词)</p></li></ol><h3 id="创建全文检索表"><a href="#创建全文检索表" class="headerlink" title="创建全文检索表"></a>创建全文检索表</h3><pre><code class="hljs sql"><span class="hljs-comment"># 创建一个支持全文检索的表，使用`FULLTEXT`来对`node_text`进行创建索引，这个索引在数据库更改之后会**自动维护和更新**</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,    note_data datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    node_text <span class="hljs-built_in">char</span>(<span class="hljs-number">10</span>) <span class="hljs-literal">NULL</span>,    PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>),    FULLTEXT(node_text))<span class="hljs-keyword">ENGINE</span>=MyISAM;</code></pre><pre><code class="hljs sql"><span class="hljs-comment"># 修改/增加索引</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`table_name`</span> <span class="hljs-keyword">ADD</span> FULLTEXT <span class="hljs-keyword">INDEX</span> index_name(<span class="hljs-string">`node_text`</span>);<span class="hljs-comment"># 修改引擎</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> book <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">INNODB</span>;</code></pre><h3 id="进行全文检索"><a href="#进行全文检索" class="headerlink" title="进行全文检索"></a>进行全文检索</h3><pre><code class="hljs sql"><span class="hljs-comment"># 使用`MATCH(note_text)`指定需要索引的列，`AGAINST(&#x27;value&#x27;)`使用搜索表达式</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;value&#x27;</span>);<span class="hljs-comment"># 使用拓展查询 -- 第一次查询的结果中有用的词将作为**新的词语**再次查询</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;value&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">QUERY</span> EXPANSION);<span class="hljs-comment"># 布尔查询 -- 包含任意一个值</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;hello world&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-built_in">BOOLEAN</span> <span class="hljs-keyword">MODE</span>);<span class="hljs-comment"># 布尔查询 -- 包含整个短语</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;&quot;hello world&quot;&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-built_in">BOOLEAN</span> <span class="hljs-keyword">MODE</span>);<span class="hljs-comment"># 布尔查询 -- 同时包含两个值</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;+hello +world&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-built_in">BOOLEAN</span> <span class="hljs-keyword">MODE</span>);<span class="hljs-comment"># 布尔查询 -- 排除hell开头的单词</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;value -hell*&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-built_in">BOOLEAN</span> <span class="hljs-keyword">MODE</span>);<span class="hljs-comment"># 布尔查询 -- 增加第一个词的权重，降低第二个词的权重</span><span class="hljs-keyword">SELECT</span> node_text <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(note_text) AGAINST(<span class="hljs-string">&#x27;&gt;hello &lt;world&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-built_in">BOOLEAN</span> <span class="hljs-keyword">MODE</span>);</code></pre><table><thead><tr><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>包含</td></tr><tr><td>-</td><td>排除</td></tr><tr><td>&gt;</td><td>包含，且增加等级</td></tr><tr><td>&lt;</td><td>包含，且降低等级</td></tr><tr><td>~</td><td>取消排序值？</td></tr><tr><td>()</td><td>与正则的()功能一致</td></tr><tr><td>*</td><td>词尾通配符</td></tr><tr><td>“”</td><td>定义一个短语</td></tr></tbody></table><p>注意事项：</p><ul><li>只能用于<code>SELECT</code>之间</li><li>不同查询需要返回相同的列</li><li>列的类型必须兼容</li></ul><h2 id="INSERT-插入"><a href="#INSERT-插入" class="headerlink" title="INSERT 插入"></a>INSERT 插入</h2><pre><code class="hljs sql"><span class="hljs-comment"># 插入完整的行 -- 自增ID使用NULL填充，有默认的也可以使用NULL填充 -- Mysql将跳过这些NULL列执行</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name <span class="hljs-keyword">VALUES</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-comment"># 插入部分字段</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (<span class="hljs-string">&#x27;cloumn_name_1&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;value_1&#x27;</span>,<span class="hljs-string">&#x27;value_2&#x27;</span>,<span class="hljs-string">&#x27;value_3&#x27;</span>);<span class="hljs-comment"># 插入检出的数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (<span class="hljs-string">&#x27;cloumn_name_1&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span>) <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;cloumn_name_1&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span>,<span class="hljs-string">&#x27;cloumn_name_2&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;new_cloumn&#x27;</span>;<span class="hljs-comment"># 获得自增的值 -- 适用于插入一行之后，得到插入的行的ID</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">last_insert_id</span>() <span class="hljs-keyword">from</span> table_name;</code></pre><h2 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h2><pre><code class="hljs sql"><span class="hljs-comment"># 更新所有行 -- 谨慎操作呀！</span><span class="hljs-keyword">UPDATE</span> table_name <span class="hljs-keyword">SET</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span>;<span class="hljs-comment"># 更行特定行</span><span class="hljs-keyword">UPDATE</span> table_name <span class="hljs-keyword">SET</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span> <span class="hljs-keyword">WHERE</span> cloumn_name = <span class="hljs-string">&#x27;value_1&#x27;</span>;<span class="hljs-comment"># ignore 更新失败继续更新 -- 原本如果更新某些行失败，将整个回退到update前，加上ignore就像try...catch...一样</span><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">IGNORE</span> table_name <span class="hljs-keyword">SET</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span> <span class="hljs-keyword">WHERE</span> cloumn_name = <span class="hljs-string">&#x27;value_1&#x27;</span>;</code></pre><h2 id="DELETE-amp-amp-删除"><a href="#DELETE-amp-amp-删除" class="headerlink" title="DELETE &amp;&amp; 删除"></a>DELETE &amp;&amp; 删除</h2><pre><code class="hljs sql"><span class="hljs-comment"># 删除所有行 -- 谨慎操作呀！</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># TRUNCATE 删除并重建表，自增序列将从0开始</span>TRANCATE table_name;<span class="hljs-comment"># 删除行</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> cloumn_name = <span class="hljs-string">&#x27;value&#x27;</span>;</code></pre><h2 id="CREATE-创建"><a href="#CREATE-创建" class="headerlink" title="CREATE 创建"></a>CREATE 创建</h2><pre><code class="hljs sql"><span class="hljs-comment"># 创建数据库 -- 设置字符集</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">&#x27;database_name&#x27;</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<span class="hljs-comment"># 一条满打满算的CREATE语句</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;table_name&#x27;</span>(    <span class="hljs-keyword">id</span>          <span class="hljs-built_in">int</span>         <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>    AUTO_INCREMENT,     <span class="hljs-comment">-- int: 不需要且不能设置Size; AUTO_INCREMENT: 自增</span>    book_text   <span class="hljs-built_in">char</span>(<span class="hljs-number">10</span>)    <span class="hljs-literal">NULL</span>,                           <span class="hljs-comment">-- NULL: NULL是默认的，即使不设置也是NULL</span>    book_num    <span class="hljs-built_in">int</span>         <span class="hljs-literal">NULL</span>,       <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,          <span class="hljs-comment">-- DEFAULT: 设置默认值</span>    fk_reader_id <span class="hljs-built_in">int</span>        <span class="hljs-literal">NULl</span>,    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(fk_reader_id) <span class="hljs-keyword">REFERENCES</span> reader(<span class="hljs-keyword">id</span>),        <span class="hljs-comment">-- FOREIGN KEY...REFERENCES... 外键，1. fk_reader_id必须存在，但不一定要相同的属性，可以为N</span>    <span class="hljs-string">`create_time`</span>     DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;创建时间&#x27;</span>,    <span class="hljs-string">`update_time`</span>     DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;更新时间&#x27;</span>,    PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>),                                        <span class="hljs-comment">-- PRIMARY KEY(): 主键必须是NOT NULL的，且值是唯一的，主键是会建立索引的</span>    PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>,book_name)                               <span class="hljs-comment">-- 复合主键: 符合组件的组合值是唯一的</span>)<span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;        <span class="hljs-comment">-- 设置字符集和排序方式</span></code></pre><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><pre><code class="hljs sql"><span class="hljs-comment"># 创建时增加外键 -- 列fk_reader_id的属性不一定要与原来的相同</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">&#x27;table_name&#x27;</span>(    <span class="hljs-keyword">id</span>          <span class="hljs-built_in">int</span>         <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>    AUTO_INCREMENT,    fk_reader_id <span class="hljs-built_in">int</span>        <span class="hljs-literal">NULl</span>,    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>(fk_reader_id) <span class="hljs-keyword">REFERENCES</span> reader(<span class="hljs-keyword">id</span>),    PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-keyword">id</span>))<span class="hljs-comment"># ALTER增加外键</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_reader_id FOREING <span class="hljs-keyword">KEY</span> (fk_reader_id) <span class="hljs-keyword">REFERENCES</span> reader (<span class="hljs-keyword">id</span>);</code></pre><h2 id="ALTER-TABLE-更改"><a href="#ALTER-TABLE-更改" class="headerlink" title="ALTER TABLE 更改"></a>ALTER TABLE 更改</h2><pre><code class="hljs sql"><span class="hljs-comment"># 修改引擎 -- 谨慎操作，可能导致外键失效(外键不能是别的引擎的)</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> book <span class="hljs-keyword">ENGINE</span> = MyISAM;<span class="hljs-comment"># 增加列</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> new_cloumn_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>);<span class="hljs-comment"># 删除列 -- 数据库中的列数据将全部删除，且不可复原</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> CLOUMN cloumn_name;<span class="hljs-comment"># 增加外键</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_cloumn_name_2 FOREING <span class="hljs-keyword">KEY</span> (cloumn_name_1) <span class="hljs-keyword">REFERENCES</span> table2 (<span class="hljs-keyword">id</span>);</code></pre><h2 id="DROP-amp-amp-RENAME-删除"><a href="#DROP-amp-amp-RENAME-删除" class="headerlink" title="DROP &amp;&amp; RENAME 删除"></a>DROP &amp;&amp; RENAME 删除</h2><pre><code class="hljs sql"><span class="hljs-comment"># 删除表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> table_name;<span class="hljs-comment"># 重命名表</span><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> table_name1 <span class="hljs-keyword">TO</span> table_name2;<span class="hljs-comment"># 重命名多张表</span><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> a <span class="hljs-keyword">TO</span> b,    c <span class="hljs-keyword">to</span> d,    f <span class="hljs-keyword">to</span> g</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li>视图就是一张临时表，用于简化SQL操作</li><li>格式化数据</li><li>过滤数据</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 创建视图</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> book_reader_view <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> book.id <span class="hljs-keyword">AS</span> book_id, reader.id <span class="hljs-keyword">AS</span> reader_id, book_name <span class="hljs-keyword">FROM</span> reader,book <span class="hljs-keyword">WHERE</span> reader.fk_book_id = book.id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> reader.id;<span class="hljs-comment"># 使用视图</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> book_reader_view;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><ul><li>存储过程就是一个SQL函数，允许定义和传参调用</li><li>简化调用过程</li><li>减少重复代码</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 创建存储过程</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">&#x27;procedure_name&#x27;</span>()<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">count</span>    <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">END</span>;<span class="hljs-comment"># 调用存储过程</span><span class="hljs-keyword">CALL</span> <span class="hljs-string">&#x27;procedure_name&#x27;</span>()<span class="hljs-comment"># 删除存储过程</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">&#x27;procedure_name&#x27;</span>;<span class="hljs-comment"># 带参数的存储过程</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">&#x27;procedure_name&#x27;</span>(    <span class="hljs-keyword">IN</span> param_1 <span class="hljs-built_in">INT</span>,  <span class="hljs-comment">-- 定义输入类型</span>    <span class="hljs-keyword">OUT</span> param_2 <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 定义返回类型</span>    INOUT param_3 <span class="hljs-built_in">INT</span>, <span class="hljs-comment">-- 既传入也传出</span>)<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(<span class="hljs-keyword">id</span>)    <span class="hljs-keyword">INTO</span> param_1    <span class="hljs-keyword">FROM</span> cloumn_name_1;<span class="hljs-keyword">END</span>;<span class="hljs-comment"># 调用传参数的存储过程 -- 带@为返回值，不带@为传入值</span><span class="hljs-keyword">CALL</span> <span class="hljs-string">&#x27;procedure_name&#x27;</span>(param_1, @param_2)<span class="hljs-comment"># 显示返回值</span><span class="hljs-keyword">SELECT</span> @param_2;<span class="hljs-comment"># 在存储过程中注释</span><span class="hljs-comment">-- 注释内容</span><span class="hljs-comment"># 使用逻辑判断</span>IF boolean_param THEN    <span class="hljs-comment">-- 执行的内容</span><span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;</code></pre><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><ul><li>游标就是一个迭代器，在Mysql中只能用于存储过程。</li><li>除了游标，存储过程也支持循环语句</li></ul><h2 id="TRIGGER-触发器"><a href="#TRIGGER-触发器" class="headerlink" title="TRIGGER 触发器"></a>TRIGGER 触发器</h2><ul><li>触发器是在下列SQL语句执行时触发另一条SQL语句(<code>before</code>还是<code>after</code>可以自己设定)<ol><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ol></li><li>触发器只支持表，不支持视图和临时表</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># 创建触发器</span><span class="hljs-comment">-- 指定触发器名</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name     <span class="hljs-comment">-- 声明触发器执行前后</span>    <span class="hljs-keyword">AFTER</span>    <span class="hljs-comment">-- 触发语句声明，每一行插入都执行</span>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> products <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span>     <span class="hljs-comment">-- 执行语句</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;执行后，触发器触发&#x27;</span><span class="hljs-comment"># 删除触发器</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> trigger_name;<span class="hljs-comment"># 使用触发器获得自增的值</span><span class="hljs-comment"># INSERT 触发器 -- 使用NEW来得到新的行, 这个值允许修改--这个修改将被更新到插入的行</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> products <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">SELECT</span> NEW.product.id;<span class="hljs-comment"># SELECT 触发器 -- 使用OLD得到删除的行的数据</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> products <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">SELECT</span> OLD.id;<span class="hljs-comment"># UPDATE 触发器 -- 使用NEW来得到新的行，使用OLD得到删除的行的数据</span><span class="hljs-comment"># 触发多行</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> products <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SELECT</span> OLD.id;    <span class="hljs-keyword">SELECT</span> OLD.name;<span class="hljs-keyword">END</span>;</code></pre><ul><li>BEFORE触发器 – 常用于校验数据或清理数据，如大小写转换等</li><li>AFTER触发器 – </li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li>事务用来维护数据完整性，保证数据在执行多个操作时候，要么全部执行，要么全部不执行</li><li>不是所有的引擎支持事务，只有<code>InnoDB</code>支持</li></ul><pre><code class="hljs sql"><span class="hljs-comment"># ROLLBACK 回退 -- 仅在`Start TRANSACTION`之后有效</span><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">-- 即使执行成功，会退后删除的部分会恢复</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-comment"># COMMIT 显式提交</span><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">-- 假设这句执行失败，面那句也会被回退</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment"># SAVEPOINT 保存点 -- 这玩意就是个占位符，跟Goto一个样</span><span class="hljs-keyword">SAVEPOINT</span> savepoint_name; <span class="hljs-comment">-- 建立保存点</span><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> savepoint_name; <span class="hljs-comment">-- 回滚到保存点</span></code></pre><ul><li><code>CREATE</code>和<code>DROP</code>操作不会被回退（可以写在事务中）</li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><pre><code class="hljs sql"><span class="hljs-comment"># 查看用户</span><span class="hljs-keyword">USE</span> mysql;<span class="hljs-keyword">SELECT</span> Host,<span class="hljs-keyword">User</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<span class="hljs-comment"># 创建用户账号 -- 登陆Host为% ,但是什么权限都没有，数据库都创建不了，连看都不能</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> czm <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;root123&#x27;</span><span class="hljs-comment"># 创建用户账户 -- 建议使用上述方式</span><span class="hljs-keyword">GRANT</span> <span class="hljs-comment"># 重命名用户 -- 也可以直接操作user表</span><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">USER</span> czm1 <span class="hljs-keyword">TO</span> czm;<span class="hljs-comment"># 显示用户访问权限</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span> <span class="hljs-keyword">FOR</span> czm;<span class="hljs-comment">-- GRANT USAGE ON *.* TO `czm`@`%`</span><span class="hljs-comment">-- USAGE 表示什么权限也没有</span><span class="hljs-comment"># 增加用户访问权限</span><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> test.* <span class="hljs-keyword">TO</span> czm;             <span class="hljs-comment">-- 增加所有权限</span><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> test.* <span class="hljs-keyword">TO</span> czm;          <span class="hljs-comment">-- 增加一个数据库看的权限</span><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> test.* <span class="hljs-keyword">TO</span> czm;  <span class="hljs-comment">-- 增加多个权限</span><span class="hljs-comment"># 删除用户访问权限</span><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> test.* <span class="hljs-keyword">TO</span> czm;<span class="hljs-comment"># 查看权限变化过程</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span> <span class="hljs-keyword">FOR</span> czm;<span class="hljs-comment"># 更改密码</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">FOR</span> czm = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;new_password&#x27;</span>)     <span class="hljs-comment">-- 其他账户</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">&#x27;new_password&#x27;</span>)             <span class="hljs-comment">-- 当前账户</span></code></pre><table><thead><tr><th>权限名</th><th>说明</th></tr></thead><tbody><tr><td>ALTER</td><td>Allows use of ALTER TABLE.</td></tr><tr><td>ALTER</td><td>ROUTINE    Alters or drops stored routines.</td></tr><tr><td>CREATE</td><td>Allows use of CREATE TABLE.</td></tr><tr><td>CREATE  ROUTINE</td><td>Creates stored routines.</td></tr><tr><td>CREATE TEMPORARY TABLE</td><td>Allows use of CREATE TEMPORARY TABLE.</td></tr><tr><td>CREATE USER</td><td>Allows use of CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES.</td></tr><tr><td>CREATE VIEW</td><td>Allows use of CREATE VIEW.</td></tr><tr><td>DELETE</td><td>Allows use of DELETE.</td></tr><tr><td>DROP</td><td>Allows use of DROP TABLE.</td></tr><tr><td>EXECUTE</td><td>Allows the user to run stored routines.</td></tr><tr><td>FILE</td><td>Allows use of SELECT… INTO OUTFILE and LOAD DATA INFILE.</td></tr><tr><td>INDEX</td><td>Allows use of CREATE INDEX and DROP INDEX.</td></tr><tr><td>INSERT</td><td>Allows use of INSERT.</td></tr><tr><td>LOCK</td><td>TABLES    Allows use of LOCK TABLES on tables for which the user also has SELECT privileges.</td></tr><tr><td>PROCESS</td><td>Allows use of SHOW FULL PROCESSLIST.</td></tr><tr><td>RELOAD</td><td>Allows use of FLUSH.</td></tr><tr><td>REPLICATION</td><td>Allows the user to ask where slave or master</td></tr><tr><td>CLIENT</td><td>servers are.</td></tr><tr><td>REPLICATION</td><td>SLAVE    Needed for replication slaves.</td></tr><tr><td>SELECT</td><td>Allows use of SELECT.</td></tr><tr><td>SHOW DATABASES</td><td>Allows use of SHOW DATABASES.</td></tr><tr><td>SHOW VIEW</td><td>Allows use of SHOW CREATE VIEW.</td></tr><tr><td>SHUTDOWN</td><td>Allows use of mysqladmin shutdown.</td></tr><tr><td>SUPER</td><td>Allows use of CHANGE MASTER, KILL, PURGE MASTER LOGS, and SET GLOBAL SQL statements. Allows mysqladmin debug command. Allows one extra  connection  to be made if maximum connections are reached.</td></tr><tr><td>UPDATE</td><td>Allows use of UPDATE.</td></tr><tr><td>USAGE</td><td>Allows connection without any specific privileges.</td></tr></tbody></table><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><ul><li>mysql使用磁盘存储，需要使用<code>FLUSH TABLES</code>来刷新，保证文件都写到文件中去。</li></ul><p>备份数据库方式如下</p><ol><li>mysqldump <pre><code class="hljs sh"><span class="hljs-comment"># 复制**结构加数据**到文件 --opt 参数可以实现更好的SQL语句，创建数据库加上`if exist`等 </span>mysqldump -uroot -p --opt --all-databases &gt; backup.sql<span class="hljs-comment"># 备份**格式**到文件</span>mysqldump --no-data --databases mydatabase1 mydatabase2 mydatabase3 &gt; backup.sql<span class="hljs-comment"># 使用管道实现跨主机数据库复制</span>mysqldump --host=主机1 --opt sourceDb | mysql --host=主机2 -C targetDb<span class="hljs-comment"># 定时备份</span>30 1 * * * root mysqldump -u root -pPASSWORD --all-databases | gzip &gt; /mnt/disk2/database_`date <span class="hljs-string">&#x27;+%m-%d-%Y&#x27;</span>`.sql.gz<span class="hljs-comment"># 恢复数据 -- 注意，数据将被覆盖，sql文件中的所有数据库和表将被创建</span>mysql -uroot -p &lt; backup.sql</code></pre></li><li>mysqlhotcopy – 需要其他依赖</li><li><code>BACKUP TABLE</code>和<code>SELECT INTO OUTFILE</code>来实现备份</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="查看支持引擎show-engines"><a href="#查看支持引擎show-engines" class="headerlink" title="查看支持引擎show engines;"></a>查看支持引擎<code>show engines;</code></h3><pre><code class="hljs sh">+--------------------+---------+----------------------------------------------------------------+--------------------+------+------------+-----------+| Engine             | Support | Comment                                                        | Transactions(事务) | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+-------- -----------+------+------------+-----------+| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL               | NULL | NULL       |           || MEMORY             | YES     | Hash based, stored <span class="hljs-keyword">in</span> memory, useful <span class="hljs-keyword">for</span> temporary tables      | NO                 | NO   | NO         |           || InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES                | YES  | YES        | YES       || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO                 | NO   | NO         |           || MyISAM             | YES     | MyISAM storage engine                                          | NO                 | NO   | NO         | YES       || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO                 | NO   | NO         |           || BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO                 | NO   | NO         |           || CSV                | YES     | CSV storage engine                                             | NO                 | NO   | NO         |           || ARCHIVE            | YES     | Archive storage engine                                         | NO                 | NO   | NO         |           |+--------------------+---------+----------------------------------------------------------------+--------------------+------+------------+-----------+</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-教程</title>
    <link href="/01-Java/13-EasyCode/01-mybatis/00-%E6%95%99%E7%A8%8B/"/>
    <url>/01-Java/13-EasyCode/01-mybatis/00-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><a href="https://gitee.com/makejava/EasyCode/wikis/pages?sort_id=725063&amp;doc_id=166248">https://gitee.com/makejava/EasyCode/wikis/pages?sort_id=725063&amp;doc_id=166248</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>13-EasyCode</category>
      
      <category>01-mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Mybatis-Plus</title>
    <link href="/01-Java/02-JavaEE/07-Mybatis-plus/01-Mybatis-Plus/"/>
    <url>/01-Java/02-JavaEE/07-Mybatis-plus/01-Mybatis-Plus/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><ul><li><a href="https://mybatis.plus/">官网</a></li><li><a href="https://mybatis.plus/guide/quick-start.html">官方入门教程无比详尽</a><br>·<h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>07-Mybatis-plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Optional</title>
    <link href="/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/02-jdk8/02-Optional/"/>
    <url>/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/02-jdk8/02-Optional/</url>
    
    <content type="html"><![CDATA[<h1 id="JSK8新特性-Optional"><a href="#JSK8新特性-Optional" class="headerlink" title="JSK8新特性 - Optional"></a>JSK8新特性 - Optional</h1><p>注意 Optional 是容器，不是对象</p><ol><li>避免使用get()方法</li><li>避免使用isPresent()方法</li><li>禁止作为类的实例属性</li><li>不要作为方法参数，1.不可序列化，2.它是容器</li></ol><p>正确的用法1：设置容器默认值</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Integer <span class="hljs-title">length</span><span class="hljs-params">(String string)</span> </span>&#123;    <span class="hljs-comment">// 相当于</span>    <span class="hljs-keyword">return</span> Optional.ofNullable(string).orElse(<span class="hljs-string">&quot;&quot;</span>).length();&#125;</code></pre><p>正确的用法2：抛出异常</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Integer <span class="hljs-title">length</span><span class="hljs-params">(String string)</span> <span class="hljs-keyword">throws</span> IllegalAccessException </span>&#123;    <span class="hljs-keyword">return</span> Optional.ofNullable(string).orElseThrow(IllegalAccessException::<span class="hljs-keyword">new</span>).length();&#125;</code></pre><p>正确的用法3: 链式调用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> IllegalAccessException </span>&#123;    <span class="hljs-keyword">return</span> Optional.ofNullable(user)            .filter(u -&gt; u.getName().length() == <span class="hljs-number">0</span>)            .map(Principal::getName)            .orElse(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;czm&quot;</span>));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>09-语言新特性</category>
      
      <category>02-jdk8</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-前端项目结构</title>
    <link href="/05-Web/01-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
    <url>/05-Web/01-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="前端项目结构"><a href="#前端项目结构" class="headerlink" title="前端项目结构"></a>前端项目结构</h1><pre><code class="hljs sh">---/html/|---- /index|---- /user/                    与用户相关的页面  |---- /user/login.html          登录页---/css/|---- /base.css                 重置浏览器样式|---- /page                     逻辑页面的css|---- /page/pagename.css        单独书写的css|---- /common.css               css通用样式库---/js/|---- /lib                      公用组件|---- /lib/jquery.2.2.3.min.js  调用jq库文件|---- /page                     逻辑页面的js|---- /page/pagename.js         单独书写的js|---- /common.js                公用方法---/img/|---- /page                     页面对应的图片|---- /page/wap                 手机端图片夹|---- /page/wap/wap_icon.png    手机端图标|---- /logo.png                 公用图片</code></pre>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Spring-security-server.html</title>
    <link href="/01-Java/06-Security/02-Oauth2/02-Spring-security-server/"/>
    <url>/01-Java/06-Security/02-Oauth2/02-Spring-security-server/</url>
    
    <content type="html"><![CDATA[<html lang="zh-cn"><head>    <meta charset="utf-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta name="referrer" content="never">    <meta property="og:description"        content="OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials">    <meta http-equiv="Cache-Control" content="no-transform">    <meta http-equiv="Cache-Control" content="no-siteapp">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <title>Spring Cloud OAuth2 实现权限认证及单点登录 - panchanggui - 博客园</title>    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.ico?v=20200522" type="image/x-icon">    <link rel="stylesheet" href="/css/blog-common.min.css?v=7Pwqzj5EBy4dBv4DJNI181rFKP8_OF0hT7jO3o8jAa0">    <link id="MainCss" rel="stylesheet"        href="/skins/bluecurve/bundle-bluecurve.min.css?v=g1hhGNvDiCLxnnI4qswUqGZZlBwtxglv2-Sm3rSFE2s">    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet"        href="/skins/bluecurve/bundle-bluecurve-mobile.min.css?v=-9jRKRAEeEtlr5EkSG-LpMBRHz2PN0kolWZ1uU8dFT4">    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/panchanggui/rss">    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/panchanggui/rsd.xml">    <link type="application/wlwmanifest+xml" rel="wlwmanifest"        href="https://www.cnblogs.com/panchanggui/wlwmanifest.xml">    <script async="" src="https://www.google-analytics.com/analytics.js"></script>    <script>        var currentBlogId = 438378;        var currentBlogApp = 'panchanggui';        var cb_enable_mathjax = false;        var isLogined = true;        var isBlogOwner = false;        var skinName = 'BlueCurve';        var visitorUserId = 'b2976596-6697-e611-845c-ac853d9f53ac';    </script>    <script>        var currentPostDateAdded = '2020-01-21 04:12';    </script>    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>    <script src="/js/blog-common.min.js?v=ZMP-E7oivIbnbdC4Ap-FXPEUrs-k9WrJgvJkU43qwDI"></script>    <script src="https://securepubads.g.doubleclick.net/gpt/pubads_impl_2020083101.js?21067372" async=""></script>    <link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=www.cnblogs.com" as="script">    <script type="text/javascript"        src="https://adservice.google.com/adsid/integrator.js?domain=www.cnblogs.com"></script></head><body>    <a name="top"></a>    <div id="container">        <!-- Header -->        <!-- Left Sidebar -->        <!-- Main Content -->        <div id=""><a id="contentstart" name="contentstart"></a>            <div id="post_detail">                <div class="post">                    <div class="posthead">                        <h2>                            <a id="cb_post_title_url" class="postTitle2 vertical-middle"                                href="https://www.cnblogs.com/panchanggui/p/12222131.html">                                <span>Spring Cloud OAuth2 实现权限认证及单点登录</span>                            </a>                        </h2>                        Posted on                        <span id="post-date">2020-01-21 16:12</span>&nbsp;                        <a href="https://www.cnblogs.com/panchanggui/">panchanggui</a>&nbsp;                        阅读(<span id="post_view_count">1745</span>)&nbsp;                        评论(<span id="post_comment_count">0</span>)&nbsp;                        <a href="https://i.cnblogs.com/EditPosts.aspx?postid=12222131" rel="nofollow">编辑</a>&nbsp;                        <a href="javascript:void(0)" onclick="AddToWz(12222131);return false;">收藏</a>                    </div>                    <div class="postbody">                        <div id="cnblogs_post_body" class="blogpost-body">                            <p>OAuth 2 有四种授权模式，分别是授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password                                credentials）、客户端模式（client credentials），具体 OAuth2                                是什么，可以参考这篇文章。(http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)</p>                            <p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt=""></p>                            <p>本文我们将使用授权码模式和密码模式两种方式来实现用户认证和授权管理。</p>                            <p>OAuth2 其实是一个关于授权的网络标准，它制定了设计思路和运行流程，利用这个标准我们其实是可以自己实现 OAuth2 的认证过程的。今天要介绍的                                spring-cloud-starter-oauth2 ，其实是 Spring Cloud 按照 OAuth2 的标准并结合 spring-security                                封装好的一个具体实现。</p>                            <h3 id="什么情况下需要用-oauth2">什么情况下需要用 OAuth2</h3>                            <p>首先大家最熟悉的就是几乎每个人都用过的，比如用微信登录、用 QQ 登录、用微博登录、用 Google 账号登录、用 github 授权登录等等，这些都是典型的 OAuth2                                使用场景。假设我们做了一个自己的服务平台，如果不使用 OAuth2 登录方式，那么我们需要用户先完成注册，然后用注册号的账号密码或者用手机验证码登录。而使用了 OAuth2                                之后，相信很多人使用过、甚至开发过公众号网页服务、小程序，当我们进入网页、小程序界面，第一次使用就无需注册，直接使用微信授权登录即可，大大提高了使用效率。因为每个人都有微信号，有了微信就可以马上使用第三方服务，这体验不要太好了。而对于我们的服务来说，我们也不需要存储用户的密码，只要存储认证平台返回的唯一ID                                和用户信息即可。</p>                            <p>以上是使用了 OAuth2                                的授权码模式，利用第三方的权威平台实现用户身份的认证。当然了，如果你的公司内部有很多个服务，可以专门提取出一个认证中心，这个认证中心就充当上面所说的权威认证平台的角色，所有的服务都要到这个认证中心做认证。                            </p>                            <p>这样一说，发现没，这其实就是个单点登录的功能。这就是另外一种使用场景，对于多服务的平台，可以使用 OAuth2                                实现服务的单点登录，只做一次登录，就可以在多个服务中自由穿行，当然仅限于授权范围内的服务和接口。</p>                            <h3 id="实现统一认证功能">实现统一认证功能</h3>                            <p>本篇先介绍密码模式实现的单点登录，下一篇再继续说授权码模式。</p>                            <p>在微服务横行的今天，谁敢说自己手上没几个微服务。微服务减少了服务间的耦合，同时也在某些方面增加了系统的复杂度，比如说用户认证。假设我们这里实现了一个电商平台，用户看到的就是一个                                APP 或者一个 web                                站点，实际上背后是由多个独立的服务构成的，比如用户服务、订单服务、产品服务等。用户只要第一次输入用户名、密码完成登录后，一段时间内，都可以任意访问各个页面，比如产品列表页面、我的订单页面、我的关注等页面。                            </p>                            <p>我们可以想象一下，自然能够想到，在请求各个服务、各个接口的时候，一定携带着什么凭证，然后各个服务才知道请求接口的用户是哪个，不然肯定有问题，那其实这里面的凭证简单来说就是一个                                Token，标识用户身份的 Token。</p>                            <h4 id="系统架构说明">系统架构说明</h4>                            <p>认证中心：oauth2-auth-server，OAuth2 主要实现端，Token 的生成、刷新、验证都在认证中心完成。</p>                            <p>订单服务：oauth2-client-order-server，微服务之一，接收到请求后会到认证中心验证。</p>                            <p>用户服务：oauth2-client-user-server，微服务之二，接收到请求后会到认证中心验证。</p>                            <p>客户端：例如 APP 端、web 端 等终端</p>                            <p><img src="https://img2018.cnblogs.com/blog/273364/201910/273364-20191023100717630-187909841.png"                                    alt=""></p>                            <p>上图描述了使用了 OAuth2 的客户端与微服务间的请求过程。大致的过程就是客户端用用户名和密码到认证服务端换取 token，返回给客户端，客户端拿着 token                                去各个微服务请求数据接口，一般这个 token 是放到 header 中的。当微服务接到请求后，先要拿着 token 去认证服务端检查 token                                的合法性，如果合法，再根据用户所属的角色及具有的权限动态的返回数据。</p>                            <h5 id="创建并配置认证服务端">创建并配置认证服务端</h5>                            <p>配置最多的就是认证服务端，验证账号、密码，存储 token，检查 token ,刷新 token 等都是认证服务端的工作。</p>                            <p>1、引入需要的 maven 包</p>                            <pre                                class="xml"><code class="hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p><code>spring-cloud-starter-oauth2</code>包含了&nbsp;<code>spring-cloud-starter-security</code>，所以不用再单独引入了。之所以引入                                redis 包，是因为下面会介绍一种用 redis 存储 token 的方式。</p>                            <p>2、配置好 application.yml</p>                            <p>将项目基本配置设置好，并加入有关 redis 的配置，稍后会用到。</p>                            <pre                                class="yaml"><code class="hljs yaml"><span class="hljs-attr"><span class="hljs-attr">spring:</span><span class="hljs-attr"><span class="hljs-attr">  application:</span><span class="hljs-attr"><span class="hljs-attr">    name:</span> <span class="hljs-string"><span class="hljs-string">auth-server</span><span class="hljs-attr"><span class="hljs-attr">  redis:</span><span class="hljs-attr"><span class="hljs-attr">    database:</span> <span class="hljs-number"><span class="hljs-number">2</span><span class="hljs-attr"><span class="hljs-attr">    host:</span> <span class="hljs-string"><span class="hljs-string">localhost</span><span class="hljs-attr"><span class="hljs-attr">    port:</span> <span class="hljs-number"><span class="hljs-number">32768</span><span class="hljs-attr"><span class="hljs-attr">    password:</span> <span class="hljs-number"><span class="hljs-number">1</span><span class="hljs-string"><span class="hljs-string">qaz@WSX</span><span class="hljs-attr"><span class="hljs-attr">    jedis:</span><span class="hljs-attr"><span class="hljs-attr">      pool:</span><span class="hljs-attr"><span class="hljs-attr">        max-active:</span> <span class="hljs-number"><span class="hljs-number">8</span><span class="hljs-attr"><span class="hljs-attr">        max-idle:</span> <span class="hljs-number"><span class="hljs-number">8</span><span class="hljs-attr"><span class="hljs-attr">        min-idle:</span> <span class="hljs-number"><span class="hljs-number">0</span><span class="hljs-attr"><span class="hljs-attr">    timeout:</span> <span class="hljs-number"><span class="hljs-number">100</span><span class="hljs-string"><span class="hljs-string">ms</span><span class="hljs-attr"><span class="hljs-attr">server:</span><span class="hljs-attr"><span class="hljs-attr">  port:</span> <span class="hljs-number"><span class="hljs-number">6001</span><span class="hljs-attr"><span class="hljs-attr">management:</span><span class="hljs-attr"><span class="hljs-attr">  endpoint:</span><span class="hljs-attr"><span class="hljs-attr">    health:</span><span class="hljs-attr"><span class="hljs-attr">      enabled:</span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>3、spring security 基础配置</p>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSecurityConfig</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordEncoder</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticationManagerBean</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">super</span>.authenticationManagerBean();    &#125;    <span class="hljs-comment"><span class="hljs-comment">/**     * 允许匿名访问所有接口 主要是 oauth 接口     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span> http     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span> Exception     */</span>    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        http.authorizeRequests()                .antMatchers(<span class="hljs-string"><span class="hljs-string">"/**"</span>).permitAll();    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>使用<code>@EnableWebSecurity</code>注解修饰，并继承自<code>WebSecurityConfigurerAdapter</code>类。</p>                            <p>这个类的重点就是声明&nbsp;<code>PasswordEncoder</code>&nbsp;和&nbsp;<code>AuthenticationManager</code>两个                                Bean。稍后会用到。其中&nbsp;<code>BCryptPasswordEncoder</code>是一个密码加密工具类，它可以实现不可逆的加密，<code>AuthenticationManager</code>是为了实现                                OAuth2 的 password 模式必须要指定的授权管理 Bean。</p>                            <p>4、实现 UserDetailsService</p>                            <p>如果你之前用过 Security                                的话，那肯定对这个类很熟悉，它是实现用户身份验证的一种方式，也是最简单方便的一种。另外还有结合&nbsp;<code>AuthenticationProvider</code>的方式，有机会讲                                Security 的时候再展开来讲吧。</p>                            <p><code>UserDetailsService</code>的核心就是&nbsp;<code>loadUserByUsername</code>方法，它要接收一个字符串参数，也就是传过来的用户名，返回一个&nbsp;<code>UserDetails</code>对象。                            </p>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta"><span class="hljs-meta">@Component</span>(value = <span class="hljs-string"><span class="hljs-string">"kiteUserDetailsService"</span>)<span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KiteUserDetailsService</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUserByUsername</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String username)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string"><span class="hljs-string">"usernameis:"</span> + username);        <span class="hljs-comment"><span class="hljs-comment">// 查询数据库操作</span>        <span class="hljs-keyword"><span class="hljs-keyword">if</span>(!username.equals(<span class="hljs-string"><span class="hljs-string">"admin"</span>))&#123;            <span class="hljs-keyword"><span class="hljs-keyword">throw</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string"><span class="hljs-string">"the user is not found"</span>);        &#125;<span class="hljs-keyword"><span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment"><span class="hljs-comment">// 用户角色也应在数据库中获取</span>            String role = <span class="hljs-string"><span class="hljs-string">"ROLE_ADMIN"</span>;            List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword"><span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            authorities.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span> SimpleGrantedAuthority(role));            <span class="hljs-comment"><span class="hljs-comment">// 线上环境应该通过用户名查询数据库获取加密后的密码</span>            String password = passwordEncoder.encode(<span class="hljs-string"><span class="hljs-string">"123456"</span>);            <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> org.springframework.security.core.userdetails.User(username,password, authorities);        &#125;    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>这里为了做演示，把用户名、密码和所属角色都写在代码里了，正式环境中，这里应该是从数据库或者其他地方根据用户名将加密后的密码及所属角色查出来的。账号 admin ，密码                                123456，稍后在换取 token 的时候会用到。并且给这个用户设置 "ROLE_ADMIN" 角色。</p>                            <p>5、OAuth2 配置文件</p>                            <p>创建一个配置文件继承自&nbsp;<code>AuthorizationServerConfigurerAdapter</code>.</p>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span><span class="hljs-meta"><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuth2Config</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span> PasswordEncoder passwordEncoder;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span> UserDetailsService kiteUserDetailsService;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> TokenStore redisTokenStore;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> AuthorizationServerEndpointsConfigurer endpoints)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment"><span class="hljs-comment">/**         * redis token 方式         */</span>        endpoints.authenticationManager(authenticationManager)                .userDetailsService(kiteUserDetailsService)                .tokenStore(redisTokenStore);    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        clients.inMemory()                .withClient(<span class="hljs-string"><span class="hljs-string">"order-client"</span>)                .secret(passwordEncoder.encode(<span class="hljs-string"><span class="hljs-string">"order-secret-8888"</span>))                .authorizedGrantTypes(<span class="hljs-string"><span class="hljs-string">"refresh_token"</span>, <span class="hljs-string"><span class="hljs-string">"authorization_code"</span>, <span class="hljs-string"><span class="hljs-string">"password"</span>)                .accessTokenValiditySeconds(<span class="hljs-number"><span class="hljs-number">3600</span>)                .scopes(<span class="hljs-string"><span class="hljs-string">"all"</span>)                .and()                .withClient(<span class="hljs-string"><span class="hljs-string">"user-client"</span>)                .secret(passwordEncoder.encode(<span class="hljs-string"><span class="hljs-string">"user-secret-8888"</span>))                .authorizedGrantTypes(<span class="hljs-string"><span class="hljs-string">"refresh_token"</span>, <span class="hljs-string"><span class="hljs-string">"authorization_code"</span>, <span class="hljs-string"><span class="hljs-string">"password"</span>)                .accessTokenValiditySeconds(<span class="hljs-number"><span class="hljs-number">3600</span>)                .scopes(<span class="hljs-string"><span class="hljs-string">"all"</span>);    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        security.allowFormAuthenticationForClients();        security.checkTokenAccess(<span class="hljs-string"><span class="hljs-string">"isAuthenticated()"</span>);        security.tokenKeyAccess(<span class="hljs-string"><span class="hljs-string">"isAuthenticated()"</span>);    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>有三个 configure 方法的重写。</p>                            <p><code>AuthorizationServerEndpointsConfigurer</code>参数的重写</p>                            <pre class="java"><code class="hljs">endpoints.authenticationManager(authenticationManager)                .userDetailsService(kiteUserDetailsService)                .tokenStore(redisTokenStore);</code></pre>                            <p><code>authenticationManage()</code>&nbsp;调用此方法才能支持 password 模式。</p>                            <p><code>userDetailsService()</code>&nbsp;设置用户验证服务。</p>                            <p><code>tokenStore()</code>&nbsp;指定 token 的存储方式。</p>                            <p>redisTokenStore Bean 的定义如下：</p>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedisTokenStoreConfig</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> RedisConnectionFactory redisConnectionFactory;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redisTokenStore</span> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory);    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p><code>ClientDetailsServiceConfigurer</code>参数的重写，在这里定义各个端的约束条件。包括</p>                            <p>ClientId、Client-Secret：这两个参数对应请求端定义的 cleint-id 和 client-secret</p>                            <p>authorizedGrantTypes 可以包括如下几种设置中的一种或多种：</p>                            <ul>                                <li>authorization_code：授权码类型。</li>                                <li>implicit：隐式授权类型。</li>                                <li>password：资源所有者（即用户）密码类型。</li>                                <li>client_credentials：客户端凭据（客户端ID以及Key）类型。</li>                                <li>refresh_token：通过以上授权获得的刷新令牌来获取新的令牌。</li>                            </ul>                            <p>accessTokenValiditySeconds：token 的有效期</p>                            <p>scopes：用来限制客户端访问的权限，在换取的 token 的时候会带上 scope 参数，只有在 scopes 定义内的，才可以正常换取 token。</p>                            <p>上面代码中是使用 inMemory 方式存储的，将配置保存到内存中，相当于硬编码了。正式环境下的做法是持久化到数据库中，比如 mysql 中。</p>                            <p>具体的做法如下：</p>                            <ol>                                <li>在数据库中增加表，并插入数据</li>                            </ol>                            <pre                                class="mysql"><code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">create</span> <span class="hljs-keyword"><span class="hljs-keyword">table</span> oauth_client_details (    client_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span>,    resource_ids <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    client_secret <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    <span class="hljs-keyword"><span class="hljs-keyword">scope</span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    authorized_grant_types <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    web_server_redirect_uri <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    authorities <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>),    access_token_validity <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span>,    refresh_token_validity <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span>,    additional_information <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">4096</span>),    autoapprove <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number"><span class="hljs-number">256</span>));<span class="hljs-keyword"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span> oauth_client_details    (client_id, client_secret, <span class="hljs-keyword"><span class="hljs-keyword">scope</span>, authorized_grant_types,    web_server_redirect_uri, authorities, access_token_validity,    refresh_token_validity, additional_information, autoapprove)<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span>    (<span class="hljs-string"><span class="hljs-string">'user-client'</span>, <span class="hljs-string"><span class="hljs-string">'$2a$10$o2l5kA7z.Caekp72h5kU7uqdTDrlamLq.57M1F6ulJln9tRtOJufq'</span>, <span class="hljs-string"><span class="hljs-string">'all'</span>,    <span class="hljs-string"><span class="hljs-string">'authorization_code,refresh_token,password'</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-number"><span class="hljs-number">3600</span>, <span class="hljs-number"><span class="hljs-number">36000</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-literal"><span class="hljs-literal">true</span>);<span class="hljs-keyword"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span> oauth_client_details    (client_id, client_secret, <span class="hljs-keyword"><span class="hljs-keyword">scope</span>, authorized_grant_types,    web_server_redirect_uri, authorities, access_token_validity,    refresh_token_validity, additional_information, autoapprove)<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span>    (<span class="hljs-string"><span class="hljs-string">'order-client'</span>, <span class="hljs-string"><span class="hljs-string">'$2a$10$GoIOhjqFKVyrabUNcie8d.ADX.qZSxpYbO6YK4L2gsNzlCIxEUDlW'</span>, <span class="hljs-string"><span class="hljs-string">'all'</span>,    <span class="hljs-string"><span class="hljs-string">'authorization_code,refresh_token,password'</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-number"><span class="hljs-number">3600</span>, <span class="hljs-number"><span class="hljs-number">36000</span>, <span class="hljs-literal"><span class="hljs-literal">null</span>, <span class="hljs-literal"><span class="hljs-literal">true</span>);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>注意：&nbsp;client_secret 字段不能直接是 secret                                的原始值，需要经过加密。因为是用的&nbsp;<code>BCryptPasswordEncoder</code>，所以最终插入的值应该是经过&nbsp;<code>BCryptPasswordEncoder.encode()</code>之后的值。                            </p>                            <ol>                                <li>然后在配置文件 application.yml 中添加关于数据库的配置</li>                            </ol>                            <pre                                class="yaml"><code class="hljs yaml"><span class="hljs-attr"><span class="hljs-attr">spring:</span><span class="hljs-attr"><span class="hljs-attr">  datasource:</span><span class="hljs-attr"><span class="hljs-attr">    url:</span> <span class="hljs-attr"><span class="hljs-attr">jdbc:mysql://localhost:3306/spring_cloud?characterEncoding=UTF-8&amp;useSSL=false</span><span class="hljs-attr"><span class="hljs-attr">    username:</span> <span class="hljs-string"><span class="hljs-string">root</span><span class="hljs-attr"><span class="hljs-attr">    password:</span> <span class="hljs-string"><span class="hljs-string">password</span><span class="hljs-attr"><span class="hljs-attr">    hikari:</span><span class="hljs-attr"><span class="hljs-attr">      connection-timeout:</span> <span class="hljs-number"><span class="hljs-number">30000</span><span class="hljs-attr"><span class="hljs-attr">      idle-timeout:</span> <span class="hljs-number"><span class="hljs-number">600000</span><span class="hljs-attr"><span class="hljs-attr">      max-lifetime:</span> <span class="hljs-number"><span class="hljs-number">1800000</span><span class="hljs-attr"><span class="hljs-attr">      maximum-pool-size:</span> <span class="hljs-number"><span class="hljs-number">9</span>   </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>Spring Boot 2.0 之后默认使用 hikari 作为数据库连接池。如果使用其他连接池需要引入相关包，然后对应的增加配置。</p>                            <ol>                                <li>在 OAuth2 配置类(OAuth2Config)中增加 DataSource 的注入</li>                            </ol>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword"><span class="hljs-keyword">private</span> DataSource dataSource;</span></span></code></pre>                            <ol>                                <li>将&nbsp;<code>public void configure(ClientDetailsServiceConfigurer clients)</code>重写方法修改为如下：                                </li>                            </ol>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;    JdbcClientDetailsServiceBuilder jcsb = clients.jdbc(dataSource);    jcsb.passwordEncoder(passwordEncoder);&#125;</span></span></span></span></span></span></span></code></pre>                            <p>还有一个重写的方法&nbsp;<code>public void configure(AuthorizationServerSecurityConfigurer security)</code>，这个方法限制客户端访问认证接口的权限。                            </p>                            <pre                                class="java"><code class="hljs">security.allowFormAuthenticationForClients();security.checkTokenAccess(<span class="hljs-string"><span class="hljs-string">"isAuthenticated()"</span>);security.tokenKeyAccess(<span class="hljs-string"><span class="hljs-string">"isAuthenticated()"</span>);</span></span></code></pre>                            <p>第一行代码是允许客户端访问 OAuth2 授权接口，否则请求 token 会返回 401。</p>                            <p>第二行和第三行分别是允许已授权用户访问 checkToken 接口和获取 token 接口。</p>                            <p>完成之后，启动项目，如果你用的是 IDEA 会在下方的 Mapping 窗口中看到 oauth2 相关的 RESTful 接口。<br><img                                    src="https://img2018.cnblogs.com/blog/273364/201910/273364-20191023100737268-1008858850.png"                                    alt=""></p>                            <p>主要有如下几个：</p>                            <pre><code class="hljs groovy">POST <span class="hljs-regexp"><span class="hljs-regexp">/oauth/</span>authorize  授权码模式认证授权接口GET<span class="hljs-regexp"><span class="hljs-regexp">/POST /</span>oauth/token  获取 token 的接口POST  <span class="hljs-regexp"><span class="hljs-regexp">/oauth/</span>check_token  检查 token 合法性接口</span></span></span></code></pre>                            <h5 id="创建用户客户端项目">创建用户客户端项目</h5>                            <p>上面创建完成了认证服务端，下面开始创建一个客户端，对应到我们系统中的业务相关的微服务。我们假设这个微服务项目是管理用户相关数据的，所以叫做用户客户端。</p>                            <p>1、引用相关的 maven 包</p>                            <pre                                class="xml"><code class="hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>2、application.yml 配置文件</p>                            <pre                                class="yaml"><code class="hljs yaml"><span class="hljs-attr"><span class="hljs-attr">spring:</span><span class="hljs-attr"><span class="hljs-attr">  application:</span><span class="hljs-attr"><span class="hljs-attr">    name:</span> <span class="hljs-string"><span class="hljs-string">client-user</span><span class="hljs-attr"><span class="hljs-attr">  redis:</span><span class="hljs-attr"><span class="hljs-attr">    database:</span> <span class="hljs-number"><span class="hljs-number">2</span><span class="hljs-attr"><span class="hljs-attr">    host:</span> <span class="hljs-string"><span class="hljs-string">localhost</span><span class="hljs-attr"><span class="hljs-attr">    port:</span> <span class="hljs-number"><span class="hljs-number">32768</span><span class="hljs-attr"><span class="hljs-attr">    password:</span> <span class="hljs-number"><span class="hljs-number">1</span><span class="hljs-string"><span class="hljs-string">qaz@WSX</span><span class="hljs-attr"><span class="hljs-attr">    jedis:</span><span class="hljs-attr"><span class="hljs-attr">      pool:</span><span class="hljs-attr"><span class="hljs-attr">        max-active:</span> <span class="hljs-number"><span class="hljs-number">8</span><span class="hljs-attr"><span class="hljs-attr">        max-idle:</span> <span class="hljs-number"><span class="hljs-number">8</span><span class="hljs-attr"><span class="hljs-attr">        min-idle:</span> <span class="hljs-number"><span class="hljs-number">0</span><span class="hljs-attr"><span class="hljs-attr">    timeout:</span> <span class="hljs-number"><span class="hljs-number">100</span><span class="hljs-string"><span class="hljs-string">ms</span><span class="hljs-attr"><span class="hljs-attr">server:</span><span class="hljs-attr"><span class="hljs-attr">  port:</span> <span class="hljs-number"><span class="hljs-number">6101</span><span class="hljs-attr"><span class="hljs-attr">  servlet:</span><span class="hljs-attr"><span class="hljs-attr">    context-path:</span> <span class="hljs-string"><span class="hljs-string">/client-user</span><span class="hljs-attr"><span class="hljs-attr">security:</span><span class="hljs-attr"><span class="hljs-attr">  oauth2:</span><span class="hljs-attr"><span class="hljs-attr">    client:</span><span class="hljs-attr"><span class="hljs-attr">      client-id:</span> <span class="hljs-string"><span class="hljs-string">user-client</span><span class="hljs-attr"><span class="hljs-attr">      client-secret:</span> <span class="hljs-string"><span class="hljs-string">user-secret-8888</span><span class="hljs-attr"><span class="hljs-attr">      user-authorization-uri:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/authorize</span><span class="hljs-attr"><span class="hljs-attr">      access-token-uri:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token</span><span class="hljs-attr"><span class="hljs-attr">    resource:</span><span class="hljs-attr"><span class="hljs-attr">      id:</span> <span class="hljs-string"><span class="hljs-string">user-client</span><span class="hljs-attr"><span class="hljs-attr">      user-info-uri:</span> <span class="hljs-string"><span class="hljs-string">user-info</span><span class="hljs-attr"><span class="hljs-attr">    authorization:</span><span class="hljs-attr"><span class="hljs-attr">      check-token-access:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/check_token</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>上面是常规配置信息以及 redis 配置，重点是下面的 security 的配置，这里的配置稍有不注意就会出现 401 或者其他问题。</p>                            <p>client-id、client-secret 要和认证服务中的配置一致，如果是使用 inMemory 还是 jdbc 方式。</p>                            <p>user-authorization-uri 是授权码认证方式需要的，下一篇文章再说。</p>                            <p>access-token-uri 是密码模式需要用到的获取 token 的接口。</p>                            <p>authorization.check-token-access 也是关键信息，当此服务端接收到来自客户端端的请求后，需要拿着请求中的 token 到认证服务端做 token                                验证，就是请求的这个接口</p>                            <p>3、资源配置文件</p>                            <p>在 OAuth2 的概念里，所有的接口都被称为资源，接口的权限也就是资源的权限，所以 Spring Security OAuth2                                中提供了关于资源的注解&nbsp;<code>@EnableResourceServer</code>，和&nbsp;<code>@EnableWebSecurity</code>的作用类似。                            </p>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span><span class="hljs-meta"><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-meta"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span>)<span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceServerConfig</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Value</span>(<span class="hljs-string"><span class="hljs-string">"$&#123;security.oauth2.client.client-id&#125;"</span>)    <span class="hljs-keyword"><span class="hljs-keyword">private</span> String clientId;    <span class="hljs-meta"><span class="hljs-meta">@Value</span>(<span class="hljs-string"><span class="hljs-string">"$&#123;security.oauth2.client.client-secret&#125;"</span>)    <span class="hljs-keyword"><span class="hljs-keyword">private</span> String secret;    <span class="hljs-meta"><span class="hljs-meta">@Value</span>(<span class="hljs-string"><span class="hljs-string">"$&#123;security.oauth2.authorization.check-token-access&#125;"</span>)    <span class="hljs-keyword"><span class="hljs-keyword">private</span> String checkTokenEndpointUrl;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> RedisConnectionFactory redisConnectionFactory;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redisTokenStore</span> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory);    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> RemoteTokenServices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenService</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        RemoteTokenServices tokenService = <span class="hljs-keyword"><span class="hljs-keyword">new</span> RemoteTokenServices();        tokenService.setClientId(clientId);        tokenService.setClientSecret(secret);        tokenService.setCheckTokenEndpointUrl(checkTokenEndpointUrl);        <span class="hljs-keyword"><span class="hljs-keyword">return</span> tokenService;    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        resources.tokenServices(tokenService());    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>因为使用的是 redis 作为 token 的存储，所以需要特殊配置一下叫做 tokenService 的 Bean，通过这个 Bean 才能实现 token 的验证。</p>                            <p>4、最后，添加一个 RESTful 接口</p>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta"><span class="hljs-meta">@RestController</span><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string"><span class="hljs-string">"get"</span>)    <span class="hljs-comment"><span class="hljs-comment">//@PreAuthorize("hasAuthority('ROLE_ADMIN')")</span>    <span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string"><span class="hljs-string">"hasAnyRole('ROLE_ADMIN')"</span>)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication authentication)</span></span>&#123;        <span class="hljs-comment"><span class="hljs-comment">//Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span>        authentication.getCredentials();        OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails)authentication.getDetails();        String token = details.getTokenValue();        <span class="hljs-keyword"><span class="hljs-keyword">return</span> token;    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>一个 RESTful 方法，只有当访问用户具有 ROLE_ADMIN 权限时才能访问，否则返回 401 未授权。</p>                            <p>通过 Authentication                                参数或者&nbsp;<code>SecurityContextHolder.getContext().getAuthentication()</code>&nbsp;可以拿到授权信息进行查看。                            </p>                            <h5 id="测试认证功能">测试认证功能</h5>                            <p>1、启动认证服务端，启动端口为 6001</p>                            <p>2、启动用户服务客户端，启动端口为6101</p>                            <p>3、请求认证服务端获取 token</p>                            <p>我是用 REST Client 来做访问请求的，请求格式如下：</p>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-string"><span class="hljs-string">POST</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token?grant_type=password&amp;username=admin&amp;password=123456&amp;scope=all</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">Basic</span> <span class="hljs-string"><span class="hljs-string">dXNlci1jbGllbnQ6dXNlci1zZWNyZXQtODg4OA==</span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>假设咱们在一个 web 端使用，grant_type 是 password，表明这是使用 OAuth2 的密码模式。</p>                            <p>username=admin 和 password=123456 就相当于在 web 端登录界面输入的用户名和密码，我们在认证服务端配置中固定了用户名是 admin 、密码是                                123456，而线上环境中则应该通过查询数据库获取。</p>                            <p>scope=all 是权限有关的，在认证服务的 OAuthConfig 中指定了 scope 为 all 。</p>                            <p>Authorization 要加在请求头中，格式为 Basic 空格 base64(clientId:clientSecret)，这个微服务客户端的 client-id 是                                user-client，client-secret 是 user-secret-8888，将这两个值通过冒号连接，并使用 base64                                编码(user-client:user-secret-8888)之后的值为 dXNlci1jbGllbnQ6dXNlci1zZWNyZXQtODg4OA==，可以通过                                https://www.sojson.com/base64.html 在线编码获取。</p>                            <p><img src="https://img2018.cnblogs.com/blog/273364/201910/273364-20191023100753748-945717226.png"                                    alt=""></p>                            <p>运行请求后，如果参数都正确的话，获取到的返回内容如下，是一段 json 格式</p>                            <pre class="json"><code class="hljs">&#123;  <span class="hljs-attr"><span class="hljs-attr">"access_token"</span>: <span class="hljs-string"><span class="hljs-string">"9f958300-5005-46ea-9061-323c9e6c7a4d"</span>,  <span class="hljs-attr"><span class="hljs-attr">"token_type"</span>: <span class="hljs-string"><span class="hljs-string">"bearer"</span>,  <span class="hljs-attr"><span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string"><span class="hljs-string">"0f5871f5-98f1-405e-848e-80f641bab72e"</span>,  <span class="hljs-attr"><span class="hljs-attr">"expires_in"</span>: <span class="hljs-number"><span class="hljs-number">3599</span>,  <span class="hljs-attr"><span class="hljs-attr">"scope"</span>: <span class="hljs-string"><span class="hljs-string">"all"</span>&#125;</span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>access_token : &nbsp;就是之后请求需要带上的 token，也是本次请求的主要目的<br>token_type：为 bearer，这是 access token                                最常用的一种形式<br>refresh_token：之后可以用这个值来换取新的 token，而不用输入账号密码<br>expires_in：token 的过期时间(秒)</p>                            <p>4、用获取到的 token 请求资源接口</p>                            <p>我们在用户客户端中定义了一个接口 http://localhost:6101/client-user/get，现在就拿着上一步获取的 token 来请求这个接口。</p>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-string"><span class="hljs-string">GET</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6101/client-user/get</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">bearer</span> <span class="hljs-string"><span class="hljs-string">ce334918-e666-455a-8ecd-8bd680415d84</span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>同样需要请求头 Authorization，格式为 bearer + 空格 + token，正常情况下根据接口的逻辑，会把 token 原样返回。</p>                            <p>5、token 过期后，用 refresh_token 换取 access_token</p>                            <p>一般都会设置 access_token 的过期时间小于 refresh_token 的过期时间，以便在 access_token 过期后，不用用户再次登录的情况下，获取新的                                access_token。</p>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-comment"><span class="hljs-comment">### 换取 access_token</span><span class="hljs-string"><span class="hljs-string">POST</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token?grant_type=refresh_token&amp;refresh_token=706dac10-d48e-4795-8379-efe8307a2282</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">Basic</span> <span class="hljs-string"><span class="hljs-string">dXNlci1jbGllbnQ6dXNlci1zZWNyZXQtODg4OA==</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>grant_type 设置为 refresh_token。</p>                            <p>refresh_token 设置为请求 token 时返回的 refresh_token 的值。</p>                            <p>请求头加入 Authorization，格式依然是 Basic + 空格 + base64(client-id:client-secret)</p>                            <p>请求成功后会返回和请求 token 同样的数据格式。</p>                            <h5 id="用-jwt-替换-redistoken">用 JWT 替换 redisToken</h5>                            <p>上面 token 的存储用的是 redis 的方案，Spring Security OAuth2 还提供了 jdbc 和 jwt 的支持，jdbc 的暂不考虑，现在来介绍用                                JWT 的方式来实现 token 的存储。</p>                            <p>用 JWT 的方式就不用把 token 再存储到服务端了，JWT 有自己特殊的加密方式，可以有效的防止数据被篡改，只要不把用户密码等关键信息放到 JWT 里就可以保证安全性。                            </p>                            <p>认证服务端改造</p>                            <p>先把有关 redis 的配置去掉。</p>                            <h6 id="添加-jwtconfig-配置类">添加 JwtConfig 配置类</h6>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JwtTokenConfig</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtTokenStore</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtAccessTokenConverter</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        JwtAccessTokenConverter accessTokenConverter = <span class="hljs-keyword"><span class="hljs-keyword">new</span> JwtAccessTokenConverter();        accessTokenConverter.setSigningKey(<span class="hljs-string"><span class="hljs-string">"dev"</span>);        <span class="hljs-keyword"><span class="hljs-keyword">return</span> accessTokenConverter;    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p><code>JwtAccessTokenConverter</code>是为了做 JWT 数据转换，这样做是因为 JWT 有自身独特的数据格式。如果没有了解过 JWT                                ，可以搜索一下先了解一下。</p>                            <h6 id="更改-oauthconfig-配置类">更改 OAuthConfig 配置类</h6>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword"><span class="hljs-keyword">private</span> TokenStore jwtTokenStore;<span class="hljs-meta"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword"><span class="hljs-keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;<span class="hljs-meta"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> AuthorizationServerEndpointsConfigurer endpoints)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment"><span class="hljs-comment">/**         * 普通 jwt 模式         */</span>         endpoints.tokenStore(jwtTokenStore)                .accessTokenConverter(jwtAccessTokenConverter)                .userDetailsService(kiteUserDetailsService)                <span class="hljs-comment"><span class="hljs-comment">/**                 * 支持 password 模式                 */</span>                .authenticationManager(authenticationManager);&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>注入 JWT 相关的                                Bean，然后修改&nbsp;<code>configure(final AuthorizationServerEndpointsConfigurer endpoints)</code>&nbsp;方法为                                JWT 存储模式。</p>                            <p>改造用户客户端</p>                            <h6 id="修改-application.yml-配置文件">修改 application.yml 配置文件</h6>                            <pre                                class="yaml"><code class="hljs yaml"><span class="hljs-attr"><span class="hljs-attr">security:</span><span class="hljs-attr"><span class="hljs-attr">  oauth2:</span><span class="hljs-attr"><span class="hljs-attr">    client:</span><span class="hljs-attr"><span class="hljs-attr">      client-id:</span> <span class="hljs-string"><span class="hljs-string">user-client</span><span class="hljs-attr"><span class="hljs-attr">      client-secret:</span> <span class="hljs-string"><span class="hljs-string">user-secret-8888</span><span class="hljs-attr"><span class="hljs-attr">      user-authorization-uri:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/authorize</span><span class="hljs-attr"><span class="hljs-attr">      access-token-uri:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token</span><span class="hljs-attr"><span class="hljs-attr">    resource:</span><span class="hljs-attr"><span class="hljs-attr">      jwt:</span><span class="hljs-attr"><span class="hljs-attr">        key-uri:</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token_key</span><span class="hljs-attr"><span class="hljs-attr">        key-value:</span> <span class="hljs-string"><span class="hljs-string">dev</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>注意认证服务端&nbsp;<code>JwtAccessTokenConverter</code>设置的 SigningKey 要和配置文件中的 key-value                                相同，不然会导致无法正常解码 JWT ，导致验证不通过。</p>                            <h6 id="resourceserverconfig-类的配置">ResourceServerConfig 类的配置</h6>                            <pre                                class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span><span class="hljs-meta"><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-meta"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span>)<span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceServerConfig</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtTokenStore</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtAccessTokenConverter</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span> </span>&#123;        JwtAccessTokenConverter accessTokenConverter = <span class="hljs-keyword"><span class="hljs-keyword">new</span> JwtAccessTokenConverter();        accessTokenConverter.setSigningKey(<span class="hljs-string"><span class="hljs-string">"dev"</span>);        accessTokenConverter.setVerifierKey(<span class="hljs-string"><span class="hljs-string">"dev"</span>);        <span class="hljs-keyword"><span class="hljs-keyword">return</span> accessTokenConverter;    &#125;    <span class="hljs-meta"><span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword"><span class="hljs-keyword">private</span> TokenStore jwtTokenStore;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;        resources.tokenStore(jwtTokenStore);    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <h6 id="运行请求-token-接口的请求">运行请求 token 接口的请求</h6>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-string"><span class="hljs-string">POST</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6001/oauth/token?grant_type=password&amp;username=admin&amp;password=123456&amp;scope=all</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">Basic</span> <span class="hljs-string"><span class="hljs-string">dXNlci1jbGllbnQ6dXNlci1zZWNyZXQtODg4OA==</span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>返回结果如下：</p>                            <pre class="json"><code class="hljs">&#123;  <span class="hljs-attr"><span class="hljs-attr">"access_token"</span>: <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzE3NDM0OTQsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiI4Y2NhMjlhZi1lYTc3LTRmZTYtOWZlMS0zMjc0MTVkY2QyMWQiLCJjbGllbnRfaWQiOiJ1c2VyLWNsaWVudCIsInNjb3BlIjpbImFsbCJdfQ.0Ik3UwB1xjX2le5luEdtVAI_MEyu_OloRRYtPOvtvwM"</span>,  <span class="hljs-attr"><span class="hljs-attr">"token_type"</span>: <span class="hljs-string"><span class="hljs-string">"bearer"</span>,  <span class="hljs-attr"><span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiI4Y2NhMjlhZi1lYTc3LTRmZTYtOWZlMS0zMjc0MTVkY2QyMWQiLCJleHAiOjE1NzE3NzU4OTQsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiZjdkMjg4NDUtMmU2ZC00ZmRjLTg1OGYtMWNiY2RlNzI1ZmMyIiwiY2xpZW50X2lkIjoidXNlci1jbGllbnQifQ.vk_msYtbrAr93h5sK4wy6EC2_wRD_cD_UBS8O6eRziw"</span>,  <span class="hljs-attr"><span class="hljs-attr">"expires_in"</span>: <span class="hljs-number"><span class="hljs-number">3599</span>,  <span class="hljs-attr"><span class="hljs-attr">"scope"</span>: <span class="hljs-string"><span class="hljs-string">"all"</span>,  <span class="hljs-attr"><span class="hljs-attr">"jti"</span>: <span class="hljs-string"><span class="hljs-string">"8cca29af-ea77-4fe6-9fe1-327415dcd21d"</span>&#125;</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>我们已经看到返回的 token 是 JWT 格式了，到 JWT 在线解码网站&nbsp;<a class="uri"                                    href="https://jwt.io/">https://jwt.io/</a>&nbsp;或者&nbsp;<a class="uri"                                    href="http://jwt.calebb.net/">http://jwt.calebb.net/</a>将 token 解码看一下</p>                            <p><img src="https://img2018.cnblogs.com/blog/273364/201910/273364-20191023100809148-1936501614.png"                                    alt=""></p>                            <p>看到了没，user_name、client_id 等信息都在其中。</p>                            <h6 id="拿着返回的-token-请求用户客户端接口">拿着返回的 token 请求用户客户端接口</h6>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-string"><span class="hljs-string">GET</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6101/client-user/get</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">bearer</span> <span class="hljs-string"><span class="hljs-string">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzE3NDM0OTQsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiI4Y2NhMjlhZi1lYTc3LTRmZTYtOWZlMS0zMjc0MTVkY2QyMWQiLCJjbGllbnRfaWQiOiJ1c2VyLWNsaWVudCIsInNjb3BlIjpbImFsbCJdfQ.0Ik3UwB1xjX2le5luEdtVAI_MEyu_OloRRYtPOvtvwM</span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>增强 JWT</p>                            <p>如果我想在 JWT 中加入额外的字段(比方说用户的其他信息)怎么办呢，当然可以。spring security oauth2                                提供了&nbsp;<code>TokenEnhancer</code>&nbsp;增强器。其实不光 JWT ，RedisToken 的方式同样可以。</p>                            <h6 id="声明一个增强器">声明一个增强器</h6>                            <pre class="java"><code class="hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JWTokenEnhancer</span> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TokenEnhancer</span> </span>&#123;    <span class="hljs-meta"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enhance</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication)</span> </span>&#123;        Map&lt;String, Object&gt; info = <span class="hljs-keyword"><span class="hljs-keyword">new</span> HashMap&lt;&gt;();        info.put(<span class="hljs-string"><span class="hljs-string">"jwt-ext"</span>, <span class="hljs-string"><span class="hljs-string">"JWT 扩展信息"</span>);        ((DefaultOAuth2AccessToken) oAuth2AccessToken).setAdditionalInformation(info);        <span class="hljs-keyword"><span class="hljs-keyword">return</span> oAuth2AccessToken;    &#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>通过 oAuth2Authentication 可以拿到用户名等信息，通过这些我们可以在这里查询数据库或者缓存获取更多的信息，而这些信息都可以作为 JWT 扩展信息加入其中。                            </p>                            <h6 id="oauthconfig-配置类修改">OAuthConfig 配置类修改</h6>                            <p>注入增强器</p>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword"><span class="hljs-keyword">private</span> TokenEnhancer jwtTokenEnhancer;<span class="hljs-meta"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> TokenEnhancer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtTokenEnhancer</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword"><span class="hljs-keyword">return</span> <span class="hljs-keyword"><span class="hljs-keyword">new</span> JWTokenEnhancer();&#125;</span></span></span></span></span></span></span></span></span></code></pre>                            <p>修改&nbsp;<code>configure(final AuthorizationServerEndpointsConfigurer endpoints)</code>方法                            </p>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> AuthorizationServerEndpointsConfigurer endpoints )</span> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception</span>&#123;    <span class="hljs-comment"><span class="hljs-comment">/**     * jwt 增强模式     */</span>    TokenEnhancerChain  enhancerChain   = <span class="hljs-keyword"><span class="hljs-keyword">new</span> TokenEnhancerChain();    List&lt;TokenEnhancer&gt; enhancerList    = <span class="hljs-keyword"><span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    enhancerList.add( jwtTokenEnhancer );    enhancerList.add( jwtAccessTokenConverter );    enhancerChain.setTokenEnhancers( enhancerList );    endpoints.tokenStore( jwtTokenStore )    .userDetailsService( kiteUserDetailsService )    <span class="hljs-comment"><span class="hljs-comment">/**     * 支持 password 模式     */</span>    .authenticationManager( authenticationManager )    .tokenEnhancer( enhancerChain )    .accessTokenConverter( jwtAccessTokenConverter );&#125;</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <h6 id="再次请求-token-返回内容中多了个刚刚加入的-jwt-ext-字段">再次请求 token ，返回内容中多了个刚刚加入的 jwt-ext 字段</h6>                            <pre class="json"><code class="hljs">&#123;  <span class="hljs-attr"><span class="hljs-attr">"access_token"</span>: <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsImp3dC1leHQiOiJKV1Qg5omp5bGV5L-h5oGvIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTU3MTc0NTE3OCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiJhNDU1MWQ5ZS1iN2VkLTQ3NTktYjJmMS1mMGI5YjIxY2E0MmMiLCJjbGllbnRfaWQiOiJ1c2VyLWNsaWVudCJ9.5j4hNsVpktG2iKxNqR-q1rfcnhlyV3M6HUBx5cd6PiQ"</span>,  <span class="hljs-attr"><span class="hljs-attr">"token_type"</span>: <span class="hljs-string"><span class="hljs-string">"bearer"</span>,  <span class="hljs-attr"><span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsImp3dC1leHQiOiJKV1Qg5omp5bGV5L-h5oGvIiwic2NvcGUiOlsiYWxsIl0sImF0aSI6ImE0NTUxZDllLWI3ZWQtNDc1OS1iMmYxLWYwYjliMjFjYTQyYyIsImV4cCI6MTU3MTc3NzU3OCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiJmNTI3ODJlOS0wOGRjLTQ2NGUtYmJhYy03OTMwNzYwYmZiZjciLCJjbGllbnRfaWQiOiJ1c2VyLWNsaWVudCJ9.UQMf140CG8U0eWh08nGlctpIye9iJ7p2i6NYHkGAwhY"</span>,  <span class="hljs-attr"><span class="hljs-attr">"expires_in"</span>: <span class="hljs-number"><span class="hljs-number">3599</span>,  <span class="hljs-attr"><span class="hljs-attr">"scope"</span>: <span class="hljs-string"><span class="hljs-string">"all"</span>,  <span class="hljs-attr"><span class="hljs-attr">"jwt-ext"</span>: <span class="hljs-string"><span class="hljs-string">"JWT 扩展信息"</span>,  <span class="hljs-attr"><span class="hljs-attr">"jti"</span>: <span class="hljs-string"><span class="hljs-string">"a4551d9e-b7ed-4759-b2f1-f0b9b21ca42c"</span>&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>用户客户端解析 JWT 数据</p>                            <p>我们如果在 JWT 中加入了额外信息，这些信息我们可能会用到，而在接收到 JWT 格式的 token 之后，用户客户端要把 JWT 解析出来。</p>                            <h6 id="引入-jwt-包">引入 JWT 包</h6>                            <pre                                class="xml"><code class="hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span>&gt;</span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span>&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <h6 id="加一个-restful-接口在其中解析-jwt">加一个 RESTful 接口，在其中解析 JWT</h6>                            <pre class="java"><code class="hljs"><span class="hljs-meta"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string"><span class="hljs-string">"jwt"</span>)<span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string"><span class="hljs-string">"hasAnyRole('ROLE_ADMIN')"</span>)<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jwtParser</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication authentication)</span></span>&#123;    authentication.getCredentials();    OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails)authentication.getDetails();    String jwtToken = details.getTokenValue();    Claims claims = Jwts.parser()                .setSigningKey(<span class="hljs-string"><span class="hljs-string">"dev"</span>.getBytes(StandardCharsets.UTF_8))                .parseClaimsJws(jwtToken)                .getBody();    <span class="hljs-keyword"><span class="hljs-keyword">return</span> claims;&#125;</span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>同样注意其中签名的设置要与认证服务端相同。</p>                            <h6 id="用上一步的-token-请求上面的接口">用上一步的 token 请求上面的接口</h6>                            <pre                                class="properties"><code class="hljs yaml"><span class="hljs-comment"><span class="hljs-comment">### 解析 jwt</span><span class="hljs-string"><span class="hljs-string">GET</span> <span class="hljs-attr"><span class="hljs-attr">http://localhost:6101/client-user/jwt</span><span class="hljs-attr"><span class="hljs-attr">Accept:</span> <span class="hljs-string"><span class="hljs-string">*/*</span><span class="hljs-attr"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal"><span class="hljs-literal">no</span><span class="hljs-bullet"><span class="hljs-bullet">-cache</span><span class="hljs-attr"><span class="hljs-attr">Authorization:</span> <span class="hljs-string"><span class="hljs-string">bearer</span> <span class="hljs-string"><span class="hljs-string">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsImp3dC1leHQiOiJKV1Qg5omp5bGV5L-h5oGvIiwic2NvcGUiOlsiYWxsIl0sImV4cCI6MTU3MTc0NTE3OCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiJhNDU1MWQ5ZS1iN2VkLTQ3NTktYjJmMS1mMGI5YjIxY2E0MmMiLCJjbGllbnRfaWQiOiJ1c2VyLWNsaWVudCJ9.5j4hNsVpktG2iKxNqR-q1rfcnhlyV3M6HUBx5cd6PiQ</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>返回内容如下：</p>                            <pre class="json"><code class="hljs">&#123;  <span class="hljs-attr"><span class="hljs-attr">"user_name"</span>: <span class="hljs-string"><span class="hljs-string">"admin"</span>,  <span class="hljs-attr"><span class="hljs-attr">"jwt-ext"</span>: <span class="hljs-string"><span class="hljs-string">"JWT 扩展信息"</span>,  <span class="hljs-attr"><span class="hljs-attr">"scope"</span>: [    <span class="hljs-string"><span class="hljs-string">"all"</span>  ],  <span class="hljs-attr"><span class="hljs-attr">"exp"</span>: <span class="hljs-number"><span class="hljs-number">1571745178</span>,  <span class="hljs-attr"><span class="hljs-attr">"authorities"</span>: [    <span class="hljs-string"><span class="hljs-string">"ROLE_ADMIN"</span>  ],  <span class="hljs-attr"><span class="hljs-attr">"jti"</span>: <span class="hljs-string"><span class="hljs-string">"a4551d9e-b7ed-4759-b2f1-f0b9b21ca42c"</span>,  <span class="hljs-attr"><span class="hljs-attr">"client_id"</span>: <span class="hljs-string"><span class="hljs-string">"user-client"</span>&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>                            <p>以上就是 password 模式的完整过程，源码放到了 github 上，有需要的可以去看一下。</p>                            <p><a href="https://github.com/huzhicheng/spring-cloud-study/tree/master/oauth2">源码地址</a>                            </p>                        </div>                        <div id="MySignature"></div>                        <div class="clear"></div>                    </div>                </div>                <script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>                <script>markdown_highlight();</script>                <script>                    var allowComments = true, cb_blogId = 438378, cb_blogApp = 'panchanggui', cb_blogUserGuid = '1bc14d5f-785e-44c0-926d-08d5cee46ae6';                    var cb_entryId = 12222131, cb_entryCreatedDate = '2020-01-21 16:12', cb_postType = 1;                    loadViewCount(cb_entryId);                </script><a name="!comments"></a>                <div id="blog-comments-placeholder"></div>                <script>                    var commentManager = new blogCommentManager();                    commentManager.renderComments(0);                </script>            </div>        </div>    </div></body></html>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>02-Oauth2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Logstash安装</title>
    <link href="/08-Elasticsearch/02-Logstash/02-Logstash%E5%AE%89%E8%A3%85/"/>
    <url>/08-Elasticsearch/02-Logstash/02-Logstash%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Logstash安装和使用-配合logback"><a href="#Logstash安装和使用-配合logback" class="headerlink" title="Logstash安装和使用(配合logback)"></a>Logstash安装和使用(配合logback)</h1><h2 id="一、Docker安装"><a href="#一、Docker安装" class="headerlink" title="一、Docker安装"></a>一、Docker安装</h2><p>这里只涉及Docker-compose的安装</p><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">logstash:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">logstash:7.9.0</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">logstash</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">MONITORING_ELASTICSEARCH_HOSTS=http://es-master:9200</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">XPACK_MONITORING_ENABLED=false</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">4560</span><span class="hljs-string">:4560</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9600</span><span class="hljs-string">:9600</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./pipeline/:/usr/share/logstash/pipeline/</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">docker:</span>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span></code></pre><p><code>logstash.conf</code></p><pre><code class="hljs conf">input &#123;  tcp &#123;        port &#x3D;&gt; 4560        codec &#x3D;&gt; &quot;json&quot;    &#125;&#125;output &#123;    elasticsearch &#123;        action &#x3D;&gt; &quot;index&quot;        hosts &#x3D;&gt; [&quot;es-master:9200&quot;]        index &#x3D;&gt; &quot;%&#123;[app_name]&#125;&quot;    &#125;&#125;</code></pre><h2 id="二、Spring配置"><a href="#二、Spring配置" class="headerlink" title="二、Spring配置"></a>二、Spring配置</h2><p><code>application.yml</code></p><p>注意端口与上文一致，此处两个配置都会被logback读取</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><span class="hljs-attr">logstash:</span>  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost:4560</span></code></pre><p>添加依赖到<code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.logstash.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;logstash.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置logback<code>logback-spring.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 从Spring中读取属性 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;applicationName&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;spring.application.name&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logstash_host&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;logstash.host&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 文件日志格式 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;[%6level] [%X&#123;X-B3-TraceId:-&#125;,%X&#123;X-B3-SpanId:-&#125;] [%thread] %logger&#123;40&#125;: %msg%n&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 保存路径 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/opt/logs/$&#123;applicationName&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOGSTASH&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">destination</span>&gt;</span>$&#123;logstash_host&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">destination</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">customFields</span>&gt;</span>&#123;&quot;app_name&quot;:&quot;$&#123;applicationName&#125;&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">customFields</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 文件INFO日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span></span><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/info_%d&#123;yyyyMMdd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- INFO保存N天 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- filter: ACCEPT接受 NEUTRAL中立(传到下一个)filter DENY:终止 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 文件ERROR日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span></span><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/error_%d&#123;yyyyMMdd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- ERROR保存N天 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 日志屏蔽级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.netflix&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sun.rmi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.sun&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.lettuce&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.netty&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;springfox.documentation&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atomikos&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.rabbitmq.client.impl.ForgivingExceptionHandler&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.alibaba.nacos&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 控制台日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置dev下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LOGSTASH&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置test下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LOGSTASH&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置prod下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LOGSTASH&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h2 id="三、效果验证"><a href="#三、效果验证" class="headerlink" title="三、效果验证"></a>三、效果验证</h2><p>kibana中会出现一个以应用命名的index</p><p><img src="../images/%E6%88%AA%E5%B1%8F2020-09-03%2017.24.55.png"></p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>02-Logstash</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-搭建Eureka</title>
    <link href="/01-Java/05-MicroService/05-Eureka/02-%E6%90%AD%E5%BB%BAEureka/"/>
    <url>/01-Java/05-MicroService/05-Eureka/02-%E6%90%AD%E5%BB%BAEureka/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Eureka"><a href="#搭建Eureka" class="headerlink" title="搭建Eureka"></a>搭建Eureka</h1><p>全文参考<a href="https://spring.io/guides/gs/service-registration-and-discovery/">Spring-cloud官方文档</a></p><h2 id="一、Eureka-Server"><a href="#一、Eureka-Server" class="headerlink" title="一、Eureka Server"></a>一、Eureka Server</h2><h3 id="1-搭建Eureka-Server"><a href="#1-搭建Eureka-Server" class="headerlink" title="1. 搭建Eureka Server"></a>1. 搭建Eureka Server</h3><p><code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-registration-and-discovery-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>service-registration-and-discovery-service<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><code>ServiceRegistrationAndDiscoveryServiceApplication.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.serviceregistrationanddiscoveryservice;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceRegistrationAndDiscoveryServiceApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceRegistrationAndDiscoveryServiceApplication.class, args);    &#125;&#125;</code></pre><p><code>application.yml</code></p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 不将自己注册为Client端（根据实际需求来定，也可以将自己作为client的）</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 不作为Client端去从Server获取注册表</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span></code></pre><h3 id="2-测试Eureka-Server"><a href="#2-测试Eureka-Server" class="headerlink" title="2. 测试Eureka Server"></a>2. 测试Eureka Server</h3><p>访问<a href="localhost:8761">localhost:8761</a></p><p><img src="../images/%E6%88%AA%E5%B1%8F2020-09-03%2010.55.08.png"></p><h2 id="二、Eureka-Client"><a href="#二、Eureka-Client" class="headerlink" title="二、Eureka Client"></a>二、Eureka Client</h2><h3 id="1-搭建Eureka-Client"><a href="#1-搭建Eureka-Client" class="headerlink" title="1. 搭建Eureka Client"></a>1. 搭建Eureka Client</h3><p><code>pom.xml</code></p><p>比Server多了一个依赖<code>spring-cloud-starter-netflix-eureka-client</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-registration-and-discovery-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>service-registration-and-discovery-client<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><code>ServiceRegistrationAndDiscoveryClientApplication.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.serviceregistrationanddiscoveryclient;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.cloud.client.ServiceInstance;<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceRegistrationAndDiscoveryClientApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ServiceRegistrationAndDiscoveryClientApplication.class, args);    &#125;&#125;<span class="hljs-meta">@RestController</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceInstanceRestController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;    <span class="hljs-comment">// 一个用于测试的RequestMapping，discoveryClient是从服务端同步过来的信息</span>    <span class="hljs-meta">@RequestMapping(&quot;/service-instances/&#123;applicationName&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title">serviceInstancesByApplicationName</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@PathVariable</span> String applicationName)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.discoveryClient.getInstances(applicationName);    &#125;&#125;</code></pre><p>⚠️注意：<code>bootstrap.yml</code></p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-client</span></code></pre><h3 id="2-测试Eureka-Client"><a href="#2-测试Eureka-Client" class="headerlink" title="2. 测试Eureka Client"></a>2. 测试Eureka Client</h3><ol><li>访问<a href="localhost:8761">localhost:8761</a> 发现多个instance<br><img src="../images/%E6%88%AA%E5%B1%8F2020-09-03%2011.07.12.png"></li><li>访问<a href="http://localhost:8080/service-instances/eureka-client">http://localhost:8080/service-instances/eureka-client</a><br><img src="../images/%E6%88%AA%E5%B1%8F2020-09-03%2011.09.01.png"></li></ol><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>Eureka作为注册中心的最佳实践是，Client和Server都在微服务应用之上去构建吗，虽然想想也挺合理的，但是又总觉得哪里怪怪的。这个设计还是有点出乎我的意料，具体的最佳实践是单独起几个Eureka的Server呢，还是全都依赖于应用，实现最简单的部署？</p><p>带着疑问继续学习吧，冲鸭。。。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>05-Eureka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Eureka原理和架构</title>
    <link href="/01-Java/05-MicroService/05-Eureka/01-Eureka%E5%8E%9F%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84/"/>
    <url>/01-Java/05-MicroService/05-Eureka/01-Eureka%E5%8E%9F%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Eureka原理和架构"><a href="#Eureka原理和架构" class="headerlink" title="Eureka原理和架构"></a>Eureka原理和架构</h1><p>Eureka是一个服务发现与注册的中心。官方原话如下：</p><div class="note note-success">            <p>In the cloud, applications can’t always know the exact location of other services. A service registry, such as <a href="https://github.com/Netflix/eureka">Netflix Eureka</a>, or a sidecar solution, such as <a href="https://www.consul.io/">HashiCorp Consul</a>, can help. Spring Cloud provides DiscoveryClient implementations for popular registries such as Eureka, Consul, Zookeeper, and even Kubernetes’ built-in system. There’s also a Spring Cloud Load Balancer to help you distribute the load carefully among your service instances.</p>          </div><h2 id="一、Eureka-和-consul比较"><a href="#一、Eureka-和-consul比较" class="headerlink" title="一、Eureka 和 consul比较"></a>一、Eureka 和 consul比较</h2><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/yjmyzz/p/replace-eureka-with-consul.html">spring cloud: 使用consul来替换eureka</a>  </li><li><a href="https://blog.csdn.net/fly910905/article/details/100023415">微服务：注册中心ZooKeeper、Eureka、Consul 、Nacos对比</a>  </li><li><a href="https://www.cnblogs.com/zhucww/p/11532770.html">consul、eureka、nacos对比</a>  </li></ul><p>总结：</p><ul><li>Eureka是Spring首推的，由netflix公司开发的服务发现&amp;注册中心，但因为Eureka2.X项目流产，所以业内也是人心惶惶。Eureka是强烈依赖于Spring-Cloud的微服务体系的，属于应用内部署。</li><li>Consul是HashiCorp公司用Go语言写的，产品能力比较强，但是普遍反应坑比较多。</li></ul><p>值得注意的是，2018年阿里巴巴开源了<a href="https://nacos.io/">Nacos</a>，其拥有各家之长，并且拥有配置中心（之前携程开源的<a href="https://github.com/ctripcorp/apollo">Apollo</a>配置中心也是比较复杂难用的），感觉是新的趋势。</p><h2 id="二、服务注册中心的CAP原则"><a href="#二、服务注册中心的CAP原则" class="headerlink" title="二、服务注册中心的CAP原则"></a>二、服务注册中心的CAP原则</h2><div class="note note-info">            <ul><li>一致性(Consistency) (所有节点在同一时间具有相同的数据) – [质量好]</li><li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)  – [速度快]</li><li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ul>          </div><p>AC为相互矛盾点，若C一致性要求高，需要确定其他节点状态并且做数据同步，不然请求结果会有差异，可用性就会受到影响；<br>若A可用性要求高，只要有一个节点存在即返回数据，即使数据可能是滞后的，一致性性受到影响。</p><ul><li>CP：适合写数据的场景，但由于强一致性，可能会导致较长时间的服务注册等待/不可用等（中央集权，所有人听中央的）</li><li>AP：适合业务重要性高的场景，保证每个节点都能对外提供服务，但不保证每个节点得到的数据是一致的（联邦共和，相互协商）</li></ul><h2 id="三、Eureka架构"><a href="#三、Eureka架构" class="headerlink" title="三、Eureka架构"></a>三、Eureka架构</h2><p><a href="https://blog.csdn.net/qwe86314/article/details/94552801">Eureka工作原理</a></p><p><img src="../images/20190703102014756.png"></p><h3 id="1-Server-Server"><a href="#1-Server-Server" class="headerlink" title="1. Server-Server"></a>1. Server-Server</h3><ul><li>Replicate 副本<ul><li>平级关系，没有主从，相互注册</li><li>从其他节点获得所有的注册信息完成初始化，并在后期不断同步</li><li>相互发送心跳，其中一个Server掉线后，其它节点接管所有的注册信息</li></ul></li></ul><h3 id="2-Server-Provider-Client"><a href="#2-Server-Provider-Client" class="headerlink" title="2. Server-Provider(Client)"></a>2. Server-Provider(Client)</h3><ul><li>Register 服务注册：Provider提供自身的元数据，比如 IP 地址、端口，运行状况指示符 URL，主页等 向Server注册自己的信息</li><li>Renew 服务续约：Provider每隔<code>30</code>秒发送一次心跳来续约，Server在<code>90</code>秒内没有收到续约，Server端会将实例从其注册表中删除</li><li>Cancel 服务下线：Provider程序关闭时向Server发送下线请求，Server从实例注册表中删除</li></ul><p><strong>Server端配置</strong></p><pre><code class="hljs properties"><span class="hljs-comment"># 服务续约任务的调用间隔时间，默认为30秒</span><span class="hljs-meta">eureka.instance.lease-renewal-interval-in-seconds</span>=<span class="hljs-string">30</span><span class="hljs-comment"># 服务失效的时间，默认为90秒。</span><span class="hljs-meta">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="hljs-string">90</span></code></pre><h3 id="3-Server-Consumer-Client"><a href="#3-Server-Consumer-Client" class="headerlink" title="3. Server-Consumer(Client)"></a>3. Server-Consumer(Client)</h3><ul><li>GetRegisty 获取注册列表信息：Consumer从服务器获取注册表信息，并将其缓存在本地，通过注册信息来寻找Provider 每30秒更新/服务不可用时更新</li></ul><p><strong>Client端配置</strong></p><pre><code class="hljs properties"><span class="hljs-comment"># 启用服务消费者从注册中心拉取服务列表的功能</span><span class="hljs-meta">eureka.client.fetch-registry</span>=<span class="hljs-string">true</span><span class="hljs-comment"># 设置服务消费者从注册中心拉取服务列表的间隔</span><span class="hljs-meta">eureka.client.registry-fetch-interval-seconds</span>=<span class="hljs-string">30</span></code></pre><h3 id="4-自我保护机制"><a href="#4-自我保护机制" class="headerlink" title="4. 自我保护机制"></a>4. 自我保护机制</h3><p>如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册表中移除因为长时间没有收到心跳而过期的服务；</li><li>Eureka仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用）；</li><li>当网络稳定时，当前实例新注册的信息会被同步到其它节点中；</li></ol><p>自我保护机制<strong>Server端配置</strong>（默认开启）</p><pre><code class="hljs properties"><span class="hljs-comment"># Server端开启自我保护机制</span><span class="hljs-meta">eureka.server.enable-self-preservation</span>=<span class="hljs-string">true</span></code></pre><p>开启自我保护之后的Server界面</p><p><img src="../images/20190703103514416.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>Eureka 通过<code>自我保护机制</code>, <code>Replicate</code>等机制，简单又高效地保证了服务的高可用性；</li><li>Eureka 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， Client-Server 间的数据可能不一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>05-Eureka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-Set总结</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/99-Set%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/99-Set%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="List接口总结"><a href="#List接口总结" class="headerlink" title="List接口总结"></a>List接口总结</h1><ul><li>相同点<ul><li>都不能重复元素</li><li>都不是线程安全的类,线程安全使用<code>Collections.synchronizedSet(new XXXSet&lt;&gt;())</code></li></ul></li></ul><h2 id="HashSet-不保证添加顺序"><a href="#HashSet-不保证添加顺序" class="headerlink" title="HashSet - 不保证添加顺序"></a>HashSet - 不保证添加顺序</h2><ul><li>判断相同的方法<ol><li>hashCode()</li><li>equals()</li></ol></li></ul><h2 id="LinkedHashSet-保证添加顺序"><a href="#LinkedHashSet-保证添加顺序" class="headerlink" title="LinkedHashSet - 保证添加顺序"></a>LinkedHashSet - 保证添加顺序</h2><ul><li>判断相同的方法<ol><li>hashCode()</li><li>equals()</li></ol></li></ul><h2 id="TreeSet-不保存添加顺序，需要排序（实现Comparable-传入Comparator的实现类作为构造参数）"><a href="#TreeSet-不保存添加顺序，需要排序（实现Comparable-传入Comparator的实现类作为构造参数）" class="headerlink" title="TreeSet - 不保存添加顺序，需要排序（实现Comparable/传入Comparator的实现类作为构造参数）"></a>TreeSet - 不保存添加顺序，需要排序（实现Comparable/传入Comparator的实现类作为构造参数）</h2><ul><li>判断相同的方法<ol><li>compareTo()</li><li>compare()</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>04-Set</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-Map总结</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/05-Map/99-Map%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/05-Map/99-Map%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Map总结"><a href="#Map总结" class="headerlink" title="Map总结"></a>Map总结</h1><ul><li>相同点<ul><li>key不能重复</li><li>value可重复</li></ul></li></ul><h2 id="HashMap-不保证添加顺序"><a href="#HashMap-不保证添加顺序" class="headerlink" title="HashMap - 不保证添加顺序"></a>HashMap - 不保证添加顺序</h2><ul><li>判断相同的方法<ol><li>hashCode()</li><li>equals()</li></ol></li></ul><h2 id="LinkedHashMap-保证key添加顺序"><a href="#LinkedHashMap-保证key添加顺序" class="headerlink" title="LinkedHashMap - 保证key添加顺序"></a>LinkedHashMap - 保证key添加顺序</h2><ul><li>判断相同的方法<ol><li>hashCode()</li><li>equals()</li></ol></li></ul><h2 id="TreeMap-不保存key添加顺序，需要排序（实现Comparable-传入Comparator的实现类作为构造参数）"><a href="#TreeMap-不保存key添加顺序，需要排序（实现Comparable-传入Comparator的实现类作为构造参数）" class="headerlink" title="TreeMap - 不保存key添加顺序，需要排序（实现Comparable/传入Comparator的实现类作为构造参数）"></a>TreeMap - 不保存key添加顺序，需要排序（实现Comparable/传入Comparator的实现类作为构造参数）</h2><ul><li>判断相同的方法<ol><li>compareTo()</li><li>compare()</li></ol></li></ul><h2 id="Hashtable-–-不要怀疑，这个t真的是小写的"><a href="#Hashtable-–-不要怀疑，这个t真的是小写的" class="headerlink" title="Hashtable – 不要怀疑，这个t真的是小写的"></a>Hashtable – 不要怀疑，这个t真的是小写的</h2><p>线程安全的HashMap，但不建议使用</p><p>建议使用<code>Map map = Collections.synchronizedMap(new HashMap(...));</code></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>限制类型的HashTable&lt;String,String&gt;</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>05-Map</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-List总结</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/99-List%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/99-List%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="List总结"><a href="#List总结" class="headerlink" title="List总结"></a>List总结</h1><ul><li>List接口特点：<ul><li>允许重复</li><li>有序</li></ul></li></ul><h2 id="Vector和ArrayList"><a href="#Vector和ArrayList" class="headerlink" title="Vector和ArrayList"></a><code>Vector</code>和<code>ArrayList</code></h2><ul><li>相同点：使用数组实现</li><li>不同点：<ul><li>Vector<strong>线程安全</strong>，性能相对较差</li><li>ArrayList<strong>线程不安全</strong>，性能相对较好</li></ul></li></ul><h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a><code>ArrayList</code>和<code>LinkedList</code></h2><ul><li>相同点：都是线程不安全</li><li>不同点：<ul><li>ArrayList使用数组实现，易于查询，不易于插入</li><li>LinkedList使用双向链表实现，易于插入，不易于查询</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>01-List</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-HashSet</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/01-HashSet/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/01-HashSet/</url>
    
    <content type="html"><![CDATA[<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><div class="note note-success">            <p>请结合<a href="../../05-Map/01-HashMap/">HashMap</a>食用，效果更佳</p>          </div><p>HashSet的实现，HashMap使用的是Hash表将数据存储在数组中，根据HashCode和数据的索引进行映射，能够快速存储（小量）和检索数据</p><p>由于HashCode为6位int，而数组长度太大会导致内存浪费，因此map并不是按照Hashcode直接存的，而是进行了映射。</p><p>默认HashMap中<strong>默认容量(Capacity)16</strong>和<strong>负载因子(Load factor)0.75</strong>，当存储的数量大于容量*负载因子时进行翻倍的扩容。</p><ol><li>put函数的实现<ol><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果HashCode()相等，且equal()为false，以链表的形式存在buckets后；</li><li>如果hashCode()相等，且equal()而true, 替换old value(保证key的唯一性)</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol></li><li>get函数的实现<ol><li>bucket里的第一个节点，如果有冲突，则通过key.equals(k)去查找对应的entry</li><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ol></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">大神的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>04-Set</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-jdk5</title>
    <link href="/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/01-jdk5/01-jdk5/"/>
    <url>/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/01-jdk5/01-jdk5/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK5新特性"><a href="#JDK5新特性" class="headerlink" title="JDK5新特性"></a>JDK5新特性</h1><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>语法糖，【不推荐使用】</p><h3 id="import的基本知识"><a href="#import的基本知识" class="headerlink" title="import的基本知识"></a>import的基本知识</h3><pre><code class="hljs java"><span class="hljs-comment">// 不需要引入的类</span>java.lang.*<span class="hljs-comment">// 相同包下的类</span><span class="hljs-comment">// *表示使用到的类，而不是该包下所有的类</span><span class="hljs-keyword">import</span> java.util.*</code></pre><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>可以将静态成员变量或方法进行静态导入，从而实现无需类名调用</p><pre><code class="hljs java"><span class="hljs-comment">// 原本的调用方法</span><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;System.out.println(StandardCharsets.UTF_8);<span class="hljs-comment">// 新特性做法</span><span class="hljs-comment">// 引入静态成员</span><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.nio.charset.StandardCharsets.UTF_8;System.out.println(UTF_8);<span class="hljs-comment">// 引入静态方法</span><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Arrays.asList;asList(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]);</code></pre><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>语法糖，原理解析，在调用方法时多参自动封装成数组<code>method(1,2,3)-&gt;method(new int[]&#123;1,2,3&#125;)</code></p><ul><li><code>String... strings</code>可以传递多参，可以传递数组</li><li>【注意】<code>String[] strings</code>只能传递数组，不能传递多参</li><li>【注意】可变参数必须作为最后一个参数</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(String... strings)</span></span>&#123;...&#125;<span class="hljs-comment">// 调用方式一</span>method(<span class="hljs-string">&quot;string1&quot;</span>,<span class="hljs-string">&quot;string2&quot;</span>);<span class="hljs-comment">// 调用方式二</span>String[] strings = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;string1&quot;</span>,<span class="hljs-string">&quot;string2&quot;</span>&#125;;method(strings);</code></pre><h2 id="for-each和Interator"><a href="#for-each和Interator" class="headerlink" title="for-each和Interator"></a>for-each和Interator</h2><p>for-each使用范围</p><ol><li>数组</li><li>Collection的实现类，List，Set（实现了Iterable）</li><li>Map(Map自己的方法)</li></ol><ul><li>注意，在需要删除集合中的元素时需要使用Iterator</li></ul><p>迭代器使用新的线程实现，在进行迭代时会通过检查迭代器线程的元素数量是否与主线程的元素数量相同，不相同则抛出并发异常<code>ConcurrentModificationException</code></p><pre><code class="hljs java"><span class="hljs-comment">// 删除元素，方式一</span>Iterator&lt;String&gt; iterator = list.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;    String item = iterator.next();    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Hello&quot;</span>.equals(item)) &#123;        iterator.remove();    &#125;&#125;<span class="hljs-comment">// 删除元素，方式二（循环结束回收变量）</span><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();)&#123;    String item = iterator.next();    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Hello&quot;</span>.equals(item)) &#123;        iterator.remove();    &#125;&#125;<span class="hljs-comment">// 删除元素，方式三</span>list.removeIf(<span class="hljs-string">&quot;Hello&quot;</span>::equals);</code></pre><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p><a href="../../../02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/00-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/">面向对象总结</a><br><a href="../../../01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">基本数据类型</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><a href="../../../03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/03-%E6%B3%9B%E5%9E%8B/01-%E6%B3%9B%E5%9E%8B/">泛型</a></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><a href="../../../01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E6%9E%9A%E4%B8%BEEnum/">枚举Enum</a></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><a href="../../../05-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3/">注解</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>09-语言新特性</category>
      
      <category>01-jdk5</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Jackson的使用和注解</title>
    <link href="/01-Java/99-Others/03-Json/03-Jackson/01-Jackson%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/01-Java/99-Others/03-Json/03-Jackson/01-Jackson%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Jacksson是什么"><a href="#Jacksson是什么" class="headerlink" title="Jacksson是什么"></a>Jacksson是什么</h1><p>Jackson是SpringBoot内置的处理json的包，因此别再引入Gson来作为json解析工具了，很撒逼。</p><h2 id="Jackson的使用"><a href="#Jackson的使用" class="headerlink" title="Jackson的使用"></a>Jackson的使用</h2><h3 id="java转Json"><a href="#java转Json" class="headerlink" title="java转Json"></a>java转Json</h3><ul><li>ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</li><li>ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。<ul><li>writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</li><li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</li><li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</li><li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</li></ul></li></ul><pre><code class="hljs java">ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();String json = mapper.writeValueAsString(user);</code></pre><h3 id="json转java"><a href="#json转java" class="headerlink" title="json转java"></a>json转java</h3><ul><li>ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。</li></ul><pre><code class="hljs java">ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();User user = mapper.readValue(json, User.class);</code></pre><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>&#123;    <span class="hljs-comment">// 这个值将不会被保存到json中传到前台</span>    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> planID;    <span class="hljs-comment">// ALWAYS, 总是返回（默认）</span>    <span class="hljs-comment">// NON_NULL, 字段为空时不返回</span>    <span class="hljs-comment">// NON_EMPTY, 属性为&quot;&quot;，不封装</span>    <span class="hljs-comment">// NON_DEFAULT, 属性为默认值，不封装到json</span>    <span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span>    <span class="hljs-keyword">private</span> String planName;    <span class="hljs-comment">// 设置返回的格式</span>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-mm-dd hh:mm:ss a&quot;,locale = &quot;zh&quot;,timezone = &quot;GMT+8&quot;)</span>    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>全局配置</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">jackson:</span>       <span class="hljs-attr">default-property-inclusion:</span> <span class="hljs-string">non_null</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>03-Json</category>
      
      <category>03-Jackson</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-注解</title>
    <link href="/01-Java/01-JavaSE/05-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3/"/>
    <url>/01-Java/01-JavaSE/05-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的实现"><a href="#注解的实现" class="headerlink" title="注解的实现"></a>注解的实现</h2><ul><li>注解：Annotation，是一种特殊的类，所有的注解都是<code>java.lang.annotation.Annotation</code>接口的子接口，用于为程序元素(Class,Method,Field)设置元数据</li></ul><p>注解三元素</p><ol><li>注解接口</li><li>被注解的程序元素</li><li>注解功能的实现类</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 1. 注解接口</span><span class="hljs-meta">@Target(ElementType.METHOD)</span>             <span class="hljs-comment">// 注解可以依附的程序元素</span><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span>      <span class="hljs-comment">// 注解生存的时期，SOURCE, CLASS, RUNTIME【建议使用】</span><span class="hljs-meta">@Documented</span>                             <span class="hljs-comment">// 注解保存到JAVA-doc</span><span class="hljs-meta">@Inherited</span>                              <span class="hljs-comment">// 注解可被子类继承, 使用这个注解的类的子类自动使用该注解</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Mapping &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 注解的属性(抽象方法)，名字和类型(基本数据类型，String, 数组, 枚举, Class, Annotation)可以自己起</span>    <span class="hljs-comment">// 当属性只有一个，且名字为**value**可省略，直接传值</span>    <span class="hljs-function">String <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;GET&quot;</span>;      <span class="hljs-comment">// 为属性设置默认值，调用时可省略</span>&#125;<span class="hljs-comment">// 2. 被注解的程序元素</span><span class="hljs-meta">@Mapping(&quot;/hello&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// TODO</span>&#125;<span class="hljs-comment">// 3. 实现注解的实现类（模拟实现Mapping）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappingDemo</span> </span>&#123;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;Method&gt; <span class="hljs-title">getMappings</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;        List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Method method : clazz.getMethods()) &#123;            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Mapping.class)) &#123;                methods.add(method);                Mapping mapping = method.getAnnotation(Mapping.class);                System.out.println(<span class="hljs-string">&quot;url:&quot;</span> + mapping.value());                System.out.println(<span class="hljs-string">&quot;method:&quot;</span> + mapping.method());            &#125;        &#125;        <span class="hljs-keyword">return</span> methods;    &#125;&#125;<span class="hljs-comment">// 调用</span>MappingDemo mappingDemo = <span class="hljs-keyword">new</span> MappingDemo();mappingDemo.getMappings(Demo.class);</code></pre><ul><li>支持的程序元素类型</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ElementType &#123;    TYPE,                   <span class="hljs-comment">// 类、接口</span>    FIELD,                  <span class="hljs-comment">// 字段</span>    METHOD,                 <span class="hljs-comment">// 方法</span>    PARAMETER,              <span class="hljs-comment">// 参数</span>    CONSTRUCTOR,            <span class="hljs-comment">// 构造器</span>    LOCAL_VARIABLE,         <span class="hljs-comment">// 局部变量</span>    ANNOTATION_TYPE,        <span class="hljs-comment">// 注解</span>    PACKAGE,                <span class="hljs-comment">// 包</span>    TYPE_PARAMETER,    TYPE_USE&#125;</code></pre><ul><li>原理解析：注解是程序元素的元数据，因此，程序元素有获得自身元数据的方法</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 获得程序元素指定类型的注解，如果不存在返回null</span>Annotation annotation = method.getAnnotation(Class&lt;T&gt; annotationClass);<span class="hljs-comment">// 获得所有注解</span>Annotation[] annotations = method.getDeclaredAnnotations();<span class="hljs-comment">// 判断是否存在指定注解</span><span class="hljs-keyword">boolean</span> bool = method.isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);</code></pre><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><pre><code class="hljs java"><span class="hljs-comment">// 抑制异常</span><span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><span class="hljs-comment">// 过时方法</span><span class="hljs-meta">@Deprecated</span><span class="hljs-comment">// 重写/覆盖</span><span class="hljs-meta">@Override</span><span class="hljs-comment">// jdk1.7, 抑制推污染异常警告，在使用**泛型**和**可变参数**时会出现，参考Arrays.asList()方法</span><span class="hljs-meta">@SafeVarargs</span></code></pre><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><span class="hljs-meta">@Cleanup</span><span class="hljs-meta">@Getter</span><span class="hljs-meta">@Setter</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@Value</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@SneakyThrows</span><span class="hljs-meta">@Synchronized</span><span class="hljs-meta">@Getter(lazy=true)</span><span class="hljs-meta">@Log</span></code></pre><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Service</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@Config</span><span class="hljs-meta">@Spring</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>05-注解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-lockback</title>
    <link href="/01-Java/99-Others/01-Log/02-lockback/"/>
    <url>/01-Java/99-Others/01-Log/02-lockback/</url>
    
    <content type="html"><![CDATA[<h1 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h1><p>Logback是Spring使用的日志管理工具</p><p><code>logback-spring.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/base.xml&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 从Spring中读取属性 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;applicationName&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;spring.application.name&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- TODO logstash --&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;springProperty scope=&quot;context&quot; name=&quot;logstash_host&quot; source=&quot;glaf.logstash&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!-- 文件日志格式 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;ABSOLUTE&#125; [%6level] [%X&#123;X-B3-TraceId:-&#125;,%X&#123;X-B3-SpanId:-&#125;] [%thread] %logger&#123;40&#125;: %msg%n&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 保存路径 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/opt/logs/$&#123;applicationName&#125;&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &lt;destination&gt;$&#123;logstash_host&#125;&lt;/destination&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--            &lt;customFields&gt;&#123;&quot;app_name&quot;:&quot;$&#123;applicationName&#125;&quot;&#125;&lt;/customFields&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &lt;/encoder&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;/appender&gt;--&gt;</span>    <span class="hljs-comment">&lt;!-- 文件INFO日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span></span><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/info_%d&#123;yyyyMMdd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- INFO保存N天 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxSize</span>&gt;</span>1024M<span class="hljs-tag">&lt;/<span class="hljs-name">MaxSize</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-comment">&lt;!-- filter: ACCEPT接受 NEUTRAL中立(传到下一个)filter DENY:终止 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>DEBUG<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 文件ERROR日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span></span><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;FILE_LOG_PATH&#125;/error_%d&#123;yyyyMMdd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>            <span class="hljs-comment">&lt;!-- ERROR保存N天 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxSize</span>&gt;</span>1024M<span class="hljs-tag">&lt;/<span class="hljs-name">MaxSize</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>NEUTRAL<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 日志屏蔽级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.netflix&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sun.rmi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.sun&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.lettuce&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;io.netty&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;springfox.documentation&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.atomikos&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.rabbitmq.client.impl.ForgivingExceptionHandler&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.alibaba.nacos&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;OFF&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 控制台日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置dev下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--            &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt;--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置test下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--            &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt;--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR_FILE&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO_FILE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置prod下的日志级别 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--特别指定自有包路径下的日志级别--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--            &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt;--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>01-Log</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-枚举Enum</title>
    <link href="/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E6%9E%9A%E4%B8%BEEnum/"/>
    <url>/01-Java/01-JavaSE/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05-%E6%9E%9A%E4%B8%BEEnum/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举Enum"><a href="#枚举Enum" class="headerlink" title="枚举Enum"></a>枚举Enum</h1><p>枚举是一种特殊的类,以下是枚举的两种形态</p><pre><code class="hljs java"><span class="hljs-comment">// 使用默认构造器创造</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  Color&#123;    RED,BLUE,YELLOW&#125;<span class="hljs-comment">// 通过定制构造器，实现自定义名称，也可以往枚举类中添加自定义方法</span><span class="hljs-keyword">enum</span>  Color&#123;    RED(<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-number">1</span>),GREEN(<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-number">2</span>);    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ordinal;    Color(String name,<span class="hljs-keyword">int</span> ordinal)&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.ordinal = ordinal;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>01-基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-多线程进阶-线程通信-生产者和消费者案例</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-Object-类的-wait-和-notify-方法-（不适用锁机制）"><a href="#使用-Object-类的-wait-和-notify-方法-（不适用锁机制）" class="headerlink" title="使用 Object 类的 wait() 和 notify() 方法 （不适用锁机制）"></a>使用 Object 类的 wait() 和 notify() 方法 （不适用锁机制）</h1><p>只有<strong>同步监听对象</strong>才可以调用 wait() 和 notify() 方法，否则报错<br>线程之间进行通信，且防止耦合度过高，使用一个中间类作为通信的共同资源</p><ul><li>需要使用 synchronized 保证一个过程的原子性</li><li>使用 isEmpty 变量作为标志参数，在结束生产和结束消费之后改变该值</li><li>使用 Object 类的 wait() 方法，判断资源状态，若存在则当前进程进入等待池</li><li>使用 Object 类的 notify() 方法，在结束生产和结束消费之后唤醒其他线程</li><li>值得注意的是：只有<strong>同步监听对象</strong>才可以调用 wait() 和 notify() 方法，否则报错</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>source 作为两个线程的参数传入</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ShareSources source = <span class="hljs-keyword">new</span> ShareSources();        <span class="hljs-keyword">new</span> Producer(source).start();        <span class="hljs-keyword">new</span> Comsumer(source).start();    &#125;&#125;</code></pre><h2 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareSources</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String sex;    <span class="hljs-keyword">private</span> Boolean isEmpty = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//使用一个参数作为标志</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">        * 存入数据</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> sex</span><span class="hljs-comment">        */</span>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(String name, String sex)</span> </span>&#123;<span class="hljs-comment">//同步方法，保证了该方法的原子性</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//此处使用While比If更加合理，</span>            <span class="hljs-keyword">while</span> (!isEmpty) &#123;<span class="hljs-comment">// 生产者是当前线程，如果资源任存在，则当前线程释放锁，进入等待池中，释放后，消费者进程获得锁</span>                <span class="hljs-keyword">this</span>.wait();<span class="hljs-comment">//this 指的是 source 对象 进入等待池中的线程只能被其他线程唤醒，这里只能在消费者线程中唤醒</span>            &#125;            <span class="hljs-comment">//---------------------开始生产-------------------------</span>            <span class="hljs-keyword">this</span>.name = name;            Thread.sleep(<span class="hljs-number">10</span>);            <span class="hljs-keyword">this</span>.sex = sex;            <span class="hljs-comment">//---------------------结束生产-------------------------</span>            isEmpty = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">this</span>.notifyAll();<span class="hljs-comment">//同时将其他线程唤醒</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">        * 获取资源</span><span class="hljs-comment">        */</span>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (isEmpty) &#123;<span class="hljs-comment">//如果资源不存在</span>                <span class="hljs-keyword">this</span>.wait();<span class="hljs-comment">//当前线程是消费者，进入等待池</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//---------------------开始消费-------------------------</span>        Thread.sleep(<span class="hljs-number">10</span>);                System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-keyword">this</span>.sex);        <span class="hljs-comment">//---------------------结束消费-------------------------</span>        isEmpty = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">this</span>.notifyAll();<span class="hljs-comment">//同时将其他线程唤醒</span>    &#125;&#125;</code></pre><h2 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h2><p>生产者可能存在多个，且需要与消费者不同线程</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> ShareSources source = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(ShareSources source)</span> </span>&#123;<span class="hljs-comment">//通过构造器获取相同的资源</span>        <span class="hljs-keyword">this</span>.source = source;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                source.push(<span class="hljs-string">&quot;春哥&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);            &#125;<span class="hljs-keyword">else</span> &#123;                source.push(<span class="hljs-string">&quot;凤姐&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> ShareSources source = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Comsumer</span><span class="hljs-params">(ShareSources source)</span> </span>&#123;        <span class="hljs-keyword">this</span>.source = source;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;            source.get();        &#125;    &#125;&#125;</code></pre><h2 id="使用-Lock-和-condition-接口"><a href="#使用-Lock-和-condition-接口" class="headerlink" title="使用 Lock 和 condition 接口"></a>使用 Lock 和 condition 接口</h2><h3 id="资源类-只有该类发生变化"><a href="#资源类-只有该类发生变化" class="headerlink" title="资源类(只有该类发生变化)"></a>资源类(只有该类发生变化)</h3><p>需要注意的是，condition 的操作一定要在获取锁之后，释放锁之前执行，否则报错</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareSources</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String sex;    <span class="hljs-keyword">private</span> Boolean isEmpty = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 实例化锁</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();<span class="hljs-comment">// 由于Condition是一个接口，lock.newCondition()方法返回一个绑定的Condition实例</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">        * 存入数据</span><span class="hljs-comment">        *</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> sex</span><span class="hljs-comment">        */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(String name, String sex)</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (!isEmpty) &#123;                condition.await();<span class="hljs-comment">// 使用condition的await()方法相当于 Object 类的 wait 方法</span>            &#125;            <span class="hljs-keyword">this</span>.name = name;            Thread.sleep(<span class="hljs-number">10</span>);            <span class="hljs-keyword">this</span>.sex = sex;            isEmpty = <span class="hljs-keyword">false</span>;            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">        * 获取资源</span><span class="hljs-comment">        */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (isEmpty) &#123;                condition.await();<span class="hljs-comment">// 使用condition的await()方法相当于 Object 类的 wait 方法</span>            &#125;            Thread.sleep(<span class="hljs-number">10</span>);            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-keyword">this</span>.sex);            isEmpty = <span class="hljs-keyword">true</span>;            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-多线程进阶-死锁问题</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h1><p><a href="https://baike.baidu.com/item/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/10929794?fr=aladdin">哲学家就餐问题</a></p><ul><li>问题描述：哲学家就餐问题，需要两个而资源才能完成任务，但都锁死了各自的资源，导致死锁问题产生，谁也无法同时持有两个资源</li><li>避免法则：当多个线程共享 A B C 三个资源时，<strong>让他们都按照一定的顺序使用资源</strong>，这样就不会锁死各自的资源了,在哲学家就餐问题中：资源（餐叉）按照某种规则编号为1至5，每一个工作单元（哲学家）总是先拿起左右两边编号较低的餐叉，再拿编号较高的。用完餐叉后，他总是先放下编号较高的餐叉，再放下编号较低的。在这种情况下，当四位哲学家同时拿起他们手边编号较低的餐叉时，只有编号最高的餐叉留在桌上，从而第五位哲学家就不能使用任何一只餐叉了。而且，只有一位哲学家能使用最高编号的餐叉，所以他能使用两只餐叉用餐。当他吃完后，他会先放下编号最高的餐叉，再放下编号较低的餐叉，从而让另一位哲学家拿起后边的这只开始吃东西。</li></ul><h2 id="Java编程写一个会导致死锁的程序"><a href="#Java编程写一个会导致死锁的程序" class="headerlink" title="Java编程写一个会导致死锁的程序"></a>Java编程写一个会导致死锁的程序</h2><p>死锁的前提是多个线程同时需要多个资源。<br>因此最简单是两个线程两个资源</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object o1 = <span class="hljs-keyword">new</span> Object(); <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object o2 = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    <span class="hljs-keyword">new</span> Thread()&#123;()-&gt; &#123;        <span class="hljs-comment">// 获得对象1的锁</span>        <span class="hljs-keyword">synchronized</span>(o1)&#123;             System.out.println(<span class="hljs-string">&quot;1&quot;</span>);             Thread.sleep(<span class="hljs-number">100</span>);        &#125;        <span class="hljs-comment">// 获得对象2的锁</span>        <span class="hljs-keyword">synchronized</span>(o2)&#123;            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);        &#125;    &#125;&#125;.start();    <span class="hljs-keyword">new</span> Thread()&#123;()-&gt; &#123;        <span class="hljs-comment">// 获得对象2的锁</span>        <span class="hljs-keyword">synchronized</span>(o2)&#123;             System.out.println(<span class="hljs-string">&quot;2&quot;</span>);             Thread.sleep(<span class="hljs-number">100</span>);        &#125;        <span class="hljs-comment">// 获得对象1的锁</span>        <span class="hljs-keyword">synchronized</span>(o1)&#123;            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);        &#125;    &#125;&#125;.start();&#125;</code></pre><p>线程A持有对象o1的锁 线程B持有对象o2的锁<br>线程A等待对象o2的锁 线程B等待对象o2的锁<br>死锁形成</p><h2 id="解决死锁办法"><a href="#解决死锁办法" class="headerlink" title="解决死锁办法"></a>解决死锁办法</h2><p>1、按顺序加锁</p><p>上个例子线程间加锁的顺序各不一致，导致死锁，如果每个线程都按同一个的加锁顺序这样就不会出现死锁。</p><p>2、获取锁时限</p><p>每个获取锁的时候加上个时限，如果超过某个时间就放弃获取锁之类的。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-JVM内存管理机制和垃圾回收机制</title>
    <link href="/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/02-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/02-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存管理机制和垃圾回收机制"><a href="#JVM内存管理机制和垃圾回收机制" class="headerlink" title="JVM内存管理机制和垃圾回收机制"></a>JVM内存管理机制和垃圾回收机制</h1><h2 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h2><p><img src="../images/01-01.jpg"></p><p>图片描述：</p><ol><li>java源码编译成class文件</li><li>class文件通过类加载器加载到内存</li><li>其中方法区存放的是运行时的常量、静态变量、类信息等，被所有线程共享</li><li>堆空间存放对象，被所有线程共享</li><li>栈空间存放的是栈帧，包括局部变量、操作数栈、返回地址等，每一个方法创建一个栈帧</li><li>本地方法栈通过本地方法接口实现本地方法的调用</li><li>程序计数器是用来记录程序执行的位置</li></ol><h2 id="JAVA代码编译"><a href="#JAVA代码编译" class="headerlink" title="JAVA代码编译"></a>JAVA代码编译</h2><p><img src="../images/01-02.jpg"></p><h2 id="JAVA字节码执行"><a href="#JAVA字节码执行" class="headerlink" title="JAVA字节码执行"></a>JAVA字节码执行</h2><p><img src="../images/01-03.jpg"></p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p><img src="../images/01-04.png"></p><ol><li>Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</li><li>Extension ClassLoader: 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</li><li>App ClassLoader: 负责记载classpath中指定的jar包及目录中class</li><li>Custom ClassLoader: 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</li></ol><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><h3 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h3><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</p><h2 id="JVM内存组成"><a href="#JVM内存组成" class="headerlink" title="JVM内存组成"></a>JVM内存组成</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>所有通过new创建的对象的内存都在堆中分配。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由From Space和To Space组成，结构图如下所示：</p><p><img src="../images/01-05.png"></p><ul><li>新生代：新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例</li><li>旧生代：用于存放新生代中经过多次垃圾回收仍然存活的对象</li><li>持久代：用于存放静态类型数据，如 Java Class, Method 等</li></ul><p><strong>晋升过程</strong></p><p>新生代分为eden区s0,s1区（from，to）。多数情况下对象首先分配在eden区，在一次新生代回收后，存活下来的对象存入s0或s1区。每经过一次新生代的回收，对象的年龄加1。默认情况下年龄达到15的对象将晋升至老年代。如果在第一次回收的时候，存活的对象大于s0（s1）空间，将直接晋升至老年代，如果在为对象第一次分配空间时，对象空间大于eden空间的话，对象也直接分配到老年代。</p><p><strong>配置</strong> </p><ol><li>-Xms初始值</li><li>-Xmx最大值</li></ol><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img src="../images/01-07.png"><br>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果</p><p><strong>配置</strong></p><ol><li>-Xss最大值</li></ol><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>用于支持native方法的执行，存储了每个native方法调用的状态</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代（Permanet Generation）来存放方法区，</p><p><strong>配置</strong></p><ol><li>-XX:PermSize最小值</li><li>-XX:MaxPermSize最大值</li></ol><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>java堆外，直接向系统申请的内存区间，允许NIO库使用。申请空间慢，读写快。默认下最大可用空间等于堆的最大可用空间。在server模式下，读写速度是堆的10倍。</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>JVM针对新生代和旧生代采用了不同的GC</p><h3 id="新生代的GC"><a href="#新生代的GC" class="headerlink" title="新生代的GC"></a>新生代的GC</h3><p>新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和From Space或To Space之间copy。</p><p>新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。</p><p>用java visualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常，如下图所示：</p><p><img src="../images/01-06.png"></p><p>在执行机制上JVM提供了串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并发GC（ParNew）。</p><ol><li>串行GC<br>在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定</li><li>并行回收GC<br>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数</li><li>并行GC<br>与旧生代的并发GC配合使用</li></ol><h3 id="旧生代的GC"><a href="#旧生代的GC" class="headerlink" title="旧生代的GC"></a>旧生代的GC</h3><p>旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。</p><p>在执行机制上JVM提供了串行GC（Serial MSC）、并行GC（parallel MSC）和并发GC（CMS）。</p><blockquote><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p></blockquote><table><thead><tr><th>指定方式</th><th>新生代GC方式</th><th>旧生代GC方式</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>串行GC</td><td>串行GC</td></tr><tr><td>-XX:+UseParallelGC</td><td>并行回收GC</td><td>并行GC</td></tr><tr><td>-XX:+UseConeMarkSweepGC</td><td>并行GC</td><td>并发GC</td></tr><tr><td>-XX:+UseParNewGC</td><td>并行GC</td><td>串行GC</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>并行回收GC</td><td>并行GC</td></tr><tr><td>-XX:+ UseConeMarkSweepGC -XX:+UseParNewGC</td><td>串行GC</td><td>并发GC</td></tr><tr><td>不支持的组合</td><td>1、-XX:+UseParNewGC -XX:+UseParallelOldGC 2、-XX:+UseParNewGC -XX:+UseSerialGC</td><td></td></tr></tbody></table><p>参考1：<a href="http://blog.csdn.net/u011225629/article/details/49000311?yyue=a21bo.50862.201879">JVM内存管理机制和垃圾回收机制</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>09-JVM与性能调优</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Redis入门</title>
    <link href="/03-Database/03-Redis/01-Redis%E5%85%A5%E9%97%A8/"/>
    <url>/03-Database/03-Redis/01-Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一种Nosql，用健值对的方式存储数据，实现更加高效地读取和写入数据，读写均能达到接近10万次/s的水平，常用于数据缓存，任务队列，网站访问处理等</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>字符串</li><li>列表</li><li>散列</li><li>集合</li><li>有序集合</li></ul><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><a href="https://hub.docker.com/_/redis">参考</a></p><ul><li>作为服务器启动</li></ul><pre><code class="hljs sh">docker run \    --name redis-server \    -v redis:/data \    -p 6379:6379 \    --network redis \    -d redis:latest</code></pre><ul><li>作为客户端启动</li></ul><pre><code class="hljs sh">docker run -it --network redis --rm redis:latest redis-cli -h redis-server</code></pre><h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h2><pre><code class="hljs sh"><span class="hljs-comment"># ping</span>ping<span class="hljs-comment"># 存储数据 支持单引号、双引号、不用引号</span><span class="hljs-built_in">set</span> name <span class="hljs-string">&#x27;czm&#x27;</span><span class="hljs-comment"># 获得数据</span>get name<span class="hljs-comment"># 获得所有的key</span>keys *<span class="hljs-comment"># 删除key</span>del name</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>03-Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-backup</title>
    <link href="/03-Database/02-Postgresql/01-backup/"/>
    <url>/03-Database/02-Postgresql/01-backup/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库备份脚本"><a href="#数据库备份脚本" class="headerlink" title="数据库备份脚本"></a>数据库备份脚本</h1><p><code>backup.sh</code></p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-comment"># 数据库备份脚本</span><span class="hljs-comment"># author:cenzhongman</span><span class="hljs-comment"># email:cenzhongman@163.com</span><span class="hljs-comment"># </span><span class="hljs-comment"># ************config************</span><span class="hljs-comment"># Backup save path</span>BACKUP_PATH=/var/lib/postgresql/data_backup<span class="hljs-comment"># Backup count</span>BACKUP_SIZE=7POSTGRES_USER=<span class="hljs-variable">$POSTGRES_USER</span>POSTGRES_PASSWORD=<span class="hljs-variable">$POSTGRES_PASSWORD</span>HOST_NAME=<span class="hljs-variable">$HOSTNAME</span>POSTGRES_PORT=5432POSTGRES_PATH=/usr/lib/postgresql/9.6/binDATE=$(date +%Y-%m-%d)<span class="hljs-built_in">echo</span> $(date +%Y-%m-%d\ %H:%M:%S)<span class="hljs-string">&quot;: backup database start......&quot;</span><span class="hljs-comment">#备份全局对象</span>BACKUP_FILE=<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>/global_<span class="hljs-variable">$&#123;DATE&#125;</span>.sqlPGPASSWORD=<span class="hljs-variable">$&#123;POSTGRES_PASSWORD&#125;</span> <span class="hljs-variable">$&#123;POSTGRES_PATH&#125;</span>/pg_dumpall -h <span class="hljs-variable">$&#123;HOST_NAME&#125;</span> -U <span class="hljs-variable">$&#123;POSTGRES_USER&#125;</span> -p <span class="hljs-variable">$&#123;POSTGRES_PORT&#125;</span> -g -f <span class="hljs-variable">$&#123;BACKUP_FILE&#125;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Database backup successful, save to file:&quot;</span> <span class="hljs-variable">$&#123;BACKUP_FILE&#125;</span><span class="hljs-comment">#备份某一个数据库</span><span class="hljs-comment"># BACKUP_DB=&quot;bmw&quot;</span><span class="hljs-comment"># PGPASSWORD=$&#123;POSTGRES_PASSWORD&#125; $&#123;POSTGRES_PATH&#125;/pg_dump -h $&#123;HOST_NAME&#125; -U $&#123;POSTGRES_USER&#125; -p 5432 -d $&#123;BACKUP_DB&#125; -C -f BACKUP_PATH/$&#123;BACKUP_DB&#125;_$&#123;DATE&#125;.sql</span><span class="hljs-built_in">echo</span> $(date +%Y-%m-%d\ %H:%M:%S)<span class="hljs-string">&quot;: backup database end.&quot;</span><span class="hljs-built_in">cd</span> <span class="hljs-variable">$BACKUP_PATH</span>DELETE_SIZE=$(($(ls -rt | wc -l)-<span class="hljs-variable">$&#123;BACKUP_SIZE&#125;</span>))<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$DELETE_SIZE</span> -gt 0 ]<span class="hljs-keyword">then</span>    DELETE_FILES=$(ls -rt | head -n<span class="hljs-variable">$&#123;DELETE_SIZE&#125;</span>)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;delete files:&quot;</span> <span class="hljs-variable">$&#123;DELETE_FILES&#125;</span>    rm -r <span class="hljs-variable">$DELETE_FILES</span><span class="hljs-keyword">fi</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>02-Postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JVM内存调优</title>
    <link href="/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/03-JVM%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/"/>
    <url>/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/03-JVM%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存调优"><a href="#JVM内存调优" class="headerlink" title="JVM内存调优"></a>JVM内存调优</h1><h2 id="为什么要内存调优"><a href="#为什么要内存调优" class="headerlink" title="为什么要内存调优"></a>为什么要内存调优</h2><p>现在的JVM在高效性和稳定性方面做的非常出色。自适应内存管理、垃圾收集、及时编译、动态类加载、锁优化，并且JVM仍然提供了足够多的外部监控和手动调优工具。使得我们可以针对特定的服务器和资源进行JVM参数的调整。</p><pre><code class="hljs sh">➜  ~ java用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32  使用 32 位数据模型 (如果可用)    -d64  使用 64 位数据模型 (如果可用)    -server  选择 <span class="hljs-string">&quot;server&quot;</span> VM                  默认 VM 是 server,                  因为您是在服务器类计算机上运行。    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 : 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:&lt;值&gt;                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -<span class="hljs-built_in">help</span>      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  按指定的粒度启用断言    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=<span class="hljs-built_in">help</span> 和 -agentlib:hprof=<span class="hljs-built_in">help</span>    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]                  按完整路径名加载本机代理库    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:&lt;imagepath&gt;                  使用指定的图像显示启动屏幕</code></pre><p>部分参数详解</p><ul><li><code>-server</code> JVM其实是<code>HotSpot JVM</code>且分为两种</li></ul><pre><code class="hljs sh">$ java  -X        -Xmixed           混合模式执行 (默认)        -Xint             仅解释模式执行        -Xbootclasspath:&lt;用 : 分隔的目录和 zip/jar 文件&gt;                        设置搜索路径以引导类和资源        -Xbootclasspath/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt;                        附加在引导类路径末尾        -Xbootclasspath/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt;                        置于引导类路径之前        -Xdiag            显示附加诊断消息        -Xnoclassgc       禁用类垃圾收集        -Xincgc           启用增量垃圾收集        -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)        -Xbatch           禁用后台编译        -Xms&lt;size&gt;        设置初始 Java 堆大小        -Xmx&lt;size&gt;        设置最大 Java 堆大小        -Xss&lt;size&gt;        设置 Java 线程堆栈大小        -Xprof            输出 cpu 配置文件数据        -Xfuture          启用最严格的检查, 预期将来的默认值        -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)        -Xcheck:jni       对 JNI 函数执行其他检查        -Xshare:off       不尝试使用共享类数据        -Xshare:auto      在可能的情况下使用共享类数据 (默认)        -Xshare:on        要求使用共享类数据, 否则将失败。        -XshowSettings    显示所有设置并继续        -XshowSettings:all                        显示所有设置并继续        -XshowSettings:vm 显示所有与 vm 相关的设置并继续        -XshowSettings:properties                        显示所有属性设置并继续        -XshowSettings:locale                        显示所有与区域设置相关的设置并继续</code></pre><h2 id="内存调优怎么调"><a href="#内存调优怎么调" class="headerlink" title="内存调优怎么调"></a>内存调优怎么调</h2><h3 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h3><ul><li>GC参数</li></ul><p>-XX:+PrintGC    每次触发GC的时候打印相关日志</p><p>-XX:+PrintGCDetails    更详细的GC日志</p><p>-XX:+PrintHeapAtGC    每次GC时打印堆的详细详细信息</p><p>-XX:+PrintGCApplicationConcurrentTime    打印应用程序执行时间</p><p>-XX:+PrintGCApplicationAtoppedTime    打印应用程序由GC引起的停顿时间</p><p>-XX:+PrintReferenceGC    跟踪系统内的软引用，弱引用，虚引用和finallize队列。</p><ul><li>类跟踪</li></ul><p>-verbose:class    跟踪类的加载和卸载</p><p>-XX:+TraceClassLoading    单独跟踪类加载</p><p>-XX:+TraceClassUnloading    单独跟踪类卸载</p><p>-XX:+PrintClassHistogram    查看运行时类的分布情况，使用时在控制台按ctrl+break</p><ul><li>系统参数查看</li></ul><p>-XX:+PrintVMOptions       运行时，打印jvm接受的命令行显式参数</p><p>-XX:+PrintCommandLineFlags    打印传递jvm的显式和隐式参数</p><p>-XX:+PrintFlagsFinal    打印所有系统参数值</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h4><p>-Xms    堆初始值</p><p>-Xmx    堆最大可用值</p><p>-Xmn    新生代大小，一般设为整个堆的1/3到1/4左右</p><p>-XX:NewRatio=n      设置年轻代和年老代的比值。如:n=3，表示年轻代与年老代比值为1：3</p><p>-XX:SurvivorRatio=n    设置新生代中eden区和from/to空间的比例关系n/1</p><p><strong>优化策略</strong>：</p><p>尽可能将对象预留在新生代，减少老年代GC的次数（通常老年回收起来比较慢）。实际工作中，通常将堆的初始值和最大值设置相等，这样可以减少程序运行时进行的垃圾回收次数和空间扩展，从而提高程序性能。</p><h4 id="非堆优化"><a href="#非堆优化" class="headerlink" title="非堆优化"></a>非堆优化</h4><p>-XX:PermSize   方法区（永久区）初始值</p><p>-XX:MaxPermSize    方法区（永久区）最大值</p><p>-Xss    设置栈空间大小</p><p>-XX:MaxDirectMemorySize    直接内存最大可用空间，设置不当可能导致系统OOM</p><h4 id="虚拟机工作模式优化"><a href="#虚拟机工作模式优化" class="headerlink" title="虚拟机工作模式优化"></a>虚拟机工作模式优化</h4><p>-client    默认工作模式</p><p>-server    server工作模式，启动虚拟机时需要显式指定</p><p>与client模式相比，server模式启动较慢，会尝试搜集更多的系统性能信息，使用更复杂的优化算法对程序进行优化，server模式下系统完全启动并进入稳定期后，执行速度远远快于client模式，适合长期后台运行的系统。Client模式更适合运行时间不长，又追求启动速度的客户端程序。</p><h3 id="Jvm性能监控工具"><a href="#Jvm性能监控工具" class="headerlink" title="Jvm性能监控工具"></a>Jvm性能监控工具</h3><p>1.JConsole</p><p>内存监控，线程监控，类加载情况，虚拟机信息</p><p>2.Visual VM</p><p>线程dump和分析，性能分析，内存快照分析，BTrace</p><p>3.Mission Control</p><p>MBean服务器，飞行记录器</p><h3 id="分析JAVA堆"><a href="#分析JAVA堆" class="headerlink" title="分析JAVA堆"></a>分析JAVA堆</h3><h4 id="常见内存泄漏原因和解决思路"><a href="#常见内存泄漏原因和解决思路" class="headerlink" title="常见内存泄漏原因和解决思路"></a>常见内存泄漏原因和解决思路</h4><ol><li>堆溢出分两种<ol><li>年老代溢出：java.lang.OutOfMemoryError:Javaheapspace<ul><li>原因：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题</li></ul></li><li>持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace<ul><li>原因：加载了大量的JAVA类，持久代空间小</li><li>解决：将-XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）</li></ul></li></ol></li><li>直接内存溢出：可能是系统内存空间不足，同时没达到参数默认的上限，没有触发GC导致OOM，解决方法是通过-XX:MaxDirectMemorySize 来限制最大内存。</li><li>过多线程导致OOM：由于每开启一个线程都会给这个线程分配一个栈，因此当线程数达到一定程度，系统空间不足的时候就会内存溢出，可以尝试减少堆空间，或者可以通过设置参数-Xss限制每个栈的大小。</li><li>GC效率低下引起的OOM：GC是内存回收的关键，回收效率低很有可能引起内存溢出，可以通过合理的分配堆（包括新生代和老年代）空间去解决。</li></ol><h4 id="String造成的内存泄漏"><a href="#String造成的内存泄漏" class="headerlink" title="String造成的内存泄漏"></a>String造成的内存泄漏</h4><p>内存泄漏是指，不再使用的对象占据内存不释放，导致可用内存不断减小，最终引起内存泄漏。在Java1.6中String.subString()方法就存在这样的问题。</p><p>SubString中新生成的对象并没有从value中获取自己需要的那部分，而是直接简单的使用了相同的引用，只是修改了offset和count，以此来确定新的String对象的值。当原始字符串还在用的时候这种情况是没有问题的，并且共用value还节省了部分的空间，但是一旦原始字符串被回收，value中多余的部分就造成了空间浪费。</p><h4 id="浅堆和深堆"><a href="#浅堆和深堆" class="headerlink" title="浅堆和深堆"></a>浅堆和深堆</h4><p>浅堆：是指一个对象本身所消耗的内存，不包括其内部引用的对象的大小。</p><p>深堆：是指对象的保留集中所有对象浅堆的大小之和。</p><p>保留集：是指当对象A被垃圾回收后，可以释放的所有对象的集合（包括A本身），通俗的讲就是，仅被对象A所持有的对象的集合。</p><h4 id="OQL查询语句"><a href="#OQL查询语句" class="headerlink" title="OQL查询语句"></a>OQL查询语句</h4><p>类似于sql语法的查询语句，可以在堆中进行对象的查找和筛选。</p><p>参考1：<a href="http://blog.csdn.net/jack85986370/article/details/52910476?yyue=a21bo.50862.201879">JVM内存调优与实际案例</a><br>参考2：<a href="https://www.cnblogs.com/RUN-TIME/archive/2016/04/29/5445115.html">一份关于jvm内存调优及原理的学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>09-JVM与性能调优</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-垃圾回收</title>
    <link href="/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/04-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/04-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="常见判断对象存活算法"><a href="#常见判断对象存活算法" class="headerlink" title="常见判断对象存活算法"></a>常见判断对象存活算法</h2><ol><li>引用计数法(Reference Counting)<ul><li>使用:FlashPlayer、Python、Squirrel</li><li>原理:给对象加一个引用计数器,被引用+1,引用失效-1</li><li>问题:无法解决循环引用问题,即A持有B的引用,B持有A的引用</li></ul></li><li><strong>可达性分析</strong>(Reachability Analysis)<ul><li>使用:Java、C#</li><li>原理:通过一系列的称为”GC Roots”的对象作为起始点，向下搜索，走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链时，不可达</li><li>GC Roots对象<ol><li>栈的局部变量表中 引用的对象</li><li>方法区中静态属性 引用的对象</li><li>方法区中常量 引用的对象</li><li>本地方法栈中 引用的对象 </li></ol></li></ul></li></ol><h2 id="对象自救-finalize-方法"><a href="#对象自救-finalize-方法" class="headerlink" title="对象自救 finalize()方法"></a>对象自救 <code>finalize()</code>方法</h2><p>对象回收过程需要经历两次标记：当一个对象不可达后第一次标记,若对象重写了<code>finalize()</code>且这个对象的<code>finalize()</code>从未执行过,将这个对象加入F-Queue,JVM将为F-Queue中每个对象提供一个单独的线程执行<code>finalize()</code>方法,若对象在<code>finalize()</code>中自救,在JVM在F-Queue中再次小规模标记时移出即将回收集合则存活。否则，第二次标记，回收。</p><blockquote><p>⚠️注意：代价极高，完全不建议使用</p></blockquote><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol><li>“标记-清除”算法（基础）<ul><li>原理：将一块连续内存区域中的对象进行对象存活分析，标记死亡对象，并进行清除。</li><li>缺点：造成内存区域不连续，在存储大对象时无法找到合适的内存空间。</li><li>图：<img src="../images/2019-12-20-17-24-15.png"></li></ul></li><li>复制算法（在<strong>新生代</strong>中使用）<ul><li>原理：为了解决内存区域不连续问题，开辟两块完全一样大小的内存空间A和B，当A用完后，将存活对象复制到B，将A一次清除。</li><li>缺点：内存只能用一半，且新生成对象死亡率过高</li><li>改进：分代内存划分 将内存区域分为新生代、老年代，新生代又分为生成区80%、幸存区（均分为两块）20%。这样浪费的内存仅为的10%（幸存区的其中一块）</li></ul></li><li>标记-整理算法（在<strong>老年代</strong>中使用）<ul><li>原理：“标记-清除”算法类似只使用一块内存，标记死亡对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ej-technologies.com/download/jprofiler/files">Jprofiler</a><br><a href="https://www.eclipse.org/mat/downloads.php">Eclipse Memory Analyzer</a><br><a href="https://zazalu.space/2019/09/17/java-memory-error-solution-Theoretically/">冷静对待你遇到的所有Java内存异常</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>09-JVM与性能调优</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Git学习.html</title>
    <link href="/04-Linux/04-Git/01-Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/04-Linux/04-Git/01-Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2>1.初始化init</h2><div class="cnblogs_code"><pre>git init</pre></div><h3><span style="font-size: 1.5em; line-height: 1.5;">2.选择哪些文件和文件夹不保存到Git</span></h3><p>通过在 .gitignore文件中添加问价路径描述来，可以使用通配符</p><div class="cnblogs_code"><pre><span style="color: #000000;">*.iml.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures.externalNativeBuild</span></pre></div><h3><span style="line-height: 1.5;">3.添加文件add</span></h3><div class="cnblogs_code"><pre><span style="color: #000000;">git add . ------------添加所有文件git add abc.xml ------------添加单个文件git add src ------------添加文件夹</span></pre></div><h3><span style="line-height: 1.5;">4.提交保存commit</span></h3><div class="cnblogs_code"><pre>git commit -m "First commit."</pre></div><h3><span style="line-height: 1.5;">5.查询修改内容</span></h3><div class="cnblogs_code"><pre><span style="color: #000000;">git status -----------查看修改哪个文件git diff    -----------查看所有文件的修改内容git diff app/src/main/java/com/cenzhongman/myapplication2/MainActivity.java -------查看修改的单个文件</span></pre></div><h3><span style="line-height: 1.5;">6.撤回(未提交)checkout</span></h3><div class="cnblogs_code"><pre>git checkout app/src/main/java/com/cenzhongman/myapplication2/MainActivity.java</pre></div><h3><span style="line-height: 1.5;">7.撤回(已提交)reset</span></h3><div class="cnblogs_code"><pre>git reset</pre></div><p>&nbsp;</p>[gitlab参考](http://www.360doc.com/content/14/0508/17/14416931_375851686.shtml)]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>04-Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-git初始化指令</title>
    <link href="/04-Linux/04-Git/02-git%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E4%BB%A4/"/>
    <url>/04-Linux/04-Git/02-git%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git初始化指令–Copy-from-gitlab"><a href="#Git初始化指令–Copy-from-gitlab" class="headerlink" title="Git初始化指令–Copy from gitlab"></a>Git初始化指令–Copy from gitlab</h1><ul><li>Git global setup</li></ul><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&quot;岑忠满&quot;</span>git config --global user.email <span class="hljs-string">&quot;cenzhongman@163.com&quot;</span></code></pre><ul><li>Create a new repository</li></ul><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> http://gitlab.datainsights.biz:1234/cenzhongman/demo.git<span class="hljs-built_in">cd</span> demotouch README.mdgit add README.mdgit commit -m <span class="hljs-string">&quot;add README&quot;</span>git push -u origin master</code></pre><ul><li>Existing folder</li></ul><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> existing_foldergit initgit remote add origin http://gitlab.datainsights.biz:1234/cenzhongman/demo.gitgit add .git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span>git push -u origin master</code></pre><ul><li>Existing Git repository</li></ul><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> existing_repogit remote rename origin old-origingit remote add origin http://gitlab.datainsights.biz:1234/cenzhongman/demo.gitgit push -u origin --allgit push -u origin --tags</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>04-Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-分布式系统搭建</title>
    <link href="/07-Bigdata/01-Hadoop/04-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
    <url>/07-Bigdata/01-Hadoop/04-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>##组建分布：</p><pre><code>    hadoop-senior            hadoop-senior02            hadoop-senior03HDFS    NameNode    DataNode                 DataNode                 DataNode                                                    SecondaryNameNodeYARN                            ResourceManager    NodeManager             NodeManager             NodeManagerMapReduce    JobHistoryServer</code></pre><p>###1.配置固定IP        配置IPV4<br><a href="http://www.cnblogs.com/cenzhongman/p/7136348.html">ubuntu主机名修改</a></p><pre><code>临时设置$ sudo hostname newHostName永久设置$ sudo vi /etv/hostname</code></pre><p>###2.配置主机名        /etc/hosts文件</p><pre><code>192.168.2.123    hostname-ubuntu.cenzhongman.com     hostname-ubuntu192.168.2.124    hostname-ubuntu2.cenzhongman.com     hostname-ubuntu2192.168.2.125    hostname-ubuntu3.cenzhongman.com     hostname-ubuntu3</code></pre><p>###3.配置<br>    * hdfs<br>         * hadoop-env.sh         -&gt;   JAVA_HOME<br>         * core-site.xml         -&gt;   namenode主机和端口 临时文件目录<br>         * hdfs-site.xml         -&gt;     删除Datanode备份数目设置，设置dfs.namenode.secondary.http-address     hostname-ubuntu3.cenzhongman.com:50090<br>         * slaves                -&gt;   配置DataNode主机</p><pre><code>* yarn     * yarn-env.sh             -&gt;   JAVA_HOME     * yarn-site.xml        -&gt;   &lt;!--设置resourceManager的主机--&gt;&lt;!--设置日志保留7天--&gt;从YARN启动mapreduce* mapredue     * mapred-env.sh        -&gt;   JAVA_HOME     * mapred-site.xml        -&gt;   &lt;!--配置jobhistory主机--&gt;</code></pre><p>###4.分发到各个节点<br>    <a href="http://www.cnblogs.com/cenzhongman/p/7052414.html">SSH无密码登录及远程拷贝命令SCP的使用</a></p><p>###5.从节点设置SSH无密钥登录(跟mac地址又关，因此需要删除重新配置)<br>    并将自己的密钥 Copy给其他节点</p><p>###6.启动集群测试<br>       *基本测试：测试集群功能<br>            hdfs 读写操作<br>            yarn 跑一个程序<br>            MapReduce 跑程序<br>        *基准测试：测试集群性能<br>            hdfs 读写速度<br>            yarn 多任务调度<br>            MapReduce 多Map任务运行<br>        *监控工具<br>            Clodera<br>            Cloderra Manager<br>                部署安装集群<br>                监控集群<br>                预置同步集群<br>                预警功能</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-kudu是什么</title>
    <link href="/07-Bigdata/06-Kudu/01-kudu%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/06-Kudu/01-kudu%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>#Apache Kudu Overview<br>###建议配合[Apache Kudo]审阅本文(<a href="http://kudu.apache.org/overview.html">http://kudu.apache.org/overview.html</a>)</p><hr><p>###数据模式<br>Kudo是一个列式存储的用于快速分析的NoSQL数据库，提供了类似SQL的查询语句，与RDBMS十分类似，有**PRIMARY KEY **，基于主键查询而不是HBase的RowKey<br><img src="http://kudu.apache.org/img/twitter-firehose-schema.png"></p><hr><p>###低延迟随机存取<br>与其他大数据数据库不同，Kudu不仅仅是一个文件格式。行访问达到毫秒级延迟，支持C++ JAVA, API PyThon API 拥有简单好用的API<br><img src="http://kudu.apache.org/img/java-code.png"></p><hr><p>###融会贯通入Hadoop生态系统<br>你可以使用Java Client实时导入数据，同时也支持Spark(运算) impala(分析工具，比Hive快) MapReduce HDFS HBase 很容易从HDFS中获取数据，占用内存小于1G<br><img src="http://kudu.apache.org/img/impala.png"></p><hr><p>###Super-fast Columnar Storage<br>列式存储有利于编码和压缩，数据比使用Parquet压缩还省空间。这样的高压缩，降低了数据的IO，为计算服务。使用如laze data这样的技术，使得超高速成为可能<br><img src="http://kudu.apache.org/img/kudu_vs_parquet.png"></p><hr><p>###分布式和容错机制<br>Kudu通过把<strong>tables</strong>切分成<strong>tablets</strong>,每个表都可以配置切分的哈希，分区和组合<br>Kudu使用了<a href="http://raft.github.io/">Raft</a>来复制给定的操作，保证了数据同时存储在两个节点上，因此不村子单点故障。<br><img src="http://kudu.apache.org/img/raft.png"></p><hr><p>###为下一代硬件设计<br>说的是他们深入了解了下一代处理器架构等等，在IO和资源优化等等方面做了一下改进<br><img src="http://kudu.apache.org/img/intel_logo.png"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>06-Kudu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Kudu安装</title>
    <link href="/07-Bigdata/06-Kudu/02-Kudu%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/06-Kudu/02-Kudu%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Kudu"><a href="#Kudu" class="headerlink" title="Kudu"></a>Kudu</h1><h3 id="Kudu官方文档"><a href="#Kudu官方文档" class="headerlink" title="Kudu官方文档"></a><a href="kudu.apache.org/docs/installation.html">Kudu官方文档</a></h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Kudu masters:管理服务，可以单节点运行(无容灾)。三节点(单容灾)，5节点(双容灾)</li><li>Kudu tablet servers：允许伪分布式，三节点以上数据可靠。</li></ul><h3 id="使用dep包安装-其他系统请参照官方文档-，并且支持编译安装"><a href="#使用dep包安装-其他系统请参照官方文档-，并且支持编译安装" class="headerlink" title="使用dep包安装(其他系统请参照官方文档)，并且支持编译安装"></a>使用dep包安装(其他系统请参照官方文档)，并且支持编译安装</h3><p>下载并添加 cloudera.list 文件到 /etc/apt/sources.list.d/目录下，或者直接下载dep包安装使用 dpkg -f &lt;XXX.dep&gt;，此处官网有错误。</p><pre><code>sudo apt-get install kudu                     # Base Kudu files                                    基础文件，都要装sudo apt-get install kudu-master              # Service scripts for managing kudu-master         只需要在作为管理节点的机器安装，以后会开机启动和关闭sudo apt-get install kudu-tserver             # Service scripts for managing kudu-tserver        只需要作为数据节点的机器上安装，以后会开机启动和关闭sudo apt-get install libkuduclient0           # Kudu C++ client shared library                    sudo apt-get install libkuduclient-dev        # Kudu C++ client SDK</code></pre><h1 id="配置gflags"><a href="#配置gflags" class="headerlink" title="配置gflags"></a>配置<a href="https://gflags.github.io/gflags/">gflags</a></h1><p>安装后会在 <strong>/etc/kudu/conf/</strong> 文件夹下放置配置文件，你可以通过编辑这里面的文件，或者创建一个替换文件，使用 link 指向该文件。还有一部分文件在 <strong>/etc/default/kudu-master</strong> 和 <strong>/etc/default/kudu-tserver</strong> 文件夹下，如果你创建自己的配置目录，你需要复制这里面的文件<br>###设置gflags方法<br>你可以使用一个配置文件来同时配置 Master server 和 tablets server 那些用不上的配置将被忽略。本文使用两个配置文件。这里讲只讨论常用的配置，其他配置信息，请出门<a href="http://kudu.apache.org/docs/configuration_reference.html">右转</a></p><ul><li><p>方式0：编辑/etc/kudu/conf/路径下的文件(对于绑定IP和日志文件目录请移步/etc/default/kudu-master这两个文件修改)</p></li><li><p>方式一：使用 –flagfile=<file> 选项在启动命令之后增加全局标志文件</p><p>  kudu-master –flagfile=todo start</p></li><li><p>方式二：通过在配置文件中使用 –flagfile 选项来指定增加其他配置文件(嵌套使用)</p></li></ul><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><pre><code>$ kudu-master --help</code></pre><h2 id="Configuring-the-Kudu-Master"><a href="#Configuring-the-Kudu-Master" class="headerlink" title="Configuring the Kudu Master"></a>Configuring the Kudu Master</h2><p><img src="../images/01-01.png" alt="Kudu Master参数"></p><h2 id="Configuring-Tablet-Servers"><a href="#Configuring-Tablet-Servers" class="headerlink" title="Configuring Tablet Servers"></a>Configuring Tablet Servers</h2><p><img src="../images/01-02.png" alt="Tablet Servers参数"></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h3 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1.启动服务"></a>1.启动服务</h3><pre><code>$ sudo service kudu-master start                # 绑定0.0.0.0:7051$ sudo service kudu-tserver start               # 绑定0.0.0.0:7050</code></pre><h3 id="2-停止服务"><a href="#2-停止服务" class="headerlink" title="2.停止服务"></a>2.停止服务</h3><pre><code>$ sudo service kudu-master stop$ sudo service kudu-tserver stop</code></pre><h3 id="3-添加服务到自启列队"><a href="#3-添加服务到自启列队" class="headerlink" title="3.添加服务到自启列队"></a>3.添加服务到自启列队</h3><pre><code>$ sudo chkconfig kudu-master on                # RHEL / CentOS / SLES$ sudo chkconfig kudu-tserver on               # RHEL / CentOS / SLES$ sudo update-rc.d kudu-master defaults        # Debian / Ubuntu$ sudo update-rc.d kudu-tserver defaults       # Debian / Ubuntu</code></pre><h3 id="4-列举自启列表"><a href="#4-列举自启列表" class="headerlink" title="4.列举自启列表"></a>4.列举自启列表</h3><pre><code>$ sudo chkconfig --list | grep kudu</code></pre><h1 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h1><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p><a href="http://kudu.apache.org/docs/troubleshooting.html">官方常见错误</a></p><h4 id="时间未同步（不要自己开定时任务）"><a href="#时间未同步（不要自己开定时任务）" class="headerlink" title="时间未同步（不要自己开定时任务）"></a>时间未同步（不要自己开定时任务）</h4><ul><li>问题描述：在使用kudu的时候出现问题，检测时间服务器状态（ntpstat）需要由ntpd server 同步才能生效，手动同步不能生效</li><li>解决办法：使用比上述方法更加简单的同步方法，编辑/etc/ntp.conf文件添加server指向自己的 <strong>ntp server</strong><br>开启定时任务</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>06-Kudu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-ubuntu主机名修改</title>
    <link href="/04-Linux/04-ubuntu%E4%B8%BB%E6%9C%BA%E5%90%8D%E4%BF%AE%E6%94%B9/"/>
    <url>/04-Linux/04-ubuntu%E4%B8%BB%E6%9C%BA%E5%90%8D%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu主机名修改"><a href="#Ubuntu主机名修改" class="headerlink" title="Ubuntu主机名修改"></a>Ubuntu主机名修改</h1><h3 id="1、查看主机名"><a href="#1、查看主机名" class="headerlink" title="1、查看主机名"></a>1、查看主机名</h3><p>在Ubuntu系统中，快速查看主机名有多种方法：<br>其一，打开一个GNOME终端窗口，在命令提示符中可以看到主机名，主机名通常位于“@”符号后；<br>其二，在终端窗口中输入命令：<code>hostname或uname –n</code>，均可以查看到当前主机的主机名。</p><h3 id="2、临时修改主机名"><a href="#2、临时修改主机名" class="headerlink" title="2、临时修改主机名"></a>2、临时修改主机名</h3><p>命令行下运行命令：<code>hostname 新主机名</code><br>其中“新主机名”可以用任何合法字符串来表示。不过采用这种方式，新主机名并不保存在系统中，重启系统后主机名将恢复为原先的主机名称。<br>例子：hostname ubuntu-temp<br>这样主机名字就临时被修改为ubuntu-temp，但是终端下不会立即显示生效后的主机名，重开一个终端窗口(通过ssh连接的终端需要重新连接才可以);</p><h3 id="3、永久修改主机名"><a href="#3、永久修改主机名" class="headerlink" title="3、永久修改主机名"></a>3、永久修改主机名</h3><p>在Ubuntu系统中永久修改主机名也比较简单。主机名存放在<code>/etc/hostname</code>文件中，修改主机名时，编辑hostname文件，在文件中输入新的主机名并保存该文件即可。重启系统后，参照上面介绍的快速查看主机名的办法来确认主机名有没有修改成功。</p><p>值的指出的是，在其它Linux发行版中，并非都存在<code>/etc/hostname</code>文件。如Fedora发行版将主机名存放在/etc/sysconfig/network文件中。所以，修改主机名时应注意区分是哪种Linux发行版。</p><h3 id="4、-etc-hostname与-etc-hosts的区别"><a href="#4、-etc-hostname与-etc-hosts的区别" class="headerlink" title="4、/etc/hostname与/etc/hosts的区别"></a>4、/etc/hostname与/etc/hosts的区别</h3><p>/etc/hostname中存放的是主机名，hostname文件的一个例子：<br>v-jiwan-ubuntu-temp</p><p>/etc/hosts存放的是域名与ip的对应关系，域名与主机名没有任何关系，你可以为任何一个IP指定任意一个名字，hostname文件的一个例子：</p><blockquote><p>127.0.0.1       localhost<br>127.0.1.1       v-jiwan-ubuntu</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-磁盘监控</title>
    <link href="/04-Linux/09-%E7%A3%81%E7%9B%98%E7%9B%91%E6%8E%A7/"/>
    <url>/04-Linux/09-%E7%A3%81%E7%9B%98%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux磁盘监控"><a href="#Linux磁盘监控" class="headerlink" title="Linux磁盘监控"></a>Linux磁盘监控</h1><h2 id="整个系统占用情况"><a href="#整个系统占用情况" class="headerlink" title="整个系统占用情况"></a>整个系统占用情况</h2><pre><code class="hljs sh">df -hl</code></pre><h2 id="查看当前目录占用情况"><a href="#查看当前目录占用情况" class="headerlink" title="查看当前目录占用情况"></a>查看当前目录占用情况</h2><p>du == diskuse</p><p>du常用的选项：<br>　　-h：以人类可读的方式显示<br>　　-a：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小<br>　　-s：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小<br>　　-c：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和<br>　　–apparent-size：显示目录或文件自身的大小<br>　　-l ：统计硬链接占用磁盘空间的大小<br>　　-L：统计符号链接所指向的文件占用的磁盘空间大小　　</p><pre><code class="hljs sh"><span class="hljs-comment"># 当前整个目录</span>du -sh<span class="hljs-comment"># 当前目录和第一级子目录</span>du -sh --max-depth=1</code></pre><h2 id="其他可能会用到的配置"><a href="#其他可能会用到的配置" class="headerlink" title="其他可能会用到的配置"></a>其他可能会用到的配置</h2><pre><code class="hljs xml">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;java.io.tmpdir&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;10000&quot;</span> </span><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span> </span><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;20&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span>/&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheTest&quot;</span> 缓存名称</span><span class="hljs-tag">        <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">&quot;1000&quot;</span> 缓存的最大个数</span><span class="hljs-tag">        <span class="hljs-attr">eternal</span>=<span class="hljs-string">&quot;false&quot;</span> 是否永久有效，一但设置了，<span class="hljs-attr">timeout</span>将不起作用。</span><span class="hljs-tag">        <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">&quot;true&quot;</span> 当数量达到<span class="hljs-attr">maxElementsInMemory</span>，<span class="hljs-attr">Ehcache</span>将会对象写到磁盘中。 </span><span class="hljs-tag">        <span class="hljs-attr">maxElementsOnDisk</span>=<span class="hljs-string">&quot;500&quot;</span>硬盘最大缓存个数。 </span><span class="hljs-tag">        <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">&quot;10&quot;</span> 缓存自创建日期起至失效时的间隔时间</span><span class="hljs-tag">        <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">&quot;20&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">memoryStoreEvictionPolicy</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">&quot;120&quot;</span>/&gt;</span> 缓存创建以后，最后一次访问缓存的日期至失效之时的时间间隔；<span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-shell脚本入门基础知识</title>
    <link href="/04-Linux/02-shell%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/04-Linux/02-shell%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><h2 id="编写shell"><a href="#编写shell" class="headerlink" title="编写shell"></a>编写shell</h2><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-meta">#!/bin/sh其实，sh是bash的一个软链接 sh -&gt; bash </span></code></pre><h3 id="变量，字母下划线开头（好像是没有类型的）"><a href="#变量，字母下划线开头（好像是没有类型的）" class="headerlink" title="变量，字母下划线开头（好像是没有类型的）"></a>变量，字母下划线开头（好像是没有类型的）</h3><pre><code class="hljs sh"><span class="hljs-comment">#普通变量</span>var1=nihao<span class="hljs-comment">#不能有空格</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span> <span class="hljs-comment">#使用$表示变量</span><span class="hljs-comment">#环境变量</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$JAVA_HOME</span> <span class="hljs-comment">#全局变量用全大写</span>/etc/profil/e         <span class="hljs-comment">#全局环境变量存储位置</span><span class="hljs-comment">#用户环境变量</span>/home/cen/.bash_profile <span class="hljs-comment">#编辑文件后需要用source命令更新</span><span class="hljs-comment">#删除变量</span><span class="hljs-built_in">unset</span> 变量名</code></pre><h3 id="位置参量，用于传递参数"><a href="#位置参量，用于传递参数" class="headerlink" title="位置参量，用于传递参数"></a>位置参量，用于传递参数</h3><pre><code class="hljs sh"><span class="hljs-comment">#定义位置参量</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$1</span> !!&quot;</span> <span class="hljs-comment">#用$1,$2....$&#123;10&#125;,$&#123;11&#125; ...表示接受到的第n个参数</span><span class="hljs-comment">#$0 表示当前脚本的文件名</span><span class="hljs-comment">#$# 表示传入参数个数</span><span class="hljs-comment">#$? 上一个命令的状态嘛，有一些依赖关系必须知道之前的执行情况</span><span class="hljs-comment">#传入参数</span>./xxx.sh 参数一 参数二 <span class="hljs-comment">#用空格分隔位置参数，如果位置参数有空格，使用&quot;hello world!&quot;</span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code class="hljs sh"><span class="hljs-comment">#数组定义</span>arr=(zhangsan lisi wangwu)<span class="hljs-comment">#数组引用</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[0]&#125;</span> <span class="hljs-comment">#zhangsan</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span> <span class="hljs-comment">#zhangsan lisi wangwu </span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#arr&#123;*&#125;</span>&#125; <span class="hljs-comment">#3</span></code></pre><h3 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a>查看时间</h3><pre><code class="hljs sh"><span class="hljs-comment">#当前时间</span>date1=$(date)<span class="hljs-comment">#一天前</span>date2=$(date --date=<span class="hljs-string">&#x27;1 days age&#x27;</span>)date2=$(date --date=<span class="hljs-string">&#x27;1 days&#x27;</span>)<span class="hljs-comment">#一天后</span>date3=$(date --date=<span class="hljs-string">&#x27;1 days&#x27;</span>)date3=$(date --date=<span class="hljs-string">&#x27;-1 days ago&#x27;</span>)</code></pre><h3 id="判断test-e-filename-或者-e-filename-两端一定要有空格"><a href="#判断test-e-filename-或者-e-filename-两端一定要有空格" class="headerlink" title="判断test -e filename 或者 [ -e filename ] []两端一定要有空格"></a>判断test -e filename 或者 [ -e filename ] []两端一定要有空格</h3><pre><code class="hljs sh"><span class="hljs-comment">#文件类型判断</span><span class="hljs-comment">#-e 判断文件是否exist</span><span class="hljs-comment">#-f 是否为file </span><span class="hljs-comment">#-d 是否为dir</span><span class="hljs-comment">#权限判断</span><span class="hljs-comment">#-r 可读</span><span class="hljs-comment">#-w 可写</span><span class="hljs-comment">#-x 可执行</span><span class="hljs-comment">#判断整数</span><span class="hljs-comment">#-eq equal相等</span><span class="hljs-comment">#-ne not equal不相等</span><span class="hljs-comment">#-gt greater than大于</span><span class="hljs-comment">#-lt less than小于</span><span class="hljs-comment">#判断字符串</span><span class="hljs-comment">#-z zero空字符串</span><span class="hljs-comment">#-n not 非空</span><span class="hljs-comment">#=/==   相等</span><span class="hljs-comment">#!=不等</span></code></pre><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre><code class="hljs sh"><span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;filename&quot;</span> ] &amp;&amp;　[ -e <span class="hljs-string">&quot;filename&quot;</span> ] ; <span class="hljs-keyword">then</span> <span class="hljs-comment">#todo...</span><span class="hljs-comment">#todo...</span><span class="hljs-keyword">elif</span> [ -e <span class="hljs-string">&quot;filename&quot;</span> ]<span class="hljs-comment">#todo...</span><span class="hljs-keyword">else</span><span class="hljs-comment">#todo...</span><span class="hljs-keyword">fi</span></code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code class="hljs sh"><span class="hljs-comment">#for循环(1)</span><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> 1 2 3 4 5<span class="hljs-keyword">do</span><span class="hljs-comment">#todo...</span><span class="hljs-keyword">done</span><span class="hljs-comment">#for循环(2)</span>n=10sum=0sum2=0<span class="hljs-keyword">for</span>((i=0;i&lt;<span class="hljs-variable">$&#123;n&#125;</span>;i=i+1))<span class="hljs-keyword">do</span>sum=$((<span class="hljs-variable">$&#123;sum1&#125;</span>+$(i))) <span class="hljs-comment">#正儿八经的加法</span>sum2=<span class="hljs-variable">$&#123;sum2&#125;</span>+<span class="hljs-variable">$&#123;i&#125;</span> <span class="hljs-comment">#字符串拼接 </span><span class="hljs-keyword">done</span></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code class="hljs sh"><span class="hljs-comment">#正经点while</span><span class="hljs-keyword">while</span> [ -e <span class="hljs-string">&quot;filename&quot;</span> ]<span class="hljs-keyword">do</span><span class="hljs-comment">#todo...</span><span class="hljs-keyword">done</span><span class="hljs-comment">#当到型while</span>until [ -e <span class="hljs-string">&quot;filename&quot;</span> ]<span class="hljs-keyword">do</span><span class="hljs-comment">#todo...</span><span class="hljs-keyword">done</span><span class="hljs-comment">#配合cat和管道函数的while(不会应用场景)</span>cat a.txt | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line</code></pre><h3 id="神奇的-符号"><a href="#神奇的-符号" class="headerlink" title="神奇的$符号"></a>神奇的$符号</h3><pre><code class="hljs sh"><span class="hljs-variable">$&#123;变量&#125;</span>$(可执行语句) <span class="hljs-comment">#(1+1)带括号的才是可执行语句</span></code></pre><h2 id="执行shell脚本的四种方式"><a href="#执行shell脚本的四种方式" class="headerlink" title="执行shell脚本的四种方式"></a>执行shell脚本的四种方式</h2><pre><code class="hljs sh">$/home/user/xxx.sh$./xxx.sh        $. xxx.sh      <span class="hljs-variable">$sh</span> xxx.sh</code></pre><p><a href="http://blog.csdn.net/meilikafei/article/details/45582573">四种方式区别</a></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-JAVA文档注释标签.html</title>
    <link href="/01-Java/02-JAVA%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/01-Java/02-JAVA%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1>Java文档注释标签</h1><p>1&nbsp;常用Java注释标签（Java comment tags）</p><p>@author&nbsp;&nbsp;作者</p><p>@param&nbsp;&nbsp;输入参数的名称&nbsp;&nbsp;说明</p><p>@return&nbsp;输出参数说明</p><p>@since JDK版本</p><p>@version&nbsp;版本号</p><p>@see&nbsp;链接目标</p><p>@throws&nbsp;异常</p><p>@deprecated&nbsp;解释</p><p>@link&nbsp;链接地址</p><p>2 Java注释的使用顺序</p><p>3&nbsp;简单常见的HTML嵌入</p><p>4&nbsp;HTML嵌入注释范例</p><p>&nbsp;</p><p>5&nbsp;参考文档</p><p>&nbsp;</p><p><a><strong>1&nbsp;&nbsp;&nbsp;常用Java</strong></a><strong>注释标签（Java comment tags）</strong></p><h2><a>@author&nbsp;&nbsp;</a>作者</h2><p>适用范围：文件、类、方法</p><p>（*多个作者使用多个@author标签标识，java doc中显示按输入时间顺序罗列。）</p><p>例：* @author&nbsp;Leo. Yao</p><p>&nbsp;</p><h2><a>@param&nbsp;&nbsp;</a>输入参数的名称&nbsp;&nbsp;说明</h2><p>适用范围：方法</p><p>例：* @param str the String用来存放输出信息。</p><p>&nbsp;</p><h2><a>@return&nbsp;</a>输出参数说明</h2><p>适用范围：方法</p><p>例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @return&nbsp;&nbsp;&nbsp;&nbsp;&lt;code&gt;true&lt;/code&gt;执行成功;</p><p>&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;code&gt;false&lt;/code&gt;执行失败.</p><p>&nbsp;</p><h2><a>@since JDK</a>版本</h2><p>用于标识编译该文件所需要的JDK环境。</p><p>适用范围：文件、类</p><p>例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @since JDK1.6</p><p>&nbsp;</p><h2><a>@version&nbsp;</a>版本号</h2><p>用于标识注释对象的版本号</p><p>适用范围：文件、类、方法</p><p>例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@version&nbsp;1.0</p><p>&nbsp;</p><h2><a>@see&nbsp;</a>链接目标</h2><p>表示参考。会在java&nbsp;文档中生成一个超链接，链接到参考的类容。使用中的感觉是@see不需要包路径，对我这种懒人比较喜欢，相对{@link }这种既要加大括号，有需要包路径，我还是选择偷懒，当然你要是不介意使用import导入要link的类，那就可以达到@see的效果，所以总体来说，还是选择@see，当然两个在特殊场合下还是用法不一样的</p><p>用法：</p><p>@see #field</p><p>&nbsp;&nbsp;&nbsp;@see #Constructor(Type, Type...)</p><p>&nbsp;&nbsp;&nbsp;@see #Constructor(Type id, Type id...)</p><p>&nbsp;&nbsp;&nbsp;@see #method(Type, Type,...)</p><p>&nbsp;&nbsp;&nbsp;@see #method(Type id, Type, id...)</p><p>&nbsp;&nbsp;&nbsp;@see Class</p><p>&nbsp;&nbsp;&nbsp;@see Class#field</p><p>&nbsp;&nbsp;&nbsp;@see Class#Constructor(Type, Type...)</p><p>&nbsp;&nbsp;&nbsp;@see Class#Constructor(Type id, Type id)</p><p>&nbsp;&nbsp;&nbsp;@see Class#method(Type, Type,...)</p><p>&nbsp;&nbsp;&nbsp;@see Class#method(Type id, Type id,...)</p><p>&nbsp;&nbsp;&nbsp;@see package.Class</p><p>&nbsp;&nbsp;&nbsp;@see package.Class#field</p><p>&nbsp;&nbsp;&nbsp;@see package.Class#Constructor(Type, Type...)</p><p>&nbsp;&nbsp;&nbsp;@see package.Class#Constructor(Type id, Type id)</p><p>&nbsp;&nbsp;&nbsp;@see package.Class#method(Type, Type,...)</p><p>&nbsp;&nbsp;&nbsp;@see package.Class#method(Type id, Type, id)</p><p>&nbsp;&nbsp;&nbsp;@see package</p><p>&nbsp;</p><h2><a>@throws&nbsp;</a>异常</h2><p>标识出方法可能抛出的异常</p><p>适用范围：方法</p><p>例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @throws IOException&nbsp;&nbsp;If an input or output exception occurred</p><p>&nbsp;</p><h2><a>@deprecated&nbsp;</a>解释</h2><p>标识对象过期</p><p>适用范围：文件、类、方法</p><p>&nbsp;</p><h2><a>@link&nbsp;</a>链接地址</h2><p>链接到一个目标，用法类似@see。但常放在注释的解释中形如{@link &hellip;}</p><p>例：</p><p>/**</p><p>&nbsp;* @deprecated&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As of JDK 1.1, replaced by</p><p>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@link #setBounds(int,int,int,int)}</p><p>&nbsp;*/</p><h1><a>2 Java</a>注释的使用顺序</h1><p>* @author&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(classes and interfaces only, required)</p><p>* @version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(classes and interfaces only, required. See footnote 1)</p><p>* @param&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(methods and constructors only)</p><p>* @return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(methods only)</p><p>* @exception&nbsp;&nbsp;&nbsp;(@throws is a synonym added in Javadoc 1.2)</p><p>* @see&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>* @since&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>* @serial&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or @serialField or @serialData)</p><p>* @deprecated&nbsp;&nbsp;(see How and When To Deprecate APIs)</p><p>&nbsp;</p><p>&nbsp;</p><p><a><strong>3&nbsp;</strong></a><strong>简单常见的HTML嵌入</strong></p><p>&lt;P&gt;&nbsp;用于分段</p><p>&lt;code&gt;&nbsp;&nbsp;标签用于表示计算机源代码或者其他机器可以阅读的文本内容。&lt;code&gt;&nbsp;标签就是为软件代码的编写者设计的。包含在该标签内的文本将用等宽、类似电传打字机样式的字体（Courier）显示出来只应该在表示计算机程序源代码或者其他机器可以阅读的文本内容上使用&nbsp;&lt;code&gt;&nbsp;标签。虽然&lt;code&gt;&nbsp;标签通常只是把文本变成等宽字体，但它暗示着这段文本是源程序代码。将来的浏览器有可能会加入其他显示效果。例如，程序员的浏览器可能会寻找&nbsp;&lt;code&gt;&nbsp;片段，并执行某些额外的文本格式化处理，如循环和条件判断语句的特殊缩进等。</p><p>本文参考：</p><p><a href="http://wzdacyl.blog.163.com/blog/static/1402716502010264035241/">http://wzdacyl.blog.163.com/blog/static/1402716502010264035241/</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-vim编辑器最简单使用方法</title>
    <link href="/04-Linux/05-vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%9C%80%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/04-Linux/05-vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%9C%80%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim-使用ff"><a href="#Vim-使用ff" class="headerlink" title="Vim 使用ff"></a>Vim 使用ff</h1><pre><code class="hljs sh">i       输入模式：q     不保存退出：q!    强制退出：wq    保存退出j 下k 上h 左l 右gg startG endx 往后删X 往前删yy      复制行p       粘贴dd 剪切行u撤销v       可视化模式&gt;&gt;      缩进&lt;&lt;      取消缩进%s/原来的/新的/g/查找的内容     n next下一个</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-linux命令行操作基本知识</title>
    <link href="/04-Linux/01-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/04-Linux/01-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux民力大全"><a href="#Linux民力大全" class="headerlink" title="Linux民力大全"></a>Linux民力大全</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><pre><code class="hljs sh">.表示当前目录..表示上一级目录ls 显示文件  -l 列表 -a 隐藏文件-h 文件大小人性化显示gedit 自带文本编辑器subl 打开sublime&gt; 重定向“w”&gt;&gt;重定向“a”cat  显示文件内容 more分页显示ls | more 管道<span class="hljs-built_in">cd</span> - 返回刚才的目录  <span class="hljs-built_in">cd</span> .. 返回上一级</code></pre><h2 id="文件夹和文件处理"><a href="#文件夹和文件处理" class="headerlink" title="文件夹和文件处理"></a>文件夹和文件处理</h2><pre><code class="hljs sh">touch 创建文件mkdir 创建文件夹rmdir 删除(空)文件夹rm 删除文件  -R / -r 递归删除文件（包括文件夹）-f 强制删除ln  创建硬链接(两个名字，指向同一个文件)，删除源文件，链接文件不会删除 -s 真正的软链接grep    搜索 -n显示行数  grep ‘^22$’ file.txt  ^ 以22开头 $以22结尾find  查找文件find /home/ -name file.txt  其他选项 -size 按大小找 -perm 按权限找cp copy -r 递归实现（文件夹） -i 交互式（不断提示）mv 移动文件（重命名也用这个）</code></pre><h3 id="归档管理tar"><a href="#归档管理tar" class="headerlink" title="归档管理tar"></a>归档管理tar</h3><pre><code class="hljs sh">tar -c create创建 -x 解包 -v 显示进度 -z 压缩成gz -j 压缩成gz2 -f fileName（需要放在最后）-C 指定路径eg：tar -cvf T.tar 1.txt 2.txt打包经典案例eg: tar -xvf T.tar解包经典案例gzip 压缩/解压 -r 递归压缩gzip T.tar T.tar.gz 第二个参数可以省略gzip -d T.tar.gz -d 解压，返回一个tar包zip 目标文件（无需后缀） 源文件unzip -d 目录 源文件</code></pre><h3 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h3><pre><code class="hljs sh">-rw-rw-r--  1  cen  cen 0 5月  26 21:57 1.py(权限)    硬链接数 用户  组  size  修改时间  named rwx-w- --xd d文件夹  -文件 rwx u用户权限-w-g组权限--x o其他</code></pre><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><pre><code class="hljs sh">普通模式chmod [u]+x 添加权限chmod [o]-x 删除权限chmod [g]=rwx,o=x 修改权限  a=x 全部修改八进制模式r 4w 2x 1- 0</code></pre><h3 id="修改文件拥有者"><a href="#修改文件拥有者" class="headerlink" title="修改文件拥有者"></a>修改文件拥有者</h3><pre><code class="hljs sh">chown username filenamechgrp groupname filename</code></pre><h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><pre><code class="hljs sh">rebootshutdown -r reboot -h halt关闭（后面可接 now 具体时间 倒计时）-c cancel取消df  检查磁盘空间ps  显示系统进程 -a all -u 详细 -x 没有终端的进程<span class="hljs-built_in">kill</span> pid -9 绝杀 top  动态系统进程 m memory c cpu t time u user q qiutdf   查看磁盘使用情况du   当前目录磁盘情况ifconfig IP信息ctrl - C 终止进程ctrl - V 强制终止进程</code></pre><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议</p><pre><code class="hljs sh">ssh root@123.345.12.345</code></pre><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><pre><code class="hljs sh">who 查看当前用户信息whoami 我是谁useradd/adduser 添加用户passwd [username] 修改用户密码su [suername] 修改用户cat /etc/passwd查看用户</code></pre><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><pre><code class="hljs sh">cat /etc/group查看用户组gropmod + tab + tab 查看用户组groupmod -g 修改为主用户组，-G添加到用户组在sudo 组中的用户有root权限groupadd 添加组groupdel  删除组groups [username] 查看属于的用户组</code></pre><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><pre><code class="hljs sh">$ sudo apt-get --purge remove</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-wget下载JDK</title>
    <link href="/04-Linux/12-wget%E4%B8%8B%E8%BD%BDJDK/"/>
    <url>/04-Linux/12-wget%E4%B8%8B%E8%BD%BDJDK/</url>
    
    <content type="html"><![CDATA[<h1 id="Wget下载JDK"><a href="#Wget下载JDK" class="headerlink" title="Wget下载JDK"></a>Wget下载JDK</h1><p>甲骨文现在要登录才能下载JDK，这在很多自动脚本里面是很不爽的。</p><pre><code class="hljs sh">wget --no-check-certificate --no-cookies --header <span class="hljs-string">&quot;Cookie: oraclelicense=accept-securebackup-cookie&quot;</span> http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz</code></pre><p>每次用之前去甲骨文官网看看最新的下载链接，复制下来替换掉。</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-Crontab</title>
    <link href="/04-Linux/13-Crontab/"/>
    <url>/04-Linux/13-Crontab/</url>
    
    <content type="html"><![CDATA[<h1 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h1><h2 id="Debain中的Crontab"><a href="#Debain中的Crontab" class="headerlink" title="Debain中的Crontab"></a>Debain中的Crontab</h2><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>/etc/crontab</p><h2 id="其他文件（实测无效）"><a href="#其他文件（实测无效）" class="headerlink" title="其他文件（实测无效）"></a>其他文件（实测无效）</h2><p>/var/spool/cron/crontabs/root</p><ul><li>权限为600</li><li>必须以换行结尾</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h2 id="打开日志"><a href="#打开日志" class="headerlink" title="打开日志"></a>打开日志</h2><pre><code class="hljs sh"><span class="hljs-comment"># 【不存在时】安装日志</span>apt-get updateapt-get install -q -y rsyslog<span class="hljs-comment"># 启动cron日志</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cron.*                /var/log/cron.log&quot;</span> &gt;&gt; /etc/rsyslog.conf<span class="hljs-comment"># 重启日志</span>/etc/init.d/rsyslog restart<span class="hljs-comment"># 查看日志</span>tail -f /var/<span class="hljs-built_in">log</span>/syslog</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-SSH无密码登录及远程拷贝命令SCP的使用</title>
    <link href="/04-Linux/03-SSH%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4SCP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/04-Linux/03-SSH%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4SCP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="SSH无密码登录"><a href="#SSH无密码登录" class="headerlink" title="SSH无密码登录"></a>SSH无密码登录</h2><p>1.生成密钥对（公钥和私钥）</p><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> /home/cen/.ssh$ ssh-keygen -t rsa <span class="hljs-comment">#生成密钥，使用rsa方式进行加密，四个回车 </span>$ ssh-copy-id hostname <span class="hljs-comment">#复制公钥密钥</span></code></pre><p>原理，通过私钥与公钥的匹配能够唯一地确定一台机器，使得自己的身份得以确认，从而实现登录</p><h2 id="远程拷贝命令SCP的使用"><a href="#远程拷贝命令SCP的使用" class="headerlink" title="远程拷贝命令SCP的使用"></a>远程拷贝命令SCP的使用</h2><h3 id="1-设置SSH无密钥登录"><a href="#1-设置SSH无密钥登录" class="headerlink" title="1.设置SSH无密钥登录"></a>1.设置SSH无密钥登录</h3><pre><code class="hljs sh">$ ssh-copy anatherHostname</code></pre><h3 id="2-远程拷贝"><a href="#2-远程拷贝" class="headerlink" title="2.远程拷贝"></a>2.远程拷贝</h3><p>文件</p><pre><code class="hljs sh">$ scp /dir/dir/file userName@hostname:/dir/dir/file.copy</code></pre><p>文件夹</p><pre><code class="hljs sh">$ scp -r /dir/dir/dir userName@hostname:/dir/dir/dir</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-修改系统时区</title>
    <link href="/04-Linux/06-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/"/>
    <url>/04-Linux/06-%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux时区修改"><a href="#Linux时区修改" class="headerlink" title="Linux时区修改"></a>Linux时区修改</h1><h2 id="关于时区"><a href="#关于时区" class="headerlink" title="关于时区"></a>关于时区</h2><ul><li>UTC( Universal Time Coordinated )世界标准时间:与GMT相同</li><li>GMT( Greenwich MeanTime ) 0 时区，即格林尼治时间</li><li>CST( China Standard time )中国标准时间 GMT+0800</li></ul><h3 id="一-查看时区"><a href="#一-查看时区" class="headerlink" title="一.查看时区"></a>一.查看时区</h3><pre><code class="hljs sh">$ date2017年 07月 30日 星期日 13:33:09 CST$ date -R Sun, 30 Jul 2017 13:32:47 +0800</code></pre><h3 id="二-调整时区"><a href="#二-调整时区" class="headerlink" title="二.调整时区"></a>二.调整时区</h3><pre><code class="hljs sh"><span class="hljs-comment"># 删除时区的链接文件</span>$ rm /etc/localtim<span class="hljs-comment"># 增加新的时区链接文件</span>$ ln /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-sed命令学习</title>
    <link href="/04-Linux/10-sed%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <url>/04-Linux/10-sed%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Sed命令学习"><a href="#Sed命令学习" class="headerlink" title="Sed命令学习"></a>Sed命令学习</h1><p>sed是一种流编辑器，能够完美匹配正则表达式的使用。常用于Dockerfile编写</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><pre><code class="hljs gams">sed [<span class="hljs-keyword">options</span>] <span class="hljs-string">&#x27;command&#x27;</span> <span class="hljs-keyword">file</span>(s) sed [<span class="hljs-keyword">options</span>] -f scriptfile <span class="hljs-keyword">file</span>(s)</code></pre><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>按行处理的</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># /^export JAVA_HOME/ 匹配这个开头的这一行</span><span class="hljs-comment"># 替换所有为新的内容等同于  s|.*|ex|    s/.*/ex/</span><span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;/^export JAVA_HOME/ s:.*:export JAVA_HOME=/usr/java/default\nexport HADOOP_PREFIX=/usr/local/hadoop\nexport HADOOP_HOME=/usr/local/hadoop\n:&#x27;</span> <span class="hljs-variable">$HADOOP_PREFIX</span>/etc/hadoop/hadoop-env.sh</span><span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;/^export HADOOP_CONF_DIR/ s:.*:export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop/:&#x27;</span> <span class="hljs-variable">$HADOOP_PREFIX</span>/etc/hadoop/hadoop-env.sh</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-进程监控</title>
    <link href="/04-Linux/08-%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7/"/>
    <url>/04-Linux/08-%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h1><h2 id="整体监控"><a href="#整体监控" class="headerlink" title="整体监控"></a>整体监控</h2><pre><code class="hljs sh"><span class="hljs-comment"># 带色彩的监控</span>htop<span class="hljs-comment"># 不带色彩的监控</span>top</code></pre><h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><pre><code class="hljs sh">free -m<span class="hljs-comment"># 1.CPU占用最多的前10个进程：</span>ps auxw|head -1;ps auxw|sort -rn -k3|head -10<span class="hljs-comment"># 2.内存消耗最多的前10个进程</span>ps auxw|head -1;ps auxw|sort -rn -k4|head -10<span class="hljs-comment"># 3.虚拟内存使用最多的前10个进程</span>ps auxw|head -1;ps auxw|sort -rn -k5|head -10</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-Windows子系统WSL</title>
    <link href="/04-Linux/14-Windows%E5%AD%90%E7%B3%BB%E7%BB%9FWSL/"/>
    <url>/04-Linux/14-Windows%E5%AD%90%E7%B3%BB%E7%BB%9FWSL/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows子系统采坑日记"><a href="#Windows子系统采坑日记" class="headerlink" title="Windows子系统采坑日记"></a>Windows子系统采坑日记</h1><ol><li>开启Windows子系统功能</li></ol><pre><code class="hljs cmd">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><ol start="2"><li>应用商店搜索安装linux</li><li>重新安装SSH</li></ol><pre><code class="hljs sh">// 卸载sudo apt-get remove openssh-server// 安装sudo apt-get install openssh-server// 编辑配置文件vim /etc/ssh/sshd_configPort 36000  <span class="hljs-comment"># 默认的是22，但是windows有自己的ssh服务用的也是22端口，修改一下</span>PasswordAuthentication yes// 重启ssh服务sudo service ssh restart</code></pre><ol start="4"><li>跟着windows系统一起启动</li></ol><blockquote><p>搜索“任务计划程序”，操作– 创建基本任务<br>触发器：当计算机启动时<br>操作：启动程序<br>程序名：wsl.exe<br>参数为 <code>sudo service ssh start</code> 意思是打开bash，执行sshd命令开启ssh服务<br>选择“点击完成打开属性页”按钮，点击完成，打开属性页<br>在属性页选择“使用最高权限运行”，避免错误。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-一个高效的虚拟机(双系统)安装方法</title>
    <link href="/04-Linux/07-%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA(%E5%8F%8C%E7%B3%BB%E7%BB%9F)%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"/>
    <url>/04-Linux/07-%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA(%E5%8F%8C%E7%B3%BB%E7%BB%9F)%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机-双系统"><a href="#虚拟机-双系统" class="headerlink" title="虚拟机+双系统"></a>虚拟机+双系统</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>VMWare Workstation 12</p></li><li><p>U盘</p></li><li><p>装好windows的电脑</p></li><li><p>ubuntu iso文件</p></li><li><p>UltraISO 软件</p></li><li><p>目的：Windows + Linux + Windows下的虚拟机 仅占用一次Linux空间，且运行效率更高，文件自动同步！</p></li></ul><h2 id="安装双系统"><a href="#安装双系统" class="headerlink" title="安装双系统"></a>安装双系统</h2><ol><li>一、使用 UltraISO 制作 ubuntu 启动盘</li><li>二、重启电脑，打开主板的 boot 菜单选择 u 盘启动</li><li>三、手动分区(记住自己分的区的大小，后面要用)安装 ubuntu</li></ol><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><h3 id="一、安装-VMWare-Workstation-12"><a href="#一、安装-VMWare-Workstation-12" class="headerlink" title="一、安装 VMWare Workstation 12"></a>一、安装 VMWare Workstation 12</h3><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222036481-392074932.png"></p><h3 id="二、创建自定义虚拟机"><a href="#二、创建自定义虚拟机" class="headerlink" title="二、创建自定义虚拟机"></a>二、创建自定义虚拟机</h3><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222052606-782679502.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222100012-1642679804.png"></p><h4 id="2-1选择稍后安装操作系统"><a href="#2-1选择稍后安装操作系统" class="headerlink" title="2.1选择稍后安装操作系统"></a>2.1选择稍后安装操作系统</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222108012-546493536.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222116278-1704636712.png"></p><h4 id="2-2主机名以后还可以改，位置仅仅用于存放配置文件，放自己能找到的文件夹"><a href="#2-2主机名以后还可以改，位置仅仅用于存放配置文件，放自己能找到的文件夹" class="headerlink" title="2.2主机名以后还可以改，位置仅仅用于存放配置文件，放自己能找到的文件夹"></a>2.2主机名以后还可以改，位置仅仅用于存放配置文件，放自己能找到的文件夹</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222122809-489097383.png"></p><h4 id="2-3根据个人需求选择处理器数量，为了虚拟机的高性能我选择与宿主本机配置相同"><a href="#2-3根据个人需求选择处理器数量，为了虚拟机的高性能我选择与宿主本机配置相同" class="headerlink" title="2.3根据个人需求选择处理器数量，为了虚拟机的高性能我选择与宿主本机配置相同"></a>2.3根据个人需求选择处理器数量，为了虚拟机的高性能我选择与宿主本机配置相同</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222129700-1292208031.png"></p><h4 id="2-4根据个人需求选择分配的内存，win10一般占用2G，随时可调节"><a href="#2-4根据个人需求选择分配的内存，win10一般占用2G，随时可调节" class="headerlink" title="2.4根据个人需求选择分配的内存，win10一般占用2G，随时可调节"></a>2.4根据个人需求选择分配的内存，win10一般占用2G，随时可调节</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222136871-1667333102.png"></p><h4 id="2-5选择网络连接方式，NAT是最简单稳定的，想了解可以百度一下"><a href="#2-5选择网络连接方式，NAT是最简单稳定的，想了解可以百度一下" class="headerlink" title="2.5选择网络连接方式，NAT是最简单稳定的，想了解可以百度一下"></a>2.5选择网络连接方式，NAT是最简单稳定的，想了解可以百度一下</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222143918-2015532657.png"></p><h4 id="2-6都推荐了，我还能说什么"><a href="#2-6都推荐了，我还能说什么" class="headerlink" title="2.6都推荐了，我还能说什么"></a>2.6都推荐了，我还能说什么</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222155981-1087107864.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222210356-1113661115.png"></p><h4 id="2-7重点来了，使用物理磁盘，就是选择我们真实的磁盘分区（一定要选齐，选对，别选了window的分区）"><a href="#2-7重点来了，使用物理磁盘，就是选择我们真实的磁盘分区（一定要选齐，选对，别选了window的分区）" class="headerlink" title="2.7重点来了，使用物理磁盘，就是选择我们真实的磁盘分区（一定要选齐，选对，别选了window的分区）"></a>2.7重点来了，使用物理磁盘，就是选择我们真实的磁盘分区（一定要选齐，选对，别选了window的分区）</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222525700-921341482.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222537371-1322451106.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222300621-1381503352.png"></p><h4 id="2-8配置文件的文件名，位置是之前选的-见2-2"><a href="#2-8配置文件的文件名，位置是之前选的-见2-2" class="headerlink" title="2.8配置文件的文件名，位置是之前选的(见2.2)"></a>2.8配置文件的文件名，位置是之前选的(见2.2)</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222307168-1916938630.png"></p><h4 id="2-9完成"><a href="#2-9完成" class="headerlink" title="2.9完成"></a>2.9完成</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170722222314075-989339471.png"></p><p>使用后果未知道，因为后面都使用Mac了。。。</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-Java内存模型一张图</title>
    <link href="/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/99-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80%E5%BC%A0%E5%9B%BE/"/>
    <url>/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/99-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80%E5%BC%A0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-内存模型一张图"><a href="#Java-内存模型一张图" class="headerlink" title="Java 内存模型一张图"></a>Java 内存模型一张图</h1><p><img src="../images/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="内存模型一张图"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>09-JVM与性能调优</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JVM内存模型</title>
    <link href="/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/01-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/01-Java/09-JVM%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/01-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p><img src="../images/2019-12-15-23-44-03.png"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程独享 存储当前线程所执行的字节码的行号</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>为native方法服务</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>线程共享的内存区域，存放被加载的类信息、常量、静态变量、编译后的代码数据。<br>方法区的实现是永久代，Java8放弃了永久代，使用元数据（Metedata）代替，两者都是方法区的实现，元数据不在JVM中，直接使用了本地内存。</p><h2 id="Java虚拟机栈（栈）Stack"><a href="#Java虚拟机栈（栈）Stack" class="headerlink" title="Java虚拟机栈（栈）Stack"></a>Java虚拟机栈（栈）Stack</h2><p>利用栈的<strong>LIFO</strong>特性，为每个方法创建栈帧，栈帧中保存当前方法的局部变量，操作栈，动态链接，方法出口等信息</p><p>常见的<code>StackOverflowError</code>就是由于方法递归导致<strong>栈帧</strong>中也形成了栈递归而导致溢出</p><h2 id="堆Heap"><a href="#堆Heap" class="headerlink" title="堆Heap"></a>堆Heap</h2><p><img src="../images/2019-12-15-23-50-03.png"></p><p>堆内存是用于存放对象数据，GC主要回收的地方。</p><p>堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）也叫方法区。</p><p>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</p><p>关于垃圾回收，详见<a href="09-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>09-JVM与性能调优</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-配置文件密码未加密</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/07-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81%E6%9C%AA%E5%8A%A0%E5%AF%86/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/07-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%86%E7%A0%81%E6%9C%AA%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="使用jasypt实现配置文件加密"><a href="#使用jasypt实现配置文件加密" class="headerlink" title="使用jasypt实现配置文件加密"></a>使用jasypt实现配置文件加密</h1><p>严重等级：⭐️⭐️⭐️️⭐️️⭐️</p><h2 id="1-SpringBoot"><a href="#1-SpringBoot" class="headerlink" title="1. SpringBoot"></a>1. SpringBoot</h2><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jasypt配置文件加解密--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jasypt.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-加解密"><a href="#2-加解密" class="headerlink" title="2.加解密"></a>2.加解密</h3><pre><code class="hljs java"><span class="hljs-comment">//import com.ulisesbocchio.jasyptspringboot.encryptor.DefaultLazyEncryptor;</span><span class="hljs-comment">//import org.jasypt.encryption.StringEncryptor;</span><span class="hljs-comment">//import org.springframework.core.env.StandardEnvironment;</span><span class="hljs-comment">//import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><span class="hljs-comment">//import org.springframework.security.crypto.password.PasswordEncoder;</span><span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJasypt</span><span class="hljs-params">()</span> </span>&#123;        System.setProperty(<span class="hljs-string">&quot;jasypt.encryptor.password&quot;</span>, <span class="hljs-string">&quot;PASSWORD&quot;</span>);        StringEncryptor stringEncryptor = <span class="hljs-keyword">new</span> DefaultLazyEncryptor(<span class="hljs-keyword">new</span> StandardEnvironment());        <span class="hljs-comment">//加密方法</span>        String stringEncrypted = stringEncryptor.encrypt(<span class="hljs-string">&quot;Data*2019*&quot;</span>);        System.out.println(stringEncrypted);        <span class="hljs-comment">//解密方法</span>        System.out.println(stringEncryptor.decrypt(stringEncrypted));    &#125;</code></pre><h3 id="3-使用加密之后文本-格式为ENC-加密文本-，如下"><a href="#3-使用加密之后文本-格式为ENC-加密文本-，如下" class="headerlink" title="3.使用加密之后文本 格式为ENC(加密文本)，如下:"></a>3.使用加密之后文本 格式为ENC(加密文本)，如下:</h3><pre><code class="hljs java">minio:  url: https:<span class="hljs-comment">//minio.datainsights.biz</span>  access-key: ENC(HLVp+vD55W8RU3LEm7X+<span class="hljs-number">6</span>pZM9v1xdbFn)  secret-key: ENC(rzlvqCAk4woDf1g2GRRoNjLbvMZ8n4fne4L7q4ghfkg=)</code></pre><h3 id="4-设置变量的方法"><a href="#4-设置变量的方法" class="headerlink" title="4. 设置变量的方法"></a>4. 设置变量的方法</h3><ol><li><code>java -jar -Djasypt.encryptor.password=PASSWORD target/$&#123;NAME&#125;-$&#123;VERSION&#125;.jar</code></li><li>结合环境变量使用(=两边不能有空格)<pre><code class="hljs sh"><span class="hljs-built_in">export</span> JASYPT_PASSWORD=PASSWORDjava -jar -Djasypt.encryptor.password=<span class="hljs-variable">$&#123;JASYPT_PASSWORD&#125;</span> xxx.jar</code></pre></li><li>IDEA配置<br> <img src="../images/2019-08-20-11-58-25.png"><br> jasypt.encryptor.password=$JASYPT_PASSWORD</li></ol><h2 id="2-普通maven工程"><a href="#2-普通maven工程" class="headerlink" title="2. 普通maven工程"></a>2. 普通maven工程</h2><h3 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a>1. pom.xml</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jasypt.version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">jasypt.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.melloware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jasypt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jasypt.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-工具类"><a href="#2-工具类" class="headerlink" title="2. 工具类"></a>2. 工具类</h3><p>直接抄袭上述<code>DefaultLazyEncryptor</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * JasyptUtil to encrypt and decrypt</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-08-20</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JasyptUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StandardPBEStringEncryptor <span class="hljs-title">encryptor</span><span class="hljs-params">()</span></span>&#123;        StandardPBEStringEncryptor encryptor = <span class="hljs-keyword">new</span> StandardPBEStringEncryptor();        SimpleStringPBEConfig config = <span class="hljs-keyword">new</span> SimpleStringPBEConfig();        encryptor.setPassword(System.getProperty(<span class="hljs-string">&quot;jasypt.encryptor.password&quot;</span>));        config.setAlgorithm(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.algorithm&quot;</span>, <span class="hljs-string">&quot;PBEWithMD5AndDES&quot;</span>));        config.setKeyObtentionIterations(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.keyObtentionIterations&quot;</span>, <span class="hljs-string">&quot;1000&quot;</span>));        config.setPoolSize(getProperty( <span class="hljs-string">&quot;jasypt.encryptor.poolSize&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));        config.setProviderName(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.providerName&quot;</span>, <span class="hljs-keyword">null</span>));        config.setProviderClassName(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.providerClassName&quot;</span>, <span class="hljs-keyword">null</span>));        config.setSaltGeneratorClassName(getProperty( <span class="hljs-string">&quot;jasypt.encryptor.saltGeneratorClassname&quot;</span>, <span class="hljs-string">&quot;org.jasypt.salt.RandomSaltGenerator&quot;</span>));        config.setIvGeneratorClassName(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.ivGeneratorClassname&quot;</span>, <span class="hljs-string">&quot;org.jasypt.salt.NoOpIVGenerator&quot;</span>));        config.setStringOutputType(getProperty(<span class="hljs-string">&quot;jasypt.encryptor.stringOutputType&quot;</span>, <span class="hljs-string">&quot;base64&quot;</span>));        encryptor.setConfig(config);        <span class="hljs-keyword">return</span> encryptor;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Properties <span class="hljs-title">getProperties</span><span class="hljs-params">(InputStream in)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Properties properties = <span class="hljs-keyword">new</span> EncryptableProperties(encryptor());        properties.load(in);        <span class="hljs-keyword">return</span> properties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String s)</span></span>&#123;        <span class="hljs-keyword">return</span> encryptor().encrypt(s);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String s)</span></span>&#123;        <span class="hljs-keyword">return</span> encryptor().decrypt(s);    &#125;&#125;</code></pre><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><pre><code class="hljs java"><span class="hljs-comment">// 直接加载配置文件，yml尚未研究</span>Properties baiduProperties = JasyptUtil.getProperties(in);<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encrypt</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//加密方法</span>    System.out.println(JasyptUtil.encrypt(<span class="hljs-string">&quot;&quot;</span>));&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrypt</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//解密方法</span>    System.out.println(JasyptUtil.decrypt(<span class="hljs-string">&quot;&quot;</span>));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-阿里镜像</title>
    <link href="/01-Java/04-Maven/08-%E9%98%BF%E9%87%8C%E9%95%9C%E5%83%8F/"/>
    <url>/01-Java/04-Maven/08-%E9%98%BF%E9%87%8C%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven使用阿里云镜像"><a href="#Maven使用阿里云镜像" class="headerlink" title="Maven使用阿里云镜像"></a>Maven使用阿里云镜像</h1>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-DependencyManagement</title>
    <link href="/01-Java/04-Maven/09-DependencyManagement/"/>
    <url>/01-Java/04-Maven/09-DependencyManagement/</url>
    
    <content type="html"><![CDATA[<h1 id="DependencyManagement"><a href="#DependencyManagement" class="headerlink" title="DependencyManagement"></a>DependencyManagement</h1><p>Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p><p>常用于XX-parent项目</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-python爬虫教程</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/02-python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/02-python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一个小时写一个python爬虫"><a href="#一个小时写一个python爬虫" class="headerlink" title="一个小时写一个python爬虫"></a>一个小时写一个python爬虫</h1><p>首先，前提是先安装好python和开发工具IDEA。</p><h2 id="第一步-网站分析"><a href="#第一步-网站分析" class="headerlink" title="第一步:网站分析"></a>第一步:网站分析</h2><p>我们的目标站点是<a href="http://www.ftchinese.com/">FT中文网</a>，进去的是首页，但是这不是我们的目标，我们的目标是文章，所以随意点一篇文章。比如：</p><p><a href="http://www.ftchinese.com/story/001075140">http://www.ftchinese.com/story/001075140</a></p><p>这篇文章需要注意的一点是，它只显示了第一页，我们在可视化界面中看到的东西就是源码编译出来的东西，所以也就是说，这时候的即使我们去爬取信息也会是不完整的。点击<strong>全文</strong>，这时候的页面变成了<a href="http://www.ftchinese.com/story/001075140?full=y">http://www.ftchinese.com/story/001075140?full=y</a>对比前后的地址就会发现，其实是多了<code>?full=y</code>这几个字符，这是HTTP请求的Get传参方式。</p><p>这时候，鼠标右键查看源码，往下滚滚滚，就会出现密密麻麻的一段文字就是我们想要的内容(大概在2/3的位置)，也就是说我们模拟浏览器下载这个源码就能够拿到我们想要的数据了。</p><p>然后我们在页面右侧找到了<strong>相关文章</strong>，这个信息非常重要。这是我们爬虫能够源源不断爬取的关键。为什么不使用底部的<strong>您可能感兴趣的文章</strong>呢，那个东西是异步加载的。技术上实现要难上很多。</p><p><img src="../../images/01-01.png"></p><h2 id="第二步-下载源码"><a href="#第二步-下载源码" class="headerlink" title="第二步:下载源码"></a>第二步:下载源码</h2><p>首先我们创建一个工程，然后新建一个<code>main.py</code>文件和<code>download_htlm.py</code>文件</p><p><code>download_html.py</code>使用这个文件来下载源码，这里可能会遇到的问题包括<strong>模拟浏览器cooice</strong>，<strong>异步加载问题</strong>，<strong>模拟登陆问题</strong>，甚至是<strong>IP封锁问题</strong>，在这里为了简单不进行赘述，可以参考我另外一篇博客<a href="http://www.cnblogs.com/cenzhongman/p/7344406.html">三种urllib实现网页下载，含cookie模拟登陆</a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">url</span>):</span>    response = urllib.request.urlopen(url)    <span class="hljs-keyword">if</span> response.getcode() == <span class="hljs-number">200</span>:        conf = response.read().decode(<span class="hljs-string">&#x27;utf8&#x27;</span>)        <span class="hljs-keyword">return</span> conf    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&#x27;URL请求错误&#x27;</span>)        <span class="hljs-keyword">return</span></code></pre><p><code>main.py</code>用于作为程序入口，调用其他组件</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> download_html <span class="hljs-keyword">import</span> downloadurl = <span class="hljs-string">&#x27;http://www.ftchinese.com/story/001075140?full=y&#x27;</span>content = download(url)print(content)</code></pre><p>观察控制台，控制台将会输出页面的源码信息。我们需要的信息也在这个控制台输出中。</p><h2 id="第三步-数据清洗"><a href="#第三步-数据清洗" class="headerlink" title="第三步:数据清洗"></a>第三步:数据清洗</h2><p>但是这个爬虫不会继续爬下去了，我们回到浏览器。在<strong>相关文章</strong>中的文章列表中右键<code>检查/审查元素</code>，将会指向一个a标签，这个a标签内容如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/story/001074864&quot;</span>&gt;</span>中国房地产热潮支撑“中国梦”<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>这是一个HTMl的<code>href</code>标签，用于跳转，我们的爬虫也需要从这个地方跳转出去，观察href标签之后的内容<code>/story/001074864</code>，然后前面加上<code>http://www.ftchinese.com</code>，后面加上<code>?full=y</code>,就变成了<code>http://www.ftchinese.com/story/001072657?full=y</code>，浏览器访问以下，发现，真的可以访问。</p><p>创建文件<code>parser_html.py</code></p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql.yaml</title>
    <link href="/04-Linux/03-k8s/mysql.yaml/"/>
    <url>/04-Linux/03-k8s/mysql.yaml/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-cenzhongman"><a href="#Author-cenzhongman" class="headerlink" title="Author:cenzhongman"></a>Author:cenzhongman</h1><h1 id="E-mail-99-x65-x6e-x7a-104-111-x6e-x67-109-x61-x6e-x40-x31-x36-x33-x2e-x63-x6f-x6d"><a href="#E-mail-99-x65-x6e-x7a-104-111-x6e-x67-109-x61-x6e-x40-x31-x36-x33-x2e-x63-x6f-x6d" class="headerlink" title="E-mail:&#99;&#x65;&#x6e;&#x7a;&#104;&#111;&#x6e;&#x67;&#109;&#x61;&#x6e;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;"></a>E-mail:<a href="mailto:&#99;&#x65;&#x6e;&#x7a;&#104;&#111;&#x6e;&#x67;&#109;&#x61;&#x6e;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#99;&#x65;&#x6e;&#x7a;&#104;&#111;&#x6e;&#x67;&#109;&#x61;&#x6e;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a></h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h1 id="整个数据库集群的公共配置"><a href="#整个数据库集群的公共配置" class="headerlink" title="整个数据库集群的公共配置"></a>整个数据库集群的公共配置</h1><p>apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: mysql<br>  labels:<br>    app: mysql<br>data:<br>  mysql.replication.username: “replication”<br>  mysql.replication.password: “Data<em>2018</em>“<br>  mysql.root.password: “MySQLData<em>2018</em>“<br>  mysql.timezone: “Asia/Shanghai”</p><hr><h1 id="Master节点Service"><a href="#Master节点Service" class="headerlink" title="Master节点Service"></a>Master节点Service</h1><p>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: mysql-master<br>  labels:<br>    app: mysql-master<br>spec:<br>  type: NodePort<br>  ports:<br>    - port: 3306<br>      targetPort: 3306<br>      nodePort: 30306<br>  selector:<br>    app: mysql-master</p><hr><h1 id="slaver节点Service"><a href="#slaver节点Service" class="headerlink" title="slaver节点Service"></a>slaver节点Service</h1><p>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: mysql-slaver<br>  labels:<br>    app: mysql-slaver<br>spec:<br>  type: NodePort<br>  ports:<br>    - port: 3306<br>      targetPort: 3306<br>      nodePort: 30307<br>  selector:<br>    app: mysql-slaver</p><hr><h1 id="Master-StatefulSet-的配置和启动"><a href="#Master-StatefulSet-的配置和启动" class="headerlink" title="Master StatefulSet 的配置和启动"></a>Master StatefulSet 的配置和启动</h1><p>apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: mysql-master<br>spec:<br>  selector:<br>    matchLabels:<br>      app: mysql-master<br>  serviceName: mysql-master<br>  replicas: 1<br>  template:<br>    metadata:<br>      labels:<br>        app: mysql-master<br>    spec:<br>      initContainers:<br>        # 生成配置文件 mysqld.cnf 和 初始化语句 init_sync.sql<br>        - name: init-mysql-master<br>          image: mysql:8.0.17<br>          env:<br>            - name: MYSQL_REPLICATION_USER<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.replication.username<br>            - name: MYSQL_REPLICATION_PASSWORD<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.replication.password<br>            - name: MYSQL_SLAVER_SERVICE_HOST<br>              value: “%”<br>            - name: CONFIG_FILE<br>              value: “/etc/mysql/conf.d/mysqld.cnf”<br>            - name: INIT_SQL_FILE<br>              value: “/docker-entrypoint-initdb.d/init_sync.sql”<br>          command:<br>            - bash<br>            - “-c”<br>            - |<br>              [[ <code>hostname</code> =~ -([0-9]+)$ ]] || exit 1<br>              ORDINAL=${BASH_REMATCH[1]}<br>              SERVER_ID=$((100+$ORDINAL))<br>              # 构造mysql配置文件<br>              echo -e ‘[mysqld]\nserver-id=’$SERVER_ID’\nlog-bin’ &gt; ${CONFIG_FILE}<br>              # 创建同步账号<br>              echo -e “CREATE USER ‘$MYSQL_REPLICATION_USER’@’$MYSQL_SLAVER_SERVICE_HOST’ IDENTIFIED WITH ‘mysql_native_password’ BY ‘$MYSQL_REPLICATION_PASSWORD’;” &gt; $INIT_SQL_FILE<br>              echo -e “GRANT REPLICATION SLAVE ON <em>.</em> TO ‘$MYSQL_REPLICATION_USER’@’$MYSQL_SLAVER_SERVICE_HOST’;” &gt;&gt; $INIT_SQL_FILE<br>              echo -e “FLUSH PRIVILEGES;” &gt;&gt; $INIT_SQL_FILE<br>          volumeMounts:<br>            - name: conf<br>              mountPath: /etc/mysql/conf.d/<br>            - name: init-path<br>              mountPath: /docker-entrypoint-initdb.d/<br>      containers:<br>        - name: mysql-master<br>          image: mysql:8.0.17<br>          env:<br>            - name: MYSQL_ROOT_PASSWORD<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.root.password<br>            - name: TZ<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.timezone<br>          ports:<br>            - name: mysql<br>              containerPort: 3306<br>          volumeMounts:<br>            - name: conf<br>              mountPath: /etc/mysql/conf.d/<br>            - name: init-path<br>              mountPath: /docker-entrypoint-initdb.d/<br>            - name: data<br>              mountPath: /var/lib/mysql<br>              subPath: mysql<br>          resources:<br>            requests:<br>              cpu: 500m<br>              memory: 1Gi<br>          readinessProbe:<br>            tcpSocket:<br>              port: mysql<br>      volumes:<br>        - name: conf<br>          emptyDir: {}<br>        - name: init-path<br>          emptyDir: {}<br>  volumeClaimTemplates:<br>    - metadata:<br>        name: data<br>      spec:<br>        accessModes: [“ReadWriteOnce”]<br>        resources:<br>          requests:<br>            storage: 10Gi</p><hr><h1 id="Slaver-StatefulSet-的配置和启动"><a href="#Slaver-StatefulSet-的配置和启动" class="headerlink" title="Slaver StatefulSet 的配置和启动"></a>Slaver StatefulSet 的配置和启动</h1><p>apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: mysql-slaver<br>spec:<br>  selector:<br>    matchLabels:<br>      app: mysql-slaver<br>  serviceName: mysql-slaver<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: mysql-slaver<br>    spec:<br>      initContainers:<br>        - name: init-mysql-slaver<br>          image: mysql:8.0.17<br>          env:<br>            - name: MYSQL_REPLICATION_USER<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.replication.username<br>            - name: MYSQL_REPLICATION_PASSWORD<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.replication.password<br>            - name: MYSQL_MASTER_SERVICE_HOST<br>              value: “mysql-master”<br>            - name: CONFIG_FILE<br>              value: “/etc/mysql/conf.d/mysqld.cnf”<br>            - name: INIT_SQL_FILE<br>              value: “/docker-entrypoint-initdb.d/init_sync.sql”<br>          command:<br>            - bash<br>            - “-c”<br>            - |<br>              [[ <code>hostname</code> =~ -([0-9]+)$ ]] || exit 1<br>              ORDINAL=${BASH_REMATCH[1]}<br>              SERVER_ID=$((1+$ORDINAL))<br>              # 构造mysql配置文件<br>              echo -e ‘[mysqld]\nserver-id=’$SERVER_ID’’ &gt; ${CONFIG_FILE}<br>              # 创建同步账号<br>              echo -e “STOP SLAVE;” &gt; $INIT_SQL_FILE<br>              echo -e “CHANGE MASTER TO master_host=’$MYSQL_MASTER_SERVICE_HOST’, master_user=’$MYSQL_REPLICATION_USER’, master_password=’$MYSQL_REPLICATION_PASSWORD’;” &gt;&gt; $INIT_SQL_FILE<br>              echo -e “START SLAVE;” &gt;&gt; $INIT_SQL_FILE<br>              echo -e “set global read_only=1;” &gt;&gt; $INIT_SQL_FILE<br>          volumeMounts:<br>            - name: conf<br>              mountPath: /etc/mysql/conf.d/<br>            - name: init-path<br>              mountPath: /docker-entrypoint-initdb.d/<br>      containers:<br>        - name: mysql-slaver<br>          image: mysql:8.0.17<br>          env:<br>            - name: MYSQL_ROOT_PASSWORD<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.root.password<br>            - name: TZ<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: mysql<br>                  key: mysql.timezone<br>          ports:<br>            - name: mysql<br>              containerPort: 3306<br>          volumeMounts:<br>            - name: conf<br>              mountPath: /etc/mysql/conf.d/<br>            - name: init-path<br>              mountPath: /docker-entrypoint-initdb.d/<br>            - name: data<br>              mountPath: /var/lib/mysql<br>              subPath: mysql<br>          resources:<br>            requests:<br>              cpu: 500m<br>              memory: 1Gi<br>          readinessProbe:<br>            tcpSocket:<br>              port: mysql<br>      volumes:<br>        - name: conf<br>          emptyDir: {}<br>        - name: init-path<br>          emptyDir: {}<br>  volumeClaimTemplates:<br>    - metadata:<br>        name: data<br>      spec:<br>        accessModes: [“ReadWriteOnce”]<br>        resources:<br>          requests:<br>            storage: 10Gi</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-五十音图</title>
    <link href="/99-Others/14-%E6%97%A5%E8%AF%AD/02-%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/"/>
    <url>/99-Others/14-%E6%97%A5%E8%AF%AD/02-%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="五十音"><a href="#五十音" class="headerlink" title="五十音"></a>五十音</h1><h2 id="一、元音"><a href="#一、元音" class="headerlink" title="一、元音"></a>一、元音</h2><table><thead><tr><th>元音</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>あ ア a</td><td>い イ i</td><td>う ウ u</td><td>え エ e</td><td>お オ o</td></tr></tbody></table><h2 id="二、辅音"><a href="#二、辅音" class="headerlink" title="二、辅音"></a>二、辅音</h2><table><thead><tr><th>辅音</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>清音</td><td>か k</td><td>さ s</td><td>た t</td><td>な n</td><td>は h</td><td>ま m</td><td>や y</td><td>ら r</td><td>わ w</td><td>ぱ p</td></tr><tr><td>浊音</td><td>が g</td><td>ざ z</td><td>だ d</td><td></td><td>ば b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="四、清音"><a href="#四、清音" class="headerlink" title="四、清音"></a>四、清音</h2><table><thead><tr><th>清音</th><th>あ 段</th><th>い 段</th><th>う 段</th><th>え 段</th><th>お 段</th></tr></thead><tbody><tr><td>あ 行 a</td><td>あ ア a</td><td>い イ i</td><td>う ウ u</td><td>え エ e</td><td>お オ o</td></tr><tr><td>か 行 k</td><td>か カ ka</td><td>き キ ki</td><td>く ク ku</td><td>け ケ ke</td><td>こ コ ko</td></tr><tr><td>さ 行 s</td><td>さ サ sa</td><td>し シ si</td><td>す ス su</td><td>せ セ se</td><td>そ ソ so</td></tr><tr><td>た 行 t</td><td>た タ ta</td><td>ち チ chi</td><td>つ ツ tsu</td><td>て テ te</td><td>と ト to</td></tr><tr><td>な 行 n</td><td>な ナ na</td><td>に ニ ni</td><td>ぬ ヌ nu</td><td>ね ネ ne</td><td>の ノ no</td></tr><tr><td>は 行 h</td><td>は ハ ha</td><td>ひ ヒ hi</td><td>ふ フ fu</td><td>ヘ ﾍ  he</td><td>ほ ホ ho</td></tr><tr><td>ま 行 m</td><td>ま マ ma</td><td>み ミ mi</td><td>む ム mu</td><td>め メ me</td><td>も モ mo</td></tr><tr><td>や 行 y</td><td>や ヤ ya</td><td></td><td>ゆ ユ yu</td><td></td><td>よ ヨ yo</td></tr><tr><td>ら 行 r</td><td>ら ラ ra</td><td>り リ ri</td><td>る ル ru</td><td>れ レ re</td><td>ろ ロ ro</td></tr><tr><td>わ 行 w</td><td>わ ワ wa</td><td></td><td></td><td></td><td>を ヲ o</td></tr><tr><td></td><td>ん ン n</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="二、浊音"><a href="#二、浊音" class="headerlink" title="二、浊音"></a>二、浊音</h2><blockquote><p>ぢ ヂ 读 ji 输 di<br>づ ヅ 读 zu 输 du</p></blockquote><table><thead><tr><th>浊音</th><th>q</th><th>去</th><th>去</th><th>q</th><th>去</th></tr></thead><tbody><tr><td>が 行 g</td><td>が ガ ga</td><td>ぎ ギ gi</td><td>ぐ グ gu</td><td>げ ゲ ge</td><td>ご ゴ go</td></tr><tr><td>ざ 行 z</td><td>ざ ザ za</td><td>じ ジ ji</td><td>ず ズ zu</td><td>ぜ ゼ ze</td><td>ぞ ゾ zo</td></tr><tr><td>だ 行 d</td><td>だ ダ da</td><td>ぢ ヂ ji</td><td>づ ヅ zu</td><td>で デ de</td><td>ど ド do</td></tr><tr><td>ば 行 b</td><td>ば バ ba</td><td>び ビ bi</td><td>ぶ ブ bu</td><td>べ ベ be</td><td>ぼ ボ bo</td></tr></tbody></table><table><thead><tr><th>半浊音</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ぱ 行 p</td><td>ぱ パ pa</td><td>ぴ ピ pi</td><td>ぷ プ pu</td><td>ぺ ペ pe</td><td>ぽ ポ po</td></tr></tbody></table><h2 id="三、拗音"><a href="#三、拗音" class="headerlink" title="三、拗音"></a>三、拗音</h2><p><strong>い</strong>段和<strong>や</strong>行拼在一起</p><table><thead><tr><th>清拗音</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>きゃ キア kya</td><td>きゅ キュ kyu</td><td>きょ キョ kyo</td><td></td></tr><tr><td>しゃ シャ sya</td><td>しゅ シュ syu</td><td>しょ ショ syo</td><td></td></tr><tr><td>ちゃ チャ cha</td><td>ちゅ チュ chu</td><td>ちょ チョ cho</td><td></td></tr><tr><td>にゃ ニャ nya</td><td>にゅ ニュ nyu</td><td>にょ ニョ nyo</td><td></td></tr><tr><td>ひゃ ヒャ hya</td><td>ひゅ ヒュ hyu</td><td>ひょ ヒョ hyo</td><td></td></tr><tr><td>みゃ ミャ mya</td><td>みゅ ミュ myu</td><td>みょ ミョ myo</td><td></td></tr><tr><td>りゃ リャ rya</td><td>りゅ リュ ryu</td><td>りょ リョ ryo</td><td></td></tr></tbody></table><table><thead><tr><th>浊拗音</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ぎゃ ギャ gya</td><td>ぎゅ ギョ gyu</td><td>ぎょ ギョ gyo</td><td></td></tr><tr><td>じゃ ジャ ja</td><td>じゅ ジュ ju</td><td>じょ ジョ jo</td><td></td></tr><tr><td>ピャ ピャ pya</td><td>ぴゅ ピュ pyu</td><td>ぴょ ピョ pyo</td><td></td></tr><tr><td>びゃ ビャ bya</td><td>びゅ ビュ byu</td><td>びょ ビョ byo</td><td></td></tr></tbody></table><h2 id="四、拨音"><a href="#四、拨音" class="headerlink" title="四、拨音"></a>四、拨音</h2><p>⚠️：拨音占一拍</p><p>拨音受后面音节的影响，有三种发音（只需了解，自然读就好了）</p><table><thead><tr><th>后面的音节</th><th>发音</th><th>例子</th></tr></thead><tbody><tr><td>ぱばま 行</td><td>m</td><td>さん<strong>ぽ</strong>【散歩】 しん<strong>ぶ</strong>ん【新聞】</td></tr><tr><td>ただらな 行</td><td>n</td><td>ほん<strong>ら</strong>い【本来】 ほん<strong>だ</strong>【本田】</td></tr><tr><td>其他</td><td>ng(鼻音)</td><td>へんか【変化】 れんあい【恋愛】</td></tr></tbody></table><table><thead><tr><th>拨音</th><th></th></tr></thead><tbody><tr><td>清音</td><td>かん かん kan</td></tr><tr><td>浊音</td><td>がん ガン gan</td></tr><tr><td>拗音</td><td>きゃん　キャン  kyan</td></tr></tbody></table><h2 id="五、促音"><a href="#五、促音" class="headerlink" title="五、促音"></a>五、促音</h2><p>つ在日语中可以作为不发音音节使用</p><ul><li><p>写法  </p><ul><li>平假名：おっと</li><li>片假名：オット</li><li>罗马字：otto</li></ul></li><li><p>读法</p><ul><li><p>摩擦促音 发s</p><table><thead><tr><th>さ行</th><th></th></tr></thead><tbody><tr><td>くし　【梳子】</td><td>くっし【屈し】</td></tr></tbody></table></li><li><p>阻塞促音 停顿不发音</p><table><thead><tr><th>かたぱ行</th><th></th></tr></thead><tbody><tr><td>おと【音】</td><td>おっと【夫】</td></tr><tr><td>さか【坂】</td><td>さっか【作家】</td></tr></tbody></table></li></ul></li></ul><h2 id="六、长音"><a href="#六、长音" class="headerlink" title="六、长音"></a>六、长音</h2><p>元音在一定情况下可能作为长音使用</p><table><thead><tr><th>段</th><th>长音</th><th>例子</th></tr></thead><tbody><tr><td>あ段</td><td>あ</td><td>おか<strong>あ</strong>さん【お母さん】母亲</td></tr><tr><td>い段</td><td>い</td><td>おに<strong>い</strong>さん【お兄さん】哥哥</td></tr><tr><td>う段</td><td>う</td><td>つ<strong>う</strong>やく【通訳】</td></tr><tr><td>え段</td><td>い　え</td><td>おね<strong>え</strong>さん【お姉さん】　え<strong>え</strong>と【ええと】</td></tr><tr><td>お段</td><td>う　お</td><td>と<strong>あ</strong>い【约会】　　　　　お<strong>お</strong>さか【大阪】</td></tr><tr><td>片假名</td><td>ー</td><td>サッカーサッカー【足球】</td></tr></tbody></table><h2 id="七、外来词专用音节"><a href="#七、外来词专用音节" class="headerlink" title="七、外来词专用音节"></a>七、外来词专用音节</h2><table><thead><tr><th>外来音</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ツァ tsa</td><td>ファ fa</td><td></td><td></td><td></td><td></td></tr><tr><td>ウィ wi</td><td>ティ ti</td><td>フィ dyu</td><td></td><td></td><td></td></tr><tr><td>トゥ tu</td><td>ドゥ du</td><td>ヂュ dyu</td><td></td><td></td><td></td></tr><tr><td>ウェ we</td><td>シェ she</td><td>チェ che</td><td>ツェt se</td><td>フェ fe</td><td>ジェ je</td></tr><tr><td>ウォ wo</td><td>ツォ tso</td><td>フォ fo</td><td></td><td></td><td></td></tr></tbody></table><h2 id="八、巧记"><a href="#八、巧记" class="headerlink" title="八、巧记"></a>八、巧记</h2><h3 id="1-1-あ行"><a href="#1-1-あ行" class="headerlink" title="1.1 あ行"></a>1.1 あ行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>あ　ア　a</td><td>女 矛</td></tr><tr><td>い　イ　i</td><td>以 他（黎）</td></tr><tr><td>う　ウ　u</td><td></td></tr><tr><td>え　エ　e</td><td>诶字写一半就去工作了</td></tr><tr><td>お　オ　o</td><td>学（黎）才术</td></tr></tbody></table><h3 id="1-2-か行"><a href="#1-2-か行" class="headerlink" title="1.2 か行"></a>1.2 か行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>か カ ka</td><td>咖啡要加水</td></tr><tr><td>き キ ki</td><td>key</td></tr><tr><td>く ク ku</td><td>拼クク :&lt;（哭）了</td></tr><tr><td>け ケ ke</td><td>射箭 开枪</td></tr><tr><td>こ コ ko</td><td>括号() ]</td></tr></tbody></table><h3 id="1-3-さ行"><a href="#1-3-さ行" class="headerlink" title="1.3 さ行"></a>1.3 さ行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>さ サ sa</td><td>杀字写一半 草头就掉了</td></tr><tr><td>し シ si</td><td>用吸管 吸三点水</td></tr><tr><td>す ス su</td><td>９字上吊很久了 身体都酥了</td></tr><tr><td>せ セ se</td><td>世</td></tr><tr><td>そ ソ so</td><td>缩两点水</td></tr></tbody></table><h3 id="1-4-た行"><a href="#1-4-た行" class="headerlink" title="1.4 た行"></a>1.4 た行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>た タ ta</td><td>他十二点看夕阳</td></tr><tr><td>ち チ chi</td><td>5千七</td></tr><tr><td>つ ツ tsu</td><td>用舌头 吃三点水</td></tr><tr><td>て テ te</td><td>镰刀草帽是科技（te… ）</td></tr><tr><td>と ト to</td><td>托起萝卜</td></tr></tbody></table><h3 id="1-5-な行"><a href="#1-5-な行" class="headerlink" title="1.5 な行"></a>1.5 な行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>な ナ na</td><td>哪(na)吒有披风 风火轮 红缨枪 站在十字路口</td></tr><tr><td>に ニ ni</td><td>二（黎）</td></tr><tr><td>ぬ ヌ nu</td><td>奴 的简写</td></tr><tr><td>ね ネ ne</td><td>ne（黎）死的人 只留下衣服</td></tr><tr><td>の ノ no</td><td></td></tr></tbody></table><h3 id="1-6-は行"><a href="#1-6-は行" class="headerlink" title="1.6 は行"></a>1.6 は行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>は ハ ha</td><td>八戒练咏春 哈</td></tr><tr><td>ひ ヒ hi</td><td>嘻(hi)嘻 我有匕首</td></tr><tr><td>ふ フ fu</td><td>小 7 戴帽子呼气</td></tr><tr><td>ヘ ﾍ he</td><td>点头 he（黎话）</td></tr><tr><td>ほ ホ ho</td><td>戴上帽子对着木头练咏春 嚯</td></tr></tbody></table><h3 id="1-7-ま行"><a href="#1-7-ま行" class="headerlink" title="1.7 ま行"></a>1.7 ま行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ま マ ma</td><td>馬字的内部 马的第一二笔</td></tr><tr><td>み ミ mi</td><td>♫ 123的mi</td></tr><tr><td>む ム mu</td><td>十字架 死翘翘的人 乌鸦天上飞 墓 么</td></tr><tr><td>め メ me</td><td>ぬ隶咩都没了 X</td></tr><tr><td>も モ mo</td><td>毛</td></tr></tbody></table><h3 id="1-8-や行"><a href="#1-8-や行" class="headerlink" title="1.8 や行"></a>1.8 や行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>や ヤ ya</td><td>也（粤）</td></tr><tr><td>ゆ ユ yu</td><td>由　油管探油</td></tr><tr><td>よ ヨ yo</td><td>yo连体也看不清视力表</td></tr></tbody></table><h3 id="1-9-ら行"><a href="#1-9-ら行" class="headerlink" title="1.9 ら行"></a>1.9 ら行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ら ラ ra</td><td>5 拉 戴帽子的 7</td></tr><tr><td>り リ ri</td><td>两根棍子立起来</td></tr><tr><td>る ル ru</td><td>儿(黎) 不知好歹</td></tr><tr><td>れ レ re</td><td>礼</td></tr><tr><td>ろ ロ ro</td><td>耳朵 和 嘴巴 咯</td></tr></tbody></table><h3 id="1-10-わ行"><a href="#1-10-わ行" class="headerlink" title="1.10 わ行"></a>1.10 わ行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>わ ワ wa</td><td>哇 这人真胖 7 低头看看</td></tr><tr><td>を ヲ o</td><td>all 火车被人踩着 7被捅了一刀</td></tr></tbody></table><h3 id="1-11-ん行"><a href="#1-11-ん行" class="headerlink" title="1.11 ん行"></a>1.11 ん行</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ん ン n</td><td>n 两点水</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>14-日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-日语基础</title>
    <link href="/99-Others/14-%E6%97%A5%E8%AF%AD/01-%E6%97%A5%E8%AF%AD%E5%9F%BA%E7%A1%80/"/>
    <url>/99-Others/14-%E6%97%A5%E8%AF%AD/01-%E6%97%A5%E8%AF%AD%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="日语基础"><a href="#日语基础" class="headerlink" title="日语基础"></a>日语基础</h1><h2 id="一、日语组成"><a href="#一、日语组成" class="headerlink" title="一、日语组成"></a>一、日语组成</h2><h3 id="1-1-日本文字构成"><a href="#1-1-日本文字构成" class="headerlink" title="1.1 日本文字构成"></a>1.1 日本文字构成</h3><ol><li>汉字</li><li>假名<ol><li>平假名 草书 あいうえお</li><li>片假名 楷书 アイウエオ</li><li>罗马字</li></ol></li></ol><h3 id="1-2-中日汉字字型"><a href="#1-2-中日汉字字型" class="headerlink" title="1.2 中日汉字字型"></a>1.2 中日汉字字型</h3><ol><li>相同</li><li>相似</li><li>差异较大</li><li>日本国字</li></ol><h3 id="1-3-中日汉字字义"><a href="#1-3-中日汉字字义" class="headerlink" title="1.3 中日汉字字义"></a>1.3 中日汉字字义</h3><p>中日同义：日本 学生<br>中日异义：丈夫（结实）新闻（报纸）</p><h3 id="1-4-日文发音"><a href="#1-4-日文发音" class="headerlink" title="1.4 日文发音"></a>1.4 日文发音</h3><ol><li>音读 模仿中国古汉字发音 山水</li><li>训读 日本本土发音，借中字 山 水</li></ol><h3 id="1-5-平假名-片假名"><a href="#1-5-平假名-片假名" class="headerlink" title="1.5 平假名 片假名"></a>1.5 平假名 片假名</h3><p>绝大部分场景下 使用平假名</p><p>片假名的场景</p><ol><li>外来语 コヒ咖啡</li><li>拟声词 ニヌニヌ 喵喵</li><li>动植物名 ネコ 猫</li><li>表强调</li></ol><h3 id="1-6-罗马字"><a href="#1-6-罗马字" class="headerlink" title="1.6 罗马字"></a>1.6 罗马字</h3><p>あ い う え お<br>a  i  u  e  o</p><ol><li>招牌、广告</li><li>文字录入</li></ol>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>14-日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWS定期快照</title>
    <link href="/99-Others/10-AWS/AWS%E5%AE%9A%E6%9C%9F%E5%BF%AB%E7%85%A7/"/>
    <url>/99-Others/10-AWS/AWS%E5%AE%9A%E6%9C%9F%E5%BF%AB%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://aws.amazon.com/cn/blogs/china/construct-ebs-life-circle-management/">https://aws.amazon.com/cn/blogs/china/construct-ebs-life-circle-management/</a><br><a href="https://github.com/fanyizhe/aws-rds-auto-snapshot">https://github.com/fanyizhe/aws-rds-auto-snapshot</a></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>10-AWS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Windows中的ubuntu子系统的问题</title>
    <link href="/99-Others/99-Others/02-Windows%E4%B8%AD%E7%9A%84ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/99-Others/99-Others/02-Windows%E4%B8%AD%E7%9A%84ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows中的ubuntu子系统的问题"><a href="#Windows中的ubuntu子系统的问题" class="headerlink" title="Windows中的ubuntu子系统的问题"></a>Windows中的ubuntu子系统的问题</h1><h2 id="问题：ssh无法登陆"><a href="#问题：ssh无法登陆" class="headerlink" title="问题：ssh无法登陆"></a>问题：ssh无法登陆</h2><ul><li>报错信息：Permission denied (publickey).</li><li>解决：将/etc/ssh/sshd_config文件中的PasswordAuthentication no 改为PasswordAuthentication yes</li></ul><h2 id="问题：不会自动更新profile"><a href="#问题：不会自动更新profile" class="headerlink" title="问题：不会自动更新profile"></a>问题：不会自动更新profile</h2><ul><li>无论是在系统级别还是用户级别，更新环境变量并没有得到缓存</li><li>可能原因？这厮是开发工具</li><li>解决办法：<ul><li>加入到系统变量bin中</li><li>更新~/.profile是可以的(推荐)</li></ul></li></ul><h3 id="问题：系统不会启动开机自启，所有需要自启动的就不能了"><a href="#问题：系统不会启动开机自启，所有需要自启动的就不能了" class="headerlink" title="问题：系统不会启动开机自启，所有需要自启动的就不能了"></a>问题：系统不会启动开机自启，所有需要自启动的就不能了</h3>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JsonRPC2.0</title>
    <link href="/99-Others/99-Others/01-JsonRPC2.0/"/>
    <url>/99-Others/99-Others/01-JsonRPC2.0/</url>
    
    <content type="html"><![CDATA[<h1 id="JsonRPC2-0说明文档"><a href="#JsonRPC2-0说明文档" class="headerlink" title="JsonRPC2.0说明文档"></a>JsonRPC2.0说明文档</h1><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html?yyue=a21bo.50862.201879">官方参考文档</a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>JsonRPC是一种基于Json的<strong>无状态</strong>、<strong>轻量级</strong>远程传输协议</p><h2 id="1-1-响应对象"><a href="#1-1-响应对象" class="headerlink" title="1.1 响应对象"></a>1.1 响应对象</h2><blockquote><p>注：**[ ]**表示可选成员</p></blockquote><ul><li>jsonrpc : jsonrpc协议的版本号，2.0</li><li>method : 调用的方法名，不能以<strong>rpc</strong>开头，<strong>RPC</strong>开头表示内部方法</li><li>[params] : 调用该方法时候的参数</li><li>[id] : 与服务器通信的标识符，用于标识请求的次数，因为json是无状态的，该值应该为整数/字符串，若该值不存在，则表示通知</li><li>[result] : 服务器相应结果，此处就是我们日常用的json对象了，注意不能与<strong>error</strong>成员共存</li><li>[error] : 当错误发生时，需要提示错误的对象，此处的错误对象不是简单的字符串/错误码，而是下文提及的错误对象</li></ul><p>一个最简单的示例</p><blockquote><p>注1：–&gt; 表示send</br><br>注2：&lt;– 表示response</p></blockquote><pre><code class="hljs json">--&gt; &#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;:[42, 23], &quot;id&quot;: 1&#125;&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19,&quot;id&quot;: 1&#125;</code></pre><h2 id="1-2-什么是通知"><a href="#1-2-什么是通知" class="headerlink" title="1.2 什么是通知"></a>1.2 什么是通知</h2><p>如果请求对象中没有<strong>id</strong>成员，则表示一个通知。通知请求对象表示客户端对相应的响应对象不感兴趣，因此不需要返回响应对象给客户端。服务器必须不回复一个通知，即使是在批量请求中。</p><h2 id="1-3-错误对象"><a href="#1-3-错误对象" class="headerlink" title="1.3 错误对象"></a>1.3 错误对象</h2><ul><li>code : 错误代码，此处的错误代码与HTTP请求的错误代码不同，请看下文</li><li>message : 错误提示信息</li><li>[data] : 错误的数据/请求的源数据</li></ul><h3 id="1-3-1-错误代码定义"><a href="#1-3-1-错误代码定义" class="headerlink" title="1.3.1 错误代码定义"></a>1.3.1 错误代码定义</h3><table><thead><tr><th>代码</th><th>消息</th><th>含义</th></tr></thead><tbody><tr><td>-32700</td><td>解析错误</td><td>服务器接收到无效的JSON。</br> 服务器解析JSON文本发生错误。</td></tr><tr><td>-32600</td><td>无效的请求</td><td>发送的JSON不是一个有效的请求。</td></tr><tr><td>-32601</td><td>方法未找到</td><td>方法不存在或不可见。</td></tr><tr><td>-32602</td><td>无效的参数</td><td>无效的方法参数。</td></tr><tr><td>-32603</td><td>内部错误</td><td>JSON-RPC内部错误。</td></tr><tr><td>-32000 to -32099</td><td>服务器端错误</td><td>保留给具体实现定义服务器端错误。</td></tr></tbody></table><h2 id="1-4-关于传参"><a href="#1-4-关于传参" class="headerlink" title="1.4 关于传参"></a>1.4 关于传参</h2><pre><code class="hljs json">&quot;params&quot;:[42, 23]&quot;params&quot;:&#123;&quot;subtrahend&quot;: 23, &quot;minuend&quot;: 42&#125;</code></pre><h2 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h2><p><a href="https://github.com/briandilley/jsonrpc4j">官方文档</a></p><ol><li>添加依赖</li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jsonrpc4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.briandilley.jsonrpc4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsonrpc4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-1-在java中作为Client使用"><a href="#2-1-在java中作为Client使用" class="headerlink" title="2.1 在java中作为Client使用"></a>2.1 在java中作为Client使用</h3><p><a href="https://www.cnblogs.com/clnchanpin/p/7058848.html">参考文档</a></p><blockquote><p>注意使用Maven/Gredle实现依赖管理</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cenzhongman;<span class="hljs-keyword">import</span> com.cenzhongman.model.User;<span class="hljs-keyword">import</span> com.googlecode.jsonrpc4j.JsonRpcHttpClient;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonRPCClient</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROOTURL = <span class="hljs-string">&quot;http://localhost:8080/user&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jsonRpcHttpClient</span><span class="hljs-params">()</span> </span>&#123;        URL url = <span class="hljs-keyword">null</span>;        Map&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();        User user = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 此处可以设置Header</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 创建请求对象</span>            url = <span class="hljs-keyword">new</span> URL(JsonRPCClient.ROOTURL);            JsonRpcHttpClient client = <span class="hljs-keyword">new</span> JsonRpcHttpClient(url);            client.setHeaders(headers);            <span class="hljs-comment">// 构建请求参数</span>            Map&lt;String, User&gt; param = <span class="hljs-keyword">new</span> HashMap&lt;String, User&gt;();            param.put(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;czm&quot;</span>, <span class="hljs-number">19</span>));            <span class="hljs-comment">// 发起请求</span>            user = client.invoke(<span class="hljs-string">&quot;setUserByClas&quot;</span>, param, User.class);        &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;            throwable.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>这样就实现了发送以对象为参数的Http请求，发出的Json格式如下</p></blockquote><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-attr">&quot;jsonrpc&quot;</span>:<span class="hljs-string">&quot;2.0&quot;</span>,<span class="hljs-attr">&quot;method&quot;</span>:<span class="hljs-string">&quot;setUserByClass&quot;</span>,<span class="hljs-attr">&quot;params&quot;</span>:&#123;<span class="hljs-attr">&quot;user&quot;</span>:&#123;<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">19</span>,<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>&#125;&#125;&#125;</code></pre><h3 id="2-2-在Spring-Framework中使用"><a href="#2-2-在Spring-Framework中使用" class="headerlink" title="2.2 在Spring Framework中使用"></a>2.2 在Spring Framework中使用</h3><p><a href="https://github.com/briandilley/jsonrpc4j">官方文档</a></p><p>由于Spring Framwork还不熟悉，暂不研究，先留个坑</p><h3 id="2-3-在springBoot中使用"><a href="#2-3-在springBoot中使用" class="headerlink" title="2.3 在springBoot中使用"></a>2.3 在springBoot中使用</h3><p><a href="https://github.com/briandilley/jsonrpc4j/wiki/">参考官方文档</a></p><ul><li>在系统配置中添加配置</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> example.jsonrpc4j.springboot;<span class="hljs-keyword">import</span> com.googlecode.jsonrpc4j.spring.AutoJsonRpcServiceImplExporter;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AutoJsonRpcServiceImplExporter <span class="hljs-title">autoJsonRpcServiceImplExporter</span><span class="hljs-params">()</span> </span>&#123;        AutoJsonRpcServiceImplExporter exp = <span class="hljs-keyword">new</span> AutoJsonRpcServiceImplExporter();        <span class="hljs-comment">//in here you can provide custom HTTP status code providers etc. eg:</span>        <span class="hljs-comment">//exp.setHttpStatusCodeProvider();</span>        <span class="hljs-comment">//exp.setErrorResolver();</span>        <span class="hljs-keyword">return</span> exp;    &#125;&#125;</code></pre><ul><li>创建一个service</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> example.jsonrpc4j.springboot.api;<span class="hljs-keyword">import</span> com.googlecode.jsonrpc4j.JsonRpcParam;<span class="hljs-keyword">import</span> com.googlecode.jsonrpc4j.JsonRpcService;<span class="hljs-meta">@JsonRpcService(&quot;/calculator&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExampleServerAPI</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multiplier</span><span class="hljs-params">(<span class="hljs-meta">@JsonRpcParam(value = &quot;a&quot;)</span> <span class="hljs-keyword">int</span> a, <span class="hljs-meta">@JsonRpcParam(value = &quot;b&quot;)</span> <span class="hljs-keyword">int</span> b)</span></span>;&#125;</code></pre><ul><li>实现这个接口</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> example.jsonrpc4j.springboot.api;<span class="hljs-keyword">import</span> com.googlecode.jsonrpc4j.spring.AutoJsonRpcServiceImpl;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span><span class="hljs-meta">@AutoJsonRpcServiceImpl</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleServerAPIImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExampleServerAPI</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">multiplier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-comment">// 这里可以返回对象</span>        <span class="hljs-keyword">return</span> a * b;    &#125;&#125;</code></pre><pre><code class="hljs sh">curl -H <span class="hljs-string">&quot;Content-Type:application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;id&quot;:&quot;1&quot;,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;multiplier&quot;,&quot;params&quot;:&#123;&quot;a&quot;:5,&quot;b&quot;:6&#125;&#125;&#x27;</span> http://localhost:8080/calculator</code></pre><h3 id="2-4-PHP调用"><a href="#2-4-PHP调用" class="headerlink" title="2.4 PHP调用"></a>2.4 PHP调用</h3><p><a href="https://www.cnblogs.com/clnchanpin/p/7058848.html">参考文档</a></p><blockquote><p>基于json-rpc-php的PHP客户端调用示例：</p></blockquote><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span>(dirname(<span class="hljs-keyword">__FILE__</span>).<span class="hljs-string">&quot;/lib/client/JsonRpcClient.php&quot;</span>);$client = <span class="hljs-keyword">new</span> JsonRpcClient(<span class="hljs-string">&quot;http://10.13.49.234:8080/xxx&quot;</span>);$response = $client-&gt;getXXX();<span class="hljs-keyword">echo</span> $response-&gt;result;<span class="hljs-meta">?&gt;</span></code></pre><h3 id="2-5-JS调用"><a href="#2-5-JS调用" class="headerlink" title="2.5 JS调用"></a>2.5 JS调用</h3><p><a href="https://www.cnblogs.com/clnchanpin/p/7058848.html">参考文档</a></p><blockquote><p>基于jsonrpcjs的JavaScript客户端调用示例：</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> rpc = <span class="hljs-keyword">new</span> jsonrpc.JsonRpc(<span class="hljs-string">&#x27;http://127.0.0.1:8080/xxx&#x27;</span>);rpc.call(<span class="hljs-string">&#x27;getXXX&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;alert(result);&#125;);</code></pre><h3 id="2-6-直接get"><a href="#2-6-直接get" class="headerlink" title="2.6 直接get"></a>2.6 直接get</h3><pre><code class="hljs http">http://127.0.0.1:8080/XXX?method=getXXX&amp;id=1&amp;params=12312</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-markdown</title>
    <link href="/99-Others/99-Others/04-markdown/"/>
    <url>/99-Others/99-Others/04-markdown/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zryxh1/article/details/53161011">公式</a></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Mac电脑重装</title>
    <link href="/99-Others/99-Others/05-Mac%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85/"/>
    <url>/99-Others/99-Others/05-Mac%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="电脑重装步骤"><a href="#电脑重装步骤" class="headerlink" title="电脑重装步骤"></a>电脑重装步骤</h1><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><ol><li><p>Mac软件合集 <a href="https://github.com/jaywcjlove/awesome-mac">https://github.com/jaywcjlove/awesome-mac</a></p></li><li><p>IDEA <a href="http://www.jetbrains.com/">http://www.jetbrains.com</a> 破解 <a href="http://idea.lanyus.com/">http://idea.lanyus.com</a> 配置 <a href="https://www.cnblogs.com/cenzhongman/p/6041008.html">https://www.cnblogs.com/cenzhongman/p/6041008.html</a> </p></li><li><p>翻墙 <a href="https://github.com/Tsuk1ko/SS-Collection">https://github.com/Tsuk1ko/SS-Collection</a> ssr://cy5sYW5na2UucHJvOjExMTM4OmF1dGhfc2hhMV92NDphZXMtMjU2LWNmYjpwbGFpbjpjM055TG14aGJtZHJaUzV3Y204Lz9vYmZzcGFyYW09Jmdyb3VwPWJHRnVaMnRs</p></li><li><p>maven</p> <pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>mirrorId<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>repositoryId<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://my.repository.com/repo/path<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>datain#18<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></li><li><p>其他免费 微信 网易云音乐 wps postman iterm2 chrome 爱奇艺 腾讯视频 git maven jdk </p></li><li><p>ssh</p> <pre><code class="hljs sh">ssh-keygen -t rsa</code></pre></li><li><p>navicat <a href="http://www.pc6.com/mac/111878.html">http://www.pc6.com/mac/111878.html</a> 允许任意来源 <a href="http://www.pc6.com/edu/168719.html">http://www.pc6.com/edu/168719.html</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-字符画在线生成</title>
    <link href="/99-Others/99-Others/07-%E5%AD%97%E7%AC%A6%E7%94%BB%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90/"/>
    <url>/99-Others/99-Others/07-%E5%AD%97%E7%AC%A6%E7%94%BB%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p><a href="http://patorjk.com/software/taag/#p=display&amp;f=Big&amp;t=Datainsights">http://patorjk.com/software/taag/#p=display&amp;f=Big&amp;t=Datainsights</a></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-书单</title>
    <link href="/99-Others/99-Others/08-%E4%B9%A6%E5%8D%95/"/>
    <url>/99-Others/99-Others/08-%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<ul><li>java<ul><li>think in java</li><li>efective java</li><li><strong>深入理解Java虚拟机</strong></li></ul></li><li>数据库<ul><li>高可用MySQL</li><li><strong>mysql技术内幕 InnoDB</strong></li></ul></li><li>java ee<ul><li><strong>Spring实战</strong></li><li><strong>springboot实战</strong></li></ul></li><li>Elasticsearch<ul><li><strong>深入理解Elasticsearch</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-打包</title>
    <link href="/99-Others/02-IDEA/02-%E6%89%93%E5%8C%85/"/>
    <url>/99-Others/02-IDEA/02-%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA中反人类的打包"><a href="#IDEA中反人类的打包" class="headerlink" title="IDEA中反人类的打包"></a>IDEA中反人类的打包</h1><h2 id="打胖包"><a href="#打胖包" class="headerlink" title="打胖包"></a>打胖包</h2><p><img src="../images/02-01.png"><br><img src="../images/02-02.png"></p><h2 id="打瘦包"><a href="#打瘦包" class="headerlink" title="打瘦包"></a>打瘦包</h2><p><img src="../images/02-03.png"></p><h2 id="打独立多包"><a href="#打独立多包" class="headerlink" title="打独立多包"></a>打独立多包</h2><p>具体忘记了，也查不到，暂时先这样吧</p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-增加快捷输入</title>
    <link href="/99-Others/02-IDEA/03-%E5%A2%9E%E5%8A%A0%E5%BF%AB%E6%8D%B7%E8%BE%93%E5%85%A5/"/>
    <url>/99-Others/02-IDEA/03-%E5%A2%9E%E5%8A%A0%E5%BF%AB%E6%8D%B7%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="增加快捷输入"><a href="#增加快捷输入" class="headerlink" title="增加快捷输入"></a>增加快捷输入</h1><ol><li>setting</li><li>Editor</li><li>live Templates</li><li>点击<code>+</code>号，添加组</li><li>点击<code>+</code>号，添加项目</li></ol><p><img src="../images/03-01.png"></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    $END$&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-IDEA控制台搜索</title>
    <link href="/99-Others/02-IDEA/04-IDEA%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%90%9C%E7%B4%A2/"/>
    <url>/99-Others/02-IDEA/04-IDEA%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA控制台搜索和过滤"><a href="#IDEA控制台搜索和过滤" class="headerlink" title="IDEA控制台搜索和过滤"></a>IDEA控制台搜索和过滤</h1><ul><li><p>问题描述：Eclipse快捷键设置下<code>Ctrl+F</code>默认是替换，而查找没有设置快捷键</p></li><li><p>解决：Main menu –&gt; Edit –&gt; Find –&gt; Find （ a string in active editor）将查找设置为<code>Ctrl+F</code>，而替换设置为<code>Alt+F</code></p></li></ul><p><img src="../images/04-01.png"></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-IDEA类注释</title>
    <link href="/99-Others/02-IDEA/06-IDEA%E7%B1%BB%E6%B3%A8%E9%87%8A/"/>
    <url>/99-Others/02-IDEA/06-IDEA%E7%B1%BB%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Files</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* TODO</span><span class="hljs-comment">* </span><span class="hljs-comment">* <span class="hljs-doctag">@author</span> $&#123;USER&#125;</span><span class="hljs-comment">* <span class="hljs-doctag">@date</span> $&#123;DATE&#125;</span><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-IDEA部署Tomcat-SpringMVC-注解</title>
    <link href="/99-Others/02-IDEA/07-IDEA%E9%83%A8%E7%BD%B2Tomcat-SpringMVC-%E6%B3%A8%E8%A7%A3/"/>
    <url>/99-Others/02-IDEA/07-IDEA%E9%83%A8%E7%BD%B2Tomcat-SpringMVC-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA部署Tomcat-SpringMVC-注解"><a href="#IDEA部署Tomcat-SpringMVC-注解" class="headerlink" title="IDEA部署Tomcat-SpringMVC-注解"></a>IDEA部署Tomcat-SpringMVC-注解</h1><p><img src="../images/2019-07-31-16-31-29.png"></p><p><img src="../images/2019-07-31-16-32-10.png"></p><p><img src="../images/2019-07-31-16-33-01.png"></p><p><img src="../images/2019-07-31-16-33-53.png"></p><h2 id="排坑"><a href="#排坑" class="headerlink" title="排坑"></a>排坑</h2><h3 id="出现Controller没有生效"><a href="#出现Controller没有生效" class="headerlink" title="出现Controller没有生效"></a>出现Controller没有生效</h3><ul><li>报错：  <pre><code class="hljs log">HTTP Status 404 – 未找到Type Status Report消息 &#x2F;demo_war_exploded&#x2F;home&#x2F;描述 The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</code></pre></li><li>原因：WebConfig中的ComponentScan注解可能没有生效</li><li>解决：检查@SpringMvc注解所在类的@ComponentScan的路径是否包含Controller注解所在的类（RootConfig.java文件的无效）</li></ul><h3 id="出现jsp-html找不到，且Controller正常执行"><a href="#出现jsp-html找不到，且Controller正常执行" class="headerlink" title="出现jsp/html找不到，且Controller正常执行"></a>出现jsp/html找不到，且Controller正常执行</h3><ul><li><p>报错：</p>  <pre><code class="hljs log">HTTP Status 404 – 未找到Type Status Report消息 &#x2F;demo_war_exploded&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp描述 The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</code></pre></li><li><p>原因：映射的路径有问题</p></li><li><p>解决：对比<code>$TOMCAT_HOME/webapps/$&#123;application_name&#125;/</code>路径下该文件是否存在，根据Tomcat中的路径设置<code>prefix</code></p><p>  SpringMvc配置-WebConfig.java</p><p>  html文件放在<code>src/main/webapp/WEB-INF/views/</code>目录下对应<code>/WEB-INF/views/</code></p><p>  html文件放在<code>src/main/resource/views/</code>目录下对应<code>/WEB-INF/classes/views/</code></p>  <pre><code class="hljs java">viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>);</code></pre><p>  SpringBoot配置-application.yml</p>  <pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">thymeleaf:</span>    <span class="hljs-attr">prefix:</span> <span class="hljs-string">classpath:/templates/</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AWS负载均衡</title>
    <link href="/99-Others/10-AWS/AWS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/99-Others/10-AWS/AWS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/containers-on-aws/using-aws-application-load-balancer-and-network-load-balancer-with-ec2-container-service-d0cb0b1d5ae5">https://medium.com/containers-on-aws/using-aws-application-load-balancer-and-network-load-balancer-with-ec2-container-service-d0cb0b1d5ae5</a></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>10-AWS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-jjwt</title>
    <link href="/99-Others/01-JWT/02-jjwt/"/>
    <url>/99-Others/01-JWT/02-jjwt/</url>
    
    <content type="html"><![CDATA[<h1 id="JJWT"><a href="#JJWT" class="headerlink" title="JJWT"></a>JJWT</h1><p>这是一个JAVA 的JWT项目</p><p><a href="https://github.com/jwtk/jjwt">Github地址</a></p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.jsonwebtoken.Jwts;<span class="hljs-keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;<span class="hljs-keyword">import</span> io.jsonwebtoken.impl.crypto.MacProvider;<span class="hljs-keyword">import</span> java.security.Key;<span class="hljs-comment">// We need a signing key, so we&#x27;ll create one just for this example. Usually</span><span class="hljs-comment">// the key would be read from your application configuration instead.</span>Key key = MacProvider.generateKey();String compactJws = Jwts.builder()  .setSubject(<span class="hljs-string">&quot;Joe&quot;</span>)  .signWith(SignatureAlgorithm.HS512, key)  .compact();</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>01-JWT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-IDEA界面介绍</title>
    <link href="/99-Others/02-IDEA/01-IDEA%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/"/>
    <url>/99-Others/02-IDEA/01-IDEA%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA和使用介绍"><a href="#IDEA和使用介绍" class="headerlink" title="IDEA和使用介绍"></a>IDEA和使用介绍</h1><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p><img src="../images/01-01.png"></p><p>上面写着数字的都可以使用<code>Alt+1</code>打开</p><h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><h3 id="帮助搜索"><a href="#帮助搜索" class="headerlink" title="帮助搜索"></a>帮助搜索</h3><ul><li><code>Ctrl + Shift + A</code></li><li><img src="../images/01-02.png"></li></ul><h2 id="定位和跳转"><a href="#定位和跳转" class="headerlink" title="定位和跳转"></a>定位和跳转</h2><p>主要在Navigate下面</p><h3 id="最近文件-最近修改的文件"><a href="#最近文件-最近修改的文件" class="headerlink" title="最近文件/最近修改的文件"></a>最近文件/最近修改的文件</h3><ul><li>recent file/recent change file</li><li><code>Ctrl + E</code> , <code>Ctrl + Shift + E</code></li><li><img src="../images/01-03.png"></li></ul><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><ul><li>new in this Dir</li><li><code>Ctrl + Alt + Insert</code></li><li><img src="../images/01-04.png"></li></ul><h3 id="光标的跳转"><a href="#光标的跳转" class="headerlink" title="光标的跳转"></a>光标的跳转</h3><ul><li>Back/Forward</li><li><code>Alt + left</code>/<code>Alt + right</code></li></ul><h3 id="快速打开Java源码"><a href="#快速打开Java源码" class="headerlink" title="快速打开Java源码"></a>快速打开Java源码</h3><ul><li>class</li><li><code>ctrl + Shift + T</code></li></ul><h3 id="快速打开文件"><a href="#快速打开文件" class="headerlink" title="快速打开文件"></a>快速打开文件</h3><ul><li>file</li><li><code>ctrl + shift + r</code></li></ul><h3 id="添加书签（用于源码标记特别有用）"><a href="#添加书签（用于源码标记特别有用）" class="headerlink" title="添加书签（用于源码标记特别有用）"></a>添加书签（用于源码标记特别有用）</h3><ul><li>bookmark</li><li><code>Ctrl + shift + F11</code>/<code>Ctrl + shift + Alt + F11</code></li></ul><h3 id="添加收藏（用于阅读源码，允许添加收藏夹）"><a href="#添加收藏（用于阅读源码，允许添加收藏夹）" class="headerlink" title="添加收藏（用于阅读源码，允许添加收藏夹）"></a>添加收藏（用于阅读源码，允许添加收藏夹）</h3><p>当光标定位在函数名，收藏函数，否则收藏类，使用<code>Alt + 2</code>查看收藏</p><ul><li>add to favorites</li><li><code>Alt + Shift + F</code></li></ul><h3 id="跳转到文件-编辑界面"><a href="#跳转到文件-编辑界面" class="headerlink" title="跳转到文件/编辑界面"></a>跳转到文件/编辑界面</h3><ul><li>跳转到文件<code>Alt + 1</code></li><li>跳转到编辑区<code>Esc</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-必装插件</title>
    <link href="/99-Others/02-IDEA/05-%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <url>/99-Others/02-IDEA/05-%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="必装插件"><a href="#必装插件" class="headerlink" title="必装插件"></a>必装插件</h1><ol><li>Key promoter X</li><li>python</li><li>Alibaba Java Coding Guidelines</li></ol>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>02-IDEA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-eclipse初始设置</title>
    <link href="/99-Others/03-Eclipse/01-eclipse%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/"/>
    <url>/99-Others/03-Eclipse/01-eclipse%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Eclipse初始化设置"><a href="#Eclipse初始化设置" class="headerlink" title="Eclipse初始化设置"></a>Eclipse初始化设置</h1><h2 id="设置编码格式"><a href="#设置编码格式" class="headerlink" title="设置编码格式"></a>设置编码格式</h2><p>windows –&gt; Preferences –&gt; General -–&gt; Workspace</p><h2 id="Maven设置"><a href="#Maven设置" class="headerlink" title="Maven设置"></a>Maven设置</h2><ol><li>windows -&gt; perferences-&gt;maven 选项<ul><li>Download Artifact Sources</li><li>DownloadArtifact JavaDOC</li></ul></li></ol><h2 id="Tomcat设置"><a href="#Tomcat设置" class="headerlink" title="Tomcat设置"></a>Tomcat设置</h2><p><img src="../images/01-01.png"><br><img src="../images/01-02.png"><br><img src="../images/01-03.png"></p><h2 id="自动代码提示"><a href="#自动代码提示" class="headerlink" title="自动代码提示"></a>自动代码提示</h2><p>Windows -&gt; preferences -&gt; java -&gt; editor -&gt; content assist<br>在右侧的对话框中auto activation 下的子选项auto activation triggers for java后的文本框中输入abcdefghijklmnopqrstuvwxyz.即可</p><h2 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h2><ol><li>windows -&gt; perferences-&gt;maven 选项<ul><li>Download Artifact Sources</li><li>DownloadArtifact JavaDOC</li></ul></li><li>右键项目 找到maven -&gt; update project</li></ol><h2 id="XML缩进"><a href="#XML缩进" class="headerlink" title="XML缩进"></a>XML缩进</h2><p> windows -&gt; perferences &gt; xmlFile &gt; editor &gt; indent using space 4</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>Windows &gt;&gt; show view &gt;&gt; tisks</p><h2 id="当个文件编码"><a href="#当个文件编码" class="headerlink" title="当个文件编码"></a>当个文件编码</h2><p>edit &gt;&gt; set endcoding</p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>03-Eclipse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Eclipse常用快捷键.html</title>
    <link href="/99-Others/03-Eclipse/02-Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/99-Others/03-Eclipse/02-Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2>编辑</h2><p>Ctrl+1 快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如import类、try catch包围等）<br />Ctrl+Shift+F 格式化当前代码<br />Ctrl+Shift+M 添加类的import导入<br />Ctrl+Shift+O 组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用）<br />Ctrl+Y 重做（与撤销Ctrl+Z相反）<br />Alt+/ 内容辅助（帮你省了多少次键盘敲打，太常用了）<br />Ctrl+D 删除当前行或者多行<br />Alt+&darr; 当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）<br />Alt+&uarr; 当前行和上面一行交互位置（同上）<br />Ctrl+Alt+&darr; 复制当前行到下一行（复制增加）<br />Ctrl+Alt+&uarr; 复制当前行到上一行（复制增加）<br />Shift+Enter 在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）<br />Ctrl+/ 注释当前行,再按则取消注释</p><h2>选择</h2><p>Alt+Shift+&uarr; 选择封装元素<br />Alt+Shift+&larr; 选择上一个元素<br />Alt+Shift+&rarr; 选择下一个元素<br />Shift+&larr; 从光标处开始往左选择字符<br />Shift+&rarr; 从光标处开始往右选择字符<br />Ctrl+Shift+&larr; 选中光标左边的单词<br />Ctrl+Shift+&rarr; 选中光标又边的单词</p><h2>移动</h2><p>Ctrl+&larr; 光标移到左边单词的开头，相当于vim的b<br />Ctrl+&rarr; 光标移到右边单词的末尾，相当于vim的e</p><h2>搜索</h2><p>Ctrl+K 参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word）<br />Ctrl+Shift+K 参照选中的Word快速定位到上一个<br />Ctrl+J 正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建）<br />Ctrl+Shift+J 反向增量查找（和上条相同,只不过是从后往前查）<br />Ctrl+Shift+U 列出所有包含字符串的行<br />Ctrl+H 打开搜索对话框<br />Ctrl+G 工作区中的声明<br />Ctrl+Shift+G 工作区中的引用</p><h2>导航</h2><p>Ctrl+Shift+T 搜索类（包括工程和关联的第三jar包）<br />Ctrl+Shift+R 搜索工程中的文件<br />Ctrl+E 快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）<br />F4 打开类型层次结构<br />F3 跳转到声明处<br />Alt+&larr; 前一个编辑的页面<br />Alt+&rarr; 下一个编辑的页面（当然是针对上面那条来说了）<br />Ctrl+PageUp/PageDown 在编辑器中，切换已经打开的文件</p><h2>调试</h2><p>F5 单步跳入<br />F6 单步跳过<br />F7 单步返回<br />F8 继续<br />Ctrl+Shift+D 显示变量的值<br />Ctrl+Shift+B 在当前行设置或者去掉断点<br />Ctrl+R 运行至行(超好用，可以节省好多的断点)</p><h2>重构</h2><p>（一般重构的快捷键都是Alt+Shift开头的了）<br />Alt+Shift+R 重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力）<br />Alt+Shift+M 把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）<br />Alt+Shift+C 修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定）<br />Alt+Shift+L 抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）<br />Alt+Shift+F 把Class中的local变量变为field变量 （比较实用的功能）<br />Alt+Shift+I 合并变量（可能这样说有点不妥Inline）<br />Alt+Shift+V 移动函数和变量（不怎么常用）<br />Alt+Shift+Z 重构的后悔药（Undo）</p><h2>其他</h2><p>Alt+Enter 显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径<br />Ctrl+&uarr; 文本编辑器 上滚行<br />Ctrl+&darr; 文本编辑器 下滚行<br />Ctrl+M 最大化当前的Edit或View （再按则反之）<br />Ctrl+O 快速显示 OutLine（不开Outline窗口的同学，这个快捷键是必不可少的）<br />Ctrl+T 快速显示当前类的继承结构<br />Ctrl+W 关闭当前Editer（windows下关闭打开的对话框也是这个，还有qq、旺旺、浏览器等都是）<br />Ctrl+L 文本编辑器 转至行<br />F2 显示工具提示描述</p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>03-Eclipse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Eclipse中.calsspath文件解析.html</title>
    <link href="/99-Others/03-Eclipse/03-Eclipse%E4%B8%AD.calsspath%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <url>/99-Others/03-Eclipse/03-Eclipse%E4%B8%AD.calsspath%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>来自帅气的Sublime Text</p><p><img src="http://images2015.cnblogs.com/blog/1047249/201612/1047249-20161206164437851-617447642.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>03-Eclipse</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-正则表达式</title>
    <link href="/99-Others/08-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/03-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/99-Others/08-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/03-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="简单的正则表达式"><a href="#简单的正则表达式" class="headerlink" title="简单的正则表达式"></a>简单的正则表达式</h1><p><a href="http://tool.oschina.net/regex/">在线测试工具</a></p><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><pre><code class="hljs sh">&#123;3&#125; 三个&#123;4,21&#125; 四个到21个(贪婪)+ 1-n* 0-n? 0 / 1</code></pre><h2 id="匹配符"><a href="#匹配符" class="headerlink" title="匹配符"></a>匹配符</h2><pre><code class="hljs sh">[a-z] 从a-z[^a-z] 不包括a-z[abcd] 在abcd中，无需逗号/d 数字[0-9]/D 不是数字[^0-9]/w 数字字母下划线[0-9a-zA-Z_]/W w的取反/s 空格和tab/S s的取反. 除\n以外的所有字符</code></pre><h2 id="起止符"><a href="#起止符" class="headerlink" title="起止符"></a>起止符</h2><pre><code class="hljs elixir">^ 必须在开头匹配<span class="hljs-variable">$ </span>必须在结尾匹配</code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><pre><code class="hljs sh">(hi|你好|hello) 或者</code></pre>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>08-正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-五险一金是什么</title>
    <link href="/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/01-%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/01-%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="五险一金是什么"><a href="#五险一金是什么" class="headerlink" title="五险一金是什么"></a>五险一金是什么</h1><p>进入职场，知道得越多肯定不吃亏，学习一下五险一金是什么</p><p>五险包括：</p><table><thead><tr><th>险种</th><th>公司缴纳</th><th>缴纳</th></tr></thead><tbody><tr><td>养老保险</td><td>14%</td><td>8%</td></tr><tr><td>医疗保险</td><td>7%</td><td>2%</td></tr><tr><td>失业保险</td><td>0.64%</td><td>0.2%</td></tr><tr><td>生育保险</td><td>0.85%</td><td>无需缴纳</td></tr><tr><td>工伤保险</td><td>0.2%</td><td>无需缴纳</td></tr><tr><td>住房公积金</td><td>5%~12%</td><td>等于或高于单位缴存比例</td></tr><tr><td>合计</td><td>27.69~34.69%</td><td>15.2~22.2%</td></tr></tbody></table><blockquote><p>按照2018年广州市社保缴纳标准</p></blockquote><p>计算器推荐：[五险一金计算器]](<a href="http://salarycalculator.sinaapp.com/city/guangzhou">http://salarycalculator.sinaapp.com/city/guangzhou</a>)</p><ul><li>缴纳基数：企业按照这个作为计算缴纳五险一金，部分企业为了减少用工成本，将资金用于奖金的形式发放</li><li>住房公积金：住房公积金属于国家强制性购买的，否则属于违规行为</li></ul><p>广州市2018年9月24日月薪10000元，企业按照10000作为缴纳基数，各项指标均缴纳最低的计算截图如下</p><p><img src="../images/00-01.png"></p>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>09-医保社保</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-个人所得税</title>
    <link href="/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/02-%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/"/>
    <url>/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/02-%E4%B8%AA%E4%BA%BA%E6%89%80%E5%BE%97%E7%A8%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="个人所得税"><a href="#个人所得税" class="headerlink" title="个人所得税"></a>个人所得税</h1><p>个人所得税是国家用于调节贫富差距的一种重要手段</p><h2 id="2011年9月-2018年9月"><a href="#2011年9月-2018年9月" class="headerlink" title="2011年9月-2018年9月"></a>2011年9月-2018年9月</h2><p>个人所得说的计算公式</p><ul><li>应纳税所得额 = 工资收入金额 － 各项社会保险费 － 起征点(3500元)</li><li>应纳税额 = 应纳税所得额 x 税率 － 速算扣除数</li><li>本级速算数 = 上一级最高应纳税所得额 ×（本级税率-上一级税率）+ 上一级速算扣除数</li></ul><p>使用税率表和速算扣除数如下</p><table><thead><tr><th>级数</th><th>应纳税所得额(含税)</th><th>税率(%)</th><th>速算扣除数</th></tr></thead><tbody><tr><td>1</td><td>不超过1,500元的部分</td><td>3</td><td>0</td></tr><tr><td>2</td><td>超过1,500元至4,500元的部分</td><td>10</td><td>105</td></tr><tr><td>3</td><td>超过4,500元至9,000元的部分</td><td>20</td><td>555</td></tr><tr><td>4</td><td>超过9,000元至35,000元的部分</td><td>25</td><td>1,005</td></tr><tr><td>5</td><td>超过35,000元至55,000元的部分</td><td>30</td><td>2,755</td></tr><tr><td>6</td><td>超过55,000元至80,000元的部分</td><td>35</td><td>5,505</td></tr><tr><td>7</td><td>超过80,000元的部分</td><td>45</td><td>13,505</td></tr></tbody></table><ul><li>用个简单的例子演示税率问题</li></ul><table><thead><tr><th>工资收入金额 － 各项社会保险费</th><th>应纳税所得额</th><th>适用税率</th><th>速算扣除数</th><th>实际交税</th></tr></thead><tbody><tr><td>3500</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5000</td><td>1500</td><td>3</td><td>0</td><td>45</td></tr><tr><td>5001</td><td>1501</td><td>10</td><td>105</td><td>45.1</td></tr><tr><td>10000</td><td>6500</td><td>20</td><td>555</td><td>745</td></tr><tr><td>20000</td><td>16500</td><td>25</td><td>1005</td><td>3120</td></tr></tbody></table><blockquote><p>从这个例子我们可以看出（注意5000和5001），国家的税务系统是科学的，合理的（不会出现阶跃式的跳变）</p></blockquote><h2 id="2018年10月"><a href="#2018年10月" class="headerlink" title="2018年10月"></a>2018年10月</h2><p>从2018年10月开始，我国实现新的个人所得税征收办法</p><p>主要变化如下：</p><ol><li>起征点提到到5000</li><li>增加专项附加扣除（子女教育、继续教育、大病医疗、住房贷款利息或者住房租金、赡养老人等6项支出，都可以先行扣除） – 2019年1月1日开始实施</li><li>扣除计算方式由月变成年（企业按照月为员工缴税）</li><li>税率表跨度调整</li></ol><p>个人综合收入税率表</p><table><thead><tr><th>级数</th><th>全年应纳税所得额</th><th>月应纳税所得额</th><th>税率（%）</th><th>速算扣除数</th></tr></thead><tbody><tr><td>1</td><td>&lt;36000</td><td>&lt;3000</td><td>3</td><td>0</td></tr><tr><td>2</td><td>36000 ~ 144000</td><td>0.3 ~ 1.2万</td><td>10</td><td>210</td></tr><tr><td>3</td><td>144000 ~ 300000</td><td>1.2 ~ 2.5万</td><td>20</td><td>1410</td></tr><tr><td>4</td><td>300000 ~ 420000</td><td>2.5 ~ 3.5万</td><td>25</td><td>2660</td></tr><tr><td>5</td><td>420000 ~ 660000</td><td>3.5 ~ 5.5万</td><td>30</td><td>4410</td></tr><tr><td>6</td><td>660000 ~ 960000</td><td>5.5 ~ 8万</td><td>35</td><td>7160</td></tr><tr><td>7</td><td>960000 ~ 部分</td><td>&gt;8万</td><td>45</td><td>15160</td></tr></tbody></table><p>再来一个上述例子（按月计算）</p><table><thead><tr><th>工资收入金额 － 各项社会保险费</th><th>应纳税所得额</th><th>适用税率</th><th>速算扣除数</th><th>实际交税</th></tr></thead><tbody><tr><td>3500</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5000</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5001</td><td>1</td><td>3</td><td>0</td><td>0.1</td></tr><tr><td>10000</td><td>5000</td><td>10</td><td>210</td><td>290</td></tr><tr><td>20000</td><td>15000</td><td>25</td><td>1410</td><td>2340</td></tr></tbody></table><blockquote><p>这个例子说明了税率对于中下收入水平的人明显下调（对高收入税率调高）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>09-医保社保</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-医疗保险</title>
    <link href="/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/03-%E5%8C%BB%E7%96%97%E4%BF%9D%E9%99%A9/"/>
    <url>/99-Others/09-%E5%8C%BB%E4%BF%9D%E7%A4%BE%E4%BF%9D/03-%E5%8C%BB%E7%96%97%E4%BF%9D%E9%99%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="医疗保险"><a href="#医疗保险" class="headerlink" title="医疗保险"></a>医疗保险</h1><p>医疗保险是用于医疗的专项保险基金</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>主要还是要说明这能怎么用</p><ul><li>定点：定点是用于明确医疗资源分配的重要方式，每个参加医保的人都能定一个小点(社区医院)，一个大点(大型医院)，不定点也能看病，但是不能报销（专科医院，如肿瘤医院、牙科医院不需要定点；急诊除外）</li><li>统筹资金：传说中的报销就是这个玩意，报销也就是使用统筹资金支付（似乎跟自己有多少无关，这是个资金池，保险同理）</li><li>个人医保资金：职工医保中自己缴纳的部分（2%）作为自己的个人账户余额，可以用于支付定点门诊费用等</li></ul>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>09-医保社保</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-反射</title>
    <link href="/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/02-%E5%8F%8D%E5%B0%84/"/>
    <url>/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/02-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Class类是描述class的类，它包含类的元数据信息，通过反射可以在运行时期动态地去获取类的成员变量信息（构造器、方法、字段、内部类、接口、父类等）</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Class实例表示在JVM中的类或者接口，枚举是一种特殊的类，注解是一种特殊的接口</p><p>一个类在JVM中只有一个对象，任何方式获得的都是相同的对象</p><pre><code class="hljs java"><span class="hljs-comment">// 方法1</span>Class&lt;String&gt; stringClass = String.class;<span class="hljs-comment">// 方法2</span>String string = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;123&quot;</span>);Class&lt;?&gt; stringClass = string.getClass(); <span class="hljs-comment">// 注意此处无法获得泛型，原因是需要在运行时反射才知道对象是什么类型</span><span class="hljs-comment">// 方法3，最常用</span>```javaClass&lt;?&gt; stringClass = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);  <span class="hljs-comment">// 注意此处无法获得泛型</span><span class="hljs-comment">// 获得全限定名</span>clazz.getName();<span class="hljs-comment">// 获得非全限定名</span>clazz.getSimpleName();<span class="hljs-comment">// 获得包名</span>clazz.getPackage();<span class="hljs-comment">// 获得直接父类</span>clazz.getSuperclass();<span class="hljs-comment">// 判断是不是数组</span>clazz.isArray();<span class="hljs-comment">// 判断是不是枚举</span>clazz.isEmun();</code></pre><h3 id="九大内置class实例"><a href="#九大内置class实例" class="headerlink" title="九大内置class实例"></a>九大内置class实例</h3><ul><li><p>基本数据类型和包装数据类型的字节码对象<br>  int.class != Integer.class<br>  Integer.TYPE==int.class</p></li><li><p>byte</p></li><li><p>short</p></li><li><p>int</p></li><li><p>long</p></li><li><p>float</p></li><li><p>double</p></li><li><p>boolean</p></li><li><p>charnest</p></li><li><p>void</p></li></ul><pre><code class="hljs java">Class clazz = <span class="hljs-keyword">int</span>.class;Class&lt;?&gt; clazz = <span class="hljs-keyword">int</span>.class;</code></pre><h3 id="数组的class实例"><a href="#数组的class实例" class="headerlink" title="数组的class实例"></a>数组的class实例</h3><p><strong>数组是一种对象，不是基本数据类型</strong>，数组的class实例与数组存储的内容息息相关，相同内容的数组的class对象唯一，不同内容的类型的class对象不相同</p><pre><code class="hljs java"><span class="hljs-comment">// 方式一</span>Class&lt;String[]&gt; clazz = String[].class;<span class="hljs-comment">// 方式二</span>String[] strings = <span class="hljs-keyword">new</span> String[]&#123;&#125;;Class&lt;String[]&gt; clazz = strings.getClass();<span class="hljs-comment">// 相同类型的数组class对象</span>args.getClass() == strings.getClass()</code></pre><h2 id="AccessibleObject"><a href="#AccessibleObject" class="headerlink" title="AccessibleObject"></a>AccessibleObject</h2><p><img src="../images/2019-05-26-22-38-46.png"></p><p><code>Constructor/Method/Field</code>类是<code>AccessibleObject</code>的子类，继承<code>setAccessible()</code>方法</p><p>在访问私有构造器/方法/字段时，可以通过设置<code>setAccessible(true)</code>来实现访问。</p><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><h3 id="获得构造器"><a href="#获得构造器" class="headerlink" title="获得构造器"></a>获得构造器</h3><pre><code class="hljs java">Class&lt;String&gt; clazz =  String.class;<span class="hljs-comment">// 获取所有public构造器，无法获得泛型即时class设置泛型</span>Constructor&lt;?&gt;[] constructors = clazz.getConstructors();<span class="hljs-comment">// 获得所有构造器</span>Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();<span class="hljs-comment">// 获得指定public构造器</span>Constructor&lt;String&gt; constructor = clazz.getConstructor();Constructor&lt;String&gt; constructor = clazz.getConstructor(String.class);<span class="hljs-comment">// 获得指定任一构造器</span>Constructor&lt;String&gt; constructor = clazz.getDeclaredConstructor();Constructor&lt;String&gt; constructor = clazz.getDeclaredConstructor(String.class);</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>反射机制下，private修饰构造器的单例模式并不安全</li><li>以下情况使用反射实现，必须在类中实现<code>public</code>的无参构造器<ul><li>JSON的序列化和反序列化-EasyJson/Gson</li><li>Feign的序列化和反序列化</li></ul></li></ul><pre><code class="hljs java">Class&lt;String&gt; clazz =  String.class;<span class="hljs-comment">// 方式一：通过Class类中的newInstance()方法创建对象</span>String string = String.class.newInstance();<span class="hljs-comment">// 方式二：构造器创建对象，无参</span>Constructor constructor =clazz.getConstructor();String string = constructor.newInstance();<span class="hljs-comment">// 方式二：构造器创建对象，带参</span>Constructor&lt;String&gt; constructor = clazz.getConstructor(String.class);String string = constructor.newInstance(<span class="hljs-string">&quot;string&quot;</span>);<span class="hljs-comment">// 访问私有化构造器，因此，私有化构造器在反射的情况下并不安全</span>Class&lt;SingleInstanceClassDemo&gt; clazz = SingleInstanceClassDemo.class;Constructor&lt;SingleInstanceClassDemo&gt; constructor = clazz.getDeclaredConstructor();<span class="hljs-comment">// 重点1，获取非public构造器</span>constructor.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 重点2，设置为可访问</span>constructor.newInstance();</code></pre><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="获得方法"><a href="#获得方法" class="headerlink" title="获得方法"></a>获得方法</h3><pre><code class="hljs java">Class&lt;String&gt; clazz = String.class;<span class="hljs-comment">// 获取所有public方法,包括继承的</span>Method[] methods = clazz.getMethods();<span class="hljs-comment">// 获取自身的所有方法，不包括继承的</span>Method[] declaredMethods = clazz.getDeclaredMethods();<span class="hljs-comment">// 无参 public 方法</span>Method toString = clazz.getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<span class="hljs-comment">// 有参 public 方法</span>Method equals = clazz.getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Object.class);<span class="hljs-comment">// 获取 private 方法</span>Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;checkBounds&quot;</span>, <span class="hljs-keyword">byte</span>[].class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="调用对象的方法"><a href="#调用对象的方法" class="headerlink" title="调用对象的方法"></a>调用对象的方法</h4><ul><li>invoke(),参数一，执行方法的对象，一般不能new，而是使用反射获得对象，参考上文构造器</li></ul><pre><code class="hljs java">Class&lt;String&gt; clazz = String.class;<span class="hljs-comment">// 有参 public 方法</span>Method equals = clazz.getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Object.class);<span class="hljs-comment">// invoke()方法参数一是执行方法的对象，参数2开始是参数</span>Object result = equals.invoke(        clazz.getConstructor(String.class).newInstance(&quot;Haha&quot;), // 通过反射获得的对象        <span class="hljs-string">&quot;Haha&quot;</span>);<span class="hljs-comment">// 非public方法</span>Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;checkBounds&quot;</span>, <span class="hljs-keyword">byte</span>[].class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);method.setAccessible(<span class="hljs-keyword">true</span>);method.invoke(...);</code></pre><h4 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h4><ul><li>invoke(),参数一，执行方法的对象设置为<code>null</code></li></ul><pre><code class="hljs java">Class&lt;Integer&gt; clazz = Integer.class;Object result = clazz.getMethod(<span class="hljs-string">&quot;valueOf&quot;</span>, String.class).invoke(<span class="hljs-keyword">null</span>,&quot;<span class="hljs-number">1</span><span class="hljs-string">&quot;);</span></code></pre><h4 id="调用可变参数方法"><a href="#调用可变参数方法" class="headerlink" title="调用可变参数方法"></a>调用可变参数方法</h4><ul><li>可变参数方法相当于数组<ul><li>基本数据类型，直接传递数组对象</li><li>引用数据类型，需要再封包一次（**同样适合基本数据类型数组和其他非数组参数，建议使用 **）</li></ul></li></ul><p>原因解析，invake方法参数二本身就是一个Object[], 直接传递Object[]会引起误解，需要使用Object[]封包，解包时才能证明调用的方法的第参数是一个<strong>引用数据类型的数据</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 基本数据类型(假设该方法存在)</span>Method method = Arrays.class.getMethod(&quot;asList&quot;, <span class="hljs-keyword">int</span>[].class);System.out.println(method.invoke(        <span class="hljs-keyword">null</span>,        <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">56</span>&#125;));<span class="hljs-comment">// 引用数据类型</span>Method method = Arrays.class.getMethod(&quot;asList&quot;, Object[].class);System.out.println(method.invoke(        <span class="hljs-keyword">null</span>,        <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">56</span>&#125;&#125;));</code></pre><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><pre><code class="hljs java"></code></pre><h2 id="Modifier-获取修饰符"><a href="#Modifier-获取修饰符" class="headerlink" title="Modifier 获取修饰符"></a>Modifier 获取修饰符</h2><p><img src="../images/2019-05-27-09-40-45.png"></p><p>观察上图发现，修饰符有1,2,4,8,16,32,64,128,256,512,1024的规律，在底层使用int[2字节]存储，多个修饰符号则对二进制进行<strong>与操作</strong></p><table><thead><tr><th>十进制</th><th>二进制</th><th>变量</th></tr></thead><tbody><tr><td>1</td><td>00000000 00000001</td><td>public</td></tr><tr><td>2</td><td>00000000 00000010</td><td>private</td></tr><tr><td>4</td><td>00000000 00000100</td><td>protected</td></tr><tr><td>8</td><td>00000000 00001000</td><td>static</td></tr><tr><td>16</td><td>00000000 00010000</td><td>final</td></tr><tr><td>32</td><td>00000000 00100000</td><td>synchronized</td></tr><tr><td>64</td><td>00000000 01000000</td><td>volatile</td></tr><tr><td>128</td><td>00000000 10000000</td><td>transient</td></tr><tr><td>256</td><td>00000001 00000000</td><td>native</td></tr><tr><td>512</td><td>00000010 00000000</td><td>interface</td></tr><tr><td>1024</td><td>00000100 00000000</td><td>abstract</td></tr></tbody></table><pre><code class="hljs java">method.getModifiers();field.getModifiers();constructor.getModifiers();clazz.getModifiers();</code></pre><pre><code class="hljs java"><span class="hljs-keyword">int</span> mod = method.getModifiers();Modifier.toString(mod);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>04-类加载及反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-获取文件夹</title>
    <link href="/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/03-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <url>/01-Java/01-JavaSE/04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8F%8D%E5%B0%84/03-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="获取项目文件夹"><a href="#获取项目文件夹" class="headerlink" title="获取项目文件夹"></a>获取项目文件夹</h1><pre><code class="hljs java"><span class="hljs-comment">// 获得当前项目文件夹</span>System.out.println(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<span class="hljs-comment">// 【推荐】通过反射获得资源流 -- 注意：必须要/路径，/表示classPath的跟路径Demo.class.getResource拿到的是class文件所在的路径，不是classPath的路径</span>System.out.println(Demo.class.getResourceAsStream(&quot;/demo.properties&quot;));<span class="hljs-comment">// 通过反射获得资源文件</span>System.out.println(Demo.class.getResource(&quot;/demo.properties&quot;));<span class="hljs-comment">// 通过ClassLoader获得资源文件流 -- 注意，只需要文件名，不需要/路径</span>ClassLoader classLoader = Demo.class.getClassLoader();System.out.println(classLoader.getResourceAsStream(<span class="hljs-string">&quot;demo.properties&quot;</span>));<span class="hljs-comment">// 【推荐】通过Thread获得ClassLoader -- 注意，只需要文件名，不需要/路径</span>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();System.out.println(classLoader.getResourceAsStream(<span class="hljs-string">&quot;demo.properties&quot;</span>));</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>04-类加载及反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-线程生命周期</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/03-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/03-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程的状态（生命周期）"><a href="#线程的状态（生命周期）" class="headerlink" title="线程的状态（生命周期）"></a>线程的状态（生命周期）</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;        NEW,        RUNNABLE,        BLOCKED,        WAITING,        TIMED_WAITING,        TERMINATED;    &#125;</code></pre><p><img src="../images/05-01.png"></p><p>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p><ol><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，不会放弃对象监视器 不需要notify 即可等待JVM的调度。</li><li>调用wait()，使该线程处于<strong>等待池</strong>(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到<strong>锁定池</strong>(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li></ol><p>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</p><h2 id="每个对象都有的方法（同步机制）"><a href="#每个对象都有的方法（同步机制）" class="headerlink" title="每个对象都有的方法（同步机制）"></a>每个对象都有的方法（同步机制）</h2><p>Java中的每个对象都有一个监视器monitor。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。</p><p><img src="../images/05-02.png" alt="监视器图"></p><p><code>wait()/notify()</code>必须存在于synchronized块中，否则会抛出<code>java.lang.IllegalMonitorStateException</code>（如图中5的状态，即脱离同步块）。在synchronized块调用其他对象的<code>wait()/notify()</code>也会因为监视器不同抛出该异常。</p><p>同步代码块</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   Object lock;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">synchronized</span>(lock)&#123;         <span class="hljs-comment">// do something</span>         <span class="hljs-comment">// 这里的代码块只有一个线程能够执行</span>       &#125;   &#125;&#125;</code></pre><p>同步方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// do something</span>   &#125;&#125;</code></pre><p>混合使用：生产者消费者模型，这里是资源类，生产者类和消费者类都是多线程的</p><p><a href="../../%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B/">线程通信之生产者和消费者案例</a></p><pre><code class="hljs java"><span class="hljs-comment">// ***************资源类*****************</span><span class="hljs-comment">/**</span><span class="hljs-comment">* 生产者生产出来的产品交给店员</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.product &gt;= MAX_PRODUCT)    &#123;        <span class="hljs-keyword">try</span>        &#123;            wait();            System.out.println(<span class="hljs-string">&quot;产品已满,请稍候再生产&quot;</span>);        &#125;        <span class="hljs-keyword">catch</span>(InterruptedException e)        &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">this</span>.product++;    System.out.println(<span class="hljs-string">&quot;生产者生产第&quot;</span> + <span class="hljs-keyword">this</span>.product + <span class="hljs-string">&quot;个产品.&quot;</span>);    notifyAll();   <span class="hljs-comment">//通知等待区的消费者可以取出产品了（此时其他线程进入锁定池）</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 消费者从店员取产品</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.product &lt;= MIN_PRODUCT)    &#123;        <span class="hljs-keyword">try</span>        &#123;            wait();            System.out.println(<span class="hljs-string">&quot;缺货,稍候再取&quot;</span>);        &#125;        <span class="hljs-keyword">catch</span> (InterruptedException e)        &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span>;    &#125;    System.out.println(<span class="hljs-string">&quot;消费者取走了第&quot;</span> + <span class="hljs-keyword">this</span>.product + <span class="hljs-string">&quot;个产品.&quot;</span>);    <span class="hljs-keyword">this</span>.product--;    notifyAll();   <span class="hljs-comment">//通知等待区的生产者可以生产产品了</span>&#125;</code></pre><h3 id="Volatile关键字修饰变量"><a href="#Volatile关键字修饰变量" class="headerlink" title="Volatile关键字修饰变量"></a>Volatile关键字修饰<strong>变量</strong></h3><p>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。</p><p>资源对象保存在堆空间中，线程共享，当有多个线程同时操作该资源，线程将值从堆空间中<strong>load</strong>到线程栈空间，操作完再<strong>save</strong>回去</p><p><img src="../images/2019-12-17-16-33-42.png"></p><p>其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能，强制执行load和save</p><h2 id="Thread类的方法"><a href="#Thread类的方法" class="headerlink" title="Thread类的方法"></a>Thread类的方法</h2><pre><code class="hljs java"><span class="hljs-comment">// 当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread.yield()<span class="hljs-comment">// 暂停一段时间</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread.sleep()<span class="hljs-comment">// 在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　　　</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// 中断 sleep join皆可以被打断</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">interrupte</span><span class="hljs-params">()</span></span></code></pre><h2 id="synchronized和Volatile的区别"><a href="#synchronized和Volatile的区别" class="headerlink" title="synchronized和Volatile的区别"></a>synchronized和Volatile的区别</h2><ol><li>Volatile 只能修饰变量 synchronized 可以修饰代码块 方法 变量</li><li>线程安全包含原子性和可见性两个方面。 Volatile解决的是可见性问题，synchronized解决的是同步性（原子性）问题, 顺便解决了可见性问题。</li><li>Volatile不会阻塞线程，synchronized会发生线程阻塞</li></ol><h2 id="sleep方法和wait方法有什么区别"><a href="#sleep方法和wait方法有什么区别" class="headerlink" title="sleep方法和wait方法有什么区别"></a>sleep方法和wait方法有什么区别</h2><table><thead><tr><th>关键字</th><th>相同点</th><th>区别</th></tr></thead><tbody><tr><td>sleep</td><td>放弃CPU</td><td>不会释放监视器 不会释放锁 时间到自动醒来继续执行</td></tr><tr><td>wait</td><td>放弃CPU</td><td>释放监视器 释放锁 需要notify 并且夺得锁才能继续执行</td></tr></tbody></table><h3 id="Thread-sleep-0-的作用"><a href="#Thread-sleep-0-的作用" class="headerlink" title="Thread.sleep(0)的作用"></a>Thread.sleep(0)的作用</h3><p>Java中用到的线程调度算法是抢占式。一个线程用完CPU之后，操作系统会根据线程<strong>优先级、线程饥饿</strong>情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。<br>可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="ReentrantLock-可重入锁-和-ReadWriteLock"><a href="#ReentrantLock-可重入锁-和-ReadWriteLock" class="headerlink" title="ReentrantLock 可重入锁 和 ReadWriteLock"></a>ReentrantLock 可重入锁 和 ReadWriteLock</h3><p>如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但多个线程读数据，并不会导致数据改变。<br>ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的。</p><h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><ol><li>synchronized是关键字 ReentrantLock是类</li><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ol><h2 id="NotifyAll和notify的区别"><a href="#NotifyAll和notify的区别" class="headerlink" title="NotifyAll和notify的区别"></a>NotifyAll和notify的区别</h2><p>如果所有线程都在等待相同的条件, 可以使用notify 会更加节省CPU资源<br>当出现线程等待条件不同时，如 生产者消费者模型中，消费者线程1发现没得消费了，notify 如果唤醒了另一个消费者，没得消费，进入等待池</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 获取资源</span><span class="hljs-comment">    */</span><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (isEmpty) &#123;            <span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">// --消费者线程 释放锁 进入等待池，下面的代码不再执行</span>        &#125;    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-comment">// 消费</span>    isEmpty = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">this</span>.notify();    <span class="hljs-comment">//同时将其他线程唤醒</span>    <span class="hljs-comment">// this.notifyAll(); //同时将其他线程唤醒</span>&#125;</code></pre><h2 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么"></a>FutureTask是什么</h2><p>FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>参考1：<a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a><br>参考2：<a href="https://www.cnblogs.com/GarfieldEr007/p/5746362.html">Java多线程学习（吐血超详细总结）</a><br>参考3：<a href="../../%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B/">线程通信之生产者和消费者案例</a>  </p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-多线程进阶-安全和线程同步</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6-%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="线程不安全问题"><a href="#线程不安全问题" class="headerlink" title="线程不安全问题"></a>线程不安全问题</h3><p>在多个线程使用同一个资源的时候，有可能存在一个资源被一个线程占有，但一系列操作(原子操作：不可再分割的操作)并未执行完成，执行过程中的资源被其他线程拿去用了。<br>#同步<br>在一个线程执行原子操作时，其他线程不能占有资源</p><h2 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h2><p>同步锁在括号中，是线程共同享有的资源</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;String name = Thread.currentThread().getName();<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//同步锁，线程共同享有的资源，这里的this是指Apple对象</span><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">10</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(name + <span class="hljs-string">&quot;吃了第&quot;</span> + num-- + <span class="hljs-string">&quot;个苹果&quot;</span>);&#125;&#125;&#125;&#125;</code></pre><h2 id="2-同步方法-不能同步run方法"><a href="#2-同步方法-不能同步run方法" class="headerlink" title="2.同步方法(不能同步run方法)"></a>2.同步方法(不能同步run方法)</h2><p>使用synchronized来修饰方法，对于非静态方法，同步锁是this；对于非静态方法，同步锁是当前方法所在类的字节码对象 类名.class</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;test();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;String name = Thread.currentThread().getName();<span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">10</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(name + <span class="hljs-string">&quot;吃了第&quot;</span> + num-- + <span class="hljs-string">&quot;个苹果&quot;</span>);&#125;&#125;</code></pre><h2 id="3-锁机制"><a href="#3-锁机制" class="headerlink" title="3.锁机制"></a>3.锁机制</h2><p>synchronized采用了自动加锁和释放锁的机制，手动加锁的方法更加透明，功能更加强大</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> java_study;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">50</span>;<span class="hljs-comment">//1.由于 Lock 是一个接口，使用其实现类 ReentrantLock 获得一个锁对象</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;eat();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//2.在方法的开始加锁吗，需要使用try-finally保证释放锁的进行</span>lock.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;Thread.sleep(<span class="hljs-number">10</span>);String name = Thread.currentThread().getName();System.out.println(name + <span class="hljs-string">&quot;吃了第&quot;</span> + num-- + <span class="hljs-string">&quot;个苹果&quot;</span>);&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//3.释放锁</span>lock.unlock();&#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClockDemo</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Apple3 a = <span class="hljs-keyword">new</span> Apple3();<span class="hljs-keyword">new</span> Thread(a, <span class="hljs-string">&quot;A&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(a, <span class="hljs-string">&quot;B&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(a, <span class="hljs-string">&quot;C&quot;</span>).start();&#125;&#125;</code></pre><h2 id="同步的优缺点"><a href="#同步的优缺点" class="headerlink" title="同步的优缺点:"></a>同步的优缺点:</h2><ul><li>使用synchronized提高了线程安全性，降低了性能，尽量减小作用域         如：StringBuffer类 Vector Hashtable</li><li>不适用synchronized提升了性能。降低了线程安全性                     如：StringBuilder类 ArrayList HashMap</li></ul><h2 id="Sleep-对锁的影响"><a href="#Sleep-对锁的影响" class="headerlink" title="Sleep 对锁的影响"></a>Sleep 对锁的影响</h2><ul><li>Sleep 不会导致锁丢失，会一直占用资源直到从 sleep 唤醒</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-优雅地关闭线程</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/06-%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/06-%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012168222/article/details/52790400">https://blog.csdn.net/u012168222/article/details/52790400</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-单例模式的线程安全</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/08-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式的线程安全"><a href="#单例模式的线程安全" class="headerlink" title="单例模式的线程安全"></a>单例模式的线程安全</h1><p>单例模式本就是为了实现在程序中只有一个实例，具体实现参考设计模式章节</p><p>饿汉模式：线程安全（建议使用）<br>懒汉模式：线程不安全（多个线程同时创建）<br>双检锁单例模式: 线程安全</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-多线程总结</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/99-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/99-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程总结"><a href="#多线程总结" class="headerlink" title="多线程总结"></a>多线程总结</h1><p>参考1：<a href="https://blog.csdn.net/zl1zl2zl3/article/details/81868173">史上最全Java多线程面试题及答案</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-线程池的数量问题</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/09-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/09-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池的数量设置"><a href="#线程池的数量设置" class="headerlink" title="线程池的数量设置"></a>线程池的数量设置</h1><h2 id="简单估算"><a href="#简单估算" class="headerlink" title="简单估算"></a>简单估算</h2><p>CPU核数 为N</p><ol><li>IO密集型操作：IO并不会占用大量CPU 因此可以<strong>多一些线程数</strong> <code>2N+1</code></li><li>计算密集型操作：<strong>少设置线程数</strong> 减少线程的上下文切换 CPU核数+1 <code>N+1</code></li></ol><p>⚠️提醒：并发多、任务时间长 应该尽量减少任务时间（如使用缓存 使用NIO），拆分任务，增加服务器的计算能力。</p><h2 id="根据请求量来计算-利尔特法则"><a href="#根据请求量来计算-利尔特法则" class="headerlink" title="根据请求量来计算 利尔特法则"></a>根据请求量来计算 <strong>利尔特法则</strong></h2><p>业务需要保证请求量 QPS = 10 线程实际运行时间为2s 为了保证10个/s的需求，则需设置线程为 *<em>10 * 2 = 20*</em></p><blockquote><p>线程数 = QPS * 线程运行时间</p></blockquote><h2 id="根据已有CPU资源来计算"><a href="#根据已有CPU资源来计算" class="headerlink" title="根据已有CPU资源来计算"></a>根据已有CPU资源来计算</h2><blockquote><p>最佳线程数目 = ((线程等待时间+线程CPU时间)/线程CPU时间) * CPU数目</p></blockquote><p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32</p><p>可以简单理解为 一个线程中 CPU的空闲时间应该用CPU时间来填满 从而提高CPU利用率</p><p>这样也可以反推出系统的QPS为 <strong>32 / 2 = 16</strong></p><h2 id="怎么查看线程的CPU时间和空闲时间"><a href="#怎么查看线程的CPU时间和空闲时间" class="headerlink" title="怎么查看线程的CPU时间和空闲时间"></a>怎么查看线程的CPU时间和空闲时间</h2><ol><li>线程CPU时间</li><li>线程IO时间/网络时间</li><li>CPU数量</li></ol><p>线程CPU时间 = 线程总时间 - 线程IO时间</p><h3 id="最简单的办法"><a href="#最简单的办法" class="headerlink" title="最简单的办法"></a>最简单的办法</h3><p>在线程开始时计时，结束时计时 结束减去开始便得到<strong>线程总时间</strong><br>在线程IO开始时计时，IO结束时计时 结束减去开始便得到<strong>线程IO时间</strong></p><h3 id="在Web中可以使用的高级方法"><a href="#在Web中可以使用的高级方法" class="headerlink" title="在Web中可以使用的高级方法"></a>在Web中可以使用的高级方法</h3><p>使用过滤器<code>javax.servlet.Filter</code>计算请求时间</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoniterFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException,</span><span class="hljs-function">            ServletException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();                HttpServletRequest httpRequest = (HttpServletRequest) request;        HttpServletResponse httpResponse = (HttpServletResponse) response;        <span class="hljs-keyword">try</span> &#123;            chain.doFilter(httpRequest, httpResponse);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">long</span> cost = System.currentTimeMillis() - start;            System.out.println(<span class="hljs-string">&quot;请求线程总时间:&quot;</span> + cost);        &#125;    &#125;&#125;</code></pre><p><a href="https://www.cnblogs.com/cjsblog/p/9068886.html">如何合理地估算线程池大小？</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-常用算法</title>
    <link href="/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/01-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/01-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><p>本笔记中的大部分案例如不说明，均使用扑克牌作为讲解道具。n=5</p><p><img src="../images/2019-12-28-23-27-51.png"></p><p>复杂度速记</p><p>选择永远都是 O(n^2)</p><p>最好情况 <strong>插入</strong> <strong>冒泡</strong>是 <code>O(n)</code> 其他都是 <code>O(nlogn)</code><br>最坏情况复杂度 仅<strong>归并</strong>、<strong>堆</strong>是<code>O(nlogn)</code> 其他都是<code>O(n^2)</code></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 冒泡排序</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 单个数组 交换</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">int</span> tmp = arr[j];                    arr[j] = arr[j + <span class="hljs-number">1</span>];                    arr[j + <span class="hljs-number">1</span>] = tmp;                &#125;                String format = String.format(<span class="hljs-string">&quot;i=%d; j=%d; arr=%s&quot;</span>, i, j, Arrays.toString(arr));                System.out.println(format);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">i=0; j=0; arr=[3, 4, 2, 1]</span><span class="hljs-comment">i=0; j=1; arr=[3, 2, 4, 1]</span><span class="hljs-comment">i=0; j=2; arr=[3, 2, 1, 4]</span><span class="hljs-comment">--------------------------</span><span class="hljs-comment">i=1; j=0; arr=[2, 3, 1, 4]</span><span class="hljs-comment">i=1; j=1; arr=[2, 1, 3, 4]</span><span class="hljs-comment">--------------------------</span><span class="hljs-comment">i=2; j=0; arr=[1, 2, 3, 4]</span><span class="hljs-comment">*/</span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 选择排序</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 单个数组 挖槽填坑</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectSort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;---------------------------------&quot;</span>);            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-comment">// 挖槽 arr[i]的位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                    min = j;                &#125;                String format = String.format(<span class="hljs-string">&quot;i=%d; j=%d; min=%d; arr=%s&quot;</span>, i, j, min, Arrays.toString(arr));                System.out.println(format);            &#125;            <span class="hljs-comment">// 填坑 arr[i]的位置，用min指向的值填</span>            <span class="hljs-keyword">if</span> (i != min) &#123;                <span class="hljs-keyword">int</span> tmp = arr[i];                arr[i] = arr[min];                arr[min] = tmp;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">i=0; j=1; min=1; arr=[4, 3, 2, 1]</span><span class="hljs-comment">i=0; j=2; min=2; arr=[4, 3, 2, 1]</span><span class="hljs-comment">i=0; j=3; min=3; arr=[4, 3, 2, 1]</span><span class="hljs-comment">---------------------------------</span><span class="hljs-comment">i=1; j=2; min=2; arr=[1, 3, 2, 4]</span><span class="hljs-comment">i=1; j=3; min=2; arr=[1, 3, 2, 4]</span><span class="hljs-comment">---------------------------------</span><span class="hljs-comment">i=2; j=3; min=2; arr=[1, 2, 3, 4]</span><span class="hljs-comment">*/</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 插入排序</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 一个数组 取后 右移</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertionSort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);            <span class="hljs-comment">// 取后</span>            <span class="hljs-keyword">int</span> next = arr[i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;                <span class="hljs-keyword">if</span> (next &lt; arr[j]) &#123;                    <span class="hljs-comment">// 右移</span>                    arr[j+<span class="hljs-number">1</span>] = arr[j];                    arr[j] = next;                &#125;                String format = String.format(<span class="hljs-string">&quot;i=%d; j=%d; next=%d; arr=%s&quot;</span>, i, j, next, Arrays.toString(arr));                System.out.println(format);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">i=0; j=0; next=3; arr=[3, 4, 2, 1]</span><span class="hljs-comment">----------------------------</span><span class="hljs-comment">i=1; j=1; next=2; arr=[3, 2, 4, 1]</span><span class="hljs-comment">i=1; j=0; next=2; arr=[2, 3, 4, 1]</span><span class="hljs-comment">----------------------------</span><span class="hljs-comment">i=2; j=2; next=1; arr=[2, 3, 1, 4]</span><span class="hljs-comment">i=2; j=1; next=1; arr=[2, 1, 3, 4]</span><span class="hljs-comment">i=2; j=0; next=1; arr=[1, 2, 3, 4]</span><span class="hljs-comment">*/</span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="hljs java"></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><pre><code class="hljs java">````## 堆排序```java</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code class="hljs java"></code></pre><p>参考1：<a href="https://www.cnblogs.com/eniac12/p/5329396.html">常用排序算法总结(一)</a><br>参考2：<a href="http://blog.csdn.net/yuzhihui_no1/article/details/44339711?yyue=a21bo.50862.201879">排序算法之 冒泡排序 及其时间复杂度和空间复杂度</a><br>参考3：<a href="https://www.cnblogs.com/shen-hua/p/5422676.html">Java中的经典算法之冒泡排序(Bubble Sort)</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>11-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-字符串逆序</title>
    <link href="/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F/"/>
    <url>/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串逆序"><a href="#字符串逆序" class="headerlink" title="字符串逆序"></a>字符串逆序</h1><p>题目：给定一个字符串<code>&quot;abcdefgh&quot;</code>求逆序</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s = <span class="hljs-string">&quot;abcdefgh&quot;</span>;    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();             <span class="hljs-comment">// ⚠️注意 toCharArray</span>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();     <span class="hljs-comment">// 也可以使用char[] newChar来接收</span>    <span class="hljs-keyword">int</span> len = chars.length;                     <span class="hljs-comment">// 注意 对象用length() 其他用length</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        sb.append(chars[i]);    &#125;    System.out.println(sb.toString());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>11-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-常见数据结构的实现</title>
    <link href="/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/03-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/01-Java/01-JavaSE/11-%E7%AE%97%E6%B3%95/03-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="常见数据结构的实现"><a href="#常见数据结构的实现" class="headerlink" title="常见数据结构的实现"></a>常见数据结构的实现</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;    <span class="hljs-keyword">private</span> Object value;    <span class="hljs-keyword">private</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Object value)</span></span>&#123;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;</code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;    <span class="hljs-keyword">int</span> value;    TreeNode left;    TreeNode right;&#125;</code></pre><h2 id="二叉树的广度优先算法-–-使用队列-进列先左后右-出列先左后右"><a href="#二叉树的广度优先算法-–-使用队列-进列先左后右-出列先左后右" class="headerlink" title="二叉树的广度优先算法 – 使用队列 进列先左后右 出列先左后右"></a>二叉树的广度优先算法 – 使用队列 进列先左后右 出列先左后右</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;    <span class="hljs-keyword">int</span> value;    TreeNode left;    TreeNode right;&#125;<span class="hljs-comment">// 非递归实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span>(!Objects.isNull(root))&#123;        Queue&lt;TreeNode&gt; nodeQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();        nodeQueue.add(root);        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty())&#123;            <span class="hljs-comment">// 从队列中取出进行左右判断</span>            TreeNode node = nodeQueue.poll();            System.out.println(node.value);            <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-keyword">null</span>)&#123;                nodeQueue.add(node.left);            &#125;            <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-keyword">null</span>)&#123;                nodeQueue.add(node.right);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="二叉树的深度优先算法-–-使用栈-入栈先右后左-出栈先左后右"><a href="#二叉树的深度优先算法-–-使用栈-入栈先右后左-出栈先左后右" class="headerlink" title="二叉树的深度优先算法 – 使用栈 入栈先右后左 出栈先左后右"></a>二叉树的深度优先算法 – 使用栈 入栈先右后左 出栈先左后右</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;    Object value;    TreeNode left;    TreeNode right;&#125;<span class="hljs-comment">// 非递归实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span>(!Objects.isNull(root))&#123;        Stack&lt;TreeNode&gt; nodeStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        nodeStack.push(root);        <span class="hljs-keyword">while</span> (!nodeStack.isEmpty())&#123;            TreeNode node = nodeStack.pop();            System.out.println(node.value);            <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-keyword">null</span>)&#123;                nodeStack.push(node.right);            &#125;            <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-keyword">null</span>)&#123;                nodeStack.push(node.left);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>11-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-maven初学者</title>
    <link href="/01-Java/04-Maven/01-maven%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    <url>/01-Java/04-Maven/01-maven%E5%88%9D%E5%AD%A6%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven从0到1"><a href="#Maven从0到1" class="headerlink" title="Maven从0到1"></a>Maven从0到1</h1><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><ul><li>统一的开发规范，所有的文件夹怎么放都是有规范的</li><li>统一的jar包管理</li></ul><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>官方标配</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.cenzhongman.kafkaSpark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafkaSpark<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><ul><li><p>modelVersion  当前Maven模型的版本号，对于Maven2和Maven3来说，它只能是4.0.0</p></li><li><p>groupId       域名倒置+项目名</p></li><li><p>artifactId    项目名，如果是子项目，可以采用xxx-xxx的方式</p></li><li><p>version       版本号 SNAPSHOT表示快照版本</p></li><li><p>packing       项目打包的类型，可以使jar、war、rar、ear、pom，默认是jar</p></li><li><p>dependencies  依赖</p></li><li><p>properties    配置</p></li><li><p>build         build表示与构建相关的配置，比如build下有finalName，表示的就是最终构建之后的名称</p></li></ul><p><strong>G</strong>roupID <strong>A</strong>rtifactId <strong>V</strong>ersion是唯一能定位到项目的三个关键元素</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="../images/01-01.png"></p><h2 id="setting-xml文件"><a href="#setting-xml文件" class="headerlink" title="setting.xml文件"></a>setting.xml文件</h2><p>配置本地仓库</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Documents\project\maven\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><h2 id="添加第三方依赖库"><a href="#添加第三方依赖库" class="headerlink" title="添加第三方依赖库"></a>添加第三方依赖库</h2><p>直接在工程的pom.xml下增加</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>cloudera<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>cloudera repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre><h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><p>1.清空缓存，保证最新</p><pre><code class="hljs sh">mvn clean</code></pre><p>2.编译工程并打包</p><pre><code class="hljs sh"><span class="hljs-comment"># 打包格式取决于pom.xml中的packing</span>mvn package<span class="hljs-comment"># 一般配合clean一起使用</span>mvn clean package</code></pre><p>3.运行单元测试</p><pre><code class="hljs sh">mvn <span class="hljs-built_in">test</span></code></pre><p><a href="http://www.yiibai.com/maven/run-unit-test-with-maven.html">参考文档</a></p><p>4.生成一个完整的项目输出到本地仓库，供其他程序调用</p><pre><code class="hljs sh"><span class="hljs-comment"># 当“install”在执行阶段，上述所有阶段 “validate“, “compile“, “test“, “package“, “integration-test“, “verify” 阶段, 包括目前的“install”阶段将被执行有序</span>mvn install<span class="hljs-comment"># 一般配合clean一起执行</span>mvn clean install</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-依赖冲突和解决</title>
    <link href="/01-Java/04-Maven/03-%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <url>/01-Java/04-Maven/03-%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="maven-依赖冲突和解决"><a href="#maven-依赖冲突和解决" class="headerlink" title="maven 依赖冲突和解决"></a>maven 依赖冲突和解决</h1><ul><li>描述：IDEA显示omitted for duplicate</li><li>描述：jar包版本冲突</li><li>解决：使用IDEA可以查看Maven的依赖图，快捷键Ctrl+Shift+Alt+u，查看到冲突分支，更改冲突的版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-install和install：install区别</title>
    <link href="/01-Java/04-Maven/04-install%E5%92%8Cinstall%EF%BC%9Ainstall%E5%8C%BA%E5%88%AB/"/>
    <url>/01-Java/04-Maven/04-install%E5%92%8Cinstall%EF%BC%9Ainstall%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="install-和-install-install区别"><a href="#install-和-install-install区别" class="headerlink" title="install 和 install:install区别"></a>install 和 install:install区别</h1><p><img src="../images/04-01.png"></p><p>这个图足以说明一切问题：</p><p>Maven的生命周期只有<code>clean install package</code>这些指令</p><p>而<code>install:install</code>是插件自带的命令而已，也就是说<code>install:install</code>执行的是<code>maven-install-plugin:install</code>，而我们的SpringBoot封装了SpringBoot自己的打包流程</p><p><a href="https://stackoverflow.com/questions/6308162/maven-the-packaging-for-this-project-did-not-assign-a-file-to-the-build-artifac">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-使用maven插件打包</title>
    <link href="/01-Java/04-Maven/02-%E4%BD%BF%E7%94%A8maven%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <url>/01-Java/04-Maven/02-%E4%BD%BF%E7%94%A8maven%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Maven打包java工程"><a href="#使用Maven打包java工程" class="headerlink" title="使用Maven打包java工程"></a>使用Maven打包java工程</h1><p><a href="http://maven.apache.org/plugins/maven-shade-plugin/examples/resource-transformers.html#ManifestResourceTransformer">官方文档</a></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 说明编码格式和Java编译版本 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-comment">&lt;!-- 忽略测试的错误 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">testFailureIgnore</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">testFailureIgnore</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-comment">&lt;!-- 打胖包，使用了share插件 --&gt;</span><span class="hljs-comment">&lt;!-- 方式1. 普通maven编译，springboot不用這個 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 将share插件绑定到package生命周期中，叠加到生命周期的末尾，因此，将会生成两个jar包，一个jar插件打的瘦包 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span>                <span class="hljs-comment">&lt;!-- jar包的Manifest文件路径转换 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>biz.datainsights.Application<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-comment">&lt;!-- 方式2：Spring用這個打包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><pre><code class="hljs sh">mvn clean install</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-maven的原理</title>
    <link href="/01-Java/04-Maven/05-maven%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/01-Java/04-Maven/05-maven%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven的原理"><a href="#Maven的原理" class="headerlink" title="Maven的原理"></a>Maven的原理</h1><h2 id="1-Maven的生命周期"><a href="#1-Maven的生命周期" class="headerlink" title="1. Maven的生命周期"></a>1. Maven的生命周期</h2><p><img src="../images/2019-01-12-23-49-09.png" alt="Maven的生命周期"></p><p>如，要执行<code>mvn package</code>会先执行<code>complie</code>和<code>test</code>，值得注意的是clean default site是三组，并不是生命周期，下面的一排才是生命周期命令支持的</p><ol><li>clean生命周期：清理项目，包含三个phase。<ol><li>pre-clean：执行清理前需要完成的工作</li><li>clean：清理上一次构建生成的文件</li><li>post-clean：执行清理后需要完成的工作</li></ol></li><li>default生命周期：构建项目，重要的phase如下。<ol><li>validate：验证工程是否正确，所有需要的资源是否可用。</li><li>compile：编译项目的源代码。</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>Package：把已编译的代码打包成可发布的格式，比如jar。</li><li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li><li>Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li></ol></li><li>site生命周期：建立和发布项目站点，phase如下<ol><li>pre-site：生成项目站点之前需要完成的工作</li><li>site：生成项目站点文档</li><li>post-site：生成项目站点之后需要完成的工作</li><li>site-deploy：将项目站点发布到服务器</li></ol></li></ol><h2 id="2-Maven的插件"><a href="#2-Maven的插件" class="headerlink" title="2. Maven的插件"></a>2. Maven的插件</h2><p><a href="http://repo1.maven.org/maven2/org/apache/maven/plugins/">maven所有的插件</a></p><p>maven的所有生命周期都是由插件来实现的，如<code>clean</code>则必然存在<code>maven-clean-plugin</code>插件提供该服务</p><p>一个插件有多个目标(goal)，当我们执行<code>mvn clean:clean</code>就是执行clean插件的clean目标，这就是插件命令</p><p>分析插件的目标, 也可以看<a href="http://maven.apache.org/plugins/index.html">官方文档</a></p><pre><code class="hljs sh">mvn <span class="hljs-built_in">help</span>:describe -Dplugin=clean</code></pre><h2 id="3-生命周期命令和插件命令"><a href="#3-生命周期命令和插件命令" class="headerlink" title="3. 生命周期命令和插件命令"></a>3. 生命周期命令和插件命令</h2><p>maven支持的两种命令</p><ul><li>插件命令：<code>mvn complier:complie compliner:testComplie surefile:test</code></li><li>生命周期命令：<code>mvn test</code> 生命周期命令是插件命令的有序组合</li></ul><p>生命周期命令的意义在于，将我们常用的插件命令有序组合，形成一个命令执行流程</p><h2 id="3-Maven的仓库"><a href="#3-Maven的仓库" class="headerlink" title="3. Maven的仓库"></a>3. Maven的仓库</h2><p><img src="../images/2019-01-13-00-06-15.png"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-maven-build版本号</title>
    <link href="/01-Java/04-Maven/06-maven-build%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <url>/01-Java/04-Maven/06-maven-build%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>Pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-Maven使用私服</title>
    <link href="/01-Java/04-Maven/07-Maven%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%8D/"/>
    <url>/01-Java/04-Maven/07-Maven%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%8D/</url>
    
    <content type="html"><![CDATA[<p>#1.找到maven的setting.xml文件下的<servers>添加如下配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>datain#18<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span></code></pre><p>#2.在需要发布到私服的java项目的pom.xml文件添加如下配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://nexus-console.datainsights.biz/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span></code></pre><p>#3.在需要依赖的java项目的pom.xml文件添加如下配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://nexus-console.datainsights.biz/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>04-Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Https-Apache使用SSL证书</title>
    <link href="/01-Java/06-Security/01-Https-Apache%E4%BD%BF%E7%94%A8SSL%E8%AF%81%E4%B9%A6/"/>
    <url>/01-Java/06-Security/01-Https-Apache%E4%BD%BF%E7%94%A8SSL%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="Apache使用Https证书"><a href="#Apache使用Https证书" class="headerlink" title="Apache使用Https证书"></a>Apache使用Https证书</h1><p><a href="https://help.aliyun.com/document_detail/98727.html?spm=5176.2020520163.cas.15.5d6dVJk0VJk0df">阿里云教程</a></p><h2 id="使用443代理本地端口"><a href="#使用443代理本地端口" class="headerlink" title="使用443代理本地端口"></a>使用443代理本地端口</h2><pre><code class="hljs sh">vim conf/extra//http-ssl.conf<span class="hljs-comment"># 在末尾加上</span>    &lt;Directory /&gt;                 Options Indexes FollowSymLinks MultiViews                 AllowOverride all                 Order deny,allow                 Allow from all     &lt;/Directory&gt;    ProxyPass / http://bmw-ss-server:10001/    ProxyPassReverse / http://bmw-ss-server:10001/&lt;/VirtualHost&gt;</code></pre><h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><ul><li><p>报错：SSLSessionCache-shmcbsessioncachenotsupported</p></li><li><p>解决：</p>  <pre><code class="hljs sh">vim httpd.confLoadModule socache_shmcb_module modules/mod_socache_shmcb.so <span class="hljs-comment"># 删除#号</span></code></pre></li><li><p>报错：Invalid command ‘RewriteEngine’, perhaps misspelled or defined by a module not included in the server configuration</p></li><li><p>解决：</p>  <pre><code class="hljs sh">vim httpd.confLoadModule rewrite_module modules/mod_rewrite.so <span class="hljs-comment"># 删除#号</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Swagger使用</title>
    <link href="/01-Java/14-Swagger/01-Swagger%E4%BD%BF%E7%94%A8/"/>
    <url>/01-Java/14-Swagger/01-Swagger%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Swagger的使用"><a href="#Swagger的使用" class="headerlink" title="Swagger的使用"></a>Swagger的使用</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springfox.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;springfox.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="Swagger2Config-java"><a href="#Swagger2Config-java" class="headerlink" title="Swagger2Config.java"></a>Swagger2Config.java</h2><pre><code class="hljs java"><span class="hljs-meta">@Profile(Constants.SPRING_PROFILE_SWAGGER)</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger2</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.cenzhongman.spring.web.application.controller&quot;</span>))                .paths(PathSelectors.any())                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">&quot;Application API&quot;</span>)                .description(<span class="hljs-string">&quot;XX项目接口&quot;</span>)                .termsOfServiceUrl(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;联系人&quot;</span>,<span class="hljs-string">&quot;联系人URL&quot;</span>,<span class="hljs-string">&quot;联系人邮箱@gmail.com&quot;</span>))                .version(<span class="hljs-string">&quot;1.0&quot;</span>)                .build();    &#125;&#125;</code></pre><p><img src="../images/2019-09-17-09-32-51.png"></p><h2 id="方式一：在Controller中实现Example"><a href="#方式一：在Controller中实现Example" class="headerlink" title="方式一：在Controller中实现Example"></a>方式一：在Controller中实现Example</h2><p>DemoController.java （不建议在controller中配置，而是通过下文<strong>对Model类进行注解实现Example</strong>）</p><ul><li>值得注意的是，在大多数情况下，swagger会通过自动判断进行Example的展示，因此通过直接注解Example的方式并不是一种很好的方式。</li><li>在注解后，所有的属性都会跟着注解的配置来展示，尽管部分属性没有进行配置，则使用默认值</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 不建议的操作</span><span class="hljs-meta">@ApiResponses(&#123;</span><span class="hljs-meta">        @ApiResponse(code = 200,message = &quot;ok&quot;,response = Response.class,examples = @Example(&#123;</span><span class="hljs-meta">                @ExampleProperty(value = &quot;&#123;&#x27;status&#x27;:&#x27;200&#x27;,&#x27;message&#x27;:&#x27;OK&#x27;,&#x27;data&#x27;:null&#125;&quot;)</span><span class="hljs-meta">        &#125;))</span><span class="hljs-meta">&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanyController</span> </span>&#123;    <span class="hljs-comment">// 建议的操作</span>    <span class="hljs-meta">@ApiOperation(value = &quot;通过 id 查询 company&quot;)</span>    <span class="hljs-comment">// 根据情况定夺，默认情况下没有对变量进行注释，但是一旦写就必须写齐所有配置</span>    <span class="hljs-meta">@ApiImplicitParams(&#123;</span><span class="hljs-meta">            @ApiImplicitParam(name = &quot;id&quot;,value = &quot;公司ID&quot;,example = &quot;1&quot;,required = true,paramType = &quot;Integer&quot;)</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id:[0-9]+&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Response&lt;Company&gt; <span class="hljs-title">getById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable(name=&quot;id&quot;)</span> Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Response.ok(<span class="hljs-keyword">this</span>.companyService.queryById(id));    &#125;&#125;</code></pre><p><img src="../images/2019-09-17-09-42-18.png"></p><h2 id="方式二：对Model类进行注解实现Example"><a href="#方式二：对Model类进行注解实现Example" class="headerlink" title="方式二：对Model类进行注解实现Example"></a>方式二：对Model类进行注解实现Example</h2><p>对于响应的内容，如公司类，可以通过对Model进行注解</p><p>DemoController.java</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanyController</span> </span>&#123;    <span class="hljs-meta">@ApiOperation(value = &quot;通过 id 查询 company&quot;)</span>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id:[0-9]+&#125;&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Response&lt;Company&gt; <span class="hljs-title">getById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable(name=&quot;id&quot;)</span> Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> Response.ok(<span class="hljs-keyword">this</span>.companyService.queryById(id));    &#125;&#125;</code></pre><p>Company.java</p><pre><code class="hljs java"><span class="hljs-meta">@ApiModelProperty(required = true,example = &quot;2000-01-01 00:00:00&quot;)</span><span class="hljs-keyword">private</span> Date listingDate;</code></pre><p><img src="../images/2019-09-17-09-55-00.png"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>14-Swagger</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-字节字符UTF-8-ASCII</title>
    <link href="/01-Java/99-Others/01-%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6UTF-8-ASCII/"/>
    <url>/01-Java/99-Others/01-%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6UTF-8-ASCII/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机字符串发展史"><a href="#计算机字符串发展史" class="headerlink" title="计算机字符串发展史"></a>计算机字符串发展史</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>这里只讨论二进制的负数的问题，一个字节的的容量有2^8=256个，由于二进制没有负数，因此使用补码实现负数，也就是说一个字节只能表示-128～+127共256个</p><table><thead><tr><th>原码</th><th>反码</th><th>补码</th><th>十进制</th></tr></thead><tbody><tr><td>0001</td><td>0001</td><td>0001</td><td>1</td></tr><tr><td>0010</td><td>0010</td><td>0010</td><td>2</td></tr><tr><td>0011</td><td>0011</td><td>0011</td><td>3</td></tr><tr><td>1001</td><td>0110</td><td>0111</td><td>-8</td></tr><tr><td>1010</td><td>0101</td><td>0110</td><td>-7</td></tr><tr><td>1111</td><td>0000</td><td>0001</td><td>-1</td></tr></tbody></table><p>正数的反码和补码都是本身，负数的补码=反码+1</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p><strong>ASCII码使用了一个字节</strong>(byte),8位二进制，总共255个，由于英文字符长度有限，限制了最高位为0(全部为正数)，<br>0～31及127(共33个)是控制字符或通信专用字符，这些控制字符不进行显示</p><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0010 0000</td><td>32</td><td>0x20</td></tr><tr><td>0111 1111</td><td>127</td><td>0x70</td></tr><tr><td>1111 1111</td><td>255</td><td>0xFF</td></tr></tbody></table><p><img src="../images/2019-05-21-11-09-05.png" alt="0-31"></p><p><img src="../images/2019-05-20-17-59-13.png" alt="32-126"></p><h2 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312/GBK/GB18030"></a>GB2312/GBK/GB18030</h2><p>由于ASCII编码范围太小，规定使用<strong>两个字节表示一个汉字</strong>，而英文符号与ASCII保持不变(一个字节)，</p><p>如：<br>0100 0110 - 1001 1100 - 0101 1100 表示一个字母加一个汉字，共3个字节</p><p>由于ASCII最高位为0，因此GB2312规定第一个字节的首位必须为1</p><p>二进制|无符号十进制|十六进制<br>—|—|—|—<br>1000 0000 0000 0000 | 32768 | 0x8000<br>1111 1111 1111 1111 | 65535 | 0xFFFF</p><p>汉字采用了区位码进行了“分区”处理，后来出现了<code>GBK</code>,<code>GB18030</code>等更为完成的中文编码标准</p><h2 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h2><p>收录拉丁符号，一个字节，收录了ASCII和西欧语言符号</p><h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>全名是American Standard Code for Information Interchange， 叫做“美国信息交换标准码”。一个英文字母占一个字节的空间，一个中文汉字占两个字节的空间。</p><p>ANSI编码其实包括很多编码：中国制定了GB2312编码，用来把中文编进去另外，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准。受制于当时的条件，不同语言之间的ANSI码之间不能互相转换</p><h2 id="Unicode-这是一种将字符-gt-数字的数学的标准"><a href="#Unicode-这是一种将字符-gt-数字的数学的标准" class="headerlink" title="Unicode(这是一种将字符 -&gt;  数字的数学的标准)"></a>Unicode(这是一种将字符 -&gt;  数字的数学的标准)</h2><p>全球统一编码格式，收录全世界的字符编码，将ASCII使用两个字节编码，高位填充0。对于生僻字Unicode已经使用4个字节来存储。</p><p>Unicode存储字符分为两步，第一步，使用数字将全球的所有字符表示出来，如0<del>127 128</del>65536表示什么来；第二步，转成能够存储在计算机中的二进制，这一步是UTF（unicode transformation format)<br>实现的</p><h2 id="UTF-16-存储Unicode标准的编码格式"><a href="#UTF-16-存储Unicode标准的编码格式" class="headerlink" title="UTF-16(存储Unicode标准的编码格式)"></a>UTF-16(存储Unicode标准的编码格式)</h2><p>全部使用两个字节来填充，所有的位都用来表示内容本身，共63335个</p><h2 id="UTF-8-存储Unicode标准的编码格式"><a href="#UTF-8-存储Unicode标准的编码格式" class="headerlink" title="UTF-8(存储Unicode标准的编码格式)"></a>UTF-8(存储Unicode标准的编码格式)</h2><p>这是一种变长的编码方式：它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，如此一来UTF-8编码也可以是为视为一种对ASCII码的拓展。值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。</p><h3 id="转换算法"><a href="#转换算法" class="headerlink" title="转换算法"></a>转换算法</h3><p>UTF-8编码文件前缀</p><p>程序是把一个字节一个字节的来读取,然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个单元来处理.</p><table><thead><tr><th>编码</th><th>长度</th><th>注解</th></tr></thead><tbody><tr><td>0xxxxxxx</td><td>2^7=128</td><td>一个字节做为一个单元.就跟ASCII完全一样</td></tr><tr><td>110xxxxx 10xxxxxx</td><td>2^11=2048</td><td>两个字节当一个单元</td></tr><tr><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>2^16=65536</td><td>三个字节当一个单元</td></tr></tbody></table><h3 id="UTF-8-BOM"><a href="#UTF-8-BOM" class="headerlink" title="UTF-8+BOM"></a>UTF-8+BOM</h3><p>微软自己给UTF-8加上了三个字节的前缀<code>EF BB BF</code></p><h2 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h2><ul><li>编码：将文本变成字节数组</li><li>解码：将字节数组变成文本</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Lombok插件</title>
    <link href="/01-Java/99-Others/02-Lombok%E6%8F%92%E4%BB%B6/"/>
    <url>/01-Java/99-Others/02-Lombok%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Lombok插件的使用"><a href="#Lombok插件的使用" class="headerlink" title="Lombok插件的使用"></a>Lombok插件的使用</h1><p><a href="https://projectlombok.org/">官网</a><br><a href="https://projectlombok.org/features/all">官方文档</a></p><h2 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.NonNull;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonNullExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Something</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonNullExample</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Person person)</span> </span>&#123;    <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;Hello&quot;</span>);    <span class="hljs-keyword">this</span>.name = person.getName();  &#125;&#125;</code></pre><h2 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Cleanup;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CleanupExample</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-meta">@Cleanup</span> InputStream in = <span class="hljs-keyword">new</span> FileInputStream(args[<span class="hljs-number">0</span>]);    <span class="hljs-meta">@Cleanup</span> OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(args[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">int</span> r = in.read(b);      <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;      out.write(b, <span class="hljs-number">0</span>, r);    &#125;  &#125;&#125;</code></pre><h2 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="@Getter and @Setter"></a>@Getter and @Setter</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AccessLevel;<span class="hljs-keyword">import</span> lombok.Getter;<span class="hljs-keyword">import</span> lombok.Setter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetterSetterExample</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Age of the person. Water is wet.</span><span class="hljs-comment">   * </span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> age New value for this person&#x27;s age. Sky is blue.</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> The current value of this person&#x27;s age. Circles are round.</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">   * Name of the person.</span><span class="hljs-comment">   * -- SETTER --</span><span class="hljs-comment">   * Changes the name of this person.</span><span class="hljs-comment">   * </span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> name The new value.</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Setter(AccessLevel.PROTECTED)</span> <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s (age: %d)&quot;</span>, name, age);  &#125;&#125;</code></pre><h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EqualsAndHashCodeExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> transientVar = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;  <span class="hljs-meta">@EqualsAndHashCode</span>.Exclude <span class="hljs-keyword">private</span> Shape shape = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-keyword">private</span> String[] tags;  <span class="hljs-meta">@EqualsAndHashCode</span>.Exclude <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;    <span class="hljs-meta">@EqualsAndHashCode(callSuper=true)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width, height;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;      <span class="hljs-keyword">this</span>.width = width;      <span class="hljs-keyword">this</span>.height = height;    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JavaBean</title>
    <link href="/01-Java/99-Others/03-JavaBean/"/>
    <url>/01-Java/99-Others/03-JavaBean/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVABean"><a href="#JAVABean" class="headerlink" title="JAVABean"></a>JAVABean</h1><ul><li>属性：不等于字段，是符合规范的getter和setter方法</li><li>事件：even一般在window button才有</li><li>方法：JavaBean除了Getter和Setter以外的方法</li></ul><h2 id="自省Introspector"><a href="#自省Introspector" class="headerlink" title="自省Introspector"></a>自省Introspector</h2><p>用于获取和操作JavaBean</p><pre><code class="hljs java"><span class="hljs-comment">// 获取BeanInfo 参数1:需要获取JAVABean的类，【参数2】停止的父类，不再往上获取</span>BeanInfo beanInfo = Introspector.getBeanInfo(User.class,Object.class);<span class="hljs-comment">// 通过反射获得对象</span>Object object = User.class.getConstructor().newInstance();<span class="hljs-comment">// 获取属性描述器</span>PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();<span class="hljs-keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;    <span class="hljs-comment">// 获得属性名</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;age&quot;</span>.equals(propertyDescriptor.getName()))&#123;        <span class="hljs-comment">// 获得属性的写方法</span>        Method setter = propertyDescriptor.getWriteMethod();        <span class="hljs-keyword">if</span> (setter!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// 执行写方法</span>            setter.invoke(object,<span class="hljs-number">19</span>);        &#125;    &#125;&#125;System.out.println(object);</code></pre><p>像这样即可实现如JSON的序列化和反序列化等操作</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-悲观锁和乐观锁</title>
    <link href="/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/07-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/01-Java/01-JavaSE/06-%E5%A4%9A%E7%BA%BF%E7%A8%8B/07-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>本文主要考量在数据持久化中的悲观锁和乐观锁</p><ol><li>丢失更新：一个事务的更新结果覆盖了其它事务的更新结果，即所谓的更新丢失。</li><li>脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。</li></ol><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS，全称为Compare and Swap，即比较-替换。</p><p>对于一个变量，线程缓存之后进行处理，有三个值, 内存值 预期值 修改值</p><p>内存值：主内存空间中的值<br>预期值：缓存值<br>修改值：基于预期值的修改值</p><p>当且仅当预期值A和内存值V相同时，才会将内存值修改为修改值并返回true，否则什么都不做并返回false。返回Flase之后进行试错操作。<br>CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁就是用户修改数据时看起来很悲观，保守态度，担心别的用户会同时修改这条数据，所以每次修改时会提前把这条数据锁定起来，只有自己可修改（但别的用户可以读），等自己修改完了再释放锁。</p><p>我们常用的<code>synchronized</code>就是悲观锁。</p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>使用悲观锁的时候我们首先必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。<br>关闭命令为：<code>set autocommit=0</code>;</p><p>悲观锁一般使用<code>select…for update</code>实现，在执行的时候会锁定数据，虽然会锁定数据，但是不影响其他事务的普通查询使用。(读写分离)<br>在我们使用悲观锁的时候事务中的语句例如：</p><pre><code class="hljs sql">//开始事务<span class="hljs-keyword">begin</span>;/<span class="hljs-keyword">begin</span> <span class="hljs-keyword">work</span>;/<span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>; (三选一)//查询信息  <span class="hljs-comment">-- 获得锁</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;//修改信息<span class="hljs-keyword">update</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;names&#x27;</span>;//提交事务  <span class="hljs-comment">-- 释放锁</span><span class="hljs-keyword">commit</span>;/<span class="hljs-keyword">commit</span> <span class="hljs-keyword">work</span>;(二选一)</code></pre><p>此处的查询语句<code>for update</code>关键字，在事务中只有<code>SELECT ... FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>同一条数据时会等待其它事务结束后才执行，一般的SELECT查询则不受影响。</p><blockquote><p>注意事项：查询条件与锁定范围</p></blockquote><ol><li>具体的主键值为查询条件<br>比如查询条件为主键ID=1等等，如果此条数据存在，则锁定当前行数据，如果不存在，则不锁定。</li><li>不具体的主键值为查询条件<br>比如查询条件为主键ID&gt;1等等，此时会锁定整张数据表。</li><li>查询条件中无主键<br>会锁定整张数据表。</li><li>如果查询条件中使用了索引为查询条件<br>明确指定索引并且查到，则锁定整条数据。如果找不到指定索引数据，则不加锁。</li></ol><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><p>ES中不使用悲欢锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁就是用户修改数据时心态很乐观，不管别人修改不修改数据，我都不上锁，我修改的时候判断下数据有没有发生变化，没发生变化我就会更新成功，发生变化了就不会更新成功我再去重试之前的动作直到更新成功。</p><h3 id="Mysql-1"><a href="#Mysql-1" class="headerlink" title="Mysql"></a>Mysql</h3><p>使用自增长的整数表示数据版本号，更新时检查版本号是否一致，比如数据库中数据版本为666，更新提交时version=666+1,使用该version值(=667)与数据库version+1(=667)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误或者发起重试动作。</p><p>数据库需要自己实现上述逻辑 如<code>student(id,name,version)</code>, 除了Version也可以使用<code>updata_time</code>时间戳来实现。</p><p>更新数据的语句</p><p><code>update student set name=&#39;txt&#39; where id = #&#123;id&#125; and version = #&#123;version&#125;;</code></p><h3 id="Es"><a href="#Es" class="headerlink" title="Es"></a>Es</h3><p>使用自增长的整数表示数据版本号，更新时检查版本号是否一致，比如数据库中数据版本为666，更新提交时version=666+1,使用该version值(=667)与数据库version+1(=667)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误或者发起重试动作。</p><p>上述就是ES官方的乐观锁实现多线程查询。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>乐观锁适合<strong>读多写少，冲突多</strong>的情况，能够提高读取速度，提高效率。<br>悲观锁适合<strong>读多写少，冲突少</strong>的情况下，能够减少重试次数，提高写入效率。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>06-多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JAVA中的异常处理机制和异常分类</title>
    <link href="/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/01-JAVA%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
    <url>/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/01-JAVA%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA中的异常处理机制和异常分类"><a href="#JAVA中的异常处理机制和异常分类" class="headerlink" title="JAVA中的异常处理机制和异常分类"></a>JAVA中的异常处理机制和异常分类</h1><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="../images/07-01.png"></p><ul><li>Thtowable是JAVA中所有异常的超类（父类）<ul><li>Error类指内部错误和资源耗尽错误，只有安全退出</li><li>Exception是可以被抛出或拦截处理的<ol><li>CheckedException：外部错误，文件加载错误</li><li>RuntimeException：程序员的错误，导致异常</li></ol></li></ul></li></ul><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><h3 id="1-抛出给调用者"><a href="#1-抛出给调用者" class="headerlink" title="1. 抛出给调用者"></a>1. 抛出给调用者</h3><p>抛出方式有三种</p><ol><li>throw，抛出特定异常，一定会抛出，不处理</li></ol><pre><code class="hljs java"><span class="hljs-comment">//程序编写者知道某句代码一定发生异常，使用throw关键字抛出</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String s = <span class="hljs-string">&quot;abc&quot;</span>;    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;abc&quot;</span>)) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException();      <span class="hljs-comment">// 其下方的代码将失去意义，已经跳转处理，此处异常为手动抛出</span>    &#125; <span class="hljs-keyword">else</span> &#123;      System.out.println(s);    &#125;&#125;</code></pre><ol start="2"><li>throws，不处理</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<span class="hljs-keyword">return</span> a/b;&#125;</code></pre><ol start="3"><li>自动抛出，不处理</li></ol><pre><code class="hljs java"><span class="hljs-comment">//系统自动抛出异常</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b =<span class="hljs-number">0</span>;    System.out.println(<span class="hljs-number">5</span>/b);&#125;</code></pre><h3 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2. 异常的处理"></a>2. 异常的处理</h3><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">//有可能发生异常的代码</span>&#125;Catch(异常类 变量)&#123;    <span class="hljs-comment">// 处理异常的代码，捕获</span>&#125;<span class="hljs-keyword">finally</span>&#123;    <span class="hljs-comment">//一定会被执行的代码</span>&#125;</code></pre><h2 id="RuntimeException和CheckedException的区别"><a href="#RuntimeException和CheckedException的区别" class="headerlink" title="RuntimeException和CheckedException的区别"></a>RuntimeException和CheckedException的区别</h2><ul><li><p>RuntimeException：不需要声明会抛出RuntimeException</p></li><li><p>CheckedException：定义方法时必须声明所有可能会抛出的exception；在调用这个方法时，处理或传递</p></li></ul><h2 id="throws-throw的区别"><a href="#throws-throw的区别" class="headerlink" title="throws throw的区别"></a>throws throw的区别</h2><p>throws表示</p><p>参考1：<a href="http://blog.csdn.net/sinat_36713319/article/details/68945619?yyue=a21bo.50862.201879">JAVA中的异常处理机制及异常分类</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>08-异常处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-异常处理源码</title>
    <link href="/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/02-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81/"/>
    <url>/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/02-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理源码"><a href="#异常处理源码" class="headerlink" title="异常处理源码"></a>异常处理源码</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">try</span> &#123;        x = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> x;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        x = <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> x;    &#125; <span class="hljs-keyword">finally</span> &#123;        x = <span class="hljs-number">3</span>;    &#125;&#125;</code></pre><p><code>javap -c FinalizeEscapeGC</code></p><pre><code class="hljs class">Compiled from &quot;FinalizeEscapeGC.java&quot;public class FinalizeEscapeGC &#123;  public FinalizeEscapeGC();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return    LineNumberTable:      line 1: 0  public int demo();    Code:       0: iconst_1       1: istore_1       2: iload_1       3: istore_2       4: iconst_3       5: istore_1       6: iload_2       7: ireturn       8: astore_2       9: iconst_2      10: istore_1      11: iload_1      12: istore_3      13: iconst_3      14: istore_1      15: iload_3      16: ireturn      17: astore        4      19: iconst_3      20: istore_1      21: aload         4      23: athrow    Exception table:                &#x2F;&#x2F; 异常表 记录异常的pc指针       from    to  target type           0     4     8   Class java&#x2F;lang&#x2F;Exception           0     4    17   any           8    13    17   any          17    19    17   any&#125;</code></pre><p>class文件通过异常表来记录异常的pc指针，在出现异常之后查表来实现跳转。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>08-异常处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Spring统一异常处理</title>
    <link href="/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/03-Spring%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/01-Java/01-JavaSE/08-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/03-Spring%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring统一异常处理"><a href="#Spring统一异常处理" class="headerlink" title="Spring统一异常处理"></a>Spring统一异常处理</h1><p>本代码实现了两种异常的拦截</p><ol><li>程序内抛出的异常</li><li>指向/error的异常</li></ol><ul><li>@ExceptionHandler 异常拦截</li><li>@ResponseStatus http状态码</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Environment env;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GlobalExceptionHandler</span><span class="hljs-params">(Environment env)</span> </span>&#123;        <span class="hljs-keyword">this</span>.env = env;    &#125;    <span class="hljs-meta">@ExceptionHandler(value = Exception.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">exceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = RuntimeException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">runtimeExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = Error.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">errorHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = AssertionError.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">assertionErrorHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = HttpRequestMethodNotSupportedException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">httpRequestMethodNotSupportedExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.NOT_FOUND.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = NoSuchElementException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">noSuchElementExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.NOT_FOUND.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = BindException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">bindExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.BAD_REQUEST.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">methodArgumentNotValidExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.BAD_REQUEST.value(), e);    &#125;    <span class="hljs-meta">@ExceptionHandler(value = NoHandlerFoundException.class)</span>    <span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">noHandlerFoundExceptionHandler</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.NOT_FOUND.value(), e);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 拦截/error转为标准错误</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping(value = &#123;&quot;/error&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestResponse&lt;Object&gt; <span class="hljs-title">noHandlerFoundExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getRestResponse(HttpStatus.NOT_FOUND.value(), <span class="hljs-keyword">new</span> NoHandlerFoundException(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将exception转为RestResponse</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status 状态码，建议与HTTP状态码一致</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e      Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> RestResponse&lt;Object&gt; <span class="hljs-title">getRestResponse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status, Throwable e)</span> </span>&#123;        log.error(e.getMessage(), e);        RestResponse.Builder&lt;Object&gt; restResponseBuilder = <span class="hljs-keyword">new</span> RestResponse.Builder&lt;&gt;()                .status(status)                .message(e.getMessage());        <span class="hljs-comment">// 仅在dev下返回异常信息</span>        <span class="hljs-keyword">if</span> (env.acceptsProfiles(Profiles.of(Constants.SPRING_PROFILE_DEVELOPMENT))) &#123;            <span class="hljs-comment">// 将与本工程包名相同的异常提出来</span>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">for</span> (StackTraceElement stackTraceElement : e.getStackTrace()) &#123;                <span class="hljs-keyword">if</span> (stackTraceElement.toString().startsWith(Constants.APPLICATION_PACKAGE)) &#123;                    <span class="hljs-keyword">if</span> (sb.length() != <span class="hljs-number">0</span>) &#123;                        sb.append(<span class="hljs-string">&quot; Nested exception is &quot;</span>);                    &#125;                    sb.append(stackTraceElement).append(<span class="hljs-string">&quot;;&quot;</span>);                &#125;            &#125;            String exception = sb.toString();            restResponseBuilder.exception(exception);        &#125;        <span class="hljs-keyword">return</span> restResponseBuilder.build();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>08-异常处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-安全漏洞汇总</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/00-%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/00-%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_32434307/article/details/82148546">https://blog.csdn.net/qq_32434307/article/details/82148546</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-常见扫描工具</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/00-%E5%B8%B8%E8%A7%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/00-%E5%B8%B8%E8%A7%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>Fortify SCA</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-密码明文传输</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/01-%E5%AF%86%E7%A0%81%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/01-%E5%AF%86%E7%A0%81%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="密码明文传输"><a href="#密码明文传输" class="headerlink" title="密码明文传输"></a>密码明文传输</h1><p>严重等级：⭐️⭐️⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用户可能导致信息泄漏，特别是在不安全的传输前提下（http）</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用AES对称加密，在前端使用密钥加密，传输加密的密码，然后在后端进行解密</p><h3 id="1-使用原生AES对称加密"><a href="#1-使用原生AES对称加密" class="headerlink" title="1. 使用原生AES对称加密"></a>1. 使用原生AES对称加密</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtils</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ALGORITHM = <span class="hljs-string">&quot;AES&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset CHARSET = StandardCharsets.UTF_8;    <span class="hljs-comment">// 默认的加密算法</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 加密算法</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;加密算法AES：决定了是是什么加密方式&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;加密模式CBC：&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;补码方式PKCS5Padding：若使用无补码，需要加密源是16的倍数&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Cipher&quot;&gt; Cipher章节&lt;/a&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CIPHER_ALGORITHM = <span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * encrypt</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> src    需要加密的字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    密码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 偏移量</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 加密失败</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String src, String key, String offset)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key.getBytes(CHARSET), ALGORITHM);        IvParameterSpec iv = <span class="hljs-keyword">new</span> IvParameterSpec(offset.getBytes(CHARSET));        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);        <span class="hljs-keyword">byte</span>[] encrypted = cipher.doFinal(src.getBytes(CHARSET));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BASE64Encoder().encode(encrypted);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * decrypt</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> src    需要解密的字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    密码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 偏移量</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 解密结果</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 解密失败</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String src, String key, String offset)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key.getBytes(CHARSET), ALGORITHM);        IvParameterSpec iv = <span class="hljs-keyword">new</span> IvParameterSpec(offset.getBytes(CHARSET));        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv);        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> BASE64Decoder().decodeBuffer(src);        <span class="hljs-keyword">byte</span>[] encrypted = cipher.doFinal(buffer);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(encrypted, CHARSET);    &#125;&#125;</code></pre><h3 id="2-使用Hutool工具包提供的工具类"><a href="#2-使用Hutool工具包提供的工具类" class="headerlink" title="2. 使用Hutool工具包提供的工具类"></a>2. 使用Hutool工具包提供的工具类</h3><ol><li>pom.xml</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_ALGORITHM = <span class="hljs-string">&quot;AES&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decryptAES</span><span class="hljs-params">(String data, String pass)</span> </span>&#123;    AES aes = <span class="hljs-keyword">new</span> AES(Mode.CBC, Padding.NoPadding,            <span class="hljs-keyword">new</span> SecretKeySpec(pass.getBytes(), KEY_ALGORITHM),            <span class="hljs-keyword">new</span> IvParameterSpec(pass.getBytes()));    <span class="hljs-keyword">byte</span>[] decodeByte = Base64.decode(data.getBytes(StandardCharsets.UTF_8));    <span class="hljs-keyword">byte</span>[] result = aes.decrypt(decodeByte);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result, StandardCharsets.UTF_8);&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/sunxuchu/p/5483956.html">常见各种加密算法比较</a></li><li><a href="https://www.cnblogs.com/tygtyg/p/10448781.html">JAVA的AES对称加密和解密，有偏移量</a></li><li><a href="http://www.seacha.com/tools/aes.html">在线AES加解密</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-任意文件可读</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/02-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8F%AF%E8%AF%BB/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/02-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8F%AF%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Any-File-Read-任意文件可读"><a href="#Any-File-Read-任意文件可读" class="headerlink" title="Any File Read-任意文件可读"></a>Any File Read-任意文件可读</h1><p>严重等级：⭐️⭐️⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>概述：任意文件可读会导致用户可以通过<code>../../</code>或者直接指定文件夹<code>/etc/XXX/</code>访问系统中的任意文件，导致服务器中的信息泄漏，黑客可以获取想要的任意信息</li></ul><p>攻击者常用下列路径越级访问文件</p><ul><li>../</li><li>..%2F</li><li>/%c0%ae%c0%ae/</li><li>%2e%2e%2f</li></ul><p>这种问题本身在<code>nginx``tomcat</code>等Web服务器中不该存在，对于<code>web</code>以外的目录均为不可访问状态，但这个漏洞却出现在了实际项目中。</p><p>原因是开发者常常为了实现<code>download</code>或加载静态图片资源功能，而使用了类似如下代码</p><p>python版</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GET</span>(<span class="hljs-params">self, filepath</span>):</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;./uploadfile/%s&quot;</span> % filepath, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:        content = f.read()    <span class="hljs-keyword">return</span> content</code></pre><p>Java 版</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(HttpServletResponse response, String path)</span></span>&#123;    InputStream in = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(path));    OutputStream out = response.getOutputStream();    in = <span class="hljs-keyword">new</span> FileInputStream(file);    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    out = response.getOutputStream();    <span class="hljs-keyword">while</span> ((len = in.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;        out.write(buf, <span class="hljs-number">0</span>, len);    &#125;    out.flush();&#125;</code></pre><p>直接将静态文件路径填写的资格交给用户或不可信的URL，而不加任何校验</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>【强制】检查路径的合法性</li><li>【强制】检查获得文件类型的合法性，使用白名单</li></ol><h3 id="1-使用PathMatchers实现文件路径检查"><a href="#1-使用PathMatchers实现文件路径检查" class="headerlink" title="1. 使用PathMatchers实现文件路径检查"></a>1. 使用PathMatchers实现文件路径检查</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 对文件进行规则检查</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> file        规则检查的文件</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> andMatchers 必须的规则，区分小大写，一般用户路径</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> orMatchers  存在的规则，不区分大小写，一般用于文件类型</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLegalFile</span><span class="hljs-params">(File file, String[] andMatchers, String[] orMatchers)</span> </span>&#123;    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    String absolutePath = file.getAbsolutePath();    <span class="hljs-keyword">boolean</span> andLegal = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (andMatchers != <span class="hljs-keyword">null</span> &amp;&amp; andMatchers.length != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 任意一个不满足则为false</span>        <span class="hljs-keyword">for</span> (String andMatcher : andMatchers) &#123;            <span class="hljs-keyword">if</span> (!antPathMatcher.match(andMatcher, absolutePath)) &#123;                andLegal = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">boolean</span> orLegal = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (orMatchers != <span class="hljs-keyword">null</span> &amp;&amp; orMatchers.length != <span class="hljs-number">0</span>) &#123;        orLegal = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 任意一个满足则为true</span>        <span class="hljs-keyword">for</span> (String orMatcher : orMatchers) &#123;            <span class="hljs-keyword">if</span> (antPathMatcher.match(orMatcher.toLowerCase(), absolutePath.toLowerCase())) &#123;                orLegal = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> andLegal &amp;&amp; orLegal;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.leavesongs.com/PENETRATION/arbitrary-files-read-via-static-requests.html">新型任意文件读取漏洞的研究</a></li><li><a href="https://www.iteye.com/blog/tiantianshagn-2323331">spring工具类AntPathMatcher</a></li><li><a href="../../../02-AntMatchers/">AntMatchers.md</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-任意文件可写</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/03-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8F%AF%E5%86%99/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/03-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8F%AF%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="任意文件可上传"><a href="#任意文件可上传" class="headerlink" title="任意文件可上传"></a>任意文件可上传</h1><p>严重等级：⭐️⭐️⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>概述：在支持上传的程序中，如文件/用户头像，在后端不做限制的情况下，任意文件可上传，而上传的东西正常情况下都需要给用户访问，如PDF/.png</li></ul><p>Webshell攻击，攻击者可以利用上传功能上传一个脚本文件（小马），然后在通过url访问这个脚本，脚本就被执行，从而协助上传webshell到网站后台，达到控制网站的目的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>建议在新的应用程序中创建上传的模块时，严格遵循下述规定</p><ol><li>【强制】上传路径限制不允许用户自行指定</li><li>【强制】文件类型限制，前后端双重校验，使用白名单模式（只允许规定的文件类型）</li><li>【建议】检查文件内容，检查是否二进制文件；如果要上传非二进制文件，只能为txt，且对内容进行检查</li><li>【建议】将上传的文件重命名</li><li>【建议】避免暴露上传文件的路径</li><li>【建议】限制相关目录的执行权限，防范webshell攻击（非前后端分离时，需要在Apache配置访问控制directory）参考<a href="https://blog.csdn.net/nohaoye/article/details/46987587">Apache Webshell</a></li></ol><h3 id="1-使用PathMatchers做类型和路径检查"><a href="#1-使用PathMatchers做类型和路径检查" class="headerlink" title="1. 使用PathMatchers做类型和路径检查"></a>1. 使用PathMatchers做类型和路径检查</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 对文件进行规则检查</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> file        规则检查的文件</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> andMatchers 必须的规则，区分小大写，一般用户路径</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> orMatchers  存在的规则，不区分大小写，一般用于文件类型</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLegalFile</span><span class="hljs-params">(File file, String[] andMatchers, String[] orMatchers)</span> </span>&#123;    AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    String absolutePath = file.getAbsolutePath();    <span class="hljs-keyword">boolean</span> andLegal = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (andMatchers != <span class="hljs-keyword">null</span> &amp;&amp; andMatchers.length != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 任意一个不满足则为false</span>        <span class="hljs-keyword">for</span> (String andMatcher : andMatchers) &#123;            <span class="hljs-keyword">if</span> (!antPathMatcher.match(andMatcher, absolutePath)) &#123;                andLegal = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">boolean</span> orLegal = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (orMatchers != <span class="hljs-keyword">null</span> &amp;&amp; orMatchers.length != <span class="hljs-number">0</span>) &#123;        orLegal = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 任意一个满足则为true</span>        <span class="hljs-keyword">for</span> (String orMatcher : orMatchers) &#123;            <span class="hljs-keyword">if</span> (antPathMatcher.match(orMatcher.toLowerCase(), absolutePath.toLowerCase())) &#123;                orLegal = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> andLegal &amp;&amp; orLegal;&#125;</code></pre><ol start="2"><li>限制上传文件夹的权限</li></ol><p>Apache配置如下<code>httpd.conf</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Directory</span> &quot;/<span class="hljs-attr">www</span>/<span class="hljs-attr">yourProject</span>/<span class="hljs-attr">uploads</span>&quot;&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">FilesMatch</span> &quot;<span class="hljs-attr">.</span>(?<span class="hljs-attr">i</span>)<span class="hljs-attr">php</span>&quot;&gt;</span>Order allow,denyDeny from all    <span class="hljs-tag">&lt;/<span class="hljs-name">FilesMatch</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Directory</span>&gt;</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_32434307/article/details/82148546">常规36个WEB渗透测试漏洞描述及修复方法—-很详细</a></li><li><a href="https://blog.csdn.net/nohaoye/article/details/46987587">webshell防范的一点笔记</a></li><li><a href="../../../02-AntMatchers/">AntMatchers.md</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Cors跨域攻击</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/05-Cors%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/05-Cors%E8%B7%A8%E5%9F%9F%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Cors跨域请求"><a href="#Cors跨域请求" class="headerlink" title="Cors跨域请求"></a>Cors跨域请求</h1><p>严重等级：⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>由于在开发过程中，常常需要跨域访问，程序员趋向于允许任何的跨域请求。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在生产和开发中使用不同的配置文件</p><ul><li>application.yml</li></ul><pre><code class="hljs yml"><span class="hljs-attr">cenzhongman:</span>  <span class="hljs-attr">header:</span>    <span class="hljs-attr">xss-protection:</span> <span class="hljs-string">&#x27;1; mode=block&#x27;</span>    <span class="hljs-attr">x-frame-options:</span> <span class="hljs-string">&#x27;SAMEORIGIN&#x27;</span>    <span class="hljs-attr">x-content-type-options:</span> <span class="hljs-string">&#x27;nosniff&#x27;</span>    <span class="hljs-attr">allowed-origins:</span> <span class="hljs-string">&#x27;localhost&#x27;</span>    <span class="hljs-attr">allowed-methods:</span> <span class="hljs-string">&#x27;POST, GET, PATCH, DELETE, PUT&#x27;</span>    <span class="hljs-attr">allowed-headers:</span> <span class="hljs-string">&#x27;Origin, X-Requested-With, Content-Type, Accept&#x27;</span>    <span class="hljs-attr">allow-credentials:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">max-age:</span> <span class="hljs-number">3600</span></code></pre><ul><li>application-dev.yml</li></ul><pre><code class="hljs yml"><span class="hljs-attr">cenzhongman:</span>  <span class="hljs-attr">header:</span>    <span class="hljs-attr">allowed-origins:</span> <span class="hljs-string">&#x27;*&#x27;</span></code></pre><ul><li>application-prod.yml</li></ul><pre><code class="hljs yml"><span class="hljs-attr">cenzhongman:</span>  <span class="hljs-attr">header:</span>    <span class="hljs-attr">allowed-origins:</span> <span class="hljs-string">&#x27;https://cenzhongman.com&#x27;</span></code></pre><ul><li>SimpleCorsFilter.java</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.xss-protection&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String xssProtection;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.x-frame-options&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String xFrameOptions;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.x-content-type-options&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String xContentTypeOptions;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.allowed-origins&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String allowedOrigins;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.allowed-methods&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String allowedMethods;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.allowed-headers&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String allowedHeaders;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.allow-credentials&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String allowCredentials;    <span class="hljs-meta">@Value(&quot;$&#123;cenzhongman.header.max-age&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String maxAge;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletResponse response = (HttpServletResponse) res;        <span class="hljs-comment">//开启XSS保护</span>        response.setHeader(<span class="hljs-string">&quot;X-XSS-Protection&quot;</span>, xssProtection);        <span class="hljs-comment">// 开启点击劫持防护</span>        response.setHeader(<span class="hljs-string">&quot;X-Frame-Options&quot;</span>, xFrameOptions);        response.setHeader(<span class="hljs-string">&quot;X-Content-Type-Options&quot;</span>, xContentTypeOptions);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, allowedOrigins);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, allowedMethods);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, allowedHeaders);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, allowCredentials);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, maxAge);        chain.doFilter(req, res);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000012364985?utm_source=tag-newest">springboot设置cors跨域请求的两种方式</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-日志伪造攻击</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/06-%E6%97%A5%E5%BF%97%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/06-%E6%97%A5%E5%BF%97%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="日志伪造攻击"><a href="#日志伪造攻击" class="headerlink" title="日志伪造攻击"></a>日志伪造攻击</h1><p>严重等级：⭐️⭐️⭐️</p><ul><li>中文名：日志伪造</li><li>英文名：log forging</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>概述</li></ul><p>将未经验证的用户输入写入日志文件可致使攻击者伪造日志条目或将恶意信息内容注入日志。<strong>直接将未经校验的用户输入信息被写入日志，可能导致日志被伪造</strong>，从而实现蒙骗日志查看者的行为。</p><ul><li>举例</li></ul><p>假设，我是阿里的竞争对手，我想在双十一搞一波破坏，阿里使用的是日志来分析和统计订单的，数据将会实时显示在双十一大屏幕上。</p><p>订单日志如下：</p><pre><code class="hljs log">[INFO]订单--用户:可爱的小猫咪,商品:拖鞋,数量:3,金额:200</code></pre><p>然而阿里有一段用来搜索商品的程序如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 搜索商品</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(String text)</span></span>&#123;    log.info(<span class="hljs-string">&quot;搜索--用户:可爱的小猫咪,输入:&quot;</span> + text)&#125;</code></pre><p>正常的日志，当用户输入“拖鞋”</p><pre><code class="hljs log">[INFO]搜索--用户:可爱的小猫咪,输入:拖鞋</code></pre><p>攻击者的日志，输入”拖鞋\n[INFO]订单–用户:马云,商品:大裤衩,数量:100000000,金额:200000000000”</p><pre><code class="hljs log">[INFO]搜索--用户:可爱的小猫咪,输入:拖鞋[INFO]订单--用户:马云,商品:大裤衩,数量:100000000000,金额:200000000000</code></pre><p>那么，今年的双十一的头条就是，震惊，双十一大裤衩10秒销量过千亿，购买者竟是同一个人。利用这个漏洞，你甚至可以找支付宝说你刚刚充值了10000块到余额宝，但是没有到账。</p><ul><li>危害</li></ul><p>日志伪造对于技术支持，数据收集等工作造成了毁灭性灾难，这个漏洞将导致网页日志毫无价值可言。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-方案一：遵从Fortify的建议，使用预设的日志条目，杜绝用户的输入直接在日志中打印"><a href="#1-方案一：遵从Fortify的建议，使用预设的日志条目，杜绝用户的输入直接在日志中打印" class="headerlink" title="1. 方案一：遵从Fortify的建议，使用预设的日志条目，杜绝用户的输入直接在日志中打印"></a>1. 方案一：遵从Fortify的建议，使用预设的日志条目，杜绝用户的输入直接在日志中打印</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NFE = <span class="hljs-string">&quot;Failed to parse val. The input is required to be an integer value.&quot;</span>;String val = request.getParameter(<span class="hljs-string">&quot;val&quot;</span>);<span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">int</span> value = Integer.parseInt(val);&#125; <span class="hljs-keyword">catch</span>(NumberFormatException nfe) &#123;    log.info(NFE);&#125;</code></pre><p>这种方法确实是安全了，可是，这，跟用户相关的信息基本没发展示了。。。不实用</p><h3 id="2-方案二：检查用户的输入"><a href="#2-方案二：检查用户的输入" class="headerlink" title="2. 方案二：检查用户的输入"></a>2. 方案二：检查用户的输入</h3><ol><li>黑名单，替换掉所有的可能出现的回车</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* convert Valid Log</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> log source log</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> normalize log</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">convertValidLog</span><span class="hljs-params">(String log)</span></span>&#123;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    list.add(<span class="hljs-string">&quot;%0d&quot;</span>);    list.add(<span class="hljs-string">&quot;\r&quot;</span>);    list.add(<span class="hljs-string">&quot;%0a&quot;</span>);    list.add(<span class="hljs-string">&quot;\n&quot;</span>);    String encode = Normalizer.normalize(log, Normalizer.Form.NFKC);    <span class="hljs-keyword">for</span>(String toReplaceStr : list)&#123;        encode = encode.replace(toReplaceStr, <span class="hljs-string">&quot; &quot;</span>);    &#125;    <span class="hljs-keyword">return</span> encode;&#125;</code></pre><p>限制用户输入的字符串的内容，一定不能包含回车。</p><ul><li>缺点：这种方式就要求开发者在记录用户输入内容的时候都要调用这个方法，比较容易遗漏，而且略显繁琐。</li></ul><ol start="2"><li>白名单</li></ol><p>严格限制用户的输入</p><ul><li>缺点：多，杂</li></ul><ol start="3"><li>对日志内容编码保存</li></ol><pre><code class="hljs java">encodeStr = URLEncoder.encode(userInput, <span class="hljs-string">&quot;utf-8&quot;</span>);</code></pre><ul><li>缺点：你需要将日志信息使用解码工具解码后才能知道用户到底输入的真实内容是什么。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/meInfo/p/9038496.html">Fortify漏洞之 Log Forging（日志伪造）</a><br><a href="https://www.jianshu.com/p/103f75941ee8">Fortify漏洞修复——Log Forging日志伪造</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-SQL注入攻击</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/04-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/04-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h1><p>严重等级：⭐️⭐️⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>概述：黑客通过在参数中加入SQL语句，这些SQL语句将会随着本身的SQL语句的一部分执行，导致黑客可以在数据库中为所欲为，绕过登录限制</li></ul><p>如</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> (<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;#&#123;userName&#125;&#x27;</span>) <span class="hljs-keyword">and</span> (pw = <span class="hljs-string">&#x27;#&#123;password&#125;&#x27;</span>);</code></pre><p>黑客输入</p><pre><code class="hljs sql">userName = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;password = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;</code></pre><p>实际执行的SQL语句</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> (<span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">and</span> (pw = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1&#x27;</span>);</code></pre><p>完美绕过登录，获得进入系统的权限。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>【强制】禁止使用拼凑SQL语句的方式执行任何数据库操作</li><li>【强制】在Mybatis中使用<code>#&#123;param&#125;</code>代替<code>$&#123;param&#125;</code></li><li>【建议】对用户输入的数据进行sql注入校验</li><li>【建议】不要使用原生JDBC</li><li>【建议】使用JPA操作数据库</li><li>【建议】不在响应中返回任何SQL错误信息</li></ol><h3 id="1-Hibernate中的SQL注入"><a href="#1-Hibernate中的SQL注入" class="headerlink" title="1. Hibernate中的SQL注入"></a>1. Hibernate中的SQL注入</h3><ul><li>❌错误的做法：Hibernate中可以直接执行拼凑好的SQL语句来创建查询对象，这是<strong>绝对禁止</strong>的</li></ul><pre><code class="hljs java">String sql = <span class="hljs-string">&quot;select * from t_user t where t.user_id = &#x27; &quot;</span>+ id + <span class="hljs-string">&quot; &#x27; &quot;</span>;List result = session.createQuery(sql).list();</code></pre><ul><li>✅正确的做法：使用参数绑定</li></ul><p>positional parameter</p><pre><code class="hljs java">String queryString = <span class="hljs-string">&quot;from Item item &quot;</span>                    + <span class="hljs-string">&quot;where item.description like ? &quot;</span>                    + <span class="hljs-string">&quot;and item.date &gt; ?&quot;</span>;List result = session.createQuery(queryString)            .setString(<span class="hljs-number">0</span>, searchString)            .setDate(<span class="hljs-number">1</span>, minDate)            .list();</code></pre><p>named parameter</p><pre><code class="hljs java">String queryString = <span class="hljs-string">&quot;from Item item &quot;</span>                    + <span class="hljs-string">&quot;where item.description like :searchString &quot;</span>                    + <span class="hljs-string">&quot;and item.date &gt; :minDate&quot;</span>;List result = session.createQuery(queryString)            .setString(<span class="hljs-string">&quot;searchString&quot;</span>, searchString)            .setDate(<span class="hljs-string">&quot;minDate&quot;</span>, minDate)            .list();</code></pre><h3 id="2-Mybatis中的SQL注入"><a href="#2-Mybatis中的SQL注入" class="headerlink" title="2. Mybatis中的SQL注入"></a>2. Mybatis中的SQL注入</h3><p>用#{param}替换所有的${param}</p><p>因为${}是拼接sql字符实现没有预编译的查询，因为是无法防御sql注入，而#{}则需要进行预编译，可以很大程度上防止sql注入。<br>在一些#{}使用时候会报错的地方，如like 查询、in 查询、order by排序等。</p><ol><li><p>like: </p><p> ❌错误的写法</p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">Users</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%$&#123;username&#125;%&#x27;</span></code></pre><p> ✅正确的做法</p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">Users</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-keyword">concat</span>(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-comment">#&#123;username&#125;, &#x27;%&#x27;)</span></code></pre></li><li><p>in</p><p> ❌错误的写法</p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">Users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> ($&#123;ids&#125;)</code></pre><p> ✅正确的做法</p> <pre><code class="hljs xml">select * from Users where id in<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>    #&#123;id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span></code></pre></li><li><p>order by</p><p> ❌错误的写法</p> <pre><code class="hljs sql"><span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> <span class="hljs-keyword">Users</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $&#123;<span class="hljs-keyword">order</span>&#125;</code></pre><p> ✅正确的做法:在Java层面做映射</p> <pre><code class="hljs xml">select *from Users order by <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;order != null and order == &#x27;id&#x27;&quot;</span>&gt;</span>        id    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>        user    <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span></code></pre></li></ol><h3 id="3-JDBC中的SQL注入"><a href="#3-JDBC中的SQL注入" class="headerlink" title="3. JDBC中的SQL注入"></a>3. JDBC中的SQL注入</h3><ul><li>❌错误的做法</li></ul><pre><code class="hljs java">String sql = <span class="hljs-string">&quot;select * from xxx where username=&quot;</span> + <span class="hljs-string">&quot;&#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27;&quot;</span> + <span class="hljs-string">&quot;and password=&quot;</span> + <span class="hljs-string">&quot;&#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>;ResultSet rs = st.executeQuery(sql);</code></pre><ul><li>✅正确的做法</li></ul><p>值得一提的是，Hibernate的参数绑定理论上也是使用了JDBC的预编译参数绑定实现的</p><pre><code class="hljs java">String sql=<span class="hljs-string">&quot;select * from xxx where username=? and password=?&quot;</span>;<span class="hljs-comment">//使用预编译</span>PreparedStatement ps = conn.prepareStatement(sql);ps.setString(<span class="hljs-number">1</span>, username);ps.setString(<span class="hljs-number">2</span>, password);ResultSet rs = ps.executeQuery();</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_22928269/article/details/80164657">结合Mybatis关于对SQL注入的见解</a></li><li><a href="https://blog.csdn.net/menger4java/article/details/73605058">hibernate防止sql注入的方法</a></li><li><a href="https://www.cnblogs.com/piaomiaohongchen/p/9102801.html">从Java角度修复SQL注入漏洞</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-密钥硬编码</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/08-%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/08-%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="密钥硬编码"><a href="#密钥硬编码" class="headerlink" title="密钥硬编码"></a>密钥硬编码</h1><p>严重等级：⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>概述：密码在代码中硬编码，可能导致代码泄漏导致数据库不安全。不利于修改。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>使用配置文件保存</li><li>使用加密方式对配置文件进行加密</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-X-Frame-Options Header未配置</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/09-X-Frame-Options%20Header%E6%9C%AA%E9%85%8D%E7%BD%AE/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/09-X-Frame-Options%20Header%E6%9C%AA%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="X-Frame-Options-HTTP-响应头未设置"><a href="#X-Frame-Options-HTTP-响应头未设置" class="headerlink" title="X-Frame-Options HTTP 响应头未设置"></a>X-Frame-Options HTTP 响应头未设置</h1><p>严重等级：⭐️⭐️⭐️</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>,<iframe> 或者 <object>中展现的标记。未配置X-Frame-Options的网站，可能有被点击劫持的风险（内容被嵌到别人的网站中去，并在上面加一个透明层，诱导用户点击）</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>DENY:表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 </li><li>SAMEORIGIN:表示该页面可以在相同域名页面的 frame 中展示。 </li><li>ALLOW-FROM:表示该页面可以在指定来源的 frame 中展示。 </li></ul><p>换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><h3 id="java-Servlet-Tomcat中"><a href="#java-Servlet-Tomcat中" class="headerlink" title="java/Servlet/Tomcat中"></a>java/Servlet/Tomcat中</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletResponse response = (HttpServletResponse) res;        <span class="hljs-comment">// 开启点击劫持防护</span>        response.setHeader(<span class="hljs-string">&quot;X-Frame-Options&quot;</span>, <span class="hljs-string">&quot;SAMEORIGIN&quot;</span>);        chain.doFilter(req, res);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-Null Dereference-空指针异常</title>
    <link href="/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/10-Null%20Dereference-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/"/>
    <url>/01-Java/06-Security/01-%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/10-Null%20Dereference-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Null-Dereference-空指针异常"><a href="#Null-Dereference-空指针异常" class="headerlink" title="Null Dereference-空指针异常"></a>Null Dereference-空指针异常</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当违反程序员的一个或多个假设时，通常会出现 null 指针异常。如果程序明确将对象设置为null，但稍后却间接引用该对象，则将出现 dereference-after-store 错误。此错误通常是因为程序员在声明变量时将变量初始化为 null。</p><p>　　大部分空指针问题只会引起一般的软件可靠性问题，但如果攻击者能够故意触发空指针间接引用，攻击者就有可能利用引发的异常绕过安全逻辑，或致使应用程序泄漏调试信息，这些信息对于规划随后的攻击十分有用。</p><p>如：</p><pre><code class="hljs java">String cmd = System.getProperty（“cmd”);cmd = cmd.trim（）;</code></pre><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span>(strings==<span class="hljs-keyword">null</span> &amp;&amp; string.size==<span class="hljs-number">0</span>)&#123;    strings = <span class="hljs-keyword">new</span> ArrayList();&#125;<span class="hljs-keyword">else</span>&#123;    foo.setBar(val);&#125;</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在调用之前，强制检查null的情况，可以避免发生此类状态。</p><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span>(strings==<span class="hljs-keyword">null</span> &amp;&amp; string.size==<span class="hljs-number">0</span>)&#123;    strings = <span class="hljs-keyword">new</span> ArrayList();&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">if</span>(string!=<span class="hljs-keyword">null</span>)&#123;        foo.setBar(val);    &#125;&#125;</code></pre><p>由于<code>Fortify</code>可能存在误报，因此，尽可能检查为空逻辑即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.owasp.org/index.php/Null_Dereference">Null_Dereference</a><br><a href="https://www.cnblogs.com/meInfo/p/9037784.html">Fortify漏洞之 Privacy Violation（隐私泄露）和 Null Dereference（空指针异常）</a><br><a href="http://www.itgo.me/a/x4071069662202185069/how-to-avoid-false-positive-null-dereference-error-in-fortify">关于误报</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>01-常见安全漏洞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Shiro-Reolm</title>
    <link href="/01-Java/06-Security/03-Shiro/01-Shiro-Reolm/"/>
    <url>/01-Java/06-Security/03-Shiro/01-Shiro-Reolm/</url>
    
    <content type="html"><![CDATA[<h1 id="Shiro-Reolm"><a href="#Shiro-Reolm" class="headerlink" title="Shiro-Reolm"></a>Shiro-Reolm</h1><h2 id="Shrro是什么"><a href="#Shrro是什么" class="headerlink" title="Shrro是什么"></a>Shrro是什么</h2><p>Shiro是基于Realm做为认证的，Realm相当于一个认证安全的持久层（Dao）</p><ul><li>简单Realm</li><li>INI Realm</li><li>JDBC Realm</li></ul><h2 id="简单Realm"><a href="#简单Realm" class="headerlink" title="简单Realm"></a>简单Realm</h2><pre><code class="hljs java"></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>03-Shiro</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Shiro入门</title>
    <link href="/01-Java/06-Security/03-Shiro/01-Shiro%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/06-Security/03-Shiro/01-Shiro%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Shiro是什么"><a href="#Shiro是什么" class="headerlink" title="Shiro是什么"></a>Shiro是什么</h1><p><a href="http://shiro.apache.org/">Apache-Shiro</a></p><p>Apache Shiro™是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理。</p><p>跟Spring Security比：</p><blockquote><p>Spring官方网站是用Shiro做权限验证的</p></blockquote><h2 id="Shiro能干什么"><a href="#Shiro能干什么" class="headerlink" title="Shiro能干什么"></a>Shiro能干什么</h2><ul><li>身份验证 - 登陆</li><li>授权 - 访问控制</li><li>密码学 - 数据加密</li><li>会话关联</li></ul><h2 id="Shiro的执行流程"><a href="#Shiro的执行流程" class="headerlink" title="Shiro的执行流程"></a>Shiro的执行流程</h2><p><img src="../images/01-01.png"></p><h2 id="Shiro认证"><a href="#Shiro认证" class="headerlink" title="Shiro认证"></a>Shiro认证</h2><pre><code class="hljs java"><span class="hljs-comment">// 1. 获得用户</span>Subject subject = SecurityUtils.getSubject();</code></pre><p><code>Subject</code>就是用户的意思，但是在安全领域一般叫做<code>Subject</code>;</p><pre><code class="hljs java"><span class="hljs-comment">// 2. 获得当前用户的会话信息</span>Session session = sbuject.getSession();</code></pre><p>这个会话在Web环境下是基于<code>HttpSession</code>环境的，在非Web环境下是不基于<code>HttpSession</code>的</p><pre><code class="hljs java"><span class="hljs-comment">// 3. 登陆</span><span class="hljs-comment">// 当前用户未验证</span><span class="hljs-keyword">if</span> ( !currentUser.isAuthenticated() ) &#123;    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>);    <span class="hljs-comment">// 是否记住密码（会根据会话）</span>    token.setRememberMe(<span class="hljs-keyword">true</span>);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 登陆</span>        currentUser.login( token );        <span class="hljs-comment">// 获得用户名</span>        log.info( <span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span> );        <span class="hljs-comment">// 是否拥有XX角色权限</span>        currentUser.hasRole( <span class="hljs-string">&quot;schwartz&quot;</span> );        <span class="hljs-comment">// 是否拥有XX功能权限</span>        currentUser.isPermitted( <span class="hljs-string">&quot;lightsaber:weild&quot;</span> );        <span class="hljs-comment">// 是否拥有XX级别的权限</span>        currentUser.isPermitted( <span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span> );        <span class="hljs-comment">// 登出</span>        currentUser.logout();        <span class="hljs-comment">//if no exception, that&#x27;s it, we&#x27;re done!</span>    &#125; <span class="hljs-keyword">catch</span> ( UnknownAccountException uae ) &#123;        <span class="hljs-comment">// 用户名不存在</span>    &#125; <span class="hljs-keyword">catch</span> ( IncorrectCredentialsException ice ) &#123;        <span class="hljs-comment">// 密码错误</span>    &#125; <span class="hljs-keyword">catch</span> ( LockedAccountException lae ) &#123;        <span class="hljs-comment">// 账号受限，无法登陆</span>    &#125; <span class="hljs-keyword">catch</span> ( AuthenticationException ae ) &#123;        <span class="hljs-comment">// 未知异常</span>    &#125;&#125;</code></pre><p>当用户登出之后，所有的权限都是不具有的，而Shiro是基于Realm做为认证的，Realm相当于一个认证安全的持久层（Dao）</p><ul><li>简单Realm</li><li>INI Realm</li><li>JDBC Realm</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 简单的Realm</span>SimpleAccountRealm simpleAccountRealm = <span class="hljs-keyword">new</span> SimpleAccountRealm();simpleAccountRealm.addAccount(<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);</code></pre><h2 id="Shiro授权"><a href="#Shiro授权" class="headerlink" title="Shiro授权"></a>Shiro授权</h2><p><img src="../images/01-02.png"></p><pre><code class="hljs java"><span class="hljs-comment">// 创建具有权限的用户</span>accountRealm.addAccount(<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<span class="hljs-comment">// 是否拥有XX角色权限</span>subject.hasRole( <span class="hljs-string">&quot;admin&quot;</span> );</code></pre><p>允许多角色</p><pre><code class="hljs java">accountRealm.addAccount(<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;user&quot;</span>);subject.hasRoles(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;user&quot;</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>06-Security</category>
      
      <category>03-Shiro</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-FreeMaker模板入门</title>
    <link href="/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/01-FreeMaker%E6%A8%A1%E6%9D%BF%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/01-FreeMaker%E6%A8%A1%E6%9D%BF%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeMaker"><a href="#FreeMaker" class="headerlink" title="FreeMaker"></a>FreeMaker</h1><h2 id="Freenaker是什么"><a href="#Freenaker是什么" class="headerlink" title="Freenaker是什么"></a>Freenaker是什么</h2><p><a href="https://freemarker.apache.org/">FreeMakers</a>是Apache开源项目，是一种模板引擎：基于模板不断变化的数据生成文本输出的Java库。<strong>Template + data-model = output</strong></p><p>举个例子：</p><p><img src="../images/01-01Freemaker%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="Freemaker工作原理"></p><h2 id="下载-安装"><a href="#下载-安装" class="headerlink" title="下载/安装"></a>下载/安装</h2><p>下载请参考官网</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker-gae<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="一、制作模板"><a href="#一、制作模板" class="headerlink" title="一、制作模板"></a>一、制作模板</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Our latest product:  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;latestProduct.url&#125;&quot;</span>&gt;</span>$&#123;latestProduct.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>!  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;nameList[2]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>对于map/JavaBean可以直接使用<code>user.name</code>这种查询方式，对于list可以使用<code>list[5]</code></p><p>值可以是<strong>string or a number or a date-time/date/time or a boolean</strong></p><h3 id="2-FTL标签"><a href="#2-FTL标签" class="headerlink" title="2.FTL标签"></a>2.FTL标签</h3><ul><li>系统自带的FTL标签，以<code>&lt;#</code>开头</li><li>用户自定义的FTL标签，以<code>&lt;@</code>开头</li></ul><h3 id="3-常用标签"><a href="#3-常用标签" class="headerlink" title="3.常用标签"></a>3.常用标签</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- if --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">user.name</span>==<span class="hljs-string">&quot;CZM&quot;</span>&gt;</span>    你是CZM<span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">user.name</span>==<span class="hljs-string">&quot;CYX&quot;</span>&gt;</span>    你是CYX<span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>    你不是人<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span><span class="hljs-comment">&lt;!-- list: 这样将会输出 animals的长度的行数 的文本 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">animals</span> <span class="hljs-attr">as</span> <span class="hljs-attr">animal</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;animal.name&#125;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;animal.price&#125; Euros<span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-comment">&lt;!-- sep分隔符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">misc.fruits</span> <span class="hljs-attr">as</span> <span class="hljs-attr">fruit</span>&gt;</span>$&#123;fruit&#125;<span class="hljs-tag">&lt;<span class="hljs-name">#sep</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>None <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-comment">&lt;!-- 另一种写法 --&gt;</span>$&#123;fruits?join(&quot;, &quot;, &quot;None&quot;)&#125;<span class="hljs-comment">&lt;!-- include标签 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#include</span> &quot;/<span class="hljs-attr">copyright_footer.html</span>&quot;&gt;</span></code></pre><p>这个<code>值</code>允许是Boolean</p><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">#--</span> 注释的内容 <span class="hljs-attr">--</span>&gt;</span></code></pre><p>这个注释是不会出现在源码中的</p><h3 id="4-关于变量缺失"><a href="#4-关于变量缺失" class="headerlink" title="4.关于变量缺失"></a>4.关于变量缺失</h3><p>在freeMaker中，变量是不能缺失的，也不允许为null</p><ul><li>我们可以为变量设置初始值<code>&lt;h1&gt;Welcome $&#123;user!&quot;访客&quot;&#125;!&lt;/h1&gt;</code></li><li>也可以添加判断条件再使用<code>&lt;#if user??&gt;&lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt;&lt;/#if&gt;</code></li></ul><h3 id="在线模板测试"><a href="#在线模板测试" class="headerlink" title="在线模板测试"></a>在线模板测试</h3><p><a href="http://try.freemarker.org/">http://try.freemarker.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>10-模版引擎</category>
      
      <category>01-FreeMaker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-FreeMaker编程入门</title>
    <link href="/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/02-FreeMaker%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/02-FreeMaker%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeMaker编程入门"><a href="#FreeMaker编程入门" class="headerlink" title="FreeMaker编程入门"></a>FreeMaker编程入门</h1><p><a href="http://freemarker.foofun.cn/pgui_quickstart.html">中文文档</a><br><a href="https://freemarker.apache.org/">英文官网</a>我用的时候是坏的</p><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker-gae<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h3 id="2-1添加模板文件"><a href="#2-1添加模板文件" class="headerlink" title="2.1添加模板文件"></a>2.1添加模板文件</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-cn&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您好$&#123;name&#125;，现在在测试FreeMarker功能<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2-2输出Html文件"><a href="#2-2输出Html文件" class="headerlink" title="2.2输出Html文件"></a>2.2输出Html文件</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> freemarker.template.Configuration;<span class="hljs-keyword">import</span> freemarker.template.Template;<span class="hljs-keyword">import</span> freemarker.template.TemplateException;<span class="hljs-keyword">import</span> freemarker.template.TemplateExceptionHandler;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileWriter;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.Writer;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">// 1. 配置信息</span>        <span class="hljs-comment">//创建配置对象</span>        Configuration cfg = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_28);        <span class="hljs-comment">//设置模板文件的路径</span>        cfg.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\34566\\OneDrive\\project\\java\\cenzhongman\\freemarker\\freemarkerDemo\\src\\main\\resources\\freemarker&quot;</span>));        cfg.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);        <span class="hljs-comment">// Sets how errors will appear.</span>        <span class="hljs-comment">// During web page *development* TemplateExceptionHandler.HTML_DEBUG_HANDLER is better.</span>        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);        <span class="hljs-comment">// 2. 获取模板</span>        Template template = cfg.getTemplate(<span class="hljs-string">&quot;freemarker.ftl&quot;</span>);        <span class="hljs-comment">// 3. 设置数据</span>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;CZM&quot;</span>);        <span class="hljs-comment">// 4. 输出Html</span>        Writer out = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;hello.html&quot;</span>));        <span class="hljs-keyword">try</span> &#123;            template.process(map,out);        &#125; <span class="hljs-keyword">catch</span> (TemplateException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>注意这个<code>Configuration</code>是单例模式的，比如， 通过final或volatile字段来声明实例</p><h2 id="3-其他数据模型"><a href="#3-其他数据模型" class="headerlink" title="3.其他数据模型"></a>3.其他数据模型</h2><p>支持Java自带的数据类型</p><pre><code class="hljs java"><span class="hljs-comment">// Create the root hash</span>Map&lt;String, Object&gt; root = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">// Put string ``user&#x27;&#x27; into the root</span>root.put(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;Big Joe&quot;</span>);<span class="hljs-comment">// Create the hash for ``latestProduct&#x27;&#x27;</span>Map&lt;String, Object&gt; latest = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">// and put it into the root</span>root.put(<span class="hljs-string">&quot;latestProduct&quot;</span>, latest);<span class="hljs-comment">// put ``url&#x27;&#x27; and ``name&#x27;&#x27; into latest</span>latest.put(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;products/greenmouse.html&quot;</span>);latest.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;green mouse&quot;</span>);</code></pre><p>支持javaBean</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// As per the JavaBeans spec., this defines the &quot;url&quot; bean property</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUrl</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> url;    &#125;        <span class="hljs-comment">// As per the JavaBean spec., this defines the &quot;name&quot; bean property</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>10-模版引擎</category>
      
      <category>01-FreeMaker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Freemarker+SpringBoot版本</title>
    <link href="/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/03-Freemarker+SpringBoot%E7%89%88%E6%9C%AC/"/>
    <url>/01-Java/10-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/01-FreeMaker/03-Freemarker+SpringBoot%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Freemarker集成版本"><a href="#SpringBoot-Freemarker集成版本" class="headerlink" title="SpringBoot + Freemarker集成版本"></a>SpringBoot + Freemarker集成版本</h1><h2 id="1依赖"><a href="#1依赖" class="headerlink" title="1依赖"></a>1依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h3 id="2-1通过配置文件配置属性"><a href="#2-1通过配置文件配置属性" class="headerlink" title="2.1通过配置文件配置属性"></a>2.1通过配置文件配置属性</h3><pre><code class="hljs properties"><span class="hljs-comment">#设定ftl文件路径(此项设置无效？还是说这个文件都无效，有待考究)</span><span class="hljs-comment">#spring.freemarker.template-loader-path=classpath:/freemarker</span><span class="hljs-comment"># 关闭缓存, 即时刷新, 上线生产环境需要改为true</span><span class="hljs-meta">spring.freemarker.cache</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.freemarker.charset</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.freemarker.check-template-location</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.content-type</span>=<span class="hljs-string">text/html</span><span class="hljs-meta">spring.freemarker.expose-request-attributes</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.expose-session-attributes</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.freemarker.request-context-attribute</span>=<span class="hljs-string">request</span><span class="hljs-meta">spring.freemarker.suffix</span>=<span class="hljs-string">.ftl</span></code></pre><h3 id="2-2添加模板文件"><a href="#2-2添加模板文件" class="headerlink" title="2.2添加模板文件"></a>2.2添加模板文件</h3><p>/resources/templates/index.ftl</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-cn&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您好$&#123;name&#125;，现在在测试FreeMarker功能<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2-3Controller"><a href="#2-3Controller" class="headerlink" title="2.3Controller"></a>2.3Controller</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.ui.ModelMap;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(ModelMap map)</span></span>&#123;        map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;CZM&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;        <span class="hljs-comment">// 此处无需写.ftl结尾，写了会错</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>10-模版引擎</category>
      
      <category>01-FreeMaker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-ElasticSearch-聚合</title>
    <link href="/08-Elasticsearch/06-ElasticSearch-%E8%81%9A%E5%90%88/"/>
    <url>/08-Elasticsearch/06-ElasticSearch-%E8%81%9A%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><h2 id="聚合操作-–-terms-avg-range"><a href="#聚合操作-–-terms-avg-range" class="headerlink" title="聚合操作 – terms/avg/range"></a>聚合操作 – terms/avg/range</h2><ul><li>size=0表示不进行查询，只聚合<br>GET /index_name/_search<br>{<br>“size”: 0,<br>“aggs”: {<br>  “chairman_count”: {<pre><code>&quot;terms&quot;: &#123;&quot;field&quot;:&quot;chairman.keyword&quot;&#125;</code></pre>  }<br>}<br>}</li></ul><h2 id="搜索嵌套聚合"><a href="#搜索嵌套聚合" class="headerlink" title="搜索嵌套聚合"></a>搜索嵌套聚合</h2><p>GET /index_name/_search<br>{<br>  “size”: 0,<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  },<br>  “aggs”: {<br>    “chairman_count”: {<br>      “terms”: {“field”:”chairman.keyword”}<br>    }<br>  }<br>}</p><h2 id="terms嵌套avg"><a href="#terms嵌套avg" class="headerlink" title="terms嵌套avg"></a>terms嵌套avg</h2><p>GET /index_name/_search<br>{<br>  “aggs”: {<br>    “group_by_field”: {<br>      “terms”: {<br>        “field”: “”,<br>        “size”: 10<br>      },<br>      “aggs”: {<br>        “avg_by_field”: {<br>          “avg”: {<br>            “field”: “”<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><h2 id="range嵌套avg"><a href="#range嵌套avg" class="headerlink" title="range嵌套avg"></a>range嵌套avg</h2><p>GET /index_name/_search<br>{<br>  “size”: 0,<br>  “aggs”: {<br>    “group_by_field”: {<br>      “range”: {<br>        “field”: “FIELD”,<br>        “ranges”: [<br>          {<br>            “from”: 50,<br>            “to”: 100<br>          }<br>        ]<br>      },<br>      “aggs”: {<br>        “group_by_field”: {<br>          “avg”: {<br>            “field”: “FIELD”<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23-Reindex</title>
    <link href="/08-Elasticsearch/23-Reindex/"/>
    <url>/08-Elasticsearch/23-Reindex/</url>
    
    <content type="html"><![CDATA[<h1 id="reindex"><a href="#reindex" class="headerlink" title="reindex"></a>reindex</h1><h2 id="最简单的reindex"><a href="#最简单的reindex" class="headerlink" title="最简单的reindex"></a>最简单的reindex</h2><pre><code class="hljs json">POST _reindex&#123;  <span class="hljs-attr">&quot;source&quot;</span>: &#123;    <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;company_index_v2&quot;</span>  &#125;,  <span class="hljs-attr">&quot;dest&quot;</span>: &#123;    <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;company_index_v3&quot;</span>  &#125;&#125;</code></pre><p>若出现超时</p><pre><code class="hljs shell">POST _reindex?wait_for_completion=false</code></pre><h2 id="远程reindex"><a href="#远程reindex" class="headerlink" title="远程reindex"></a>远程reindex</h2><p>[reindex-from-remote](<a href="https://www.el/">https://www.el</a>      astic.co/guide/en/elasticsearch/reference/master/docs-reindex.html#reindex-from-remote)</p><h2 id="不停机reindex"><a href="#不停机reindex" class="headerlink" title="不停机reindex"></a>不停机reindex</h2><p>使用alias实现不停机部署，Java client访问的永远是一个别名</p><ol><li><p>reindex</p><pre><code class="hljs json">POST _reindex?wait_for_completion=false&#123;  <span class="hljs-attr">&quot;source&quot;</span>: &#123;    <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;company_index_v1&quot;</span>  &#125;,  <span class="hljs-attr">&quot;dest&quot;</span>: &#123;    <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;company_index_v4&quot;</span>  &#125;,  <span class="hljs-attr">&quot;script&quot;</span>: &#123;    <span class="hljs-attr">&quot;lang&quot;</span>: <span class="hljs-string">&quot;painless&quot;</span>,    <span class="hljs-attr">&quot;inline&quot;</span>: <span class="hljs-string">&quot;ctx._source.remove(&#x27;ipcDomains&#x27;)&quot;</span>  &#125;&#125;</code></pre></li><li><p>替换别名</p><pre><code class="hljs json">POST _aliases&#123;  <span class="hljs-attr">&quot;actions&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;remove&quot;</span>: &#123;        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;index_name_v1&quot;</span>,        <span class="hljs-attr">&quot;alias&quot;</span>: <span class="hljs-string">&quot;index_name&quot;</span>      &#125;,      <span class="hljs-attr">&quot;add&quot;</span>: &#123;        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;index_name_v2&quot;</span>,        <span class="hljs-attr">&quot;alias&quot;</span>: <span class="hljs-string">&quot;index_name&quot;</span>      &#125;    &#125;  ]&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24-scroll-遍历数据</title>
    <link href="/08-Elasticsearch/24-scroll-%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE/"/>
    <url>/08-Elasticsearch/24-scroll-%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="使用scroll遍历数据"><a href="#使用scroll遍历数据" class="headerlink" title="使用scroll遍历数据"></a>使用scroll遍历数据</h1><p>第一次调用</p><pre><code class="hljs json">GET /company_index_v1/_search?scroll=10m&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;  &#125;,  <span class="hljs-attr">&quot;sort&quot;</span>: [<span class="hljs-string">&quot;_doc&quot;</span>],  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">100</span>&#125;</code></pre><p>接下来调用</p><pre><code class="hljs json">GET /_search/scroll&#123;  <span class="hljs-attr">&quot;scroll&quot;</span>:<span class="hljs-string">&quot;1m&quot;</span>,  <span class="hljs-attr">&quot;scroll_id&quot;</span>:<span class="hljs-string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAxbiMFkJmQUl6bkczU21pWExEQnQ3QlluQncAAAAAAQC2CRZoM0pYYlNLc1JkMllWV1BUalZUWVhRAAAAAAEAtggWaDNKWGJTS3NSZDJZVldQVGpWVFlYUQAAAAAAxAiDFlNiX2dTX0xfUjQ2dnNIMGFIdy04QmcAAAAAAMW4jRZCZkFJem5HM1NtaVhMREJ0N0JZbkJ3&quot;</span>&#125;</code></pre><p>Java代码</p><pre><code class="hljs java"><span class="hljs-comment">// 初始化有效期</span><span class="hljs-keyword">final</span> Scroll scroll = <span class="hljs-keyword">new</span> Scroll(TimeValue.timeValueMinutes(<span class="hljs-number">1L</span>));<span class="hljs-keyword">if</span> (StringUtil.isEmpty(scrollId)) &#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(index);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    searchSourceBuilder.query(QueryBuilders.matchAllQuery())            .size(size);    searchRequest.source(searchSourceBuilder);    searchRequest.scroll(scroll);    searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);    scrollId = searchResponse.getScrollId();&#125; <span class="hljs-keyword">else</span> &#123;    SearchScrollRequest scrollRequest = <span class="hljs-keyword">new</span> SearchScrollRequest(scrollId);    scrollRequest.scroll(scroll);    searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT);&#125;</code></pre><h2 id="有效时间"><a href="#有效时间" class="headerlink" title="有效时间"></a>有效时间</h2><p>在<code>RESTApi</code>中<code>&quot;scroll&quot;:&quot;1m&quot;</code>表示这个ID保持1分钟的有效期，过了有效期就无效了。</p><p>在java代码中</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-单例模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>需求：保证一个类只有一个实例，并提供一个全局访问</li><li>一般实现：<ol><li>每次创建一个对象，</li></ol></li><li>单例模式思想：<ol><li>私有化静态对象</li><li>私有化构造器</li><li>提供公共静态方法返回静态对象</li></ol></li><li>理念：对象由类创建，私有化构造器，不允许外部创建对象</li><li>具体实现：</li></ul><h2 id="饿汉模式-SingletonHungry-java最简单，且线程安全-推荐使用"><a href="#饿汉模式-SingletonHungry-java最简单，且线程安全-推荐使用" class="headerlink" title="饿汉模式 SingletonHungry.java最简单，且线程安全 推荐使用"></a>饿汉模式 <code>SingletonHungry.java</code>最简单，且线程安全 推荐使用</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 饿汉单例模式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHungry</span> </span>&#123;    <span class="hljs-comment">// 1. 私有化静态对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonHungry singletonHungry = <span class="hljs-keyword">new</span> SingletonHungry();    <span class="hljs-comment">// 2. 私有化构造器</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonHungry</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 3. 提供公共静态方法返回静态对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonHungry <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> singletonHungry;    &#125;&#125;</code></pre><h2 id="懒汉模式SingletonLazy-java-线程不安全"><a href="#懒汉模式SingletonLazy-java-线程不安全" class="headerlink" title="懒汉模式SingletonLazy.java 线程不安全"></a>懒汉模式<code>SingletonLazy.java</code> 线程不安全</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 懒汉单例模式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonLazy</span> </span>&#123;    <span class="hljs-comment">// 1. 私有化静态对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 2. 私有化构造器</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonLazy</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 3. 提供公共静态方法返回静态对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SingletonLazy();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre><h2 id="双重检查锁单例模式-线程安全"><a href="#双重检查锁单例模式-线程安全" class="headerlink" title="双重检查锁单例模式 线程安全"></a>双重检查锁单例模式 线程安全</h2><p>由于懒汉模式线程不安全 需要使用<code>synchronized</code>关键字来保证线程安全</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;        instance = <span class="hljs-keyword">new</span> LazySingletonDemo();    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre><p>但这样的加锁范围太大, 线程会阻塞在判断<code>instance</code>是否存在之前，降低了效率</p><pre><code class="hljs java"><span class="hljs-comment">// 1.声明对象(饿汉),使用volatile 该资源不会被本地线程缓存，资源直接共享内存，保证了多个线程能正确处理该资源</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonLazy instance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 2.提供获取方法并实例化，使用判断是否单例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//多个线程有可能同时进入这个位置，如果线程存在，以后都不会执行同步代码块了</span>        <span class="hljs-keyword">synchronized</span> (LazySingletonDemo.class) &#123;//由于该方法是静态方法，同步锁是 类.class            <span class="hljs-comment">//因此需要再次判断 因为假设有n个线程同时开启，那么就会都在锁定池等抢占锁，一个抢到了new instance()，其他的下次抢到锁 还会来到这个位置 因此变量instance需要使用volatile修饰</span>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                instance = <span class="hljs-keyword">new</span> LazySingletonDemo();            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre><h2 id="源码中的单例模式"><a href="#源码中的单例模式" class="headerlink" title="源码中的单例模式"></a>源码中的单例模式</h2><pre><code class="hljs java">Runtime runtime = Runtime.getRuntime();</code></pre><ul><li><p>优点：</p><ol><li>在内存里只有一个实例，减少了内存的开销、</li><li>避免对资源的多重占用</li></ol></li><li><p>缺点：</p><ol><li>没有接口，不能继承</li></ol></li><li><p>使用场景：任何需要生成<strong>唯一</strong>对象的地方</p><ol><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li><li>一个公司只能有一个CEO，不能随便new</li></ol></li></ul><p>⚠️提示：单例模式在反射情况下还是有可能不安全。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-工厂模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><ul><li>基本概念：为创建对象提供过度接口，一边将创建对象的具体过程屏蔽起来，达到灵活高效的目的，也就是说这个对象是工厂生产的，不是自己new出来的</li></ul><ol><li>简单工厂模式<code>Simple Factory</code>:不利于产生系列产品,又叫静态工厂方法模式</li><li>工厂方法模式<code>Factory Method</code>:又称为多形式工厂</li><li>抽象工厂模式<code>Abstract Factory</code>:又成为工具箱，产生产品族，但不利于产生新的产品</li></ol><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>说人话：这是一个汽车工厂类，我们需要生产一辆卡车，由汽车类去实现可移动等这些功能的抽象类，然后实例化汽车类</p><ul><li>基本概念：在一个类中定义一个用于创建对象的静态方法，这个对象是不唯一的，也就是非单例的</li><li>组成：<ol><li>工厂类角色：本模式的核心，一个非抽象类，用于控制对象的实例化；</li><li>抽象产品角色：具体产品需要实现的抽象类/接口；</li><li>具体产品角色：具体类，用于实例化对象的类。</li></ol></li></ul><p>范例:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SUV</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-meta">@Overried</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;会移动的SUV&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">getInstance</span><span class="hljs-params">(CarType type)</span></span>&#123;        Car car;        <span class="hljs-keyword">switch</span>(type)&#123;            <span class="hljs-keyword">case</span> CarType.SUV:                car = <span class="hljs-keyword">new</span> Suv();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:        &#125;        <span class="hljs-keyword">return</span> car;    &#125;&#125;<span class="hljs-comment">// 工厂类角色</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span></span>&#123; <span class="hljs-comment">//getClass 产生Sample 一般可使用动态类装载装入类。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sample <span class="hljs-title">creator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> which)</span></span>&#123;        <span class="hljs-keyword">if</span> (which==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SampleA();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (which==<span class="hljs-number">2</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SampleB();    &#125;&#125;</code></pre><p>目前比较流行的规范是把静态工厂方法命名为<code>valueOf</code>或者<code>getInstance</code>，如：</p><pre><code class="hljs java">Integer a=Integer.valueOf(<span class="hljs-number">100</span>); <span class="hljs-comment">//返回取值为100的Integer对象</span>Calendar cal=Calendar.getInstance(Locale.CHINA); <span class="hljs-comment">//返回符合中国标准的日历</span></code></pre><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>说人话：这个一个抽象工厂类，我们要先继承/实现这个抽象工厂，才能拥有一个普通的工厂类，之后的事情就跟普通的一样了。</p><ul><li>基本概念：在简单工厂模式的基础上，工厂类再次被抽象，工厂类变成了一个抽象工厂类和其实现类组成。</li><li>组成：<ol><li>抽象工厂角色：这是工厂方法模式的核心，是具体工厂角色必须实现的接口/抽象类。</li><li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。</li><li>抽象产品角色：具体产品需要实现的抽象类/接口。</li><li>具体产品角色：具体类，用于实例化对象的类。</li></ol></li></ul><pre><code class="hljs java"><span class="hljs-comment">//抽象产品角色</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Moveable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体产品角色</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Moveable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;plane....&quot;</span>);    &#125;&#125;<span class="hljs-comment">//具体产品角色</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Broom</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Moveable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;broom.....&quot;</span>);    &#125;&#125;<span class="hljs-comment">//抽象工厂</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Moveable <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体工厂</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlaneFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VehicleFactory</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Moveable <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plane();    &#125;&#125;<span class="hljs-comment">//具体工厂</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BroomFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VehicleFactory</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Moveable <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Broom();    &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        VehicleFactory factory = <span class="hljs-keyword">new</span> BroomFactory();        Moveable m = factory.create();        m.run();    &#125;&#125;</code></pre><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>说人话：这个时候的抽象工厂就不是上一个中的抽象工厂了，这里的抽象工厂是用来定义抽象产品线的，也就是说，这是一个万能的工厂，不仅能够生产车，还能生产食物和枪支弹药。</p><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Weapon <span class="hljs-title">createWeapon</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Food <span class="hljs-title">createFood</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Food <span class="hljs-title">createFood</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Weapon <span class="hljs-title">createWeapon</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AK47();    &#125;&#125;<span class="hljs-comment">//测试类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AbstractFactory f = <span class="hljs-keyword">new</span> DefaultFactory();        Vehicle v = f.createVehicle();        v.run();        Weapon w = f.createWeapon();        w.shoot();        Food a = f.createFood();        a.printName();    &#125;&#125;</code></pre><blockquote><p>总结：<br>简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。<br>工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。<br>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。</p></blockquote><ul><li>优点：增加一种产品变得简单了，比如一套QQ皮肤，一个电脑</li></ul><p><img src="../images/03-01.png"></p><p>============================丑的分割线=============================</p><h1 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul><li>需求：构建一个 <strong>动物</strong> 对象，动物都会 <strong>唱歌</strong> ，每种动物的歌声都不同</li><li>一般实现：<ol><li>创建 <strong>Animal</strong> 接口，定义 <strong>sing()</strong> 方法；</li><li>创建 <strong>Cat，Dog…</strong> 类，实现<strong>Animal</strong>接口；</li><li>每次需要时通过<code>new Cat()</code>实现</li></ol></li><li>工厂模式思想：<ol><li>创建 <strong>Animal</strong> 接口，定义 <strong>sing()</strong> 方法；</li><li>创建 <strong>Cat，Dog…</strong> 类，实现<strong>Animal</strong>接口；</li><li>创建一个工厂，生成基于给定信息的实体类的对象；</li><li>每次使用时通过给行信息去获取对象</li></ol></li><li>理念：将创建对象的具体过程屏蔽起来，达到灵活高效的目的，也就是说这个对象是工厂生产的，不是自己new出来的</li><li>具体实现：</li></ul><p><code>Animal.java</code></p><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 **Animal** 接口，定义 **sing()** 方法；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>Cat.java</code></p><pre><code class="hljs java"><span class="hljs-comment">// 2. 创建 **Cat，Dog...** 类，实现**Animal**接口；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;喵喵喵！&quot;</span>);    &#125;&#125;</code></pre><p><code>Dog.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;汪汪汪&quot;</span>);    &#125;&#125;</code></pre><p><code>AnimalFactory.java</code></p><pre><code class="hljs java"><span class="hljs-comment">// 3. 创建一个工厂，生成基于给定信息的实体类的对象；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimalFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Animal <span class="hljs-title">getAnimal</span><span class="hljs-params">(String animalType)</span> </span>&#123;        <span class="hljs-keyword">if</span> (animalType == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (animalType.equals(<span class="hljs-string">&quot;CAT&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cat();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (animalType.equals(<span class="hljs-string">&quot;DOG&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p><code>Test.java</code></p><pre><code class="hljs java"><span class="hljs-comment">// 4. 每次使用时通过给行信息去获取对象</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 工厂模式实现</span>        Animal animal = <span class="hljs-keyword">new</span> AnimalFactory().getAnimal(<span class="hljs-string">&quot;CAT&quot;</span>);        animal.sing();        <span class="hljs-comment">// 正常实现</span>        Animal animal1 = <span class="hljs-keyword">new</span> Cat();        animal1.sing();        <span class="hljs-comment">// 源码中的工厂模式，一般使用valueOf/getInstance方法</span>        Integer a=Integer.valueOf(<span class="hljs-string">&quot;100&quot;</span>); <span class="hljs-comment">//返回取值为100的Integer对象</span>        Calendar cal=Calendar.getInstance(Locale.CHINA); <span class="hljs-comment">//返回符合中国标准的日历</span>    &#125;&#125;</code></pre><ul><li><p>优点：</p><ol><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ol></li><li><p>缺点：</p><ol><li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度。</li><li>同时也增加了系统具体类的依赖。</li></ol></li><li><p>使用场景：任何需要生成<strong>复杂</strong>对象的地方</p><ol><li>日志数据存储，可能在磁盘，数据库，服务器等</li><li>数据库连接，提供数据库类型和连接配置即可</li><li>网络请求，”POP3”、”IMAP”、”HTTP”封装起来</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-建造者模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><ul><li>需求：创建一个复杂对象，如<strong>汽车</strong></li><li>一般实现：<ol><li>创建简单类，轮子，座椅，发动机</li><li>创建汽车类，封装简单类</li></ol></li><li>建造者模式思想：<ol><li>创建汽车类</li><li>创建（一个）汽车Builder接口，声明构建方法</li><li>创建（多个）汽车Builder接口的实现类，实现构建方法</li><li>创建（一个）汽车Director类，组装构造器接收Builder实现类的对象，组装方法build(),返回汽车对象</li></ol></li><li>理念：构建复杂的对象时，生产和组装分开来</li><li>具体实现：</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建汽车类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;String&gt; parts = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPart</span><span class="hljs-params">(String part)</span></span>&#123;        parts.add(part);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder rst = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (String part : parts) &#123;            rst.append(part).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> rst.toString();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 2. 创建（一个）汽车Builder接口，声明构建方法</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarBuilder</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 3. 创建（多个）汽车Builder接口的实现类，实现构建方法</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 第A汽车生产线</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarBuilderImplA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarBuilder</span> </span>&#123;    <span class="hljs-keyword">private</span> Car car = <span class="hljs-keyword">new</span> Car();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span> </span>&#123;        car.addPart(<span class="hljs-string">&quot;partA&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span> </span>&#123;        car.addPart(<span class="hljs-string">&quot;partB&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span> </span>&#123;        car.addPart(<span class="hljs-string">&quot;partC&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.car;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 4. 创建（一个）汽车Director类，组装构造器接收Builder实现类的对象，组装方法build(),返回汽车对象</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarDirector</span> </span>&#123;    <span class="hljs-keyword">private</span> CarBuilder builder = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CarDirector</span><span class="hljs-params">(CarBuilder builder)</span> </span>&#123;        <span class="hljs-keyword">this</span>.builder = builder;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        <span class="hljs-keyword">return</span> builder.getCar();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 构建者模式</span>        CarBuilder carBuilder = <span class="hljs-keyword">new</span> CarBuilderImplA();        carBuilder.buildPartC();        CarDirector director = <span class="hljs-keyword">new</span> CarDirector(carBuilder);        Car car = director.build();        System.out.println(car);        <span class="hljs-comment">// 源码中的实现</span>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        stringBuilder.append(<span class="hljs-number">123</span>);        System.out.println(stringBuilder);    &#125;&#125;</code></pre><ul><li>优点：<ol><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ol></li><li>缺点：<ol><li>产品必须有共同点，范围有限制。</li><li>如内部变化复杂，会有很多的建造类。</li></ol></li><li>使用场景：<ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li></ol></li><li>注意事项：与工厂模式的区别：建造者模式更加关注与零件装配的顺序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-过滤器模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h1><ul><li>需求：有一群人，我们要将他们用技术手段区分出来</li><li>一般实现：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">if</span>(p1.getSex().equal(<span class="hljs-string">&quot;Man&quot;</span>))&#123;    namList.add(p1);&#125;</code></pre><ul><li>过滤器模式思想：<ol><li>创建 People 类</li><li>创建 Criteria 接口</li><li>创建 Criteria 接口实现类CriteriaMale，接受List<Person>，返回过滤后的List<Person></li><li>通过CriteriaMale实现过滤</li></ol></li><li>具体实现：</li></ul><p><code>Person.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> String maritalStatus;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, String gender, String maritalStatus)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.gender = gender;        <span class="hljs-keyword">this</span>.maritalStatus = maritalStatus;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> gender;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMaritalStatus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> maritalStatus;    &#125;&#125;</code></pre><p><code>Criteria.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Criteria</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span></span>;&#125;</code></pre><p><code>CriteriaMale.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CriteriaMale</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Criteria</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">meetCriteria</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> </span>&#123;        List&lt;Person&gt; malePersons = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();        <span class="hljs-keyword">for</span> (Person person : persons) &#123;            <span class="hljs-keyword">if</span> (person.getGender().equalsIgnoreCase(<span class="hljs-string">&quot;MALE&quot;</span>)) &#123;                malePersons.add(person);            &#125;        &#125;        <span class="hljs-keyword">return</span> malePersons;    &#125;&#125;</code></pre><p><code>Test.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Person&gt; persons = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();        persons.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Robert&quot;</span>, <span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));        persons.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Laura&quot;</span>, <span class="hljs-string">&quot;Female&quot;</span>, <span class="hljs-string">&quot;Married&quot;</span>));        persons.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Diana&quot;</span>, <span class="hljs-string">&quot;Female&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));        persons.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-string">&quot;Male&quot;</span>, <span class="hljs-string">&quot;Single&quot;</span>));        Criteria male = <span class="hljs-keyword">new</span> CriteriaMale();        System.out.println(<span class="hljs-string">&quot;Males: &quot;</span>);        printPersons(male.meetCriteria(persons));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPersons</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Person person : persons) &#123;            System.out.println(<span class="hljs-string">&quot;Person : [ Name : &quot;</span> + person.getName()                    + <span class="hljs-string">&quot;, Gender : &quot;</span> + person.getGender()                    + <span class="hljs-string">&quot;, Marital Status : &quot;</span> + person.getMaritalStatus()                    + <span class="hljs-string">&quot; ]&quot;</span>);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-责任链模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><ul><li>需求：举个例子，根据公司管理制度，请假三天以内，需找<strong>直属上级</strong>签名；三天以上，需找<strong>直属上级以及行政处</strong>签名。</li><li>实现：<ol><li>抽象请假类，并定义请假的类型/等级，抽象具体请假的方法，声明下一级处理的逻辑</li><li>继承抽象的请假类，多种实体类</li><li>测试类，先在行政处定义处理流程，请假</li></ol></li><li>场景：数据处理需要经过几个地方，不同的</li></ul><p><code>AbstractVacateStep.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractVacateStep</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SHORT = <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> LONG = <span class="hljs-number">2</span>;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> level;    <span class="hljs-comment">//责任链中的下一个元素</span>    <span class="hljs-keyword">protected</span> AbstractVacateStep nextVacateStep;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextVacateStep</span><span class="hljs-params">(AbstractVacateStep nextVacateStep)</span></span>&#123;        <span class="hljs-keyword">this</span>.nextVacateStep = nextVacateStep;    &#125;    <span class="hljs-comment">// 1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, String message)</span></span>&#123;        <span class="hljs-comment">// 我的等级&lt;=传进来的等级,自己签名</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.level &lt;= level)&#123;            sign(message);        &#125;        <span class="hljs-comment">// 递交给下一个人</span>        <span class="hljs-keyword">if</span>(nextVacateStep !=<span class="hljs-keyword">null</span>)&#123;            nextVacateStep.signMessage(level, message);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sign</span><span class="hljs-params">(String message)</span></span>;&#125;</code></pre><p><code>ManagerStep.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManagerStep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractVacateStep</span> </span>&#123;    <span class="hljs-comment">// 通过构造器限制了必须提供等级信息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ManagerStep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">this</span>.level = level;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign</span><span class="hljs-params">(String message)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;他要&quot;</span>+message+<span class="hljs-string">&quot;,主子准了！&quot;</span>);    &#125;&#125;</code></pre><p><code>BossStep.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BossStep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractVacateStep</span> </span>&#123;    <span class="hljs-comment">// 通过构造器限制了必须提供等级信息,并赋值给父类变量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BossStep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span> </span>&#123;        <span class="hljs-keyword">this</span>.level = level;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sign</span><span class="hljs-params">(String message)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;他要&quot;</span> + message + <span class="hljs-string">&quot;,朕，同意了！&quot;</span>);    &#125;&#125;</code></pre><p><code>Demo.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-comment">// 行政处定义请假的形式</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AbstractVacateStep <span class="hljs-title">getVacateStep</span><span class="hljs-params">()</span> </span>&#123;        AbstractVacateStep bossStep = <span class="hljs-keyword">new</span> BossStep(AbstractVacateStep.LONG);        AbstractVacateStep managerStep = <span class="hljs-keyword">new</span> ManagerStep(AbstractVacateStep.SHORT);        managerStep.setNextVacateStep(bossStep);        <span class="hljs-comment">// 返回的是责任链中第一个经手的</span>        <span class="hljs-keyword">return</span> managerStep;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 问行政处得到请假步骤</span>        AbstractVacateStep vacateStep = getVacateStep();        vacateStep.signMessage(AbstractVacateStep.SHORT,<span class="hljs-string">&quot;回家娶媳妇！&quot;</span>);        vacateStep.signMessage(AbstractVacateStep.LONG,<span class="hljs-string">&quot;删库跑路！&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs sh">他要回家娶媳妇！,主子准了！他要删库跑路！,主子准了！他要删库跑路！,朕，同意了！</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-IO流中用到的设计模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-IO%E6%B5%81%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-IO%E6%B5%81%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流中用到的设计模式"><a href="#IO流中用到的设计模式" class="headerlink" title="IO流中用到的设计模式"></a>IO流中用到的设计模式</h1><pre><code class="hljs java"><span class="hljs-comment">// 适配器模式 字节流-&gt; 字符流</span>InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">// 装饰器模式 字符流 -&gt; 缓冲字符流</span>BufferReader bufferReader = <span class="hljs-keyword">new</span> BufferReader(inputStreamReader);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JHipster</title>
    <link href="/01-Java/08-JHipster/01-JHipster/"/>
    <url>/01-Java/08-JHipster/01-JHipster/</url>
    
    <content type="html"><![CDATA[<h1 id="JHipster"><a href="#JHipster" class="headerlink" title="JHipster"></a>JHipster</h1><p><a href="https://www.jhipster.tech/cn/">JHipster官网</a></p><h2 id="JHipster是什么"><a href="#JHipster是什么" class="headerlink" title="JHipster是什么"></a>JHipster是什么</h2><p>JHipster 是一种代码生成工具，使用<a href="https://yeoman.io/">Yeoman</a>生成代码，具体地来说就是以最流行地多种方式拼接 客户端-服务端-微服务-生产部署，具体支持类型见<a href="https://www.jhipster.tech/cn/">官网</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.jhipster.tech/cn/installation/">官方安装教程</a></p><ol><li>安装 JDK8</li><li>安装 Node.js</li><li>安装 git</li><li>安装 maven</li><li>升级npm：<code>npm install -g npm</code></li><li>安装Yeoman： <code>npm install -g yo</code></li><li>安装 JHipster: <code>npm install -g generator-jhipster</code></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>08-JHipster</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-中介者模式</title>
    <link href="/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><ul><li>目的: 用一个中介对象来负责中间交流，解耦和</li><li>例子: </li></ul><p><img src="../images/10-01.png"><br><img src="../images/10-02.png"> </p><ul><li>实现</li></ul><p><code>ProductManager.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductManager</span> </span>&#123;    <span class="hljs-keyword">private</span> Demander demander;    <span class="hljs-keyword">private</span> Programmer programmer;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProgrammer</span><span class="hljs-params">(Programmer programmer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.programmer = programmer;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDemander</span><span class="hljs-params">(Demander demander)</span> </span>&#123;        <span class="hljs-keyword">this</span>.demander = demander;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">manager</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>.programmer.program(<span class="hljs-keyword">this</span>.demander.getDemand());    &#125;&#125;</code></pre><p><code>Demander.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demander</span> </span>&#123;    <span class="hljs-keyword">private</span> String demand;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demander</span><span class="hljs-params">(String demand)</span> </span>&#123;        <span class="hljs-keyword">this</span>.demand = demand;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDemand</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> demand;    &#125;&#125;</code></pre><p><code>Programmer.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Programmer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Programmer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">program</span><span class="hljs-params">(String demand)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我是&quot;</span>+id+<span class="hljs-string">&quot;號程序員，正在實現：&quot;</span> + demand);    &#125;&#125;</code></pre><p><code>Demo.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Demander demander1 = <span class="hljs-keyword">new</span> Demander(<span class="hljs-string">&quot;第1個需求&quot;</span>);        Demander demander2 = <span class="hljs-keyword">new</span> Demander(<span class="hljs-string">&quot;第2個需求&quot;</span>);        Programmer programmer1 = <span class="hljs-keyword">new</span> Programmer(<span class="hljs-number">1</span>);        Programmer programmer4 = <span class="hljs-keyword">new</span> Programmer(<span class="hljs-number">4</span>);        ProductManager pm = <span class="hljs-keyword">new</span> ProductManager();        pm.setDemander(demander1);        pm.setProgrammer(programmer1);        pm.manager();        pm.setDemander(demander2);        pm.setProgrammer(programmer4);        pm.manager();    &#125;&#125;</code></pre><p>执行结果</p><blockquote><p>我是1號程序員，正在實現：第1個傻逼需求</p><p>我是4號程序員，正在實現：第2個傻逼需求</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>07-设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Tika安装</title>
    <link href="/01-Java/11-Office/01-Tika%E5%AE%89%E8%A3%85/"/>
    <url>/01-Java/11-Office/01-Tika%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是tika"><a href="#什么是tika" class="headerlink" title="什么是tika"></a><a href="http://tika.apache.org/index.html">什么是tika</a></h1><p><a href="https://www.ibm.com/developerworks/cn/opensource/tutorials/os-apache-tika/">IBM中文简单教程</a></p><p>Tika是一个可以读全世界各种各样的文档的集成框架，提供命令行，GUI和API，不仅支持各种文档的解析，还支持检索和分析，翻译等。</p><h2 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a><a href="http://tika.apache.org/1.16/formats.html">支持的格式</a></h2><p>Tika支持多种功能：</p><ul><li>文档类型检测</li><li>内容提取</li><li>元数据提取</li><li>语言检测</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>JDK</li></ul><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>下载两个文件，<a href="http://www.apache.org/dyn/closer.cgi/tika/tika-1.16-src.zip">tika-1.16-src.zip</a>和<a href="http://www.apache.org/dyn/closer.cgi/tika/tika-app-1.16.jar">tika-app-1.16.jar</a></p><table><thead><tr><th>os</th><th>output</th></tr></thead><tbody><tr><td>windows</td><td>添加字符串<code>C:\jars\Tika-app-1.6.jar</code>到用户环境变量 CLASSPATH</td></tr><tr><td>Linux</td><td>Export CLASSPATH=$CLASSPATH:/usr/share/jars/Tika-app-1.6.jar</td></tr></tbody></table><h3 id="使用Maven构建工程"><a href="#使用Maven构建工程" class="headerlink" title="使用Maven构建工程"></a>使用Maven构建工程</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tika-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span> Tika-parsers<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 非必要 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span> org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tika<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tika-serialization<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tika-app<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.Tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tika-bundle<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>11-Office</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Tika入门使用</title>
    <link href="/01-Java/11-Office/02-Tika%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <url>/01-Java/11-Office/02-Tika%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Maven开发tika项目"><a href="#使用Maven开发tika项目" class="headerlink" title="使用Maven开发tika项目"></a>使用Maven开发tika项目</h1><p><a href="http://www.yiibai.com/tika/">中文参考</a></p><h2 id="依赖关系pom-xml"><a href="#依赖关系pom-xml" class="headerlink" title="依赖关系pom.xml"></a>依赖关系pom.xml</h2><p>奇怪的官网，请使用1.6版本</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tika.version</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">tika.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tika-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;tika.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tika<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tika-parsers<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;tika.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h2 id="关键类和接口"><a href="#关键类和接口" class="headerlink" title="关键类和接口"></a><a href="http://tika.apache.org/1.16/api/">关键类和接口</a></h2><p><a href="http://www.yiibai.com/tika/tika_referenced_api.html">中文API参考</a></p><h3 id="Tika类"><a href="#Tika类" class="headerlink" title="Tika类"></a>Tika类</h3><h4 id="detect方法"><a href="#detect方法" class="headerlink" title="detect方法"></a>detect方法</h4><p>基于MIME的文件识别技术</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> org.apache.tika.Tika;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Typedetection</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;example.mp3&quot;</span>);<span class="hljs-comment">//</span>      <span class="hljs-comment">// 创建tika实例</span>      Tika tika = <span class="hljs-keyword">new</span> Tika();            <span class="hljs-comment">// 使用detect方法</span>      String filetype = tika.detect(file);      System.out.println(filetype);   &#125;&#125;</code></pre><h3 id="Parser接口"><a href="#Parser接口" class="headerlink" title="Parser接口"></a>Parser接口</h3><p>所有的解析器都要实现这个接口，有两种方案来实现文档内容解析</p><h4 id="方式一：自动解析-自动判断类型，实现解析，读取内容"><a href="#方式一：自动解析-自动判断类型，实现解析，读取内容" class="headerlink" title="方式一：自动解析(自动判断类型，实现解析，读取内容)"></a>方式一：自动解析(自动判断类型，实现解析，读取内容)</h4><p>简单，能够读取一般的文档并获得文档信息，但是可定制性差。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> org.apache.tika.Tika;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TikaDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\34566\\OneDrive\\docs\\Hadoop.The.Definitive.Guide.4th.Edition.2015.3.pdf&quot;</span>);<span class="hljs-comment">//</span>        <span class="hljs-comment">// 创建tika实例</span>        Tika tika = <span class="hljs-keyword">new</span> Tika();        <span class="hljs-comment">// 使用解析器解析</span>        String filecontent = tika.parseToString(file);        System.out.println(<span class="hljs-string">&quot;文件内容是：&quot;</span> + filecontent);    &#125;&#125;</code></pre><p><code>tika.parseToString(file);</code>方法的实际流程是这样的</p><p><img src="http://www.yiibai.com/uploads/allimg/141115/1-141115062619264.jpg"></p><h4 id="方式二：Parser接口的parse-方法-其实parseToString用的也是这样的方法，详情见源码"><a href="#方式二：Parser接口的parse-方法-其实parseToString用的也是这样的方法，详情见源码" class="headerlink" title="方式二：Parser接口的parse()方法(其实parseToString用的也是这样的方法，详情见源码)"></a>方式二：Parser接口的parse()方法(其实parseToString用的也是这样的方法，详情见源码)</h4><p>方法参数定义：</p><pre><code class="hljs java">parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context)</code></pre><p>要使用这个方法，必须实例化任何实现这个接口的类(内容太多不一一列举)</p><p>值得一提的是</p><ul><li><code>AutoDetectParser</code>类提供了自动类型判断的解析器接口，自动判断类型之后进行调用</li><li><code>CompositeParser</code>类，可以选择几个解析器作为一组解析器</li></ul><p><img src="http://www.yiibai.com/uploads/allimg/141115/1-141115062F53S.jpg"></p><h5 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h5><p>1.实例化实现解析器接口的类</p><pre><code class="hljs java">Parser parser = <span class="hljs-keyword">new</span> AutoDetectParser();<span class="hljs-comment">//Parser parser = new CompositeParser();</span></code></pre><p>2.实例化一个处理类的对象</p><p>Handler   描述</p><hr><p>BodyContentHandler 这个类采用XHTML输出的主体部分，并写入该内容到输出写入或输出流。然后重定向XHTML内容到另一个内容处理程序实例。<br>LinkContentHandler 这个类检测，并挑选XHTML文档的所有H-参考标签和转发那些使用类似网络爬虫工具<br>TeeContentHandler 这个类可以帮助在同时使用多个工具</p><pre><code class="hljs java">BodyContentHandler handler = <span class="hljs-keyword">new</span> BodyContentHandler();</code></pre><p>3.创建的元数据对象</p><pre><code class="hljs java">Metadata metadata = <span class="hljs-keyword">new</span> Metadata();</code></pre><p>4.创建输入流</p><pre><code class="hljs java">File file=<span class="hljs-keyword">new</span> File(filepath)FileInputStream inputstream=<span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">// 或者</span>InputStream stream = TikaInputStream.get(<span class="hljs-keyword">new</span> File(filename));</code></pre><p>5.创建上下文对象</p><pre><code class="hljs java">ParseContext context =<span class="hljs-keyword">new</span> ParseContext();</code></pre><p>6.实例化解析器对象，调用parse方法，并通过所有需要的对象</p><pre><code class="hljs java">parser.parse(inputstream, handler, metadata, context);</code></pre><p>完整示例：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.tika.Tika;<span class="hljs-keyword">import</span> org.apache.tika.metadata.Metadata;<span class="hljs-keyword">import</span> org.apache.tika.parser.AutoDetectParser;<span class="hljs-keyword">import</span> org.apache.tika.parser.ParseContext;<span class="hljs-keyword">import</span> org.apache.tika.parser.Parser;<span class="hljs-keyword">import</span> org.apache.tika.sax.BodyContentHandler;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TikaDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\Desktop\\test.txt&quot;</span>);<span class="hljs-comment">//</span>        <span class="hljs-comment">// 创建tika实例</span>        Tika tika = <span class="hljs-keyword">new</span> Tika();        Parser parser = <span class="hljs-keyword">new</span> AutoDetectParser();        BodyContentHandler handler = <span class="hljs-keyword">new</span> BodyContentHandler();        Metadata metadata = <span class="hljs-keyword">new</span> Metadata();        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);        ParseContext context = <span class="hljs-keyword">new</span> ParseContext();        parser.parse(inputStream, handler, metadata, context);        System.out.println(<span class="hljs-string">&quot;内容是：&quot;</span> + handler.toString());    &#125;&#125;</code></pre><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>这个类实现了各种接口来支持不同的数据模型，依据的是Adobe公司创建的XMP标准。</p><h4 id="get-metadata"><a href="#get-metadata" class="headerlink" title="get metadata"></a>get metadata</h4><pre><code class="hljs java"><span class="hljs-comment">// 方法一：</span><span class="hljs-comment">// 接上文代码，必须在解析之后，原理是：传递一个空的元数据对象作为一个参数进入解析器，将会将元数据信息封装在metedata对象中</span>String[] metadataNames = metadata.names();<span class="hljs-keyword">for</span>(String name : metadataNames) &#123;                    System.out.println(name + <span class="hljs-string">&quot;: &quot;</span> + metadata.get(name));&#125;<span class="hljs-comment">// 方法二：</span><span class="hljs-comment">// 存储的是Arrays的样式，也可以这样输出</span>System.out.println(Arrays.toString(metadata.names()));</code></pre><h4 id="add-metadata"><a href="#add-metadata" class="headerlink" title="add metadata"></a>add metadata</h4><pre><code class="hljs java"><span class="hljs-comment">// 直接使用ky值就可以存入metaData，但是最好还是要符合XMP标准的</span><span class="hljs-comment">// XMP标准可以参考源码Metadata类的常量，以及各种接口中的类变量</span>metadata.add(<span class="hljs-string">&quot;Key&quot;</span>,<span class="hljs-string">&quot;Value&quot;</span>);</code></pre><h4 id="set-metadata"><a href="#set-metadata" class="headerlink" title="set metadata"></a>set metadata</h4><p>根据已有的metadata</p><pre><code class="hljs java"><span class="hljs-comment">// 设置日期</span>metadata.set(Metadata.DATE, <span class="hljs-keyword">new</span> Date());<span class="hljs-comment">// 设置作者</span>metadata.set(Metadata.AUTHOR, <span class="hljs-string">&quot;authorA ,authorB ,authorC&quot;</span>);</code></pre><p><strong>！值得注意的是，这时候的元数据是没有得到存储的，存储方法没找到。</strong></p><h3 id="Language-Identifier类"><a href="#Language-Identifier类" class="headerlink" title="Language Identifier类"></a>Language Identifier类</h3><p>用于翻译</p><h4 id="语言检测，针对没有语言元数据的文档，做必要的语言检测"><a href="#语言检测，针对没有语言元数据的文档，做必要的语言检测" class="headerlink" title="语言检测，针对没有语言元数据的文档，做必要的语言检测"></a>语言检测，针对没有语言元数据的文档，做必要的语言检测</h4><p>检测原理：与日常于语料库进行匹配，Tika使用3-grams算法，支持的列表如下</p><table><thead><tr><th>list</th><th>list</th><th>list</th><th>list</th></tr></thead><tbody><tr><td>da—Danish</td><td>de—German</td><td>et—Estonian</td><td>el—Greek</td></tr><tr><td>en—English</td><td>es—Spanish</td><td>fi—Finnish</td><td>fr—French</td></tr><tr><td>hu—Hungarian</td><td>is—Icelandic</td><td>it—Italian</td><td>nl—Dutch</td></tr><tr><td>no—Norwegian</td><td>pl—Polish</td><td>pt—Portuguese</td><td>ru—Russian</td></tr><tr><td>sv—Swedish</td><td>th—Thai</td><td></td><td></td></tr></tbody></table><p>实例化LanguageIdentifier类，则应该将内容传递的字符串格式将被提取。</p><pre><code class="hljs java">LanguageIdentifier object=<span class="hljs-keyword">new</span> LanguageIdentifier(“<span class="hljs-keyword">this</span> is english”);String language = identifier.getLanguage();System.out.println(<span class="hljs-string">&quot;Language of the given content is : &quot;</span> + language);</code></pre><p>读取文档语言实例：</p><pre><code class="hljs java"><span class="hljs-comment">// 必须在解析器之后</span><span class="hljs-keyword">import</span> org.apache.tika.Tika;<span class="hljs-keyword">import</span> org.apache.tika.language.LanguageIdentifier;<span class="hljs-keyword">import</span> org.apache.tika.metadata.Metadata;<span class="hljs-keyword">import</span> org.apache.tika.parser.AutoDetectParser;<span class="hljs-keyword">import</span> org.apache.tika.parser.ParseContext;<span class="hljs-keyword">import</span> org.apache.tika.parser.Parser;<span class="hljs-keyword">import</span> org.apache.tika.sax.BodyContentHandler;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TikaDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\Desktop\\test.txt&quot;</span>);<span class="hljs-comment">//</span>        <span class="hljs-comment">// 创建tika实例</span>        Tika tika = <span class="hljs-keyword">new</span> Tika();        <span class="hljs-comment">// parser</span>        Parser parser = <span class="hljs-keyword">new</span> AutoDetectParser();        BodyContentHandler handler = <span class="hljs-keyword">new</span> BodyContentHandler();        Metadata metadata = <span class="hljs-keyword">new</span> Metadata();        FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);        ParseContext context = <span class="hljs-keyword">new</span> ParseContext();        parser.parse(inputStream, handler, metadata, context);        <span class="hljs-comment">// get language</span>        LanguageIdentifier object = <span class="hljs-keyword">new</span> LanguageIdentifier(handler.toString());        System.out.println(<span class="hljs-string">&quot;Language name :&quot;</span> + object.getLanguage());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>11-Office</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-docx4j是什么</title>
    <link href="/01-Java/11-Office/04-docx4j%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/01-Java/11-Office/04-docx4j%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="docx4j是什么"><a href="#docx4j是什么" class="headerlink" title="docx4j是什么"></a>docx4j是什么</h1><p>docx4j is an open source (ASLv2) Java library for creating and manipulating Microsoft Open XML (Word docx, Powerpoint pptx, and Excel xlsx) files.</p><p><a href="https://www.docx4java.org/trac/docx4j">官方文档</a></p><p><a href="http://blog.csdn.net/zhyh1986/article/details/8766131">参考博客</a></p><p><a href="https://www.docx4java.org/docx4j/plutext-docx4j_on_a_page-v300.pdf">一张图看懂docx4j编程</a></p><p><a href="http://htmlpreview.github.io/?https://github.com/plutext/docx4j/blob/master/docs/Docx4j_GettingStarted.html">官方快速入门</a></p><h2 id="遗留问题doc的解决方式"><a href="#遗留问题doc的解决方式" class="headerlink" title="遗留问题doc的解决方式"></a>遗留问题doc的解决方式</h2><ul><li>使用apache poi</li><li>使用<code>org.docx4j.convert.in.Doc</code>类，但是再某些情况下会出错</li><li>自己手动装</li></ul><h2 id="开始和使用"><a href="#开始和使用" class="headerlink" title="开始和使用"></a>开始和使用</h2><p>maven依赖在<a href="https://www.docx4java.org/docx4j/plutext-docx4j_on_a_page-v300.pdf">一张图看懂docx4j编程</a>中可以找到</p><p><img src="../images/04-01.png"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>11-Office</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-poi最佳实战</title>
    <link href="/01-Java/11-Office/03-poi%E6%9C%80%E4%BD%B3%E5%AE%9E%E6%88%98/"/>
    <url>/01-Java/11-Office/03-poi%E6%9C%80%E4%BD%B3%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Poi是什么"><a href="#Poi是什么" class="headerlink" title="Poi是什么"></a><a href="http://poi.apache.org/">Poi是什么</a></h1><p>Poi是Apache顶级项目，目的是为了解析Office全家而生的。后来Office使用了高级的Docx之后项目就停滞了，但是我们依然要向前兼容，因此，还是得使用这个项目依赖。</p><p><a href="http://poi.apache.org/document/index.html">Word的文档</a></p><h2 id="使用示范"><a href="#使用示范" class="headerlink" title="使用示范"></a>使用示范</h2><p>修改pom.xml文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">poi.version</span>&gt;</span>3.17-beta1<span class="hljs-tag">&lt;/<span class="hljs-name">poi.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-comment">&lt;!-- poi --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-scratchpad<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>stax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stax-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>xml-apis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xml-apis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><a href="http://blog.csdn.net/lurao/article/details/64490699">参考博客docx</a><br><a href="http://blog.csdn.net/qq578473688/article/details/72083684">参考博客docx</a><br><a href="http://newerdragon.iteye.com/blog/1675653">参考博客doc</a>    </p><p>后话</p><p>经过一番调研和实战，发现这个是不好的，是一个半成品的项目，对docx的支持很一般，很难从中获取到完整的框架结构。</p><p>因此，我换了使用<a href="04docx4j%E6%98%AF%E4%BB%80%E4%B9%88/">docx4j</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>11-Office</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-Poi读取Excel文档</title>
    <link href="/01-Java/11-Office/06-Poi%E8%AF%BB%E5%8F%96Excel%E6%96%87%E6%A1%A3/"/>
    <url>/01-Java/11-Office/06-Poi%E8%AF%BB%E5%8F%96Excel%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Poi读取Excel"><a href="#Poi读取Excel" class="headerlink" title="Poi读取Excel"></a>Poi读取Excel</h1><p>这个还没写成工具类，所以，将就看看吧</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> biz.datainsights.tools;<span class="hljs-keyword">import</span> org.apache.log4j.Logger;<span class="hljs-keyword">import</span> org.apache.poi.openxml4j.exceptions.InvalidFormatException;<span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.*;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileNotFoundException;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">biz</span>.<span class="hljs-title">datainsights</span>.<span class="hljs-title">tools</span>.<span class="hljs-title">Reader</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(Excel2Json.class);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCEL_XLS = <span class="hljs-string">&quot;xls&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCEL_XLSX = <span class="hljs-string">&quot;xlsx&quot;</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断Excel的版本,获取Workbook</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 需要判断的excel文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Workbook <span class="hljs-title">getWorkbook</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, InvalidFormatException </span>&#123;        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(file);        Workbook wb = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 这种方式 Excel2003/2007/2010都是可以处理的</span>        <span class="hljs-keyword">try</span> &#123;            wb = WorkbookFactory.create(is);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (wb != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    wb.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    logger.error(e.getMessage());                &#125;            &#125;            <span class="hljs-keyword">try</span> &#123;                is.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                logger.error(e.getMessage());            &#125;        &#125;        <span class="hljs-keyword">return</span> wb;    &#125;    <span class="hljs-keyword">public</span> Map&lt;String, List&lt;Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt;&gt;&gt; read(File file) <span class="hljs-keyword">throws</span> FileNotFoundException, InvalidFormatException &#123;        Map&lt;String, List&lt;Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt;&gt;&gt; fileMap = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt;&gt;&gt;();        List&lt;Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt;&gt; sheets = <span class="hljs-keyword">new</span> ArrayList&lt;Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt;&gt;();        Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt; sheepMap = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;List&lt;String&gt;&gt;&gt;();        Workbook workbook = getWorkbook(file);        SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; workbook.getNumberOfSheets(); i++) &#123;            Sheet sheet = workbook.getSheetAt(i);            String sheetName = sheet.getSheetName();            List&lt;List&lt;String&gt;&gt; stringRows = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();            <span class="hljs-keyword">for</span> (Row row : sheet) &#123;                List&lt;String&gt; stringCells = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();                <span class="hljs-comment">// 如果当前行没有数据，跳出循环</span>                <span class="hljs-keyword">if</span> (row.getCell(<span class="hljs-number">0</span>) == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span> (Cell cell : row) &#123;                    <span class="hljs-keyword">if</span> (cell.toString() == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">int</span> cellType = cell.getCellType();                    String cellValue = <span class="hljs-string">&quot;&quot;</span>;                    <span class="hljs-keyword">switch</span> (cellType) &#123;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_STRING:     <span class="hljs-comment">// 文本</span>                            cellValue = cell.getRichStringCellValue().getString();                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_NUMERIC:    <span class="hljs-comment">// 数字、日期</span>                            <span class="hljs-keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;                                cellValue = simpleDateFormat.format(cell.getDateCellValue());                            &#125; <span class="hljs-keyword">else</span> &#123;                                cell.setCellType(Cell.CELL_TYPE_STRING);                                cellValue = String.valueOf(cell.getRichStringCellValue().getString());                            &#125;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_BOOLEAN:    <span class="hljs-comment">// 布尔型</span>                            cellValue = String.valueOf(cell.getBooleanCellValue());                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_BLANK: <span class="hljs-comment">// 空白</span>                            cellValue = cell.getStringCellValue();                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_ERROR: <span class="hljs-comment">// 错误</span>                            cellValue = <span class="hljs-string">&quot;Error&quot;</span>;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> Cell.CELL_TYPE_FORMULA:    <span class="hljs-comment">// 公式</span>                            <span class="hljs-comment">// 得到对应单元格的公式</span>                            cellValue = cell.getCellFormula();<span class="hljs-comment">//                        // 得到对应单元格的字符串</span><span class="hljs-comment">//                        cell.setCellType(Cell.CELL_TYPE_STRING);</span><span class="hljs-comment">//                        cellValue = String.valueOf(cell.getRichStringCellValue().getString());</span>                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">default</span>:                            cellValue = <span class="hljs-string">&quot;OtherType&quot;</span>;                    &#125;                    stringCells.add(cellValue);                &#125;                stringRows.add(stringCells);            &#125;            sheepMap.put(sheetName, stringRows);        &#125;        sheets.add(sheepMap);        fileMap.put(file.getName(), sheets);        <span class="hljs-keyword">return</span> fileMap;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>11-Office</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Beats入门</title>
    <link href="/08-Elasticsearch/01-Beats/01-Beats%E5%85%A5%E9%97%A8/"/>
    <url>/08-Elasticsearch/01-Beats/01-Beats%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Beats的入门使用"><a href="#Beats的入门使用" class="headerlink" title="Beats的入门使用"></a>Beats的入门使用</h1><p>一个轻量级的数据传输工具</p><ul><li>FileBeat 日志文件</li><li>Metricbeat 度量数据:CPU/内存/磁盘/Nginx/数据库的监控数据</li><li>PacketBeat 网络数据</li><li>WinlogBeat Windows数据</li><li>HeartBeat 健康数据</li></ul><h2 id="FileBeats日志数据"><a href="#FileBeats日志数据" class="headerlink" title="FileBeats日志数据"></a>FileBeats日志数据</h2><ol><li><p>Input 多输入</p> <pre><code class="hljs yml"><span class="hljs-attr">filebeat.inputs:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">log</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">paths:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">/var/log/*.log</span>        <span class="hljs-comment">#- c:\programdata\elasticsearch\logs\*</span></code></pre><p> 所有输入类型</p><ul><li>type:log/stdin  </li></ul></li><li><p>Filter</p> <pre><code class="hljs yml"><span class="hljs-attr">processors:</span><span class="hljs-comment"># 忽略以DBG开头的</span><span class="hljs-bullet">-</span> <span class="hljs-attr">drop_event:</span>    <span class="hljs-attr">when:</span>        <span class="hljs-attr">regexp:</span>        <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;^DBG:&quot;</span><span class="hljs-comment"># 将&#123;&quot;data&quot;:&quot;&#123;\&quot;haha\&quot;:\&quot;123\&quot;&#125;&quot;&#125; &gt;  &#123;&quot;data&quot;:&quot;&#123;&quot;haha&quot;:&quot;123&quot;&#125;&quot;&#125;</span><span class="hljs-bullet">-</span> <span class="hljs-attr">decode_json_fields:</span>    <span class="hljs-attr">fields:</span> [<span class="hljs-string">&quot;inner&quot;</span>]</code></pre></li><li><p>Output 单输出</p> <pre><code class="hljs yml"><span class="hljs-comment"># 直接输出到ES</span><span class="hljs-attr">output.elasticsearch:</span>    <span class="hljs-attr">hosts:</span> [<span class="hljs-string">&quot;myEShost:9200&quot;</span>]    <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment"># 输出到控制台</span><span class="hljs-attr">output.console:</span>    <span class="hljs-attr">preety:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 输出到logstash</span><span class="hljs-attr">output.logstash:</span>    <span class="hljs-attr">hosts:</span> [<span class="hljs-string">&quot;logstash:5044&quot;</span>]</code></pre><p> <a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuring-output.html">所有输出类型</a></p><ul><li>Elasticsearch</li><li>Logstash</li><li>Kafka</li><li>Redis</li><li>File</li><li>Console</li><li>Cloud</li></ul></li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs sh">sudo ./filebeat -e -c filebeat.yml --strict.perms=<span class="hljs-literal">false</span><span class="hljs-comment"># 注意：fileBeat.yml文件的所有者必须为root, 且权限为544 -rw-r--r-- 设置--strict.perms=false不需要设置权限</span><span class="hljs-comment"># -c 使用字符串/文件 默认文件路径&quot;/usr/share/filebeat/filebeat.yml&quot;</span><span class="hljs-comment"># -e 交互式，使用控制台输出日志</span></code></pre><h3 id="fileBeat-Model模块"><a href="#fileBeat-Model模块" class="headerlink" title="fileBeat Model模块"></a>fileBeat Model模块</h3><p><a href="https://www.elastic.co/guide/en/beats/libbeat/current/community-beats.html">支持的模块</a></p><ul><li>Mysql</li><li>Apache2</li><li>springboot2beat</li><li>redis</li><li>docker</li><li>…</li></ul><p>你使用Model</p><h2 id="Metricbeat度量数据"><a href="#Metricbeat度量数据" class="headerlink" title="Metricbeat度量数据"></a>Metricbeat度量数据</h2><p>CPU/磁盘/MySQL的监控数据</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>01-Beats</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-FileBeats的安装</title>
    <link href="/08-Elasticsearch/01-Beats/02-FileBeats%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/08-Elasticsearch/01-Beats/02-FileBeats%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="FileBeat基于Docker安装"><a href="#FileBeat基于Docker安装" class="headerlink" title="FileBeat基于Docker安装"></a>FileBeat基于Docker安装</h1><p>注意：**#fileBeat.yml文件的所有者必须为root, 且权限为544 -rw-r–r–**</p><pre><code class="hljs yml"><span class="hljs-attr">filebeat:</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/beats/filebeat:6.5.4</span>  <span class="hljs-attr">container_name:</span> <span class="hljs-string">filebeat</span>  <span class="hljs-attr">user:</span> <span class="hljs-string">root</span>  <span class="hljs-attr">volumes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">./filebeat/filebeat.stdio.yml:/usr/share/filebeat/filebeat.yml:ro</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>01-Beats</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Logstash入门</title>
    <link href="/08-Elasticsearch/02-Logstash/01-Logstash%E5%85%A5%E9%97%A8/"/>
    <url>/08-Elasticsearch/02-Logstash/01-Logstash%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><h2 id="Logstash是什么"><a href="#Logstash是什么" class="headerlink" title="Logstash是什么"></a>Logstash是什么</h2><p>Logstash是Beats的增强版本，但建议一起使用</p><p>Logstash是个日志生成器，基于log2j2实现普通输出和日志的转化，它拥有管道，能够作为收集的终端，是一个全平台日志收集系统，使用管道收集数据，并存储到Elastic Search，使用Kibana作为数据可视化的工具，是ES全家桶的一员</p><h2 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h2><ol><li><p>input</p><ul><li>file</li><li>redis</li><li>beats</li><li>kafka</li></ul></li><li><p>filter</p><ul><li>grok – 一个基于正则表达式的格式转换</li><li>mutate – 字符串处理，增删改等操作</li><li>date – 时间格式化</li><li>drop</li></ul></li><li><p>output</p><ul><li>stdout<ul><li>codec =&gt; rubydebug</li><li>codec =&gt; json</li></ul></li><li>elasticsearch</li><li>redis</li><li>kafka</li></ul></li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="最简单的管道-–-由命令行配置管道"><a href="#最简单的管道-–-由命令行配置管道" class="headerlink" title="最简单的管道 – 由命令行配置管道"></a>最简单的管道 – 由命令行配置管道</h3><ul><li>注意：这条命令在Docker下无法使用，原因是logstash是单例模式，Docker已经开了一个进程了，这个就不能跑了</li></ul><pre><code class="hljs sh">bin/logstash -e <span class="hljs-string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span></code></pre><p>执行这条指令，将开始监控控制台的输入，然后变成了标准的log输出</p><ul><li>-e 由命令行配置配置管道</li></ul><pre><code class="hljs sh">input  &gt; hello worldoutput &gt; 2013-11-21T01:22:14.405+0000 0.0.0.0 hello world</code></pre><h3 id="使用Filebeat收集日志，标准管道-–-由配置文件配置管道"><a href="#使用Filebeat收集日志，标准管道-–-由配置文件配置管道" class="headerlink" title="使用Filebeat收集日志，标准管道 – 由配置文件配置管道"></a>使用Filebeat收集日志，标准管道 – 由配置文件配置管道</h3><ol><li><p>input</p> <pre><code class="hljs conf">input &#123;    beats &#123;        port &#x3D;&gt; 5044    &#125;&#125;</code></pre></li><li><p>filter</p><ul><li><p><a href="https://www.elastic.co/guide/en/logstash/6.5/plugins-filters-grok.html">frok</a><br>fork建议使用默认的正则表达式</p><pre><code class="hljs conf"># 使用grok默认模板表达式 原始数据：55.3.244.1 GET &#x2F;index.html 15824 0.043filter &#123;    grok &#123;        match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;    &#125;&#125;# 自定义模版# 1. 编辑一个模板文件 .&#x2F;patterns&#x2F;postfixPOSTFIX_QUEUEID [0-9A-F]&#123;10,11&#125;# 2. 告诉grok你的文件在哪个文件夹grok &#123;    patterns_dir &#x3D;&gt; [&quot;&#x2F;opt&#x2F;logstash&#x2F;patterns&quot;]    match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;SYSLOGBASE&#125; %&#123;POSTFIX_QUEUEID:queue_id&#125;: %&#123;GREEDYDATA:syslog_message&#125;&quot; &#125;&#125;</code></pre><p>可以使用kibana作为grok调试<br><img src="../images/2019-01-10-17-04-24.png" alt="kinaba调试"></p></li></ul></li><li><p>output</p> <pre><code class="hljs conf">output &#123;    elasticsearch &#123; hosts &#x3D;&gt; [&quot;es-master:9200&quot;] &#125;    # stdout &#123; codec &#x3D;&gt; rubydebug &#125;&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>02-Logstash</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-ElasticStack-全家桶介绍</title>
    <link href="/08-Elasticsearch/00-ElasticStack-%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/08-Elasticsearch/00-ElasticStack-%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Elastic全家桶介绍"><a href="#Elastic全家桶介绍" class="headerlink" title="Elastic全家桶介绍"></a>Elastic全家桶介绍</h1><ul><li>ElasticSearch 文本存储和检索</li><li>LogStash 日志整理和收集</li><li>Beats 日志传输</li><li>Kibana 数据可视化</li></ul><p><img src="../images/2019-01-09-11-52-50.png"></p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Elasticsearch-是什么</title>
    <link href="/08-Elasticsearch/01-Elasticsearch-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/08-Elasticsearch/01-Elasticsearch-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch第一课"><a href="#ElasticSearch第一课" class="headerlink" title="ElasticSearch第一课"></a>ElasticSearch第一课</h1><h2 id="什么是ES，为什么要用ES"><a href="#什么是ES，为什么要用ES" class="headerlink" title="什么是ES，为什么要用ES"></a>什么是ES，为什么要用ES</h2><h3 id="传统的搜索怎么做"><a href="#传统的搜索怎么做" class="headerlink" title="传统的搜索怎么做"></a>传统的搜索怎么做</h3><p>使用数据库做搜索引擎的缺点</p><ol><li>长文本搜索时需要进行遍历，效率低</li><li>数据库只支持模式匹配，对于用户输入不准确的情况的时候，无法进行搜索</li></ol><h3 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h3><p>lucene是一个封装好了各种建立<code>倒排索引</code>的各种算法的jar包，lucene能够在磁盘上组织索引的数据结构，也可以使用这个包对磁盘上已经有的索引数据进行搜索。</p><h3 id="什么是倒排索引"><a href="#什么是倒排索引" class="headerlink" title="什么是倒排索引"></a>什么是倒排索引</h3><ol><li><p>建立倒排索引:存储时候将一个句子中的单词进行拆分<br> eg:如有三个句子，1. 生化危机电影 2. 生化危机海报 3. 生化危机文章，建立倒排索引之后</p><table><thead><tr><th>key</th><th>ids</th></tr></thead><tbody><tr><td>生化</td><td>1,2,3</td></tr><tr><td>危机</td><td>1,2,3</td></tr><tr><td>电影</td><td>1</td></tr><tr><td>海报</td><td>2</td></tr><tr><td>文章</td><td>3</td></tr></tbody></table></li><li><p>用搜索的文字也会进行拆分进行查找，如用户搜索“生化机电影”，-&gt; [生化,机,电影]进行匹配，得到文章id</p></li></ol><h2 id="实际上的倒排索引"><a href="#实际上的倒排索引" class="headerlink" title="实际上的倒排索引"></a>实际上的倒排索引</h2><p>在实际存储中，倒排索引会存储</p><ol><li>包含搜索term的document list</li><li>包含搜索term的文档数量（用于计算IDF）</li><li>包含搜索term的文档中term的次数（用于计算TF）</li><li>term在文档中的次序</li><li>document的长度</li><li>document的平均长度</li></ol><h3 id="什么是ES"><a href="#什么是ES" class="headerlink" title="什么是ES"></a>什么是ES</h3><p>ES是将Lucene进行封装，提供分布式、高可用、高性能、可伸缩的搜索和分析系统.</p><ol><li>提供集群管理，数据自动分发到多个节点，搜索请求分发</li><li>维护数据高可用</li><li>封装更多高级功能，如聚合分析、复杂搜索，以便进行快速开发</li></ol><h2 id="ES基本概念"><a href="#ES基本概念" class="headerlink" title="ES基本概念"></a>ES基本概念</h2><h3 id="Es的高可用性，和高性能"><a href="#Es的高可用性，和高性能" class="headerlink" title="Es的高可用性，和高性能"></a>Es的高可用性，和高性能</h3><p>ES通过设置<strong>primary shard</strong>来进行分片，以实现大数据的存储，提高吞吐量（数据在哪，CURD请求发哪里）<br>ES通过设置<strong>replica shard</strong>来进行冗余，以实现高可用，提高吞度量（副本同时提供数据读的请求）</p><ul><li><strong>shard</strong> 也叫 <strong>primary shard</strong> 分片：将一个index切分的份数 – 默认为5，后面不能修改</li><li><strong>replica</strong> 也叫 <strong>replica shard</strong> 副本：副本数 – 默认为1，可以随时修改</li></ul>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-ElasticSearch-安装</title>
    <link href="/08-Elasticsearch/02-ElasticSearch-%E5%AE%89%E8%A3%85/"/>
    <url>/08-Elasticsearch/02-ElasticSearch-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Docker安装分布式的ElasticSearch"><a href="#使用Docker安装分布式的ElasticSearch" class="headerlink" title="使用Docker安装分布式的ElasticSearch"></a>使用Docker安装分布式的ElasticSearch</h1><p>ElasticSearch有许多安装方式，这里只介绍了基于Docker的方式</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-install.html#_installation_example_with_tar">Tar包安装</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-install.html#_installation_with_homebrew">MacOs-使用Homebrew进行安装</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-install.html#_installation_example_with_msi_windows_installer">Windows-MSI安装</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.4/docker.html">Docker安装</a></li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ul><li>版本：6.4</li><li>日期：2018年9月5日</li><li>系统：Linux虚拟机</li><li>前提：</li></ul><h3 id="单节点安装"><a href="#单节点安装" class="headerlink" title="单节点安装"></a>单节点安装</h3><ol><li><p>查看自己最大文件限制</p> <pre><code class="hljs sh"><span class="hljs-comment"># 临时修改</span>sudo sysctl -w vm.max_map_count=262144<span class="hljs-comment"># 临时查看</span>sudo sysctl -a|grep vm.max_map_count<span class="hljs-comment"># 永久修改</span>sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;vm.max_map_count=262144&#x27;</span> &gt;&gt; /etc/sysctl.conf<span class="hljs-comment"># 永久查看</span>sudo grep vm.max_map_count /etc/sysctl.conf<span class="hljs-comment"># 必须大于262144</span></code></pre></li><li><p>运行</p><ul><li><p>可以加上参数 <code>-d</code>使程序在后台运行</p><pre><code class="hljs sh">docker run -d --name elasticsearch-simgle -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:6.4.0</code></pre></li></ul></li></ol><ul><li>9300用于ElasticSearch节点之间的通信、客户端通信</li><li>9200端口用于提供Rest API</li></ul><h3 id="多节点安装"><a href="#多节点安装" class="headerlink" title="多节点安装"></a>多节点安装</h3><p>使用<code>docker-compose.yml</code>文件</p><pre><code class="hljs yml"><span class="hljs-comment"># es分布式多节点的docker-composer.yml文件</span><span class="hljs-comment"># 用于一把梭部署4docker(1主节点，3数据节点)</span><span class="hljs-comment"># author : cenzhongman</span><span class="hljs-comment"># email : cenzhongman@163.com</span><span class="hljs-comment"># 官方建议：生产环境bootstrap.memory_lock=true</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.2&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">es-master:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">datainsights/elasticsearch-ik:latest</span>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-master</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">cluster.name=docker-cluster</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.name=es-master</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.master=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.data=false</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>    <span class="hljs-attr">ulimits:</span>      <span class="hljs-attr">memlock:</span>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9200</span><span class="hljs-string">:9200</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">9300</span><span class="hljs-string">:9300</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">es-master:/usr/share/elasticsearch/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">esnet</span>    <span class="hljs-attr">es-datanode1:</span>    <span class="hljs-attr">image:</span>  <span class="hljs-string">datainsights/elasticsearch-ik:latest</span>     <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-datanode1</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">cluster.name=docker-cluster</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.name=es-datanode1</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.master=false</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.data=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.zen.ping.unicast.hosts=es-master&quot;</span>    <span class="hljs-attr">ulimits:</span>      <span class="hljs-attr">memlock:</span>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">es-datanode1:/usr/share/elasticsearch/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">esnet</span>  <span class="hljs-attr">es-datanode2:</span>    <span class="hljs-attr">image:</span>  <span class="hljs-string">datainsights/elasticsearch-ik:latest</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-datanode2</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">cluster.name=docker-cluster</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.name=es-datanode2</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.master=false</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.data=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.zen.ping.unicast.hosts=es-master&quot;</span>    <span class="hljs-attr">ulimits:</span>      <span class="hljs-attr">memlock:</span>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">es-datanode2:/usr/share/elasticsearch/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">esnet</span>  <span class="hljs-attr">es-datanode3:</span>    <span class="hljs-attr">image:</span>  <span class="hljs-string">datainsights/elasticsearch-ik:latest</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">es-datanode3</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">cluster.name=docker-cluster</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.name=es-datanode3</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.master=false</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">node.data=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">bootstrap.memory_lock=true</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.zen.ping.unicast.hosts=es-master&quot;</span>    <span class="hljs-attr">ulimits:</span>      <span class="hljs-attr">memlock:</span>        <span class="hljs-attr">soft:</span> <span class="hljs-number">-1</span>        <span class="hljs-attr">hard:</span> <span class="hljs-number">-1</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">es-datanode3:/usr/share/elasticsearch/data</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">esnet</span>    <span class="hljs-attr">kibana:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:6.4.0</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kibana</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">SERVER_NAME=kibana</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">ELASTICSEARCH_URL=http://es-master:9200</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">5601</span><span class="hljs-string">:5601</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">esnet</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">esnet:</span><span class="hljs-attr">volumes:</span>  <span class="hljs-attr">es-master:</span>  <span class="hljs-attr">es-datanode1:</span>  <span class="hljs-attr">es-datanode2:</span>  <span class="hljs-attr">es-datanode3:</span></code></pre><p>执行</p><pre><code class="hljs sh">docker-compose up -d</code></pre><ul><li>-d 表示后台运行</li></ul><h2 id="踩坑日志"><a href="#踩坑日志" class="headerlink" title="踩坑日志"></a>踩坑日志</h2><h3 id="交换空间开启失败"><a href="#交换空间开启失败" class="headerlink" title="交换空间开启失败"></a>交换空间开启失败</h3><ul><li><p>报错信息：<code>ERROR: bootstrap checks failed memory locking requested for elasticsearch process but memory is not locked</code></p></li><li><p>错误原因：<code>- bootstrap.memory_lock=true</code>为ElacticSearch推荐配置，作用是禁止交换空间，交换空间的使用将导致ES运行缓慢甚至运行着就奔溃了，该项需要宿主主机的配合</p></li><li><p>解决办法：在<code>docker-compose.yml</code>文件中添加</p><pre><code class="hljs sh">ulimits:  memlock:    soft: -1    hard: -1</code></pre></li></ul><h3 id="Exited-with-exit-code-137内存不够闪退"><a href="#Exited-with-exit-code-137内存不够闪退" class="headerlink" title="Exited with exit code 137内存不够闪退"></a><code>Exited with exit code 137</code>内存不够闪退</h3><ul><li>报错信息：<code>Exited with exit code 137</code>而且down的时候，也没有这个节点</li><li>错误原因：这是内存怪兽，内存不足被杀掉了</li><li>解决办法：给Docker足够的内存</li></ul>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-ElasticSearch-指令-入门版</title>
    <link href="/08-Elasticsearch/03-ElasticSearch-%E6%8C%87%E4%BB%A4-%E5%85%A5%E9%97%A8%E7%89%88/"/>
    <url>/08-Elasticsearch/03-ElasticSearch-%E6%8C%87%E4%BB%A4-%E5%85%A5%E9%97%A8%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch指令操作"><a href="#ElasticSearch指令操作" class="headerlink" title="ElasticSearch指令操作"></a>ElasticSearch指令操作</h1><h2 id="Cat-API"><a href="#Cat-API" class="headerlink" title="Cat API"></a>Cat API</h2><h3 id="获取集群健康状态"><a href="#获取集群健康状态" class="headerlink" title="获取集群健康状态"></a>获取集群健康状态</h3><p>GET _cat/health/?v</p><h3 id="获取集群中的节点状态"><a href="#获取集群中的节点状态" class="headerlink" title="获取集群中的节点状态"></a>获取集群中的节点状态</h3><p>GET _cat/nodes/?v</p><h3 id="获取集群中索引状态"><a href="#获取集群中索引状态" class="headerlink" title="获取集群中索引状态"></a>获取集群中索引状态</h3><p>GET _cat/indices/?v</p><h2 id="Index-Management"><a href="#Index-Management" class="headerlink" title="Index Management"></a>Index Management</h2><h3 id="新建简单索引"><a href="#新建简单索引" class="headerlink" title="新建简单索引"></a>新建简单索引</h3><p>PUT /index_name</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>DELETE /index_name</p><h2 id="Document-Managerment"><a href="#Document-Managerment" class="headerlink" title="Document Managerment"></a>Document Managerment</h2><h3 id="增加文档-–-ID可不写，可自动生成"><a href="#增加文档-–-ID可不写，可自动生成" class="headerlink" title="增加文档 – ID可不写，可自动生成"></a>增加文档 – ID可不写，可自动生成</h3><p>PUT /index_name/_doc/doc_id<br>{<br>  “key1”:”value1”,<br>  “key2”:”value2”<br>}</p><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>GET /index_name/_doc/doc_id</p><h3 id="修改文档-–-两种方式"><a href="#修改文档-–-两种方式" class="headerlink" title="修改文档 – 两种方式"></a>修改文档 – 两种方式</h3><h4 id="完整替换-–-优点-可以直接使用插入文档的接口，缺点：增加数据传输"><a href="#完整替换-–-优点-可以直接使用插入文档的接口，缺点：增加数据传输" class="headerlink" title="完整替换 – 优点: 可以直接使用插入文档的接口，缺点：增加数据传输"></a>完整替换 – 优点: 可以直接使用插入文档的接口，缺点：增加数据传输</h4><p>PUT /index_name/_doc/doc_id<br>{<br>  “key1”:”new_value1”,<br>  “key2”:”value2”<br>}</p><h4 id="部分更新，若文档不存在则报错，若字段不存在则增加-–-优点：只更新部分数据，缺点：学习新的API"><a href="#部分更新，若文档不存在则报错，若字段不存在则增加-–-优点：只更新部分数据，缺点：学习新的API" class="headerlink" title="部分更新，若文档不存在则报错，若字段不存在则增加 – 优点：只更新部分数据，缺点：学习新的API"></a>部分更新，若文档不存在则报错，若字段不存在则增加 – 优点：只更新部分数据，缺点：学习新的API</h4><p>POST /index_name/_doc/doc_id/_update<br>{<br>  “doc”: {<br>    “key1”:”new_value2”<br>  }<br>}</p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>DELETE /index_name/_doc/doc_id</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-ElasticSearch-指令-完整版</title>
    <link href="/08-Elasticsearch/03-ElasticSearch-%E6%8C%87%E4%BB%A4-%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <url>/08-Elasticsearch/03-ElasticSearch-%E6%8C%87%E4%BB%A4-%E5%AE%8C%E6%95%B4%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch指令操作"><a href="#ElasticSearch指令操作" class="headerlink" title="ElasticSearch指令操作"></a>ElasticSearch指令操作</h1><h2 id="Cat-API"><a href="#Cat-API" class="headerlink" title="Cat API"></a>Cat API</h2><h3 id="获取集群健康状态"><a href="#获取集群健康状态" class="headerlink" title="获取集群健康状态"></a>获取集群健康状态</h3><p>GET _cat/health/?v</p><h3 id="获取集群中的节点状态"><a href="#获取集群中的节点状态" class="headerlink" title="获取集群中的节点状态"></a>获取集群中的节点状态</h3><p>GET _cat/nodes/?v</p><h3 id="获取集群中索引状态"><a href="#获取集群中索引状态" class="headerlink" title="获取集群中索引状态"></a>获取集群中索引状态</h3><p>GET _cat/indices/?v</p><h2 id="Index-Management"><a href="#Index-Management" class="headerlink" title="Index Management"></a>Index Management</h2><h3 id="新建简单索引"><a href="#新建简单索引" class="headerlink" title="新建简单索引"></a>新建简单索引</h3><p>PUT /index_name</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>DELETE /index_name</p><h2 id="Document-Managerment"><a href="#Document-Managerment" class="headerlink" title="Document Managerment"></a>Document Managerment</h2><h3 id="增加文档"><a href="#增加文档" class="headerlink" title="增加文档"></a>增加文档</h3><h4 id="增加单条数据-–-ID可不写，可自动生成"><a href="#增加单条数据-–-ID可不写，可自动生成" class="headerlink" title="增加单条数据 – ID可不写，可自动生成"></a>增加单条数据 – ID可不写，可自动生成</h4><p>PUT /index_name/_doc/doc_id<br>{<br>  “key1”:”value1”,<br>  “key2”:”value2”<br>}</p><h4 id="批量增加文档-–-一行指定index一行指定内容"><a href="#批量增加文档-–-一行指定index一行指定内容" class="headerlink" title="批量增加文档 – 一行指定index一行指定内容"></a>批量增加文档 – 一行指定index一行指定内容</h4><p>POST /customer/_doc/_bulk?pretty<br>{“index”:{“_id”:”1”}}<br>{“name”: “John Doe” }<br>{“index”:{“_id”:”2”}}<br>{“name”: “Jane Doe” }</p><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="根据ID查询文档"><a href="#根据ID查询文档" class="headerlink" title="根据ID查询文档"></a>根据ID查询文档</h4><p>GET /index_name/_doc/doc_id</p><h4 id="根据条件查询文档-–-详细的查询，请看ElasticSearch查询-md"><a href="#根据条件查询文档-–-详细的查询，请看ElasticSearch查询-md" class="headerlink" title="根据条件查询文档 – 详细的查询，请看ElasticSearch查询.md"></a>根据条件查询文档 – 详细的查询，请看<a href="04-ElasticSearch%E6%9F%A5%E8%AF%A2/">ElasticSearch查询.md</a></h4><p>GET /index_name/_search<br>{<br>    “query”: { “match_all”: {} },<br>    “sort”: [<br>        { “account_number”: “asc” }<br>    ]<br>}</p><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="完整替换-–-优点-可以直接使用插入文档的接口，缺点：增加数据传输"><a href="#完整替换-–-优点-可以直接使用插入文档的接口，缺点：增加数据传输" class="headerlink" title="完整替换 – 优点: 可以直接使用插入文档的接口，缺点：增加数据传输"></a>完整替换 – 优点: 可以直接使用插入文档的接口，缺点：增加数据传输</h4><p>PUT /index_name/_doc/doc_id<br>{<br>  “key1”:”new_value1”,<br>  “key2”:”value2”<br>}</p><h4 id="部分更新，若文档不存在则报错，若字段不存在则增加-–-优点：只更新部分数据，缺点：学习新的API"><a href="#部分更新，若文档不存在则报错，若字段不存在则增加-–-优点：只更新部分数据，缺点：学习新的API" class="headerlink" title="部分更新，若文档不存在则报错，若字段不存在则增加 – 优点：只更新部分数据，缺点：学习新的API"></a>部分更新，若文档不存在则报错，若字段不存在则增加 – 优点：只更新部分数据，缺点：学习新的API</h4><p>#注意doc不可少<br>POST /index_name/_doc/doc_id/_update<br>{<br>  “doc”: {<br>    “key1”:”new_value2”<br>  }<br>}</p><h4 id="使用脚本修改文档ctx-source表示当前版本的source"><a href="#使用脚本修改文档ctx-source表示当前版本的source" class="headerlink" title="使用脚本修改文档ctx._source表示当前版本的source"></a>使用脚本修改文档<code>ctx._source</code>表示当前版本的source</h4><p>POST /customer/_doc/1/_update?pretty<br>{<br>  “script” : “ctx._source.age += 5”<br>}</p><h4 id="批量修改文档-–-一行命令，一行内容"><a href="#批量修改文档-–-一行命令，一行内容" class="headerlink" title="批量修改文档 – 一行命令，一行内容"></a>批量修改文档 – 一行命令，一行内容</h4><p>POST /customer/_doc/_bulk?pretty<br>{“update”:{“_id”:”1”}}<br>{“doc”: { “name”: “John Doe becomes Jane Doe” } }<br>{“delete”:{“_id”:”2”}}</p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>DELETE /index_name/_doc/doc_id</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Elasticsearch-配置</title>
    <link href="/08-Elasticsearch/05-Elasticsearch-%E9%85%8D%E7%BD%AE/"/>
    <url>/08-Elasticsearch/05-Elasticsearch-%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch配置"><a href="#ElasticSearch配置" class="headerlink" title="ElasticSearch配置"></a>ElasticSearch配置</h1><h2 id="主节点配置"><a href="#主节点配置" class="headerlink" title="主节点配置"></a>主节点配置</h2><p><a href="051-elasticsearch-master.yml">elasticsearch-master</a></p><h2 id="从节点配置"><a href="#从节点配置" class="headerlink" title="从节点配置"></a>从节点配置</h2><p><a href="052-elasticsearch-datanode.yml">elasticsearch-datanode</a></p><h2 id="JVM配置"><a href="#JVM配置" class="headerlink" title="JVM配置"></a>JVM配置</h2><p>方法1: 编辑<code>jvm.options</code>文件</p><pre><code class="hljs sh">-Xms1g-Xmx1g</code></pre><p>方法2: 使用环境变量</p><pre><code class="hljs sh"><span class="hljs-built_in">export</span> ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms1g -Xmx1g&quot;</span></code></pre><h2 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html</a></p><p>一旦配置了类似的网络设置network.host，Elasticsearch就会假定您正在转向生产并将上述警告升级为异常。这些异常将阻止您的Elasticsearch节点启动。这是一项重要的安全措施，可确保您不会因服务器配置错误而丢失数据。</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-ElasticSearch-查询</title>
    <link href="/08-Elasticsearch/04-ElasticSearch-%E6%9F%A5%E8%AF%A2/"/>
    <url>/08-Elasticsearch/04-ElasticSearch-%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch查询"><a href="#ElasticSearch查询" class="headerlink" title="ElasticSearch查询"></a>ElasticSearch查询</h1><p>ElasticSearch支持的查询</p><h2 id="query-string-search"><a href="#query-string-search" class="headerlink" title="query string search"></a>query string search</h2><p>GET /index_name/_search?q=name:czm&amp;sort=age:desc</p><h2 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h2><h3 id="Match-All"><a href="#Match-All" class="headerlink" title="Match_All"></a>Match_All</h3><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match_all”: {}<br>  }<br>}</p><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  }<br>}</p><h3 id="multi-fields"><a href="#multi-fields" class="headerlink" title="multi_fields"></a>multi_fields</h3><p>GET example_index/_search<br>{<br>  “query”: {<br>    “multi_match”: {<br>      “query”: “查询的内容”,<br>      “fields”: [“chineseName”,”englishName”]<br>    }<br>  }<br>}</p><h3 id="自定义排序-–desc-asc"><a href="#自定义排序-–desc-asc" class="headerlink" title="自定义排序 –desc/asc"></a>自定义排序 –desc/asc</h3><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  },<br>  “sort”: [<br>    {<br>      “FIELD”: {<br>        “order”: “desc”<br>      }<br>    }<br>  ]<br>}</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  },<br>  “from”: 0,<br>  “size”: 20<br>}</p><h3 id="只返回部分字段"><a href="#只返回部分字段" class="headerlink" title="只返回部分字段"></a>只返回部分字段</h3><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  },<br>  “_source”: [“FIELD”,”FIELD”]<br>}</p><h2 id="bool-filter"><a href="#bool-filter" class="headerlink" title="bool filter"></a>bool filter</h2><ul><li>filter仅仅作为过滤条件，对于搜索结果的权重没有贡献</li></ul><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “bool”: {<br>      “must”: [<br>        {<br>          “match”: {<br>          “FIELD”: “TEXT”<br>          }<br>        }<br>      ],<br>      “should”: [<br>        {<br>          “match”: {<br>            “FIELD”: “TEXT”<br>          }<br>        }<br>      ],<br>      “filter”: {<br>        “range”: {<br>          “FIELD”: {<br>            “gte”: 10,<br>            “lte”: 20<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><h2 id="constant-score-fliter"><a href="#constant-score-fliter" class="headerlink" title="constant_score fliter"></a>constant_score fliter</h2><p>GET example_index/_search<br>{<br>  “query”: {<br>    “constant_score”: {<br>      “filter”: {<br>        “range”: {<br>          “FIELD”: {<br>            “gte”: 10,<br>            “lte”: 20<br>          }<br>        }<br>      },<br>      “boost”: 1.2<br>    }<br>  }<br>}</p><h2 id="full-text-query"><a href="#full-text-query" class="headerlink" title="full text query"></a>full text query</h2><ul><li>全文检索的意思是，在多个搜索词的时候，使用TF/IDF等算法进行权重计算，返回携带一个/多个搜索词的结果</li></ul><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT1 TEXT2”<br>    }<br>  }<br>}</p><h2 id="phrase-search"><a href="#phrase-search" class="headerlink" title="phrase search"></a>phrase search</h2><ul><li>短语搜索的意思是，整个短语连续出现的时候，才能作为结果返回</li></ul><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match_phrase_prefix”: {<br>      “FIELD”: “TEXT1 TEXT2”<br>    }<br>  }<br>}</p><h2 id="highlight-search"><a href="#highlight-search" class="headerlink" title="highlight search"></a>highlight search</h2><p>GET /index_name/_search<br>{<br>  “query”: {<br>    “match”: {<br>      “FIELD”: “TEXT”<br>    }<br>  },<br>  “highlight”: {<br>    “fields”: {<br>      “FIELD”:{}<br>    }<br>  }<br>}</p><h2 id="range-query"><a href="#range-query" class="headerlink" title="range query"></a>range query</h2><p>GET example_index/_search<br>{<br>  “query”: {<br>    “range”: {<br>      “FIELD”: {<br>        “gte”: 10,<br>        “lte”: 20<br>      }<br>    }<br>  }<br>}</p><h2 id="term-query"><a href="#term-query" class="headerlink" title="term query"></a>term query</h2><ul><li>注意 term query不是keywoed query, 而是将整个查询的字符串（不分词）拿到倒排索引中去查</li></ul><p>GET example_index/_search<br>{<br>  “query”: {<br>    “term”: {<br>      “FIELD”: {<br>        “value”: “VALUE”<br>      }<br>    }<br>  }<br>}</p><h2 id="terms-query"><a href="#terms-query" class="headerlink" title="terms query"></a>terms query</h2><p>GET example_index/_search<br>{<br>  “query”: {<br>    “terms”: {<br>      “FIELD”: [<br>        “VALUE1”,<br>        “VALUE2”<br>      ]<br>    }<br>  }<br>}</p><h2 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a>搜索结果</h2><table><thead><tr><th>返回结果</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>took</td><td>耗费时间(ms)</td><td>6</td></tr><tr><td>timed_out</td><td>是否超时</td><td>false</td></tr><tr><td>_shard.total</td><td>shard总数</td><td>6</td></tr><tr><td>_shard.successful</td><td>成功的shard数</td><td>6</td></tr><tr><td>_shard.failed</td><td>失败的shard数</td><td>0</td></tr><tr><td>hits.total</td><td>能够匹配的条数</td><td>10</td></tr><tr><td>hits.max_score</td><td>最高分数</td><td>1</td></tr><tr><td>hits.hits</td><td>匹配结果</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-ElasticSearch-分片和副本原理</title>
    <link href="/08-Elasticsearch/07-ElasticSearch-%E5%88%86%E7%89%87%E5%92%8C%E5%89%AF%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/08-Elasticsearch/07-ElasticSearch-%E5%88%86%E7%89%87%E5%92%8C%E5%89%AF%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch分片和副本原理"><a href="#ElasticSearch分片和副本原理" class="headerlink" title="ElasticSearch分片和副本原理"></a>ElasticSearch分片和副本原理</h1><h2 id="shard-和-replica"><a href="#shard-和-replica" class="headerlink" title="shard 和 replica"></a>shard 和 replica</h2><ul><li>shard – primary shard</li><li>replica – replica shard</li></ul><ol><li>一个index有多个primary shard；</li><li>每个shard都是一个lucene实例，拥有保存和索引数据的能力；</li><li>增减节点时，shard在nodes之间自动负载均衡；</li><li>一个document只会存在一个primary shard；</li><li>primary shard的数量在创建索引时已经固定，replica shard可以随时修改；</li><li>primary shard默认为5，replica shard默认为1，一共是10个shard；</li><li>primary shard和replica shard不能存在同一个节点上；</li><li>primary shard和replica shard的区别是，只有primary shard才能增删改，replica shard只能提供数据存储和检索服务。</li></ol><h2 id="当机器不断扩充时"><a href="#当机器不断扩充时" class="headerlink" title="当机器不断扩充时"></a>当机器不断扩充时</h2><h3 id="单节点，primary-shard-3，replica-shard-1"><a href="#单节点，primary-shard-3，replica-shard-1" class="headerlink" title="单节点，primary shard = 3，replica shard = 1"></a>单节点，primary shard = 3，replica shard = 1</h3><ul><li>容错性：无法容错</li></ul><p><img src="../images/07-01.png"></p><h3 id="2节点，primary-shard-3，replica-shard-1"><a href="#2节点，primary-shard-3，replica-shard-1" class="headerlink" title="2节点，primary shard = 3，replica shard = 1"></a>2节点，primary shard = 3，replica shard = 1</h3><ul><li>容错性：允许关闭1个node</li></ul><p><img src="../images/07-02.png"></p><h3 id="3节点，primary-shard-3，replica-shard-1"><a href="#3节点，primary-shard-3，replica-shard-1" class="headerlink" title="3节点，primary shard = 3，replica shard = 1"></a>3节点，primary shard = 3，replica shard = 1</h3><ul><li>容错性：允许关闭1个node, 若replace为2可以关闭两个节点</li></ul><p><img src="../images/07-03.png"></p><h3 id="足量节点，primary-shard-3，replica-shard-1"><a href="#足量节点，primary-shard-3，replica-shard-1" class="headerlink" title="足量节点，primary shard = 3，replica shard = 1"></a>足量节点，primary shard = 3，replica shard = 1</h3><p>此时达到扩容瓶颈，集群不再扩容</p><ul><li>容错性：允许关闭1个node，两个node可能导致数据丢失</li></ul><p><img src="../images/07-04.png"></p><h3 id="增加副本，primary-shard-3，replica-shard-2"><a href="#增加副本，primary-shard-3，replica-shard-2" class="headerlink" title="增加副本，primary shard = 3，replica shard = 2"></a>增加副本，primary shard = 3，replica shard = 2</h3><p><img src="../images/07-05.png"></p><h2 id="容错过程"><a href="#容错过程" class="headerlink" title="容错过程"></a>容错过程</h2><ol><li>主节点宕机，集群状态Red</li><li>重新选举主节点，检查primary shard状态，提升replica shard升级为primary shard，若此时缺少replica shard集群状态改为yellow</li><li>重启故障节点，同步宕机后修改过的数据，集群状态改为green</li></ol>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-_Index_type_id</title>
    <link href="/08-Elasticsearch/08-_Index_type_id/"/>
    <url>/08-Elasticsearch/08-_Index_type_id/</url>
    
    <content type="html"><![CDATA[<h1 id="index-Type-id-source"><a href="#index-Type-id-source" class="headerlink" title="_index_Type_id_source"></a>_index_Type_id_source</h1><h2 id="index"><a href="#index" class="headerlink" title="_index"></a>_index</h2><p>index用于存储一类数据，在ES6中已经没有了type的概念</p><h2 id="id"><a href="#id" class="headerlink" title="_id"></a>_id</h2><h3 id="指定ID"><a href="#指定ID" class="headerlink" title="指定ID"></a>指定ID</h3><ul><li>适用场景：数据已经有ID了，如数据库导出的数据</li></ul><pre><code class="hljs json">PUT /_index/_type/_id&#123;    <span class="hljs-attr">&quot;&quot;</span>:<span class="hljs-string">&quot;&quot;</span>&#125;</code></pre><h3 id="自动生成ID"><a href="#自动生成ID" class="headerlink" title="自动生成ID"></a>自动生成ID</h3><ul><li>适用场景：数据无ID</li><li>长度20 URL安全 base64编码 GUID生成保证ID不冲突</li></ul><pre><code class="hljs json">POST /_index/_type&#123;    <span class="hljs-attr">&quot;&quot;</span>:<span class="hljs-string">&quot;&quot;</span>&#125;</code></pre><h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>定制返回数据</p><pre><code class="hljs json">GET /_index/_type/_id?_source=field1,field2GET /index_name/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;  &#125;,  <span class="hljs-attr">&quot;_source&quot;</span>: [<span class="hljs-string">&quot;test_field&quot;</span>]&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-ElasticSearch-并发冲突</title>
    <link href="/08-Elasticsearch/10-ElasticSearch-%E5%B9%B6%E5%8F%91%E5%86%B2%E7%AA%81/"/>
    <url>/08-Elasticsearch/10-ElasticSearch-%E5%B9%B6%E5%8F%91%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch中的多线程和并发控制"><a href="#ElasticSearch中的多线程和并发控制" class="headerlink" title="ElasticSearch中的多线程和并发控制"></a>ElasticSearch中的多线程和并发控制</h1><p>当ES作为资源时，多线程并发就会导致数据错误。</p><h2 id="悲观锁并发控制"><a href="#悲观锁并发控制" class="headerlink" title="悲观锁并发控制"></a>悲观锁并发控制</h2><p>常见于关系型数据库中，当有线程A读取数据时进行加锁操作，加锁后，其他线程只能等待释放锁才能拿到数据。从而实现数据的并发控制。</p><p><img src="../images/2019-03-01-14-24-11.png" alt="悲观锁"></p><ul><li>优点：简单，透明，容易理解，操作相对简单</li><li>缺点：效率低</li></ul><h2 id="乐观锁并发控制"><a href="#乐观锁并发控制" class="headerlink" title="乐观锁并发控制"></a>乐观锁并发控制</h2><p>ES使用的是乐观锁</p><p><img src="../images/2019-03-01-14-29-19.png" alt="乐观锁"></p><ul><li>优点：并发能力高，适合多线程操作</li><li>缺点：麻烦</li></ul><p>对document操作，修改和删除都会导致版本号<code>+1</code>，删除后重新put，版本号继续<code>+1</code>，这说明删除的时候数据还是在的，只是我们查不到了而已</p><h3 id="ES内部基于乐观锁的并发控制"><a href="#ES内部基于乐观锁的并发控制" class="headerlink" title="ES内部基于乐观锁的并发控制"></a>ES内部基于乐观锁的并发控制</h3><p>在ES后台进行primary shard和replica shard同步的时候，一般都是多线程异步的，可能会出现后修改的先到，先修改的后到的情况</p><p>先修改先到，多线程顺序正确<br><img src="../images/2019-03-01-14-56-50.png" alt="先修改先到"></p><p>先修改后到，进行线程控制的时候，当版本号旧的将被丢弃<br><img src="../images/2019-03-01-14-56-07.png" alt="先修改后到"></p><h3 id="客户端根据版本号进行并发控制"><a href="#客户端根据版本号进行并发控制" class="headerlink" title="客户端根据版本号进行并发控制"></a>客户端根据版本号进行并发控制</h3><ul><li>注意：当客户端提供的version和资源的version相同时，才能进行更新。</li></ul><pre><code class="hljs json">GET /_index/_id?version=1&#123;    <span class="hljs-attr">&quot;FIELD&quot;</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;</code></pre><p>此时需要重新获得数据并重新进行计算等操作，并带上新的版本号对数据进行更新。</p><h3 id="使用外部版本号"><a href="#使用外部版本号" class="headerlink" title="使用外部版本号"></a>使用外部版本号</h3><ul><li>注意，该版本号需要大于es的_version</li></ul><pre><code class="hljs json">PUT /index_name/_doc/1?version=4&amp;version_type=external&#123;  <span class="hljs-attr">&quot;test_field&quot;</span>:<span class="hljs-string">&quot;test v1&quot;</span>,  <span class="hljs-attr">&quot;test_field2&quot;</span>:<span class="hljs-string">&quot;test2 v1&quot;</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-Document增删改操作</title>
    <link href="/08-Elasticsearch/09-Document%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/"/>
    <url>/08-Elasticsearch/09-Document%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Document操作"><a href="#Document操作" class="headerlink" title="Document操作"></a>Document操作</h1><h2 id="Document的全量替换"><a href="#Document的全量替换" class="headerlink" title="Document的全量替换"></a>Document的全量替换</h2><p>ES中的文档是不可变的，在索引时候就已经固定下来了，修改就是标记为<code>deleted</code>，然后重新创建一个新的文档，旧的文档暂时还不会被删除，当数据增多的时候才会触发物理删除</p><p>使用PUT进行更新</p><pre><code class="hljs json">PUT /index_name/_doc/_id&#123;    <span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;</code></pre><h2 id="partial-update-增量更新-–-建议使用"><a href="#partial-update-增量更新-–-建议使用" class="headerlink" title="partial update 增量更新 – 建议使用"></a>partial update 增量更新 – 建议使用</h2><p>实际上，ES也是进行了全量更新，只是内部进行了拼装</p><p>使用POST进行更新</p><pre><code class="hljs json">POST /index_name/_doc/1/_update&#123;  <span class="hljs-attr">&quot;doc&quot;</span>:&#123;    <span class="hljs-attr">&quot;test_field&quot;</span>:<span class="hljs-string">&quot;test v3&quot;</span>  &#125;&#125;</code></pre><p>优点：减少网络请求的次数，减少网络流量</p><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>同上述替换一样，也只是标记为<code>deleted</code>, 无法进行检索</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-ElasticSearch-内置脚本</title>
    <link href="/08-Elasticsearch/11-ElasticSearch-%E5%86%85%E7%BD%AE%E8%84%9A%E6%9C%AC/"/>
    <url>/08-Elasticsearch/11-ElasticSearch-%E5%86%85%E7%BD%AE%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch脚本"><a href="#ElasticSearch脚本" class="headerlink" title="ElasticSearch脚本"></a>ElasticSearch脚本</h1><h2 id="使用内置脚本"><a href="#使用内置脚本" class="headerlink" title="使用内置脚本"></a>使用内置脚本</h2><pre><code class="hljs json">POST /index_name/_doc/2/_update&#123;  <span class="hljs-attr">&quot;script&quot;</span>: <span class="hljs-string">&quot;ctx._source.num+=1&quot;</span>&#125;</code></pre><h2 id="使用脚本文件"><a href="#使用脚本文件" class="headerlink" title="使用脚本文件"></a>使用脚本文件</h2><h3 id="创建脚本文件FILE-SCRIPT-NAME-groovy放到-ES-HOME-config-scripts下"><a href="#创建脚本文件FILE-SCRIPT-NAME-groovy放到-ES-HOME-config-scripts下" class="headerlink" title="创建脚本文件FILE_SCRIPT_NAME.groovy放到${ES_HOME}/config/scripts下"></a>创建脚本文件<code>FILE_SCRIPT_NAME.groovy</code>放到<code>$&#123;ES_HOME&#125;/config/scripts</code>下</h3><pre><code class="hljs groovy"><span class="hljs-comment">// 执行删除文档</span>ctx.op = ctx._source.num == count ? <span class="hljs-string">&#x27;delete&#x27;</span> : <span class="hljs-string">&#x27;none&#x27;</span></code></pre><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><pre><code class="hljs json">POST /index_name/_doc/2/_update&#123;  <span class="hljs-attr">&quot;script&quot;</span>: &#123;    <span class="hljs-attr">&quot;lang&quot;</span>: <span class="hljs-string">&quot;groovy&quot;</span>,    <span class="hljs-attr">&quot;file&quot;</span>: <span class="hljs-string">&quot;FILE_SCRIPT_NAME&quot;</span>,    <span class="hljs-attr">&quot;params&quot;</span>: &#123;      <span class="hljs-attr">&quot;count&quot;</span>:<span class="hljs-number">1</span>    &#125;  &#125;&#125;</code></pre><h2 id="实现不存在则初始化的操作"><a href="#实现不存在则初始化的操作" class="headerlink" title="实现不存在则初始化的操作"></a>实现不存在则初始化的操作</h2><p>存在，则+1 -&gt; num = 1<br>不存在，则初始化 -&gt; num = 0</p><pre><code class="hljs json">POST /index_name/_doc/1/_update&#123;    <span class="hljs-attr">&quot;script&quot;</span>:<span class="hljs-string">&quot;ctx._source.num+=1&quot;</span>,    <span class="hljs-attr">&quot;upsert&quot;</span>:&#123;        <span class="hljs-attr">&quot;num&quot;</span>:<span class="hljs-number">0</span>,        <span class="hljs-attr">&quot;tags&quot;</span>:[]    &#125;&#125;</code></pre><h3 id="实现删除字段操作"><a href="#实现删除字段操作" class="headerlink" title="实现删除字段操作"></a>实现删除字段操作</h3><pre><code class="hljs json">POST company_index_v1/_update_by_query?wait_for_completion=false&#123;    <span class="hljs-attr">&quot;query&quot;</span> : &#123;        <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;    &#125;,    <span class="hljs-attr">&quot;script&quot;</span>:<span class="hljs-string">&quot;ctx._source.remove(&#x27;ipcDomains&#x27;)&quot;</span>&#125;</code></pre><h2 id="在JAVA中使用脚本"><a href="#在JAVA中使用脚本" class="headerlink" title="在JAVA中使用脚本"></a>在JAVA中使用脚本</h2><p><a href="https://www.jianshu.com/p/18d0c54cd2a8">参考</a></p><ul><li>方法1:inline</li></ul><pre><code class="hljs java">TransportClient esClient = EsClient.getInstance();UpdateRequest updateRequest = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;notes2&quot;</span>, <span class="hljs-string">&quot;note&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> HashMap() &#123;    &#123;        put(<span class="hljs-string">&quot;click_count&quot;</span>, <span class="hljs-number">120</span>);        put(<span class="hljs-string">&quot;impr_count&quot;</span>, <span class="hljs-number">5</span>);    &#125;&#125;;String code = <span class="hljs-string">&quot;ctx._source.click_count=params.click_count;ctx._source.impr_count=params.impr_count;ctx._source.ctr=(double)ctx._source.click_count/ctx._source.impr_count*100&quot;</span>;Script script = <span class="hljs-keyword">new</span> Script(ScriptType.INLINE, <span class="hljs-string">&quot;painless&quot;</span>, code, params);updateRequest.script(script);esClient.update(updateRequest).get();</code></pre><ul><li>方法2</li></ul><pre><code class="hljs java">TransportClient esClient = EsClient.getInstance();UpdateRequest updateRequest = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;notes2&quot;</span>, <span class="hljs-string">&quot;note&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> HashMap() &#123;    &#123;        put(<span class="hljs-string">&quot;click_count&quot;</span>, <span class="hljs-number">120</span>);        put(<span class="hljs-string">&quot;impr_count&quot;</span>, <span class="hljs-number">5</span>);    &#125;&#125;;<span class="hljs-comment">//String code = &quot;ctx._source.read_time=params.read_time;ctx._source.read_num=params.read_num;ctx._source.avg_read_time=(double)ctx._source.read_time/ctx._source.read_num&quot;;</span>Script script = <span class="hljs-keyword">new</span> Script(ScriptType.STORED, <span class="hljs-string">&quot;painless&quot;</span>, <span class="hljs-string">&quot;ctr_calc&quot;</span>, params);updateRequest.script(script);esClient.update(updateRequest).get();</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-ElaxsticSearch-批量操作</title>
    <link href="/08-Elasticsearch/12-ElaxsticSearch-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    <url>/08-Elasticsearch/12-ElaxsticSearch-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch批量操作"><a href="#ElasticSearch批量操作" class="headerlink" title="ElasticSearch批量操作"></a>ElasticSearch批量操作</h1><h2 id="批量查询-mget"><a href="#批量查询-mget" class="headerlink" title="批量查询_mget"></a>批量查询_mget</h2><p>尽可能使用mget进行批量查询，能够极大优化性能和网络</p><pre><code class="hljs json">GET /_mget&#123;  <span class="hljs-attr">&quot;docs&quot;</span>:[    &#123;      <span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,      <span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,      <span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,      <span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,      <span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">2</span>    &#125;  ]&#125;</code></pre><p>支持index/type相同的情况</p><pre><code class="hljs json">GET /index_name/_doc/_mget&#123;  <span class="hljs-attr">&quot;docs&quot;</span>:[    &#123;      <span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">2</span>    &#125;  ]&#125;```jsonGET /index_name/_doc/_mget&#123;  <span class="hljs-attr">&quot;ids&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;</code></pre><h2 id="批量增删改-bulk"><a href="#批量增删改-bulk" class="headerlink" title="批量增删改_bulk"></a>批量增删改_bulk</h2><p>语法结构，⚠️Json只能写一行，不能换行<br>1000～5000条操作开始逐渐增加，5～15M之间</p><pre><code class="hljs json">POST /_bluk&#123;<span class="hljs-attr">&quot;action&quot;</span>:&#123;<span class="hljs-attr">&quot;metadata&quot;</span>:&#123;&#125;&#125;&#125;&#123;<span class="hljs-attr">&quot;data&quot;</span>:&#123;&#125;&#125;</code></pre><pre><code class="hljs json">POST /_bulk#删除document&#123;<span class="hljs-attr">&quot;delete&quot;</span>:&#123;<span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,<span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,<span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>&#125;&#125;#索引document，不存在创建，存在则全量替换&#123;<span class="hljs-attr">&quot;index&quot;</span>:&#123;<span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,<span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,<span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>&#125;&#125;&#123;<span class="hljs-attr">&quot;test_field&quot;</span>:<span class="hljs-string">&quot;test_by_index&quot;</span>&#125;#创建document，强制,若ID存在则报错&#123;<span class="hljs-attr">&quot;create&quot;</span>:&#123;<span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,<span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,<span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-attr">&quot;test_field&quot;</span>:<span class="hljs-string">&quot;test_by_create&quot;</span>&#125;#更新document，partial update&#123;<span class="hljs-attr">&quot;update&quot;</span>:&#123;<span class="hljs-attr">&quot;_index&quot;</span>:<span class="hljs-string">&quot;index_name&quot;</span>,<span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;_doc&quot;</span>,<span class="hljs-attr">&quot;_id&quot;</span>:<span class="hljs-number">1</span>&#125;&#125;&#123;<span class="hljs-attr">&quot;doc&quot;</span>:&#123;<span class="hljs-attr">&quot;test_field&quot;</span>:<span class="hljs-string">&quot;text_by_update&quot;</span>&#125;&#125;</code></pre><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>不能使用格式化的Json的原因，使用格式化的Json需要将Json转为JsonArray数组，会导致内存占用增加，同时GC的次数更加频繁。</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-Document的路由</title>
    <link href="/08-Elasticsearch/13-Document%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <url>/08-Elasticsearch/13-Document%E7%9A%84%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch的路由"><a href="#ElasticSearch的路由" class="headerlink" title="ElasticSearch的路由"></a>ElasticSearch的路由</h1><h2 id="什么是数据路由"><a href="#什么是数据路由" class="headerlink" title="什么是数据路由"></a>什么是数据路由</h2><p><img src="../images/2019-03-01-17-32-59.png"></p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><pre><code class="hljs sh">shard = <span class="hljs-built_in">hash</span>(routing) % number_of_primary_shard</code></pre><ul><li>routing: 默认是document_id，也可以手动指定</li><li>hash(): 结果为16进制的数字</li></ul><p>举个例子：<br>shard = hash(123) % 5<br>因此shard取值范围为[0,4]</p><h2 id="手动指定路由"><a href="#手动指定路由" class="headerlink" title="手动指定路由"></a>手动指定路由</h2><p>可以在index时候指定routing，手动指定路由（<code>routing=0</code>）可以保证数据都到同一个shard上面，可以提升批量读取性能，进行应用级别的性能提升。</p><pre><code class="hljs json">PUT /index_name/_doc/_id?routing=user_id&#123;    <span class="hljs-attr">&quot;user_id&quot;</span>:<span class="hljs-string">&quot;0001&quot;</span>&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从路由算法可以知道，当primary_shard数量变化时，对于同一个document，路由的计算的结果不一样。<strong>因此primary_shard不能后期改变</strong></p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-ElasticSearch-查询原理篇</title>
    <link href="/08-Elasticsearch/14-ElasticSearch-%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E7%AF%87/"/>
    <url>/08-Elasticsearch/14-ElasticSearch-%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch原理篇"><a href="#ElasticSearch原理篇" class="headerlink" title="ElasticSearch原理篇"></a>ElasticSearch原理篇</h1><h2 id="同时查询多个索引"><a href="#同时查询多个索引" class="headerlink" title="同时查询多个索引"></a>同时查询多个索引</h2><pre><code class="hljs sh"><span class="hljs-comment"># 搜索所有索引</span>/_search<span class="hljs-comment"># 搜索index1的所有type</span>/index1/_search<span class="hljs-comment"># 搜索index1，index2的所有type</span>/index1,index2/_search<span class="hljs-comment"># 搜索index1的type1，type2</span>/index1/type1,type2/_esarch<span class="hljs-comment"># 搜索符合规则的index的所有type</span>/*1,*2/_search<span class="hljs-comment"># 搜索所有index的type1</span>/_all/type1/_search</code></pre><h2 id="查询的步骤"><a href="#查询的步骤" class="headerlink" title="查询的步骤"></a>查询的步骤</h2><p><img src="../images/2019-03-18-17-49-24.png" alt="查询的步骤"></p><p>来自<code>client</code>的请求会随机发到一个节点,那个节点将成为<code>coordinate node</code>，<code>coordinate node</code>会构造一个大小为from + size 的 <code>priority queue</code> index的请求会根据数据路由的计算结果存储数据（详见数据路由），搜索的请求会发送到每一个primary shard（因为是搜索，每一个shard都有可能有搜索需要的数据），如果<code>primary shard</code>存在对应的 <code>replica shard</code>，请求可能会被<code>replica shard</code>接送和处理，这时候<code>primary shard</code>就不会接收到搜索请求了。</p><h2 id="设置timeout返回部分数据"><a href="#设置timeout返回部分数据" class="headerlink" title="设置timeout返回部分数据"></a>设置timeout返回部分数据</h2><p>通过设置timeout，在进行耗时操作时，可以按时返回部分数据。如本需要检索1000条数据，但是在timeout到达的时候，只搜到了10条，那就返回10条。</p><h2 id="all-的实现原理"><a href="#all-的实现原理" class="headerlink" title="_all 的实现原理"></a>_all 的实现原理</h2><p>在查询是的时候，我们可以<code>GET /index/type?q=查询的内容</code>，这样就是对搜索的字段进行搜索，其实ES在实现上是使用了_all字段，组合了所有字段的值作为该字段的值，建立倒排索引。</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;_all&quot;</span>:<span class="hljs-string">&quot;a b c&quot;</span>,    <span class="hljs-attr">&quot;filed1&quot;</span>:<span class="hljs-string">&quot;a&quot;</span>,    <span class="hljs-attr">&quot;filed2&quot;</span>:<span class="hljs-string">&quot;b&quot;</span>,    <span class="hljs-attr">&quot;filed3&quot;</span>:<span class="hljs-string">&quot;c&quot;</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-ElasticSearch-增删改原理</title>
    <link href="/08-Elasticsearch/15-ElasticSearch-%E5%A2%9E%E5%88%A0%E6%94%B9%E5%8E%9F%E7%90%86/"/>
    <url>/08-Elasticsearch/15-ElasticSearch-%E5%A2%9E%E5%88%A0%E6%94%B9%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="增删改原理篇"><a href="#增删改原理篇" class="headerlink" title="增删改原理篇"></a>增删改原理篇</h1><h2 id="增删改操作流程"><a href="#增删改操作流程" class="headerlink" title="增删改操作流程"></a>增删改操作流程</h2><p><img src="../images/2019-03-01-18-12-04.png"></p><h2 id="增删改操作一致性"><a href="#增删改操作一致性" class="headerlink" title="增删改操作一致性"></a>增删改操作一致性</h2><ul><li>one: 只需要primary shard活跃即可执行</li><li>all: primary shard和replica shard都为active才可执行</li><li>quorum: 大部分的shard处于active可执行（默认）, <code>(primary + number_of_replica)/2 + 1 </code>, 默认：int((5+2)/2) + 1 = 4，要求四个shard是Active, <strong>number_of_replica &gt; 1才生效，默认不生效</strong></li></ul><pre><code class="hljs json"><span class="hljs-comment">// 设置操作一致性的方式</span>PUT /index_name/_doc/id?consistency=quorum<span class="hljs-comment">// 设置超时时长，当quorum不齐全的时候进行等待，可以写30s，默认60s</span>PUT /index/_doc/id?timeout=30ms</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16-ElasticSearch-搜索模式</title>
    <link href="/08-Elasticsearch/16-ElasticSearch-%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%BC%8F/"/>
    <url>/08-Elasticsearch/16-ElasticSearch-%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch的搜索模式"><a href="#ElasticSearch的搜索模式" class="headerlink" title="ElasticSearch的搜索模式"></a>ElasticSearch的搜索模式</h1><h2 id="exact-value-–-term-query"><a href="#exact-value-–-term-query" class="headerlink" title="exact value – term query"></a>exact value – term query</h2><p>完全匹配搜索</p><table><thead><tr><th>支持模式</th><th>例子</th></tr></thead><tbody><tr><td>大小写</td><td>Tom tom</td></tr></tbody></table><h2 id="full-text"><a href="#full-text" class="headerlink" title="full text"></a>full text</h2><p>简称智能搜索</p><table><thead><tr><th>支持模式</th><th>例子</th></tr></thead><tbody><tr><td>支持缩写</td><td>China CN</td></tr><tr><td>格式转换</td><td>like liked likes</td></tr><tr><td>大小写</td><td>Tom tom</td></tr><tr><td>同义词</td><td>Like love</td></tr></tbody></table><h3 id="full-text-search的实现原理"><a href="#full-text-search的实现原理" class="headerlink" title="full text search的实现原理"></a>full text search的实现原理</h3><ol><li>index的时候进行<code>normalization</code>分词，将所有词去掉词态，去掉复数、转换成最简模式</li><li>搜索的时候，对搜索词也进行<code>normalization</code>分词</li></ol>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17-Elasticsearch-Mapping</title>
    <link href="/08-Elasticsearch/17-Elasticsearch-Mapping/"/>
    <url>/08-Elasticsearch/17-Elasticsearch-Mapping/</url>
    
    <content type="html"><![CDATA[<h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><h2 id="什么是mapping"><a href="#什么是mapping" class="headerlink" title="什么是mapping"></a>什么是mapping</h2><p>自动或手动为index中的type建立的一种<strong>与数据结构相关的配置</strong>，其中包含了字段的类型和分词器等设置</p><h2 id="mapping的数据类型"><a href="#mapping的数据类型" class="headerlink" title="mapping的数据类型"></a>mapping的数据类型</h2><ul><li>text(6.0以上版本只有text没有String)</li><li>keyword</li><li>byte</li><li>short</li><li>integer</li><li>long</li><li>float</li><li>double</li><li>boolean</li><li>date</li><li>…</li></ul><p>对于数组类型的数据，相当于text，没有区别，可以通用</p><h2 id="查看-amp-修改Mapping"><a href="#查看-amp-修改Mapping" class="headerlink" title="查看&amp;修改Mapping"></a>查看&amp;修改Mapping</h2><pre><code class="hljs json"><span class="hljs-comment">// 查看</span>GET /index_name/_mapping/_doc</code></pre><h2 id="默认的Mapping-–-dymanic-mapping"><a href="#默认的Mapping-–-dymanic-mapping" class="headerlink" title="默认的Mapping – dymanic mapping"></a>默认的Mapping – dymanic mapping</h2><h3 id="自动推断的标准"><a href="#自动推断的标准" class="headerlink" title="自动推断的标准"></a>自动推断的标准</h3><p>例子|推断类型<br>true|boolean<br>123|long<br>12.1|double<br>2017-01-01|date<br>“Hello world”|text</p><p>自动创建的mapping如下</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;mapping&quot;</span>: &#123;    <span class="hljs-attr">&quot;_doc&quot;</span>: &#123;      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;        <span class="hljs-attr">&quot;field_name_0&quot;</span>: &#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>        &#125;,        <span class="hljs-attr">&quot;field_name_1&quot;</span>: &#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,          <span class="hljs-attr">&quot;fields&quot;</span>: &#123;            <span class="hljs-attr">&quot;keyword&quot;</span>: &#123;              <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,              <span class="hljs-attr">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span>            &#125;          &#125;        &#125;,        <span class="hljs-attr">&quot;field_name_2&quot;</span>: &#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,          <span class="hljs-attr">&quot;fields&quot;</span>: &#123;            <span class="hljs-attr">&quot;keyword&quot;</span>: &#123;              <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,              <span class="hljs-attr">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span>            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h3 id="使用RestFulAPi创建的时候"><a href="#使用RestFulAPi创建的时候" class="headerlink" title="使用RestFulAPi创建的时候"></a>使用RestFulAPi创建的时候</h3><ol><li><p>数字：不使用分词器，类型为long</p> <pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>&#125;</code></pre></li><li><p>字符串：</p><ul><li><p>时间日期格式</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>&#125;</code></pre></li></ul><ul><li><p>普通字符串</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,    <span class="hljs-attr">&quot;fields&quot;</span>: &#123;    <span class="hljs-attr">&quot;keyword&quot;</span>: &#123;        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,        <span class="hljs-attr">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span>    &#125;&#125;</code></pre></li></ul></li></ol><h2 id="手动的mapping"><a href="#手动的mapping" class="headerlink" title="手动的mapping"></a>手动的mapping</h2><pre><code class="hljs json"><span class="hljs-comment">// 新增index的mapping</span>PUT /index_name&#123;  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;    <span class="hljs-attr">&quot;_doc&quot;</span>: &#123;      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;        <span class="hljs-attr">&quot;field_1&quot;</span>: &#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,          <span class="hljs-attr">&quot;analyzer&quot;</span>:<span class="hljs-string">&quot;english&quot;</span>****        &#125;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 修改特定_type的类型</span>PUT /index_name/_mapping/_doc&#123;  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;    <span class="hljs-attr">&quot;field_1&quot;</span>: &#123;      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,      <span class="hljs-attr">&quot;fields&quot;</span>: &#123;        <span class="hljs-attr">&quot;keyword&quot;</span>: &#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,          <span class="hljs-attr">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span>        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="使用multi-field增加一个或多个类型的字段"><a href="#使用multi-field增加一个或多个类型的字段" class="headerlink" title="使用multi-field增加一个或多个类型的字段"></a>使用multi-field增加一个或多个类型的字段</h2><p>PUT /sort_example<br>{<br>  “mappings”: {<br>    “_doc”:{<br>      “properties”:{<br>        “chineseName”:{<br>          “type”:”text”,<br>          “fields”:{<br>            “raw”:{<br>              “type”:”keyword”<br>            },<br>            “pinyin:{<br>              “type”:”text”,<br>              “analyze”:”pinyin”<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18-ElasticSearch-分词器</title>
    <link href="/08-Elasticsearch/18-ElasticSearch-%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    <url>/08-Elasticsearch/18-ElasticSearch-%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch-分词器"><a href="#ElasticSearch-分词器" class="headerlink" title="ElasticSearch-分词器"></a>ElasticSearch-分词器</h1><h2 id="什么是分词器"><a href="#什么是分词器" class="headerlink" title="什么是分词器"></a>什么是分词器</h2><p>分词器，就是切分词语，提高recall(召回率)</p><ol><li>character filter: 文本预处理，如：过滤HTML标签，将<code>&amp;</code>转为<code>and</code>等</li><li>tokenizer: 分词</li><li>token filter: 大小写转换，去停用词，词态转换，同义词转换</li></ol><p>分词器的结果用于建立倒排索引。默认情况下，搜索用的分词器会与建立索引的时候相同</p><h2 id="分词器测试方法"><a href="#分词器测试方法" class="headerlink" title="分词器测试方法"></a>分词器测试方法</h2><pre><code class="hljs json">GET /_analyer&#123;    <span class="hljs-attr">&quot;analyzer&quot;</span>:<span class="hljs-string">&quot;stander&quot;</span>,    <span class="hljs-attr">&quot;text&quot;</span>:<span class="hljs-string">&quot;Test text&quot;</span>&#125;GET</code></pre><h2 id="内置分词器"><a href="#内置分词器" class="headerlink" title="内置分词器"></a>内置分词器</h2><blockquote><p>Set the shape to semi-transpartent by calling set_trans(5)</p></blockquote><h3 id="standard-analyzer-–-该拆就拆"><a href="#standard-analyzer-–-该拆就拆" class="headerlink" title="standard analyzer – 该拆就拆"></a>standard analyzer – 该拆就拆</h3><p>set the shape to semi transpartent by calling set_trans 5</p><h3 id="simple-analyzer-–-能拆就拆"><a href="#simple-analyzer-–-能拆就拆" class="headerlink" title="simple analyzer – 能拆就拆"></a>simple analyzer – 能拆就拆</h3><p>set the shape to semi transpartent by calling set trans</p><h3 id="whitespace-analyzer-–-能不拆就不拆"><a href="#whitespace-analyzer-–-能不拆就不拆" class="headerlink" title="whitespace analyzer – 能不拆就不拆"></a>whitespace analyzer – 能不拆就不拆</h3><p>set the shape to semi-transpartent by calling set_trans(5)</p><h3 id="language-analyzer-–-如-english-根据语言删掉停用词-进行normalization转换"><a href="#language-analyzer-–-如-english-根据语言删掉停用词-进行normalization转换" class="headerlink" title="language analyzer – 如:english 根据语言删掉停用词 进行normalization转换"></a>language analyzer – 如:english 根据语言删掉停用词 进行normalization转换</h3><p>set shape semi transpar call set_tran 5</p><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><h2 id="拼音分词器"><a href="#拼音分词器" class="headerlink" title="拼音分词器"></a>拼音分词器</h2>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19-Object类型的数据结构</title>
    <link href="/08-Elasticsearch/19-Object%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/08-Elasticsearch/19-Object%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Object类型的数据结构"><a href="#Object类型的数据结构" class="headerlink" title="Object类型的数据结构"></a>Object类型的数据结构</h1><h2 id="Lise的存储结构不会发生改变，但是和String没有什么区别"><a href="#Lise的存储结构不会发生改变，但是和String没有什么区别" class="headerlink" title="Lise的存储结构不会发生改变，但是和String没有什么区别"></a>Lise的存储结构不会发生改变，但是和String没有什么区别</h2><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;names&quot;</span>:[        <span class="hljs-string">&quot;name1&quot;</span>,        <span class="hljs-string">&quot;name2&quot;</span>    ]&#125;&#123;    <span class="hljs-attr">&quot;names&quot;</span>:[        <span class="hljs-string">&quot;name1&quot;</span>,        <span class="hljs-string">&quot;name2&quot;</span>    ]&#125;</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;people&quot;</span>:&#123;        <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>,        <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">19</span>    &#125;&#125;&#123;    <span class="hljs-attr">&quot;people.name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>,    <span class="hljs-attr">&quot;people.age&quot;</span>:<span class="hljs-number">19</span>&#125;</code></pre><h2 id="MapList"><a href="#MapList" class="headerlink" title="MapList"></a>MapList</h2><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;peoples&quot;</span>:[        &#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">19</span>&#125;,        &#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;mzc&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">20</span>&#125;,    ]&#125;&#123;    <span class="hljs-attr">&quot;peoples.name&quot;</span>:[<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-string">&quot;mzc&quot;</span>],    <span class="hljs-attr">&quot;peoples.age&quot;</span>:[<span class="hljs-number">19</span>,<span class="hljs-number">20</span>]&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20-Elasticsearch-自定义排序</title>
    <link href="/08-Elasticsearch/20-Elasticsearch-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
    <url>/08-Elasticsearch/20-Elasticsearch-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h1><p>GET example_index/_search<br>{<br>  “query”: {<br>    “match_all”: {}<br>  },<br>  “sort”: [<br>    {<br>      “chineseName”: {<br>        “order”: “desc”<br>      }<br>    }<br>  ]<br>}</p><p>text类型的字段，直接执行上述操作会报错，Fielddata is disabled on text fields by default. Set fielddata=true on [chineseName] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.</p><p>主要意思是：对于text类型的字段，无法进行排序操作，因为这样会占用内存，有两种方法可以使这个字段进行排序</p><h2 id="方法一：使用multi-field增加一个keyword类型的字段"><a href="#方法一：使用multi-field增加一个keyword类型的字段" class="headerlink" title="方法一：使用multi-field增加一个keyword类型的字段"></a>方法一：使用multi-field增加一个keyword类型的字段</h2><p>PUT /sort_example<br>{<br>  “mappings”: {<br>    “_doc”:{<br>      “properties”:{<br>        “chineseName”:{<br>          “type”:”text”,<br>          “fields”:{<br>            “raw”:{<br>              “type”:”keyword”<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p><p>然后对<code>chinesName.raw</code>字段进行排序</p><p>GET sort_example/_search<br>{<br>  “query”: {<br>    “match_all”: {}<br>  },<br>  “sort”: [<br>    {<br>      “chineseName.raw”: {<br>        “order”: “desc”<br>      }<br>    }<br>  ]<br>}</p><p>这时候，是对整个值进行排序，如<code>广东工业大学</code>一整个字段，注意与下文进行比较</p><h2 id="方法二：使用-quot-fielddata-quot-true，将允许原字段进行排序"><a href="#方法二：使用-quot-fielddata-quot-true，将允许原字段进行排序" class="headerlink" title="方法二：使用&quot;fielddata&quot;:true，将允许原字段进行排序"></a>方法二：使用<code>&quot;fielddata&quot;:true</code>，将允许原字段进行排序</h2><p>PUT /sort_example<br>{<br>  “mappings”: {<br>    “_doc”:{<br>      “properties”:{<br>        “chineseName”:{<br>          “type”:”text”,<br>          “fielddata”:true<br>        }<br>      }<br>    }<br>  }<br>}</p><p>对<code>chinesName</code>字段进行排序</p><p>GET sort_example/_search<br>{<br>  “query”: {<br>    “match_all”: {}<br>  },<br>  “sort”: [<br>    {<br>      “chineseName”: {<br>        “order”: “desc”<br>      }<br>    }<br>  ]<br>}</p><p>这时候，是对分词器中的第一个词进行排序，如<code>广东工业大学</code>中的<code>广东</code>进行排序，注意与上文进行比较</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-Elasticsearch-搜索权重TF-IDF</title>
    <link href="/08-Elasticsearch/21-Elasticsearch-%E6%90%9C%E7%B4%A2%E6%9D%83%E9%87%8DTF-IDF/"/>
    <url>/08-Elasticsearch/21-Elasticsearch-%E6%90%9C%E7%B4%A2%E6%9D%83%E9%87%8DTF-IDF/</url>
    
    <content type="html"><![CDATA[<h1 id="ElastciSearch的搜索相关度算法详解"><a href="#ElastciSearch的搜索相关度算法详解" class="headerlink" title="ElastciSearch的搜索相关度算法详解"></a>ElastciSearch的搜索相关度算法详解</h1><p>ES中的相关度评分（relevance scroe）使用的是TF-IDF算法，主要包括</p><ul><li>TF: term frequency 词频，一个词出现在字段的次数，次数越多，评分越高</li><li>IDF: Inverse document frequency 一个词在整个索引中的出现次数，次数越多，评分越低</li><li>Field-length norm: 字段长度，字段越长，相关度越弱</li></ul><h2 id="查看ElasticSearch的评分规则"><a href="#查看ElasticSearch的评分规则" class="headerlink" title="查看ElasticSearch的评分规则"></a>查看ElasticSearch的评分规则</h2><pre><code class="hljs json"><span class="hljs-comment">//方法一: 在get参数中加</span>GET /example_index/_search?explain=true&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;chineseName&quot;</span>: <span class="hljs-string">&quot;广州&quot;</span>    &#125;  &#125;&#125;<span class="hljs-comment">// 方法二: 在query后加</span>GET /example_index/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;chineseName&quot;</span>: <span class="hljs-string">&quot;广州&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">&quot;explain&quot;</span>: <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 方法三：针对特定的id</span>GET /example_index/_doc/1/_explain&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;chineseName&quot;</span>: <span class="hljs-string">&quot;广州&quot;</span>    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22-ElasticSearch-正排索引</title>
    <link href="/08-Elasticsearch/22-ElasticSearch-%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <url>/08-Elasticsearch/22-ElasticSearch-%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch正排索引"><a href="#ElasticSearch正排索引" class="headerlink" title="ElasticSearch正排索引"></a>ElasticSearch正排索引</h1><ul><li>倒排索引: 使用<code>term</code>来找<code>doc</code></li><li>正排索引: 使用<code>doc</code>来找<code>term</code>，也就是我们本来存储的数据的样子</li></ul><p>在ES里，正排索引叫做<code>doc values</code>，正排索引可用作<strong>排序</strong>，<strong>聚合</strong>，<strong>过滤</strong><br>如果内存足够，<code>doc values</code>保存在内存中，内存不足的时候，存储在磁盘中</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25-setting</title>
    <link href="/08-Elasticsearch/25-setting/"/>
    <url>/08-Elasticsearch/25-setting/</url>
    
    <content type="html"><![CDATA[<h1 id="Setting文件配置"><a href="#Setting文件配置" class="headerlink" title="Setting文件配置"></a>Setting文件配置</h1><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;settings&quot;</span>: &#123;    <span class="hljs-attr">&quot;number_of_shards&quot;</span>: <span class="hljs-number">5</span>,    <span class="hljs-attr">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">1</span>  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26-Elasticsearch-_type底层原理</title>
    <link href="/08-Elasticsearch/26-Elasticsearch-_type%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/08-Elasticsearch/26-Elasticsearch-_type%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch-type底层原理（ES6之后不建议使用type）"><a href="#Elasticsearch-type底层原理（ES6之后不建议使用type）" class="headerlink" title="Elasticsearch-_type底层原理（ES6之后不建议使用type）"></a>Elasticsearch-_type底层原理（ES6之后不建议使用type）</h1><p>在lucense中不存在type 的概念，因此在底层，es存储是使用字段进行标注的。</p><p>如:</p><pre><code class="hljs json">PUT /index_name/type_name1&#123;  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>&#125;PUT /index_name/type_name2&#123;  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">12</span>&#125;实际上存储&#123;  <span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;type_name1&quot;</span>,  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;czm&quot;</span>,  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-literal">null</span>&#125;&#123;  <span class="hljs-attr">&quot;_type&quot;</span>:<span class="hljs-string">&quot;type_name2&quot;</span>,  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-literal">null</span>,  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">12</span>&#125;</code></pre><p>因此，index中的不同type最终存储是相同的，会包含所有类型的所有字段</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27-Elasticsearch-root-object</title>
    <link href="/08-Elasticsearch/27-Elasticsearch-root-object/"/>
    <url>/08-Elasticsearch/27-Elasticsearch-root-object/</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch-root-object"><a href="#Elasticsearch-root-object" class="headerlink" title="Elasticsearch-root-object"></a>Elasticsearch-root-object</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>type,index,analyzer</p><h2 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h2><p>好处</p><ol><li>document直接包含在查询结果中</li><li>partial update基于_source实现（创建新的doc, 把老的标记为删除）</li><li>reindex基于_source实现</li><li>可以基于_dource定制返回的field</li><li>debug更简单</li></ol><p>关闭_source (仅创建Index时生效)</p><pre><code class="hljs json">PUT /index_name/_mapping/_type_name&#123;  <span class="hljs-attr">&quot;_source&quot;</span>:&#123;    <span class="hljs-attr">&quot;enabled&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>  &#125;&#125;</code></pre><h2 id="all"><a href="#all" class="headerlink" title="_all"></a>_all</h2><p>_all，一个包含所有字段的字段</p><p>关闭_all (仅创建Index时生效)</p><pre><code class="hljs json">PUT /index_name/_mapping/_type_name&#123;<span class="hljs-attr">&quot;_type_name&quot;</span>:&#123;<span class="hljs-attr">&quot;_all&quot;</span>:&#123;<span class="hljs-attr">&quot;enabled&quot;</span>:<span class="hljs-string">&quot;false&quot;</span>&#125;&#125;&#125;</code></pre><p>部分字段不加入_all</p><pre><code class="hljs json">PUT /index_name/_mapping/_type_name&#123;  <span class="hljs-attr">&quot;preperties&quot;</span>:&#123;    <span class="hljs-attr">&quot;field_name&quot;</span>:&#123;      <span class="hljs-attr">&quot;include_in_all&quot;</span>:<span class="hljs-literal">false</span>    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28-Elasticsearch定制自己的dynamic策略</title>
    <link href="/08-Elasticsearch/28-Elasticsearch%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84dynamic%E7%AD%96%E7%95%A5/"/>
    <url>/08-Elasticsearch/28-Elasticsearch%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84dynamic%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="定制自己的动态dynamic策略"><a href="#定制自己的动态dynamic策略" class="headerlink" title="定制自己的动态dynamic策略"></a>定制自己的动态dynamic策略</h1><p>定制自己的动态增加策略，意思是当增加不存在字段时，如何实现动态增加。</p><p>策略:</p><ol><li>true 遇到特殊字段就动态增加</li><li>false 遇到特殊字段就忽略</li><li>strict 遇到特殊字段就报错</li></ol><h2 id="定制自己的dynamic策略"><a href="#定制自己的dynamic策略" class="headerlink" title="定制自己的dynamic策略"></a>定制自己的dynamic策略</h2><pre><code class="hljs json">PUT /index_name&#123;  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;    <span class="hljs-attr">&quot;_doc&quot;</span>:&#123;      <span class="hljs-attr">&quot;dynamic&quot;</span>:<span class="hljs-string">&quot;strict&quot;</span>,       <span class="hljs-attr">&quot;properties&quot;</span>: &#123;        <span class="hljs-attr">&quot;title&quot;</span>:&#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>        &#125;,        <span class="hljs-attr">&quot;address&quot;</span>:&#123;          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,          <span class="hljs-attr">&quot;dynamic&quot;</span>:<span class="hljs-literal">true</span>        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>上述策略，全局使用严谨的策略，address对象自动创建</p><h3 id="dynamic-mapping-template-type-level"><a href="#dynamic-mapping-template-type-level" class="headerlink" title="dynamic mapping template(type level)"></a>dynamic mapping template(type level)</h3><pre><code class="hljs json">PUT index_name3&#123;  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;    <span class="hljs-attr">&quot;type_name&quot;</span>:&#123;      <span class="hljs-attr">&quot;dynamic_templates&quot;</span>:[          &#123;            <span class="hljs-attr">&quot;dynamic_name&quot;</span>:&#123;              <span class="hljs-attr">&quot;match&quot;</span>:<span class="hljs-string">&quot;*_en&quot;</span>,              <span class="hljs-attr">&quot;match_mapping_type&quot;</span>:<span class="hljs-string">&quot;string&quot;</span>,              <span class="hljs-attr">&quot;mapping&quot;</span>:&#123;                <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span>,                <span class="hljs-attr">&quot;analyzer&quot;</span>:<span class="hljs-string">&quot;english&quot;</span>              &#125;            &#125;          &#125;        ]    &#125;  &#125;&#125;</code></pre><h3 id="dynamic-mapping-template-index-level"><a href="#dynamic-mapping-template-index-level" class="headerlink" title="dynamic mapping template(index level)"></a>dynamic mapping template(index level)</h3><pre><code class="hljs json">PUT /index_name&#123;  <span class="hljs-attr">&quot;mappings&quot;</span>:&#123;    <span class="hljs-attr">&quot;_default_&quot;</span>:&#123;      <span class="hljs-attr">&quot;_all&quot;</span>:&#123;<span class="hljs-attr">&quot;enabled&quot;</span>:<span class="hljs-literal">false</span>&#125;    &#125;,    <span class="hljs-attr">&quot;blog&quot;</span>:&#123;      <span class="hljs-attr">&quot;_all&quot;</span>:&#123;<span class="hljs-attr">&quot;enabled&quot;</span>:<span class="hljs-literal">true</span>&#125;    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29-从ES集群中移除节点</title>
    <link href="/08-Elasticsearch/29-%E4%BB%8EES%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/"/>
    <url>/08-Elasticsearch/29-%E4%BB%8EES%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="从ES集群中移除节点"><a href="#从ES集群中移除节点" class="headerlink" title="从ES集群中移除节点"></a>从ES集群中移除节点</h1><ol><li><p>将一个节点排除出去</p> <pre><code class="hljs json">PUT _cluster/settings&#123;<span class="hljs-attr">&quot;transient&quot;</span> : &#123;    <span class="hljs-attr">&quot;cluster.routing.allocation.exclude._name&quot;</span> : <span class="hljs-string">&quot;titan-node2&quot;</span>&#125;&#125;</code></pre></li><li><p>集群会开始重新转移数据，等待操作完成之后停止该节点(relocating_shards=0)</p><ul><li><p>通过monitor查看</p><p><img src="../images/2019-05-31-17-35-07.png" alt="数据迁移"></p></li><li><p>通过健康检查查看</p><pre><code class="hljs json">http://192.168.10.125:9200/_cluster/health?pretty&#123;    <span class="hljs-attr">&quot;cluster_name&quot;</span> : <span class="hljs-string">&quot;datainsights-es&quot;</span>,    <span class="hljs-attr">&quot;status&quot;</span> : <span class="hljs-string">&quot;green&quot;</span>,    <span class="hljs-attr">&quot;timed_out&quot;</span> : <span class="hljs-literal">false</span>,    <span class="hljs-attr">&quot;number_of_nodes&quot;</span> : <span class="hljs-number">4</span>,    <span class="hljs-attr">&quot;number_of_data_nodes&quot;</span> : <span class="hljs-number">4</span>,    <span class="hljs-attr">&quot;active_primary_shards&quot;</span> : <span class="hljs-number">62</span>,    <span class="hljs-attr">&quot;active_shards&quot;</span> : <span class="hljs-number">104</span>,    <span class="hljs-attr">&quot;relocating_shards&quot;</span> : <span class="hljs-number">3</span>,    <span class="hljs-attr">&quot;initializing_shards&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;unassigned_shards&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;delayed_unassigned_shards&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;number_of_pending_tasks&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;number_of_in_flight_fetch&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;task_max_waiting_in_queue_millis&quot;</span> : <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;active_shards_percent_as_number&quot;</span> : <span class="hljs-number">100.0</span>&#125;</code></pre></li></ul></li><li><p>恢复自动分配机制</p> <pre><code class="hljs json">PUT _cluster/settings&#123;    <span class="hljs-attr">&quot;transient&quot;</span> : &#123;        <span class="hljs-attr">&quot;cluster.routing.allocation.exclude._name&quot;</span> : <span class="hljs-string">&quot;&quot;</span>    &#125;&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30-ES不停机替换索引</title>
    <link href="/08-Elasticsearch/30-ES%E4%B8%8D%E5%81%9C%E6%9C%BA%E6%9B%BF%E6%8D%A2%E7%B4%A2%E5%BC%95/"/>
    <url>/08-Elasticsearch/30-ES%E4%B8%8D%E5%81%9C%E6%9C%BA%E6%9B%BF%E6%8D%A2%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="不停机替换索引"><a href="#不停机替换索引" class="headerlink" title="不停机替换索引"></a>不停机替换索引</h1><p>不停机不改代码替换索引</p><h2 id="在Kibana中实现"><a href="#在Kibana中实现" class="headerlink" title="在Kibana中实现"></a>在Kibana中实现</h2><ol><li><p>为索引创建别名</p> <pre><code class="hljs json">POST _aliases&#123;    <span class="hljs-attr">&quot;actions&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;add&quot;</span>: &#123;                <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn_v1&quot;</span>,                <span class="hljs-attr">&quot;alias&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn&quot;</span>            &#125;        &#125;    ]&#125;</code></pre></li><li><p>在代码中使用索引别名操作数据</p> <pre><code class="hljs java">index = <span class="hljs-string">&quot;patent_data_index_cn&quot;</span>;</code></pre></li><li><p>修改别名(删除旧的别名，增加新的别名)</p> <pre><code class="hljs json">POST _aliases&#123;    <span class="hljs-attr">&quot;actions&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;remove&quot;</span>: &#123;                <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn_v1&quot;</span>,                <span class="hljs-attr">&quot;alias&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn&quot;</span>            &#125;,            <span class="hljs-attr">&quot;add&quot;</span>: &#123;                <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn_v2&quot;</span>,                <span class="hljs-attr">&quot;alias&quot;</span>: <span class="hljs-string">&quot;patent_data_index_cn&quot;</span>            &#125;        &#125;    ]&#125;</code></pre></li><li><p>查看别名</p> <pre><code class="hljs json">GET _cat/aliases</code></pre></li></ol><p>这样能实现即使索引需要替换或数据升级时无需修改代码，无需关闭任何服务</p>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-常用小知识点</title>
    <link href="/08-Elasticsearch/99-%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/08-Elasticsearch/99-%E5%B8%B8%E7%94%A8%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="常用小知识点"><a href="#常用小知识点" class="headerlink" title="常用小知识点"></a>常用小知识点</h1><ul><li><p>异步执行 — ?wait_for_completion=false</p></li><li><p>修改字段</p><pre><code class="hljs json">PUT /company_index_test/_mapping/_doc&#123;  <span class="hljs-attr">&quot;properties&quot;</span>:&#123;    <span class="hljs-attr">&quot;establishTime&quot;</span>:&#123;      <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;date&quot;</span>    &#125;  &#125;&#125;POST company_index_v3/_update_by_query?wait_for_completion=false&#123;  <span class="hljs-attr">&quot;query&quot;</span>:&#123;    <span class="hljs-attr">&quot;match_all&quot;</span>:&#123;&#125;  &#125;,      <span class="hljs-attr">&quot;script&quot;</span>: &#123;        <span class="hljs-attr">&quot;lang&quot;</span>: <span class="hljs-string">&quot;painless&quot;</span>,        <span class="hljs-attr">&quot;inline&quot;</span>: <span class="hljs-string">&quot;ctx._source.establishTime = ctx._source.oldTime&quot;</span>      &#125;&#125;</code></pre></li><li><p>删除字段</p><pre><code class="hljs json">POST /type/1/_update&#123;    <span class="hljs-attr">&quot;script&quot;</span> : <span class="hljs-string">&quot;ctx._source.remove(\&quot;name\&quot;)&quot;</span>&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-kubectl使用手册</title>
    <link href="/04-Linux/03-k8s/00-kubectl%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/04-Linux/03-k8s/00-kubectl%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><pre><code class="hljs sh"><span class="hljs-comment"># 查看ctl版本</span>kubectl version<span class="hljs-comment"># 查看集群的信息</span>kubectl cluster-info<span class="hljs-comment"># 查看节点情况</span>kubectl get nodes<span class="hljs-comment"># 部署一个应用</span>kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080<span class="hljs-comment"># 查看应用</span>kubectl get deployments<span class="hljs-comment"># 打开proxy 在8081端口开启一个监听服务</span>kubectl proxy<span class="hljs-comment"># 通过rest api获得服务器信息</span>curl http://localhost:8001/version<span class="hljs-comment"># 查看Pods</span>kubectl get pods<span class="hljs-comment"># Pod 的默认路由</span>curl http://localhost:8001/api/v1/namespaces/default/pods/<span class="hljs-variable">$POD_NAME</span>/proxy/<span class="hljs-comment"># 查看所有Pods的详情</span>kubectl describe pods<span class="hljs-comment"># 查看Pod的详情</span>kubectl describe pod <span class="hljs-variable">$POD_NAME</span><span class="hljs-comment"># 查看日志</span>kubectl logs <span class="hljs-variable">$POD_NAME</span><span class="hljs-comment"># 在POD中执行命令</span>kubectl <span class="hljs-built_in">exec</span> <span class="hljs-variable">$POD_NAME</span> env<span class="hljs-comment"># 显式在POD中执行命令</span>kubectl <span class="hljs-built_in">exec</span> -ti <span class="hljs-variable">$POD_NAME</span> bash<span class="hljs-comment"># 查看services</span>kubectl get services<span class="hljs-comment"># 创建Services</span>kubectl expose deployment/kubernetes-bootcamp --<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;NodePort&quot;</span> --port 8080<span class="hljs-comment"># 查看Services详情</span>kubectl describe services <span class="hljs-variable">$SERVICES_NAME</span><span class="hljs-comment"># 通过label查询Pods</span>kubectl get pods -l run=kubernetes-bootcamp<span class="hljs-comment"># 通过label查询Services</span>kubectl get services -l run=kubernetes-bootcamp<span class="hljs-comment"># 增加label</span>kubectl label pod <span class="hljs-variable">$POD_NAME</span> app=v1<span class="hljs-comment"># 删除Service</span>kubectl delete service -l run=kubernetes-bootcamp<span class="hljs-comment"># 查看部署程序</span>kubectl get deployments<span class="hljs-comment"># 拓展Pods 可多可少</span>kubectl scale deployments/<span class="hljs-variable">$DEPLOYMENT_NAME</span> --replicas=4<span class="hljs-comment"># 查看PODS的IP</span>ubectl get pods -o wide<span class="hljs-comment"># 查看部署详情</span>kubectl describe deployments/<span class="hljs-variable">$DEPLOYMENT_NAME_NAME</span><span class="hljs-comment"># 自动负载均衡replicas 使用的都是相同的NodePort 已经自动负载均衡</span></code></pre><p>Rolling updates</p><pre><code class="hljs sh"><span class="hljs-comment"># 升级images</span>kubectl <span class="hljs-built_in">set</span> image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2<span class="hljs-comment"># 查看升级状态</span>kubectl rollout status deployments/kubernetes-bootcamp<span class="hljs-comment"># 回滚操作</span>kubectl rollout undo deployments/kubernetes-bootcamp</code></pre><p>部署应用时，系统做的事情</p><ul><li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li><li>scheduled the application to run on that Node</li><li>configured the cluster to reschedule the instance on a new Node when needed</li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-官方导览</title>
    <link href="/04-Linux/03-k8s/00-%E5%AE%98%E6%96%B9%E5%AF%BC%E8%A7%88/"/>
    <url>/04-Linux/03-k8s/00-%E5%AE%98%E6%96%B9%E5%AF%BC%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="官网导览"><a href="#官网导览" class="headerlink" title="官网导览"></a>官网导览</h1><ul><li><a href="https://kubernetes.io/docs/">官方-文档</a></li><li><a href="https://kuboard.cn/">kuboard-文档</a></li><li><a href="https://www.kubernetes.org.cn/docs/">k8s中国-文档</a></li></ul><h2 id="Getting-Start"><a href="#Getting-Start" class="headerlink" title="Getting Start"></a><a href="https://kubernetes.io/docs/setup/">Getting Start</a></h2><ul><li>内容：各种各样的<strong>安装方式比较</strong>和<strong>安装教程</strong></li><li>前提：Linux Docker</li><li>难度：⭐️⭐️</li><li>建议：较简单，可以跳过<code>Learning environment</code>, 直接阅读<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">Installing kubeadm</a>，在对k8s熟悉之后，再阅读<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/">Creating Highly Available clusters with kubeadm</a>，配合<a href="https://kuboard.cn/install/install-k8s.html">Kuboard中文简易教程</a>阅读效果更佳</li></ul><p><img src="../images/2019-09-27-14-33-58.png"></p><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a><a href="https://kubernetes.io/docs/concepts/">Concepts</a></h2><ul><li>内容：概念介绍，<strong>设计理念介绍</strong>，组件原理</li><li>前提：Linux Docker</li><li>难度：⭐️⭐️⭐️⭐️</li><li>建议：在安装了集群之后，进行概览，遇到不会的可以查查<a href="https://www.kubernetes.org.cn/docs">Kubernetes中文手册</a>, 熟悉之后可以精读</li></ul><p><img src="../images/2019-09-27-15-05-33.png"></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a><a href="https://kubernetes.io/docs/tasks/">Tasks</a></h2><ul><li>内容：k8s能实现的各种应用和Demo等</li><li>前提：Linux Docker kubernates基础</li><li>难度：⭐️⭐</li><li>建议：概览，熟悉章节包含的内容，在需要使用的时候进行查阅使用</li></ul><p><img src="../images/2019-09-27-15-08-25.png"></p><h2 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a><a href="https://kubernetes.io/docs/tutorials/">Tutorials</a></h2><ul><li>内容：Kubemini的在线操练</li><li>前提：Linux</li><li>难度：⭐️</li><li>建议：按部就班执行一遍教程中的所有内容，体验k8s是什么和熟悉kubectl的使用</li></ul><p><img src="../images/2019-09-27-15-21-35.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><a href="https://kubernetes.io/docs/reference/">Reference</a></h2><ul><li>内容：k8s开放的接口文档等</li><li>前提：Linux Docker kubernates</li><li>难度：⭐️⭐️⭐️⭐️</li><li>建议：在熟悉了K8s之后进行拓展开发时使用</li></ul><p><img src="../images/2019-09-27-15-21-35.png"></p><h2 id="Contribute"><a href="#Contribute" class="headerlink" title="Contribute"></a><a href="https://kubernetes.io/docs/contribute/">Contribute</a></h2><ul><li>内容：为K8S发展贡献</li><li>前提：Linux Docker kubernates</li><li>难度：⭐️⭐️⭐️⭐️⭐️</li><li>建议：成为大神之后，或发现了BUG可以在这里找反馈方式</li></ul><p><img src="../images/2019-09-27-15-28-04.png"></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-概念理解</title>
    <link href="/04-Linux/03-k8s/00-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <url>/04-Linux/03-k8s/00-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubenetes"><a href="#Kubenetes" class="headerlink" title="Kubenetes"></a>Kubenetes</h1><ul><li><a href="https://kubernetes.io/docs/">官方-文档</a></li><li><a href="https://kuboard.cn/">kuboard-文档</a></li><li><a href="https://www.kubernetes.org.cn/docs/">k8s中国-文档</a></li></ul><h2 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h2><p>Kubernetes简称k8s, 是谷歌开源的用来管理容器编排的技术，容器技术不止Docker，但本系列文章只讨论k8s和docker结合使用。</p><p>终极目标：</p><ol><li>自动负载均衡</li><li><strong>集群状态全生命周期监控</strong><ul><li>Dashboard</li><li>Kuboard</li></ul></li><li><strong>JAVA微服务完整支持</strong><ul><li>Spring Cloud</li><li>Nacos</li><li>Dubbo</li></ul></li><li><strong>持续构建和持续集成</strong><ul><li>Jenkins</li></ul></li><li><strong>无状态容器，横向扩容，自修复，滚动升级</strong></li><li><strong>有状态容器数据容灾</strong><ul><li>RDB</li><li>Redis</li><li>Elasticsearch</li><li>ZooKeeper</li></ul></li><li>统一配置中心</li><li>统一日志中心</li><li>自动熔断、限流、降级</li></ol><p>东西很多，我们一个一个实现</p><h2 id="K8s是什么，能做什么"><a href="#K8s是什么，能做什么" class="headerlink" title="K8s是什么，能做什么"></a>K8s是什么，能做什么</h2><p>K8S</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/gui951753/article/details/81543545">深度好文-网易云架构师刘超-为什么k8s天然适合微服务</a>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-安装Harbor</title>
    <link href="/04-Linux/03-k8s/01-%E5%AE%89%E8%A3%85Harbor/"/>
    <url>/04-Linux/03-k8s/01-%E5%AE%89%E8%A3%85Harbor/</url>
    
    <content type="html"><![CDATA[<h1 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h1><p><a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide/">Installation and Configuration Guide</a></p><ul><li>在本人Mac上使用1.9.0 docker login 无法登录harbor, docker版本19.03.2 原因未知</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装步骤请参考官方说明<a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide/">Installation and Configuration Guide</a></p><p>hostname 主要功能就是作为输出的提示而已，作用不大，可以直接改成ip或者域名 不用纠结<br>主要是修改两个密码，admin密码和数据库密码</p><ul><li>注：若直接在yml文件中修改密码，密码需要符合规则<strong>8到20个字符且需包含至少一个大写字符、小写字符或者数字</strong>，如果修改不当，程序看起来正常启动，其实是启动失败的。建议在系统运行后在界面修改密码。</li></ul><p>端口建议使用5000</p><p><img src="../images/2019-09-30-12-00-31.png"></p><p>使用网关作为DNS，直接将请求寻址到内网，可以实现在内网访问公网IP而使用内网的速度。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>修改<code>/etc/docker/daemon.json</code><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;insecure-registries&quot;</span>:[        <span class="hljs-string">&quot;hub.datainsights.biz&quot;</span>    ]&#125;</code></pre></li><li>登录<pre><code class="hljs sh">docker login hub.datainsights.biz</code></pre></li><li>tag <pre><code class="hljs sh"><span class="hljs-comment"># 注意：这个项目名必须在管理界面中新建</span>docker tag mysql/mysql:1.0 hub.datainsights.biz/项目名/mysql:1.0</code></pre></li><li>push<pre><code class="hljs sh">docker push hub.datainsights.biz/项目名/mysql:1.0</code></pre></li><li>pull<pre><code class="hljs sh">docker pull hub.datainsights.biz/项目名/mysql:1.0</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-安装docker cubectl</title>
    <link href="/04-Linux/03-k8s/02-%E5%AE%89%E8%A3%85docker%20cubectl/"/>
    <url>/04-Linux/03-k8s/02-%E5%AE%89%E8%A3%85docker%20cubectl/</url>
    
    <content type="html"><![CDATA[<h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><ul><li><p><a href="https://kubernetes.io/docs/setup/">官方-安装教程首页</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">官方-使用kubeadm单节点安装</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/">官方-使用kubeadm HA 安装</a></p></li><li><p><a href="https://kuboard.cn/install/install-k8s.html">kuboard-使用kubeadm单节点安装</a></p></li><li><p><a href="https://kuboard.cn/install/install-k8s.html">kuboard-使用kubeadmHA安装</a></p></li><li><p>值得注意的是，官网的教程因为涉及Google家的服务器，因此基本都要找国内源</p></li></ul><h2 id="Ubuntu使用kubeadm可拓展HA的安装-非HA"><a href="#Ubuntu使用kubeadm可拓展HA的安装-非HA" class="headerlink" title="Ubuntu使用kubeadm可拓展HA的安装(非HA)"></a>Ubuntu使用kubeadm可拓展HA的安装(非HA)</h2><h3 id="1-检查系统配置"><a href="#1-检查系统配置" class="headerlink" title="1. 检查系统配置"></a>1. 检查系统配置</h3><ol><li>2台 及以上主机</li><li>ubuntu16.04 及以上</li><li>节点 hostname 不是 localhost <strong>此处 hostname 的输出将会是该机器在 Kubernetes 集群中的节点名字</strong></li><li>CPU 内核数量大于等于 2</li></ol><pre><code class="hljs sh"><span class="hljs-comment"># 检查Hostname不为localhost</span>cat /etc/hostname<span class="hljs-comment"># 修改Hostname，并重启系统</span>vim /etc/hostname<span class="hljs-comment"># 查看内核数</span>lscpu</code></pre><h3 id="2-安装必备软件"><a href="#2-安装必备软件" class="headerlink" title="2. 安装必备软件"></a>2. 安装必备软件</h3><p>Master和Worker都要以root用户执行</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># Email:cenzhongman@163.com</span><span class="hljs-comment"># 参考文档如下</span><span class="hljs-comment"># https://docs.docker.com/install/linux/docker-ce/ubuntu/</span><span class="hljs-comment"># https://docs.docker.com/install/linux/linux-postinstall/</span><span class="hljs-comment"># https://kubernetes.io/docs/setup/production-environment/container-runtimes/</span><span class="hljs-comment"># 卸载docker旧版本</span>apt-get remove -y docker docker-engine docker.io containerd runc docker-ce<span class="hljs-comment"># 安装必备工具</span>apt-get update &amp;&amp; apt-get install -y apt-transport-https ca-certificates curl software-properties-common<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;安装Docker&quot;</span><span class="hljs-comment"># 以下安装步骤来自https://kubernetes.io/docs/setup/production-environment/container-runtimes/</span><span class="hljs-comment">### Add Docker’s official GPG key</span>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | apt-key add -<span class="hljs-comment">### Add Docker apt repository.</span>add-apt-repository \  <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> \</span><span class="hljs-string">  stable&quot;</span><span class="hljs-comment">### Install Docker CE.</span>apt-get update &amp;&amp; apt-get install docker-ce=18.06.2~ce~3-0~ubuntu<span class="hljs-comment">### Setup daemon.</span>cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>],  <span class="hljs-string">&quot;log-driver&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;    <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;100m&quot;</span>  &#125;,  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>,  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>]&#125;EOFmkdir -p /etc/systemd/system/docker.service.dsystemctl daemon-reloadsystemctl restart docker<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker 安装完成&quot;</span>docker version<span class="hljs-comment"># 关闭 防火墙</span>systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalld<span class="hljs-comment"># 关闭 swap</span>swapoff -ayes | cp /etc/fstab /etc/fstab_bakcat /etc/fstab_bak |grep -v swap &gt; /etc/fstab<span class="hljs-comment"># 修改 /etc/sysctl.conf</span><span class="hljs-comment"># 如果有配置，则修改</span>sed -i <span class="hljs-string">&quot;s#^net.ipv4.ip_forward.*#net.ipv4.ip_forward=1#g&quot;</span>  /etc/sysctl.confsed -i <span class="hljs-string">&quot;s#^net.bridge.bridge-nf-call-ip6tables.*#net.bridge.bridge-nf-call-ip6tables=1#g&quot;</span>  /etc/sysctl.confsed -i <span class="hljs-string">&quot;s#^net.bridge.bridge-nf-call-iptables.*#net.bridge.bridge-nf-call-iptables=1#g&quot;</span>  /etc/sysctl.conf<span class="hljs-comment"># 可能没有，追加</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf<span class="hljs-comment"># 执行命令以应用</span>sysctl -p<span class="hljs-comment"># 配置apt源</span>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF<span class="hljs-comment"># 卸载旧版本</span>apt-get remove -y kubelet kubeadm kubectl<span class="hljs-comment"># 安装kubelet、kubeadm、kubectl</span>apt-get update &amp;&amp; apt-get install kubelet=1.16.0-00 kubeadm=1.16.0-00 kubectl=1.16.0-00<span class="hljs-comment"># 重启Docker 启动 kubelet</span>systemctl daemon-reloadsystemctl restart dockersystemctl <span class="hljs-built_in">enable</span> kubelet &amp;&amp; systemctl start kubeletkubectl versionkubeadm version</code></pre><h3 id="3-初始化Master"><a href="#3-初始化Master" class="headerlink" title="3. 初始化Master"></a>3. 初始化Master</h3><p>在Master节点执行</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># Email:cenzhongman@163.com</span><span class="hljs-comment"># （单机模式）集群统一的对外端口, 注意这个端口以后可以改为负载均衡的集群入口</span><span class="hljs-built_in">export</span> APISERVER_NAME=cluster.endpoint<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;127.0.0.1    <span class="hljs-variable">$&#123;APISERVER_NAME&#125;</span>&quot;</span> &gt;&gt; /etc/hosts<span class="hljs-comment"># 由K8s创建的虚拟内网</span><span class="hljs-built_in">export</span> POD_SUBNET= 10.100.0.1/20<span class="hljs-comment"># 查看完整配置选项 https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</span>rm -f ./kubeadm-config.yamlcat &lt;&lt;EOF &gt; ./kubeadm-config.yamlapiVersion: kubeadm.k8s.io/v1beta2kind: ClusterConfigurationkubernetesVersion: v1.16.0imageRepository: registry.aliyuncs.com/google_containerscontrolPlaneEndpoint: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APISERVER_NAME&#125;</span>:6443&quot;</span>networking:  podSubnet: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;POD_SUBNET&#125;</span>&quot;</span>  dnsDomain: <span class="hljs-string">&quot;cluster.local&quot;</span>EOF<span class="hljs-comment"># kubeadm init</span><span class="hljs-comment"># 根据您服务器网速的情况，您需要等候 3 - 10 分钟</span>kubeadm init --config=kubeadm-config.yaml --upload-certs<span class="hljs-comment"># 配置 kubectl</span>rm -rf /root/.kube/mkdir /root/.kube/cp -i /etc/kubernetes/admin.conf /root/.kube/config<span class="hljs-comment"># 安装 calico 网络插件</span><span class="hljs-comment"># 参考文档 https://docs.projectcalico.org/v3.8/getting-started/kubernetes/</span>rm -f calico.yamlwget https://docs.projectcalico.org/v3.8/manifests/calico.yamlsed -i <span class="hljs-string">&quot;s#192\.168\.0\.0/16#<span class="hljs-variable">$&#123;POD_SUBNET&#125;</span>#&quot;</span> calico.yamlkubectl apply -f calico.yaml</code></pre><ul><li>监控运行状态</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态</span>watch kubectl get pod -n kube-system -o wide<span class="hljs-comment"># 查看 master 节点初始化结果</span>kubectl get nodes -o wide</code></pre><ul><li>撤销初始化操作</li></ul><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-built_in">export</span> NODE_NAME=$(kubectl get nodes -o go-template --template <span class="hljs-string">&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span>)<span class="hljs-comment"># 排空节点</span>kubectl drain <span class="hljs-variable">$&#123;NODE_NAME&#125;</span> --delete-local-data --force --ignore-daemonsetskubectl delete node <span class="hljs-variable">$&#123;NODE_NAME&#125;</span><span class="hljs-comment"># 重置安装器</span>kubeadm reset</code></pre><h3 id="4-初始化Workers"><a href="#4-初始化Workers" class="headerlink" title="4. 初始化Workers"></a>4. 初始化Workers</h3><ul><li><p>获得Join命令</p>  <pre><code class="hljs sh"><span class="hljs-comment">#【Master】获得Json命令</span>kubeadm token create --<span class="hljs-built_in">print</span>-join-command</code></pre></li><li><p>加入集群</p>  <pre><code class="hljs sh"><span class="hljs-comment"># 注意手动替换参数 $&#123;MASTER_IP&#125;主节点IP    $&#123;APISERVER_NAME&#125;上文APISERVER_NAME参数的值</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;MASTER_IP&#125;</span>    <span class="hljs-variable">$&#123;APISERVER_NAME&#125;</span>&quot;</span> &gt;&gt; /etc/hostskubeadm join cluster.endpoint:6443 --token 2gbe21.q0y22wt9o9ya674a     --discovery-token-ca-cert-hash sha256:acd189d273d7e5b8b9222f877e0b62b8bf6f8e659fc2679b5bfb84a8b9f4d6a2</code></pre></li><li><p>从集群中删除节点</p>  <pre><code class="hljs sh"><span class="hljs-comment"># 【Master】排空节点</span>kubectl drain <span class="hljs-variable">$&#123;NODE_NAME&#125;</span> --delete-local-data --force --ignore-daemonsetskubectl delete node <span class="hljs-variable">$&#123;NODE_NAME&#125;</span></code></pre></li></ul><h3 id="5-验证集群"><a href="#5-验证集群" class="headerlink" title="5. 验证集群"></a>5. 验证集群</h3><pre><code class="hljs sh">kubectl get nodes</code></pre><h3 id="6-安装Dashoard"><a href="#6-安装Dashoard" class="headerlink" title="6. 安装Dashoard"></a>6. 安装Dashoard</h3><p><a href="02-%E5%AE%89%E8%A3%85Dashboard/">安装Dashboard</a></p><h3 id="7-HA拓展"><a href="#7-HA拓展" class="headerlink" title="7. HA拓展"></a>7. HA拓展</h3><h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>参考</p><ul><li><a href="https://kuboard.cn/install/install-k8s.html">kuboard-使用kubeadm单节点安装</a></li><li><a href="https://kuboard.cn/install/install-k8s.html">kuboard-使用kubeadmHA安装</a></li></ul><h2 id="MacOS-Docker-Desktop"><a href="#MacOS-Docker-Desktop" class="headerlink" title="MacOS Docker Desktop"></a>MacOS Docker Desktop</h2><ul><li><p><a href="https://kuboard.cn/install/install-docker-desktop.html">kuboard-WIN_MAC安装</a></p></li><li><p>Mac开启K8s卡住动, 谷歌源导致镜像下不来的原因</p></li></ul><pre><code>1. 克隆项目<pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/maguowei/k8s-docker-desktop-for-mac.git<span class="hljs-built_in">cd</span> k8s-docker-desktop-for-mac</code></pre>1. 检查`images`文件的配置和Docker-Desktop是否相同![](../images/2019-09-27-15-37-48.png)1. 下载镜像<pre><code class="hljs sh">./load_images.sh</code></pre>1. 重启Kubernates参考* [k8s-docker-desktop-for-mac](https://github.com/maguowei/k8s-docker-desktop-for-mac)* [MacOS Docker fix &quot;kubernetes is starting&quot;](https://blog.csdn.net/bacteriumX/article/details/87856225)</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-安装Dashboard</title>
    <link href="/04-Linux/03-k8s/03-%E5%AE%89%E8%A3%85Dashboard/"/>
    <url>/04-Linux/03-k8s/03-%E5%AE%89%E8%A3%85Dashboard/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Dashboard"><a href="#安装Dashboard" class="headerlink" title="安装Dashboard"></a>安装Dashboard</h1><ul><li><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">官方-安装Web-UI</a></li></ul><h2 id="安装Dashboard-1"><a href="#安装Dashboard-1" class="headerlink" title="安装Dashboard"></a>安装Dashboard</h2><ol><li><p>安装官方的Dashboard描述文件</p> <pre><code class="hljs sh"><span class="hljs-comment"># 安装Dashboard应用程序</span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml<span class="hljs-comment"># 开启代理转发</span>kubectl proxy</code></pre></li><li><p>注册用户</p><p> 必须注册一个用户，超级用户如下</p> <pre><code class="hljs yaml"><span class="hljs-comment">#admin-user-admin.rbac.yaml</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><span class="hljs-attr">metadata:</span><span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><span class="hljs-meta">---</span><span class="hljs-comment"># Create ClusterRoleBinding</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><span class="hljs-attr">metadata:</span><span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><span class="hljs-attr">roleRef:</span><span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><span class="hljs-attr">subjects:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span></code></pre> <pre><code class="hljs sh">kubectl create -f admin-user-admin.rbac.yaml</code></pre><p> <a href="https://www.jianshu.com/p/3af2f9ee4cf8">非超级用户</a></p></li><li><p>获得Token</p> <pre><code class="hljs sh">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)</code></pre><ul><li><p>会得到以下的token</p><pre><code class="hljs bash">Name:         admin-user-token-hmctlNamespace:    kube-systemLabels:       &lt;none&gt;Annotations:  kubernetes.io/service-account.name: admin-user              kubernetes.io/service-account.uid: 00774986-5066-11e9-a0e8-fe242749c541Type:  kubernetes.io/service-account-tokenData====ca.crt:     1025 bytesnamespace:  11 bytestoken:      xxxxxxxxxxxxx</code></pre></li></ul></li><li><p>访问浏览器</p><ul><li><p>注意，8081只绑定了127.0.0.1因此只能本地访问</p><p><a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a></p><p><img src="../images/2019-09-26-10-52-18.png"></p></li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/3af2f9ee4cf8">Dashboard用户登录问题</a></li><li><a href="99-yewei-%E9%83%A8%E7%BD%B2k8s%E5%88%86%E5%B8%83%E5%BC%8F/">yewei-部署k8s分布式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-安装Ingress Crontrollers</title>
    <link href="/04-Linux/03-k8s/04-%E5%AE%89%E8%A3%85Ingress%20Crontrollers/"/>
    <url>/04-Linux/03-k8s/04-%E5%AE%89%E8%A3%85Ingress%20Crontrollers/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Ingress-Controller"><a href="#安装Ingress-Controller" class="headerlink" title="安装Ingress Controller"></a>安装Ingress Controller</h1><p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">官方-多种Ingress-controller方案选择</a><br><a href="https://www.nginx.com/products/nginx/kubernetes-ingress-controller">Nginx-Ingress-Controller</a><br><a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/installation/">Nginx-Installration</a></p><p>基本无坑，按着官方教程安装就可以了</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-从外部访问Pod</title>
    <link href="/04-Linux/03-k8s/05-%E4%BB%8E%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEPod/"/>
    <url>/04-Linux/03-k8s/05-%E4%BB%8E%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEPod/</url>
    
    <content type="html"><![CDATA[<h1 id="从外部访问Pod"><a href="#从外部访问Pod" class="headerlink" title="从外部访问Pod"></a>从外部访问Pod</h1><p><a href="https://blog.csdn.net/u013061106/article/details/79748511">从外部访问Pod的几种方式</a></p><h2 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h2><p><a href="http://localhost:8001/api/v1/namespaces/$NAME_SAPCE/services/http:docker-registry-frontend:5080/proxy/home">http://localhost:8001/api/v1/namespaces/$NAME_SAPCE/services/http:docker-registry-frontend:5080/proxy/home</a></p><p>kubectl proxy开放8081</p><h2 id="2-hostNetwork-true"><a href="#2-hostNetwork-true" class="headerlink" title="2. hostNetwork: true"></a>2. hostNetwork: true</h2><p>直接使用宿主主机网络</p><p><img src="../images/2019-09-30-09-44-39.png"></p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">influxdb</span></code></pre><p>访问http://$POD_HOST:port直接访问到Pod，这种方式可能因为集群内的调度而导致部署的Pod发生变化，也可能产生端口冲突等问题。</p><p>这种方式适合作为网络插件在所有主机上部署，可以直接管理集群的网络。</p><h2 id="3-Hostport"><a href="#3-Hostport" class="headerlink" title="3. Hostport"></a>3. Hostport</h2><p>将宿主主机端口与容器进行路由</p><p><img src="../images/2019-09-30-09-46-09.png"></p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">influxdb</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8086</span>          <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8086</span></code></pre><p>通过宿主主机的IP可以访问，这种方式可能因为集群内的调度而导致部署的Pod发生变化。</p><p>类似于Docker中使用的网络映射，这是在不干涉宿主主机网络的原则上，最直接访问Pod的方式。<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">nginx Ingress controller</a>就是用这种网络方式实现的。</p><h2 id="4-ClusterIP"><a href="#4-ClusterIP" class="headerlink" title="4. ClusterIP"></a>4. ClusterIP</h2><p>kubenates Service 默认的方式，这种方式将创建一个<code>ClusterIP</code>，仅供集群内部访问，通过<code>ClusterIP</code>访问Pods的流量将会被负载均衡到各个容器。</p><p><img src="../images/2019-09-30-09-53-13.png"></p><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8086</span>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30000</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span></code></pre><h2 id="5-NodePort"><a href="#5-NodePort" class="headerlink" title="5. NodePort"></a>5. NodePort</h2><p>使用kube的代理功能kube-proxy，代理指定端口的流量，再分发给Pods处理。<code>nodePort</code>可指定的范围30000-32767, </p><p><img src="../images/2019-09-30-09-58-07.png"></p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">influxdb</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8086</span></code></pre><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8086</span>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30000</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span></code></pre><p>这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。</p><h2 id="6-LoadBalancer"><a href="#6-LoadBalancer" class="headerlink" title="6. LoadBalancer"></a>6. LoadBalancer</h2><p>LoadBalancer 只能在service上定义。这是公有云提供的负载均衡器，如AWS、Azure、CloudStack、GCE等。</p><p><img src="../images/2019-09-30-10-08-20.png"></p><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8086</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">influxdb</span></code></pre><pre><code class="hljs sh">$ kubectl get svc influxdbNAME       CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGEinfluxdb   10.97.121.42   10.13.242.236   8086:30051/TCP   39s</code></pre><p>内部：$CLUSTER-IP:8086<br>外部：</p><ol><li>$EXTERNAL-IP:8086</li><li>$NODE_IP:30051</li></ol><h2 id="7-Ingress"><a href="#7-Ingress" class="headerlink" title="7. Ingress"></a>7. Ingress</h2><p>Ingress 中文:入口。使用前需要安装<code>Ingress Controller</code>, <code>Ingress Controller</code>提供像nginx或HAProxy的负载均衡器和一个控制器守护进程兼容,由不同的开发商提供。</p><p><code>Ingress Resource</code>提供<code>Ingress Controller</code>规则更新，通过这些规则，使得流量直接由Ingress代理，转发。不需再经过kube-proxy的转发，比LoadBalancer方式更高效。</p><p>尽管，Ingress指向Service，但是流量将不经过Service的VIP的负载均衡，直接转发给Pods.</p><p><img src="../images/2019-09-30-11-18-41.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是K8s中所有的网络方式，这些网络决定了K8S非常重要的流量流向。</p><p>Ingress由于其灵活行，高效性，非侵入性，安全性等优点，成为最受欢迎的使用方式，也是我们作为Web部署最可靠的方式。</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-安装Application</title>
    <link href="/04-Linux/03-k8s/06-%E5%AE%89%E8%A3%85Application/"/>
    <url>/04-Linux/03-k8s/06-%E5%AE%89%E8%A3%85Application/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Application"><a href="#安装Application" class="headerlink" title="安装Application"></a>安装Application</h1><ul><li><a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">官方-安装Nginx</a></li><li><a href="http://docs.kubernetes.org.cn/717.html">k8s中文社区-安装前后端应用</a></li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li><input disabled="" type="checkbox"> 部署一个<strong>集群内/外</strong>均可访问的Docker镜像仓库</li><li><input disabled="" type="checkbox"> 镜像仓库的数据安全可迁移</li><li><input disabled="" type="checkbox"> 开发者可以将自己构建的镜像推到镜像仓库</li><li><input disabled="" type="checkbox"> 新加入的机器可以通过Docker镜像仓库拉取镜像</li><li><input checked="" disabled="" type="checkbox"> 镜像仓库有WEB界面可以操作</li></ul><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ol><li>已经安装了k8s集群，如果没有，请参考<a href="02-%E5%AE%89%E8%A3%85Dashboard/">02-安装Dashboard</a>安装集群</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="1-部署docker-registry"><a href="#1-部署docker-registry" class="headerlink" title="1. 部署docker-registry"></a>1. 部署docker-registry</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 查询`kubectl api-versions`可见所有支持apiVersion 与 kind 有对应关系</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span> <span class="hljs-comment"># 声明创建的类型为Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># 声明名称</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># Deployment用来找自己管辖区域的Pod 必须与 `metadata.labels:`一致</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 容器副本数</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># 标注，一般会加上`app:$NAME` 可以添加别的label</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># 声明挂载</span>          <span class="hljs-attr">hostPath:</span>            <span class="hljs-attr">path:</span> <span class="hljs-string">/Users/cenzhongman/docker-registry</span> <span class="hljs-comment"># 容器外挂载路径</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># 容器名</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2.7.1</span> <span class="hljs-comment"># 基于镜像</span>          <span class="hljs-attr">volumeMounts:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># 使用声明好的挂载</span>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/registry</span> <span class="hljs-comment"># 容器内挂载的路径</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 容器中需要开放的端口</span></code></pre><p>无注解版本</p><pre><code class="hljs yaml"><span class="hljs-comment"># docker-registry.yaml</span><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># Email:cenzhongman@163.com</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span>          <span class="hljs-attr">hostPath:</span>            <span class="hljs-attr">path:</span> <span class="hljs-string">/Users/cenzhongman/docker-registry</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2.7.1</span>          <span class="hljs-attr">volumeMounts:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/registry</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><p>运行</p><pre><code class="hljs sh">kubectl create -f docker-registry.yaml</code></pre><p>后端通过<code>Deployment</code>程序会启动<code>Pod</code>来运行一个或多个<code>docker-registry</code>容器，可以通过Dashboard实现监控。此时仅仅是启动了这个容器，我们要怎么通过5000端口访问呢，靠容器名<code>docker-registry</code>？ 其实创建的容器容器名并不是<code>docker-registry</code>，因为如果我们设置<code>replicas=2</code>时，需要启动多个容器。</p><p>kubenate引入Service来为Pods提供稳定的网络访问服务。</p><p>监控</p><pre><code class="hljs sh">kubectl get pods -o wide</code></pre><p>可以看到服务的运行情况，容器的IP，但是这个IP并没有在宿主主机挂载网络，所以<strong>无法</strong>通过<code>容器IP:port</code>来访问。</p><h2 id="2-创建后端Service对象"><a href="#2-创建后端Service对象" class="headerlink" title="2. 创建后端Service对象"></a>2. 创建后端Service对象</h2><p>service 是前端连接后端的主要桥梁，Service 创建一个固定 IP 和 DNS 解析名入口， 使得后端Pods可达。Service 使用 selector 标签来寻找目标 Pod。</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span> <span class="hljs-comment"># 与Service对应</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span> <span class="hljs-comment"># 声明创建的类型为Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># Service name</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span> <span class="hljs-comment"># Service 使用 selector label 来寻找目标 Pod。</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span> <span class="hljs-comment"># ClusterIP，NodePort，LoadBalancer</span>  <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 网络解释看下面注释</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span>       <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><span class="hljs-comment"># port: 5000          # A 【Service】集群内网端口 D -&gt; B -&gt; A</span><span class="hljs-comment"># targetPort: 5000    # B 【Service】Pod暴露的端口 D -&gt; B</span><span class="hljs-comment"># nodePort: 5000      # C 【Service】外部访问端口 D -&gt; B -&gt; C</span><span class="hljs-comment"># containerPort: 5000 # D 【Deployment】容器的实际端口 D 在Deployment中说明，若不声明于targetPort一致</span></code></pre><p>无注解版本</p><pre><code class="hljs yaml"><span class="hljs-comment"># docker-registry.yaml</span><span class="hljs-comment"># Author:cenzhongman</span><span class="hljs-comment"># Email:cenzhongman@163.com</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span></code></pre><p>此时，通过Service，创建了一个稳定的IP和DNS</p><p>DNS:<code>docker-registry:5000</code><br>IP:<code>CLUSTER-IP:5000</code>访问</p><p>查看IP</p><pre><code class="hljs sh">kubectl service -o wide</code></pre><h2 id="3-部署前端"><a href="#3-部署前端" class="headerlink" title="3. 部署前端"></a>3. 部署前端</h2><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry-frontend</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry-frontend</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry-frontend</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry-frontend</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">konradkleine/docker-registry-frontend:v2</span>          <span class="hljs-attr">env:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_DOCKER_REGISTRY_HOST</span>              <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;docker-registry&quot;</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ENV_DOCKER_REGISTRY_PORT</span>              <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;5000&quot;</span></code></pre><p>通过Service发布固定的前端地址</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry-frontend</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">docker-registry-frontend</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>  <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">5080</span>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span></code></pre><p>通过Ingress实现转发</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-registry-ingress</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">http:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">localhost</span>  <span class="hljs-comment"># tls:</span>  <span class="hljs-comment"># - hosts:</span>  <span class="hljs-comment">#   - cafe.example.com</span>    <span class="hljs-comment"># secretName: cafe-secret</span>  <span class="hljs-attr">rules:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>    <span class="hljs-attr">http:</span>      <span class="hljs-attr">paths:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/docker-registry</span>        <span class="hljs-attr">backend:</span>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">docker-registry-frontend</span>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">5080</span></code></pre><p><a href="http://localhost:8001/api/v1/namespaces/default/services/http:docker-registry-frontend:5080/proxy/home">http://localhost:8001/api/v1/namespaces/default/services/http:docker-registry-frontend:5080/proxy/home</a></p><h2 id="已知BUG"><a href="#已知BUG" class="headerlink" title="已知BUG"></a>已知BUG</h2><p>无法在Dashboard中和直接删除Deployments</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-ConfigMap的使用</title>
    <link href="/04-Linux/03-k8s/07-ConfigMap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/04-Linux/03-k8s/07-ConfigMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ConfigMap-的使用"><a href="#ConfigMap-的使用" class="headerlink" title="ConfigMap 的使用"></a>ConfigMap 的使用</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><span class="hljs-attr">data:</span>  <span class="hljs-attr">mysql.replication.username:</span> <span class="hljs-string">&#x27;replication&#x27;</span>  <span class="hljs-attr">mysql.replication.password:</span> <span class="hljs-string">&#x27;password&#x27;</span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>There are two approaches, using valueFrom for individual values or envFrom for multiple values.</p><p>valueFrom is used inside the  env attribute, like this:</p><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ad-sync</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">foo.azurecr.io/foobar/ad-sync</span>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;dotnet&quot;</span>, <span class="hljs-string">&quot;AdSyncService.dll&quot;</span>]        <span class="hljs-attr">args:</span> []        <span class="hljs-attr">env:</span>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">AdSyncService</span>            <span class="hljs-attr">valueFrom:</span>              <span class="hljs-attr">configMapKeyRef:</span>                <span class="hljs-attr">name:</span> <span class="hljs-string">ad-sync-service-configmap</span>                <span class="hljs-attr">key:</span> <span class="hljs-string">log_level</span></code></pre><p>envFrom is used direct inside the container attribure like this:</p><pre><code class="yaml">spec:  template:    spec:      containers:      - name: ad-sync        image: foo.azurecr.io/foobar/ad-sync        command: [&quot;dotnet&quot;, &quot;AdSyncService.dll&quot;]        envFrom:          - configMapRef:              name: ad-sync-service-configmap</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-使用PersistentVolume实现Stateful单节点应用</title>
    <link href="/04-Linux/03-k8s/07-%E4%BD%BF%E7%94%A8PersistentVolume%E5%AE%9E%E7%8E%B0Stateful%E5%8D%95%E8%8A%82%E7%82%B9%E5%BA%94%E7%94%A8/"/>
    <url>/04-Linux/03-k8s/07-%E4%BD%BF%E7%94%A8PersistentVolume%E5%AE%9E%E7%8E%B0Stateful%E5%8D%95%E8%8A%82%E7%82%B9%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="使用PersistentVolume实现Stateful单节点应用"><a href="#使用PersistentVolume实现Stateful单节点应用" class="headerlink" title="使用PersistentVolume实现Stateful单节点应用"></a>使用PersistentVolume实现Stateful单节点应用</h1><p><a href="https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/">官方-单节点有状态应用</a></p><p>Stateful是kubenetes提出的用于有状态服务的应用程序，如数据库，存储等</p><h2 id="单点数据持久化"><a href="#单点数据持久化" class="headerlink" title="单点数据持久化"></a>单点数据持久化</h2><h3 id="创建PersistentVolumeClaim"><a href="#创建PersistentVolumeClaim" class="headerlink" title="创建PersistentVolumeClaim"></a>创建PersistentVolumeClaim</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-pv-volume</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">local</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span>  <span class="hljs-attr">capacity:</span>    <span class="hljs-attr">storage:</span> <span class="hljs-string">20Gi</span>  <span class="hljs-attr">accessModes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-attr">hostPath:</span>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mnt/data&quot;</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-pv-claim</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span>  <span class="hljs-attr">accessModes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-attr">requests:</span>      <span class="hljs-attr">storage:</span> <span class="hljs-string">20Gi</span></code></pre><h3 id="将数据挂载到PersistentVolumeClaim"><a href="#将数据挂载到PersistentVolumeClaim" class="headerlink" title="将数据挂载到PersistentVolumeClaim"></a>将数据挂载到PersistentVolumeClaim</h3><pre><code class="hljs yaml"><span class="hljs-string">application/mysql/mysql-deployment.yaml</span> <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span>  <span class="hljs-attr">strategy:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.6</span>        <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span>        <span class="hljs-attr">env:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD</span>          <span class="hljs-attr">value:</span> <span class="hljs-string">password</span>        <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">3306</span>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span>        <span class="hljs-attr">volumeMounts:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-persistent-storage</span>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span>      <span class="hljs-comment"># 使用一个persistentVolumeClaim来作为持久存储卷</span>      <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-persistent-storage</span>        <span class="hljs-attr">persistentVolumeClaim:</span>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">mysql-pv-claim</span></code></pre><p>对比直接挂载文件</p><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-persistent-storage</span>    <span class="hljs-attr">hostPath:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/Users/cenzhongman/mysql</span></code></pre><p>查看挂载详情</p><pre><code class="hljs sh">kubectl describe pvc mysql-pv-claim---Name:         mysql-pv-claimNamespace:    defaultStorageClass:Status:       BoundVolume:       mysql-pv-volumeLabels:       &lt;none&gt;Annotations:    pv.kubernetes.io/<span class="hljs-built_in">bind</span>-completed=yes                pv.kubernetes.io/bound-by-controller=yesCapacity:     20GiAccess Modes: RWOEvents:       &lt;none&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-使用StatefulSet实现Mysql主从数据库</title>
    <link href="/04-Linux/03-k8s/08-%E4%BD%BF%E7%94%A8StatefulSet%E5%AE%9E%E7%8E%B0Mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/04-Linux/03-k8s/08-%E4%BD%BF%E7%94%A8StatefulSet%E5%AE%9E%E7%8E%B0Mysql%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="使用StatefulSet实现主从数据库"><a href="#使用StatefulSet实现主从数据库" class="headerlink" title="使用StatefulSet实现主从数据库"></a>使用StatefulSet实现主从数据库</h1><p><a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/">官方-使用StatefulSet实现主从Mysql</a><br><a href="https://www.jianshu.com/p/da0b339e1274">基于Kubernetes搭建MySQL主从集群</a></p><h2 id="Mysql主从数据库基础"><a href="#Mysql主从数据库基础" class="headerlink" title="Mysql主从数据库基础"></a>Mysql主从数据库基础</h2><p>Mysql主从数据库的设计，一般使用读写分离的设计，主数据库进行写入操作（包括<strong>insert、update、delete</strong>）从数据库进行读取操作。</p><p><img src="../images/2019-10-08-10-14-08.png"></p><p>主从复制</p><p>使用Binlog进行主从同步，该方案由MySQL原生支持，步骤如下：</p><ol><li>Master启动Binlog</li><li>Slaver通过一个IO线程监控Binlog的变化</li><li>Slaver监控到Binlog变化，将Master的日志复制到Slaver的中继日志中</li><li>Slaver读取中继日志并执行相应的操作。</li></ol><p><img src="../images/2019-10-08-10-14-21.png"></p><h2 id="基于物理主机搭建"><a href="#基于物理主机搭建" class="headerlink" title="基于物理主机搭建"></a>基于物理主机搭建</h2><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ol><li>文件/etc/my.cnf中[mysqld]下添加配置 <pre><code class="hljs properties"><span class="hljs-meta">log-bin</span>=<span class="hljs-string">mysql-bin</span><span class="hljs-comment"># 注意 id不能为0</span><span class="hljs-meta">server-id</span>=<span class="hljs-string">1</span></code></pre></li><li>重启MySQL <pre><code class="hljs sh">service mysqld restart</code></pre></li><li>创建同步账号 <pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;sync&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;MySQL@lipuan.2018&#x27;</span>;</code></pre></li><li>赋予同步账号远程权限 <pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">replication</span> <span class="hljs-keyword">slave</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;sync&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;MySQL@lipuan.2018&#x27;</span>;</code></pre></li></ol><h3 id="Slaver"><a href="#Slaver" class="headerlink" title="Slaver"></a>Slaver</h3><ol><li>文件/etc/my.cnf中[mysqld]下添加配置 <pre><code class="hljs properties"><span class="hljs-meta">log-bin</span>=<span class="hljs-string">mysql-bin</span><span class="hljs-meta">server-id</span>=<span class="hljs-string">2</span></code></pre></li><li>重启MySQL <pre><code class="hljs sh">service mysqld restart</code></pre></li><li>配置主机IP <pre><code class="hljs sql"><span class="hljs-keyword">change</span> <span class="hljs-keyword">master</span> <span class="hljs-keyword">to</span> master_host=<span class="hljs-string">&#x27;x.x.x.x&#x27;</span>,master_user=<span class="hljs-string">&#x27;sync&#x27;</span>,master_password=<span class="hljs-string">&#x27;MySQL@lipuan.2018&#x27;</span>;</code></pre>注意: server-id为主机标识，不能重复。x.x.x.x’为master服务器IP</li></ol><h2 id="使用Docker搭建"><a href="#使用Docker搭建" class="headerlink" title="使用Docker搭建"></a>使用Docker搭建</h2><p>思路：通过官方镜像提供的初始化功能，实现主从数据库的用户 连接信息建立等。</p><p><a href="https://hub.docker.com/_/mysql">MySQL官方镜像</a><br><a href="https://blog.csdn.net/boling_cavalry/article/details/79775617">Dokcer-主从MySQL</a></p><h3 id="Master-1"><a href="#Master-1" class="headerlink" title="Master"></a>Master</h3><p>由官方的<a href="https://github.com/docker-library/mysql/blob/4af273a07854d7e4b68c5148b8e23b86aa8706e2/8.0/docker-entrypoint.sh">docker-entrypoint.sh</a>我们可以看到</p><pre><code class="hljs sh"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> /docker-entrypoint-initdb.d/*; <span class="hljs-keyword">do</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$f</span>&quot;</span> <span class="hljs-keyword">in</span>                    *.sh)     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>: running <span class="hljs-variable">$f</span>&quot;</span>; . <span class="hljs-string">&quot;<span class="hljs-variable">$f</span>&quot;</span> ;;                    *.sql)    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>: running <span class="hljs-variable">$f</span>&quot;</span>; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mysql[@]&#125;</span>&quot;</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$f</span>&quot;</span>; <span class="hljs-built_in">echo</span> ;;                    *.sql.gz) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>: running <span class="hljs-variable">$f</span>&quot;</span>; gunzip -c <span class="hljs-string">&quot;<span class="hljs-variable">$f</span>&quot;</span> | <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mysql[@]&#125;</span>&quot;</span>; <span class="hljs-built_in">echo</span> ;;                    *)        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>: ignoring <span class="hljs-variable">$f</span>&quot;</span> ;;            <span class="hljs-keyword">esac</span><span class="hljs-keyword">done</span></code></pre><p>官方的docker-entrypoint文件会遍历<code>/docker-entrypoint-initdb.d/</code>文件中的<strong>sh文件，sql文件，sql.gz压缩包</strong>，随后按照sh&gt;sql&gt;sql.gz的顺序依次执行。当该文件夹只存在一种文件时，便会按照文件名排序后执行。</p><p>因此我们吧初始化语句加到<code>/docker-entrypoint-initdb.d/</code>文件夹中，即可实现初始化。</p><h2 id="使用Kubenetes搭建"><a href="#使用Kubenetes搭建" class="headerlink" title="使用Kubenetes搭建"></a>使用Kubenetes搭建</h2><p><a href="mysql.yaml">使用Kubenetes搭建</a></p><p>注意点</p><ol><li>限制了Slaver集群普通用户写入，不建议使用root用户进行数据库操作<ul><li>Master 任意用户均可进行读写操作</li><li>Slaver仅Root用户可以进行写入（不会进行从-&gt;主同步），普通用户仅有读取权限，实现方式<code>set global read_only=1;</code>参考<a href="https://blog.csdn.net/xieyunc/article/details/80527465">保证Slaver数据库只读</a></li></ul></li><li>数据库同步的实现<ul><li>使用MySQL的数据库同步方案，通过Master产生Binlog，slaver通过同步账号IO读取日志，然后执行日志</li></ul></li><li>使用ConfigMap实现数据库的共同配置<ul><li>mysql.replication.username: “”   同步账户名</li><li>mysql.replication.password: “”   同步的密码</li><li>mysql.root.password: “”          root用户的账户密码</li><li>mysql.timezone: “Asia/Shanghai”  时区</li></ul></li><li>Service 的 Port 方式为 NodePort<ul><li>不使用NodePort也可以在slaver中使用mysql-master连接Master</li><li>NodePort将数据库，Master集群，SLaver集群暴露在任意Node上，端口指定范围30000-32700</li></ul></li><li>initContainers 目的在于生成两个文件，因此必须挂载这两个文件的目录，以供下面的Containers使用<ul><li>/etc/mysql/conf.d/mysqld.cnf</li><li>/docker-entrypoint-initdb.d/init_sync.sql</li></ul></li><li>mysql配置文件中，server-id必须从1开始，且为数字，而StatefulSet从0开始，不能直接截取hostname的后缀就作为server-id，本文Master+100，Slaver+1</li><li>上述server-id Master和Slaver加的值不同，原因是这是两个StatefulSet集群，他们都是从0开始，而Mysql中，任意节点的ID不能相同</li><li>readinessProbe通过对TCP端口的监控检查容器的健康状态</li><li>volumeClaimTemplates为持久化存储，且根据ID与容器密切绑定</li><li>ReadWriteOnce  表示仅支持一个节点读写操作，对应的还有<code>ReadWriteMany</code>等</li><li>Slaver不能在配置文件中设置<code>super-read-only</code>，会导致初始化SQL中的增加同步用户操作无效，参考<strong>注意点1</strong></li></ol><h3 id="初始化操作initContainers"><a href="#初始化操作initContainers" class="headerlink" title="初始化操作initContainers"></a>初始化操作initContainers</h3><p><a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/#understanding-stateful-pod-initialization">understanding-stateful-pod-initialization</a><br><a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">Init Containers</a></p><p><code>initContainers</code>初始化镜像，供<code>containers</code>使用, 初始化程序执行失败，就一直等待。与yaml文件的顺序无关，与声明的image相关。</p><h2 id="踩坑日志"><a href="#踩坑日志" class="headerlink" title="踩坑日志"></a>踩坑日志</h2><h3 id="1-主从数据库同步失败"><a href="#1-主从数据库同步失败" class="headerlink" title="1. 主从数据库同步失败"></a>1. 主从数据库同步失败</h3><p>原因：可能原因很多<br>解决：通过命令查看同步日志<br>  <pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">slave</span> <span class="hljs-keyword">status</span>;<span class="hljs-keyword">show</span> <span class="hljs-keyword">master</span> <span class="hljs-keyword">status</span>;</code></pre><br>参考：<a href="https://www.cnblogs.com/shqblogs/p/5562877.html">https://www.cnblogs.com/shqblogs/p/5562877.html</a></p><h3 id="2-同步失败，登录失败"><a href="#2-同步失败，登录失败" class="headerlink" title="2. 同步失败，登录失败"></a>2. 同步失败，登录失败</h3><ul><li>报错：error connecting to master ‘test@mysql-0.mysql:3306’ - retry-time: 60 retries: 12 message: Access denied for user ‘test’@’mysql-1.mysql.default.svc.cluster.local’ (using password: YES)</li><li>错误码：1045</li><li>原因：可能是授权的登录范围问题，尝试使用<code>%</code></li><li>解决：<code>CREATE USER &#39;repl&#39;@&#39;%&#39; IDENTIFIED WITH &#39;mysql_native_password&#39; BY &#39;PASSWORD&#39;;</code></li></ul><h3 id="3-同步失败，需要安全的验证方式"><a href="#3-同步失败，需要安全的验证方式" class="headerlink" title="3. 同步失败，需要安全的验证方式"></a>3. 同步失败，需要安全的验证方式</h3><ul><li>报错：Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection.</li><li>错误码：2061</li><li>原因：MySQL8.0默认指定使用需要SSL的身份验证插件caching_sha2_password，而我们在创建同步复制账号时候没有指定REQUIRE SSL。为了降低这件事情的复杂性，我们选择了社区的解决方法，选择绕过SSL插件的验证，改为mysql_native_password验证来做同步复制。</li><li>解决：<code>CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED WITH &#39;mysql_native_password&#39; BY &#39;Data*2018*&#39;;CREATE USER &#39;repl&#39;@&#39;192.168.1.3&#39; IDENTIFIED WITH &#39;mysql_native_password&#39; BY &#39;PASSWORD&#39;;</code></li><li>参考：<a href="https://blog.csdn.net/wawa8899/article/details/86689618">https://blog.csdn.net/wawa8899/article/details/86689618</a></li></ul><h3 id="4-同步失败，主节点不能为0"><a href="#4-同步失败，主节点不能为0" class="headerlink" title="4. 同步失败，主节点不能为0"></a>4. 同步失败，主节点不能为0</h3><ul><li>报错：Got fatal error 1236 from master when reading data from binary log: ‘Misconfigured master - master server_id is 0’</li><li>错误码：13114</li><li>原因：节点ID不能从0开始，且只能是数字</li><li>解决：<code>server-id=1</code></li><li>参考：<a href="https://blog.csdn.net/sunbocong/article/details/89454600">https://blog.csdn.net/sunbocong/article/details/89454600</a></li></ul><h3 id="5-同步失败，Master和Slaver有相同的id"><a href="#5-同步失败，Master和Slaver有相同的id" class="headerlink" title="5. 同步失败，Master和Slaver有相同的id"></a>5. 同步失败，Master和Slaver有相同的id</h3><ul><li>报错：Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different for replication to work (or the –replicate-same-server-id option must be used on slave but this does not always make sense; please check the manual before using it). </li><li>错误码：13117</li><li>原因：Master 和 Slaver 的 server-id不能相同</li><li>解决：<code>server-id=?</code></li></ul><h3 id="5-重启后，设定的同步账号等数据不变"><a href="#5-重启后，设定的同步账号等数据不变" class="headerlink" title="5. 重启后，设定的同步账号等数据不变"></a>5. 重启后，设定的同步账号等数据不变</h3><p>原因：需要删除数据库的挂载。</p><h3 id="6-开启-super-read-only-保证Slaver只读-导致sql初始化失败"><a href="#6-开启-super-read-only-保证Slaver只读-导致sql初始化失败" class="headerlink" title="6. 开启 super-read-only 保证Slaver只读 导致sql初始化失败"></a>6. 开启 super-read-only 保证Slaver只读 导致sql初始化失败</h3><p>原因：super-read-only会导致增加同步的用户都加不进去<br>解决：使用其他方式实现只读<br>参考：<a href="https://blog.csdn.net/xieyunc/article/details/80527465">https://blog.csdn.net/xieyunc/article/details/80527465</a></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-readinessProbe容器探针</title>
    <link href="/04-Linux/03-k8s/09-readinessProbe%E5%AE%B9%E5%99%A8%E6%8E%A2%E9%92%88/"/>
    <url>/04-Linux/03-k8s/09-readinessProbe%E5%AE%B9%E5%99%A8%E6%8E%A2%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="readinessProbe容器探针"><a href="#readinessProbe容器探针" class="headerlink" title="readinessProbe容器探针"></a>readinessProbe容器探针</h1><p><a href="https://blog.51cto.com/3241766/2428879?source=dra">https://blog.51cto.com/3241766/2428879?source=dra</a></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-yewei-部署k8s分布式</title>
    <link href="/04-Linux/03-k8s/99-yewei-%E9%83%A8%E7%BD%B2k8s%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/04-Linux/03-k8s/99-yewei-%E9%83%A8%E7%BD%B2k8s%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><pre><code class="hljs bash">author: yewei_andyemail: 896882701yw@gmail.com</code></pre><h3 id="部署k8s分布式"><a href="#部署k8s分布式" class="headerlink" title="部署k8s分布式"></a>部署k8s分布式</h3><h4 id="主机配置："><a href="#主机配置：" class="headerlink" title="主机配置："></a>主机配置：</h4><h5 id="虚拟机方案："><a href="#虚拟机方案：" class="headerlink" title="虚拟机方案："></a>虚拟机方案：</h5><ol><li>使用虚拟机部署3个一样的centos7或者ubuntu虚拟机</li><li>配置2张网卡<ul><li>一张用来主机和虚拟机通讯(host only 网卡),master和node节点通信也是使用这张网卡</li><li>一张用来nat和外网通信</li></ul></li></ol><h5 id="三台物理机方案："><a href="#三台物理机方案：" class="headerlink" title="三台物理机方案："></a>三台物理机方案：</h5><ol><li>三台内网的主机即可，centos7或者ubuntu</li></ol><h4 id="配置docker的代理-主要用来拉取镜像使用"><a href="#配置docker的代理-主要用来拉取镜像使用" class="headerlink" title="配置docker的代理(主要用来拉取镜像使用)"></a>配置docker的代理(主要用来拉取镜像使用)</h4><pre><code class="hljs bash">mkdir -p /etc/systemd/system/docker.service.dcat &lt;&lt;EOF &gt;/etc/systemd/system/docker.service.d/http-proxy.conf[Service]Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://192.168.56.1:1087/&quot;</span>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://192.168.56.1:1087/&quot;</span>Environment=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com&quot;</span>EOFsystemctl daemon-reloadsystemctl restart docker</code></pre><ul><li><p>测试配置</p><pre><code class="hljs bash">docker info | grep Proxy  <span class="hljs-comment"># 有输出说明配置成功</span>docker pull gcr.io/google-containers/hello-world <span class="hljs-comment"># pull 成功代表代理器工作正常。</span></code></pre></li><li><p>也可以使用以下脚本去实现不代理就拉镜像</p><pre><code class="hljs bash">kubernetes_version=1.13.0 <span class="hljs-comment">#指定k8s版本</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `kubeadm config images list --kubernetes-version=<span class="hljs-variable">$&#123;kubernetes_version&#125;</span>`; <span class="hljs-keyword">do</span>  imageName=<span class="hljs-variable">$&#123;i#k8s.gcr.io/&#125;</span>  docker pull registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span>  docker tag registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span> k8s.gcr.io/<span class="hljs-variable">$imageName</span>  docker rmi registry.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span><span class="hljs-keyword">done</span>;</code></pre></li></ul><h4 id="配置终端代理-如果有需要"><a href="#配置终端代理-如果有需要" class="headerlink" title="配置终端代理(如果有需要)"></a>配置终端代理(如果有需要)</h4><h5 id="全局终端http-https代理"><a href="#全局终端http-https代理" class="headerlink" title="全局终端http/https代理:"></a>全局终端http/https代理:</h5><pre><code class="hljs bash">cat &lt;&lt;EOF &gt;&gt;/etc/environmenthttp_proxy=<span class="hljs-string">&quot;http://&#123;http代理地址&#125;:8118/&quot;</span>https_proxy=<span class="hljs-string">&quot;http://&#123;http代理地址&#125;:8118/&quot;</span>no_proxy=<span class="hljs-string">&quot;localhost, 127.0.0.1&quot;</span>EOF<span class="hljs-built_in">source</span> /etc/environment</code></pre><h5 id="仅限当前shell生效的代理-使用export"><a href="#仅限当前shell生效的代理-使用export" class="headerlink" title="仅限当前shell生效的代理(使用export):"></a>仅限当前shell生效的代理(使用export):</h5><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://&#123;http代理地址&#125;:8118/&quot;</span><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://&#123;http代理地址&#125;:8118/&quot;</span><span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost, 127.0.0.1&quot;</span></code></pre><h4 id="修改host-conf文件"><a href="#修改host-conf文件" class="headerlink" title="修改host.conf文件"></a>修改host.conf文件</h4><p>修改这个文件的目的在于使用主机名都能访问，不需要输入ip地址</p><ul><li>三台机都要设置</li></ul><pre><code class="hljs bash"><span class="hljs-comment">#192.168.56.101 yeweinode1</span><span class="hljs-comment"># /etc/hosts</span>&#123;节点1的ip&#125; 节点1的主机名&#123;节点2的ip&#125; 节点1的主机名&#123;节点3的ip&#125; 节点1的主机名</code></pre><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>由于k8s会大量修改防火墙的配置，因此在使用k8s的时候尽量关闭iptables或者防火墙</p><pre><code class="hljs bash">systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalldsystemctl stop ufwsystemctl <span class="hljs-built_in">disable</span> ufw</code></pre><h4 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h4><pre><code class="hljs bash"><span class="hljs-comment"># 临时禁用</span>setenforce 0<span class="hljs-comment"># 永久禁用 </span>vim /etc/selinux/config    <span class="hljs-comment"># 或者修改/etc/sysconfig/selinux</span>SELINUX=disabled</code></pre><h4 id="打开nf-bridge模块"><a href="#打开nf-bridge模块" class="headerlink" title="打开nf-bridge模块"></a>打开nf-bridge模块</h4><p>编辑<code>/etc/sysctl.conf</code>文件</p><pre><code class="hljs bash">net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-arptables = 1</code></pre><p>然后<code>sysctl -p</code>生效</p><h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4><pre><code class="hljs bash"><span class="hljs-comment"># 临时关闭</span>swapoff -a<span class="hljs-comment"># 注释掉以下字段</span>/dev/mapper/cl-swap     swap                    swap    defaults        0 0</code></pre><h5 id="如果不想关闭swap的话，需要做以下操作："><a href="#如果不想关闭swap的话，需要做以下操作：" class="headerlink" title="如果不想关闭swap的话，需要做以下操作："></a>如果不想关闭swap的话，需要做以下操作：</h5><ol><li><p>kubeadm 启动时候需要加入参数</p><pre><code class="hljs bash">--ignore-preflight-errors=swap</code></pre></li><li><p>修改<code> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></p></li><li><p>在这个文件加入以下代码:</p><pre><code class="hljs bash">Environment=<span class="hljs-string">&quot;KUBELET_EXTRA_ARGS=--fail-swap-on=false&quot;</span></code></pre><p>使得最后看起来像这样:</p><p><img src="http://storage.ywandy.top/20190416094438_KPueef_image-20190327143612345.jpeg"></p></li></ol><h4 id="命令行程序安装-安装kubectl-kubeadm-kubelet三个组件-："><a href="#命令行程序安装-安装kubectl-kubeadm-kubelet三个组件-：" class="headerlink" title="命令行程序安装(安装kubectl kubeadm kubelet三个组件)："></a>命令行程序安装(安装kubectl kubeadm kubelet三个组件)：</h4><h5 id="使用centos"><a href="#使用centos" class="headerlink" title="使用centos:"></a>使用centos:</h5><ul><li>配置软件源</li></ul><pre><code class="hljs bash">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</code></pre><ul><li>安装**<em>kubelet kubeadm kubectl**</em></li></ul><pre><code class="hljs bash">yum install -y kubelet-1.13.0 kubeadm-1.13.0 kubectl-1.13.0 kubernetes-cni-0.6.0-0systemctl <span class="hljs-built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</code></pre><h5 id="使用ubuntu"><a href="#使用ubuntu" class="headerlink" title="使用ubuntu:"></a>使用ubuntu:</h5><pre><code class="hljs bash">apt-get update &amp;&amp; apt-get install -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF  apt-get updateapt-get install -y kubelet kubeadm kubectl</code></pre><h4 id="使用kubeadm启动k8s"><a href="#使用kubeadm启动k8s" class="headerlink" title="使用kubeadm启动k8s"></a>使用kubeadm启动k8s</h4><ul><li>在node1(master)中执行</li></ul><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=&#123;这里填写node1的host-only网卡的地址&#125; --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=swap --kubernetes-version=1.12.7<span class="hljs-comment">#--apiserver-advertise-address 这个参数是k8s集群中master对外能访问的地址</span><span class="hljs-comment">#--pod-network-cidr=10.244.0.0/16 这一节是配置pod的内网网段</span><span class="hljs-comment">#--ignore-preflight-errors=swap 如果是使用swap启动的话，需要加这个参数</span></code></pre><ol><li><code>--apiserver-advertise-address=192.168.56.101</code> 绑定 apiserver 到 master 节点的 Host-Only 适配器的地址，默认是绑到 NAT 的地址上，这样其他机器是永远也访问不到的。</li><li><code>--pod-network-cidr=10.244.0.0/16</code> 指定 pod 网络地址空间，我们使用 flannel 组件必须使用这个空间<ul><li>等待node1执行结束，会有以下的输出：</li></ul></li></ol><p><img src="http://storage.ywandy.top/20190416094328_xmFxCd_image-20190327114031824.jpeg"></p><ul><li><p>如果你忘记了join的命令，可以使用如下命令重新生成一个</p><p><code>kubeadm token create --print-join-command</code></p><p><img src="http://storage.ywandy.top/20190506205959_ID0E8s_Screenshot.jpeg"></p></li></ul><h4 id="配置kubectl，使得能连上k8s的apiserver"><a href="#配置kubectl，使得能连上k8s的apiserver" class="headerlink" title="配置kubectl，使得能连上k8s的apiserver"></a>配置kubectl，使得能连上k8s的apiserver</h4><p>这时候需要使用kubectl接入kubernets的api，在我们刚刚的kubeadm init时候，程序已经为我们创建了kubectl的配置文件，这时候我们只需要export到环境变量即可</p><pre><code class="hljs bash">1.如果是root用户的话<span class="hljs-comment"># root user</span><span class="hljs-built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf2.如果是非root用户的话<span class="hljs-comment"># non-root user</span>mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config3.如果从其他机器操作的话<span class="hljs-comment"># 从本地主机操作，需要在本地安装 kubectl 客户端</span>mkdir -p ~/.kubescp &lt;username&gt;@&#123;远端服务器&#125;:/home/&lt;username&gt;/.kube/config ~/.kube/config <span class="hljs-comment"># 从 master 复制配置文件到本地</span><span class="hljs-comment">#把远端服务器的admin.conf拷贝到本地</span></code></pre><p>以上的操作其实是把kubectl需要用到的配置文件配置到kubectl的配置当中</p><p>当完成了以上操作后，kuberctl已经能使用了</p><ul><li>在终端输入：</li></ul><pre><code class="hljs bash">kubectl cluster-info</code></pre><ul><li>会有类似下面的输出：</li></ul><p><img src="http://storage.ywandy.top/20190416094438_huN7sN_image-20190327144224237.jpeg"></p><p>这时候kubectl命令是已经能正常连上api server，集群也处于可用状态</p><h4 id="安装flannel网络"><a href="#安装flannel网络" class="headerlink" title="安装flannel网络"></a>安装flannel网络</h4><ul><li>可以通过修改kube-flannel.yml文件去修改flannel的默认监听端口</li></ul><pre><code class="hljs bash">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml给 /opt/bin/flanneld 命令添加 --iface=<span class="hljs-string">&quot;br0&quot;</span> 参数 <span class="hljs-comment">#按照实际情况进行配置（一般情况下不需要）</span>kubectl apply -f kube-flannel.yml</code></pre><ul><li>测试配置</li></ul><pre><code class="hljs bash">kubectl get pods --all-namespaces -o wide <span class="hljs-comment"># 稍等一会，下载镜像需要一定时间，</span><span class="hljs-comment">#最后应该显示 flannel pods 是 Running 状态， kube-dns 也是 Running 状态</span></code></pre><p>​    如图：</p><p><img src="http://storage.ywandy.top/20190416095718_E7xJaU_image-20190416095647483.jpeg"></p><ul><li><p>如果出现coredns多次启动失败，可能是resolver被systemd取代了，因此要么禁用systemd的reslover，要么加入如下的参数到如下配置文件</p><pre><code class="hljs bash"><span class="hljs-comment">#/var/lib/kubelet/kubeadm-flags.env</span>--resolv-conf=/run/systemd/resolve/resolv.conf</code></pre></li></ul><h4 id="让master节点也参与调度"><a href="#让master节点也参与调度" class="headerlink" title="让master节点也参与调度"></a>让master节点也参与调度</h4><p>如果需要在master也进行pod调度（k8s默认不进行pod调度) 执行以下指令</p><pre><code class="hljs bash"><span class="hljs-comment"># taint命令用于配置污点</span><span class="hljs-comment">#k8s通过设定是否能容忍污点</span>kubectl taint nodes --all node-role.kubernetes.io/master-</code></pre><h4 id="其他节点加入集群"><a href="#其他节点加入集群" class="headerlink" title="其他节点加入集群"></a>其他节点加入集群</h4><ul><li>此时需要在要加入集群的服务器上面执行以下指令（当然网段要能访问到,并且已经安装了kubeadm）</li></ul><pre><code class="hljs bash">kubeadm join xxxxxxxxx:6443 --token xxxxxx.xxxxxxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxx</code></pre><p>这时候会出现以下的信息，说明已经成功加入了集群</p><p><img src="http://storage.ywandy.top/20190416094438_lG3lu2_image-20190327114341988.jpeg"></p><h4 id="查看核心组件的状态"><a href="#查看核心组件的状态" class="headerlink" title="查看核心组件的状态"></a>查看核心组件的状态</h4><p><code>kubectl get componentstatus</code></p><p><img src="http://storage.ywandy.top/20190506205842_3k3mQ2_Screenshot.jpeg"></p><h3 id="安装和配置kubernetes-dashboard"><a href="#安装和配置kubernetes-dashboard" class="headerlink" title="安装和配置kubernetes-dashboard"></a>安装和配置kubernetes-dashboard</h3><h4 id="安装kubernetes-dashboard"><a href="#安装kubernetes-dashboard" class="headerlink" title="安装kubernetes-dashboard"></a>安装kubernetes-dashboard</h4><ul><li><p>下载官方kubernetes-dashboard的k8s资源文件</p><pre><code class="hljs bash">curl -L http://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml -O</code></pre></li><li><p>把资源文件应用到k8s集群</p><pre><code class="hljs bash">kubectl create -f kubernetes-dashboard.yaml</code></pre></li><li><p>等待dashboard 完全启动，使用以下命令确认</p></li></ul><p><img src="http://storage.ywandy.top/20190416094438_M3oysh_image-20190327160432156.jpeg"></p><ul><li>此时，kubernetes-dashboard已经部署</li></ul><h4 id="配置kubernetes-dashboard的rbac策略"><a href="#配置kubernetes-dashboard的rbac策略" class="headerlink" title="配置kubernetes-dashboard的rbac策略"></a>配置kubernetes-dashboard的rbac策略</h4><p>kubernetes-dashboard比较坑的地方在于</p><ul><li><p>如果没有配置策略，那么在启动kubernetes-dashboard的时候会出现很多的warning，然后即使能登陆到kubernetes-dashboard，也无法访问里面的资源</p></li><li><p>配置rbac策略</p><pre><code class="hljs yaml"><span class="hljs-comment">#admin-user-admin.rbac.yaml</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><span class="hljs-meta">---</span><span class="hljs-comment"># Create ClusterRoleBinding</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><span class="hljs-attr">roleRef:</span>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><span class="hljs-attr">subjects:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span></code></pre></li><li><p>应用rbac策略到k8s集群</p><pre><code class="hljs bash">kubectl create -f admin-user-admin.rbac.yaml</code></pre></li></ul><h4 id="得到用于登陆dashboard的secret"><a href="#得到用于登陆dashboard的secret" class="headerlink" title="得到用于登陆dashboard的secret"></a>得到用于登陆dashboard的secret</h4><ul><li>运行命令</li></ul><pre><code class="hljs bash">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user|awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)</code></pre><ul><li>会得到以下的token</li></ul><pre><code class="hljs bash">Name:         admin-user-token-hmctlNamespace:    kube-systemLabels:       &lt;none&gt;Annotations:  kubernetes.io/service-account.name: admin-user              kubernetes.io/service-account.uid: 00774986-5066-11e9-a0e8-fe242749c541Type:  kubernetes.io/service-account-tokenData====ca.crt:     1025 bytesnamespace:  11 bytestoken:      xxxxxxxxxxxxx</code></pre><h4 id="使用kubectl-proxy在本地打开dashboard"><a href="#使用kubectl-proxy在本地打开dashboard" class="headerlink" title="使用kubectl proxy在本地打开dashboard"></a>使用kubectl proxy在本地打开dashboard</h4><pre><code class="hljs bash">kubectl proxy</code></pre><ul><li>访问dashboard</li></ul><p>本地浏览器地址栏输入:</p><p><code>localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</code></p><p>会出现如下的页面:</p><p><img src="http://storage.ywandy.top/20190416094438_NhTgGj_image-20190327164400572.jpeg"></p><ul><li><p>输入刚刚拿到的令牌</p><p>如果没有配置rbac策略，在这个时候，使用令牌即使以admin-user登陆进去，也不能访问里面的资源</p></li><li><p>然后进入dashboard界面，如下:</p></li></ul><p><img src="http://storage.ywandy.top/20190416094438_uUnp0s_image-20190327165331282.jpeg"></p><p>此时，已经可以正常访问了</p><ul><li><p>创建能用来访问kubedashboard的config文件</p><pre><code class="hljs bash"><span class="hljs-comment"># 设置集群参数</span><span class="hljs-built_in">export</span> KUBE_APISERVER=<span class="hljs-string">&quot;https://192.168.56.102:6443&quot;</span>kubectl config <span class="hljs-built_in">set</span>-cluster kubernetes \--certificate-authority=/etc/kubernetes/pki/ca.crt \--embed-certs=<span class="hljs-literal">true</span> \--server=<span class="hljs-variable">$&#123;KUBE_APISERVER&#125;</span> \--kubeconfig=devuser.kubeconfig<span class="hljs-comment"># 设置客户端认证参数</span><span class="hljs-comment">#kubectl config set-credentials devuser \</span><span class="hljs-comment">#--client-certificate=/etc/kubernetes/pki/devuser.pem \</span><span class="hljs-comment">#--client-key=/etc/kubernetes/pki/devuser-key.pem \</span><span class="hljs-comment">#--embed-certs=true \</span><span class="hljs-comment">#--kubeconfig=devuser.kubeconfig</span><span class="hljs-comment"># 设置上下文参数</span>kubectl config <span class="hljs-built_in">set</span>-context kubernetes \--cluster=kubernetes \--user=admin-user \--namespace=kube-system \--kubeconfig=devuser.kubeconfig<span class="hljs-comment"># 设置默认上下文</span>kubectl config use-context kubernetes --kubeconfig=devuser.kubeconfig</code></pre></li><li><p>最后在文件后面加上</p><pre><code class="hljs less"><span class="hljs-attribute">users</span>:- <span class="hljs-attribute">name</span>: admin-user  <span class="hljs-attribute">user</span>:    <span class="hljs-attribute">token</span>: &#123;能正确登陆的token&#125;</code></pre></li></ul><h3 id="解决ubuntu中nodeport类型只有一个节点能访问"><a href="#解决ubuntu中nodeport类型只有一个节点能访问" class="headerlink" title="解决ubuntu中nodeport类型只有一个节点能访问"></a>解决ubuntu中nodeport类型只有一个节点能访问</h3><p>在每一个节点运行</p><pre><code class="hljs tp">sudo iptables -<span class="hljs-keyword">P</span> FORWARD <span class="hljs-keyword">ACC</span>EPT</code></pre><h3 id="重新生成join-token"><a href="#重新生成join-token" class="headerlink" title="重新生成join token"></a>重新生成join token</h3><pre><code class="hljs bash">kubeadm token createopenssl x509 -pubkey -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span>kubeadm join --token &#123;join token&#125; --discovery-token-ca-cert-hash sha256:&#123;证书<span class="hljs-built_in">hash</span>&#125;  &#123;集群ip&#125;:6443 --skip-preflight-checkskubeadm join --token ccjxkq.6zxymnvz16q13g4h --discovery-token-ca-cert-hash sha256:32810997128e7b7e589f0899a3f9d6b608bb60743e31c61ff3559d7d306cc6d5  108.160.135.88:6443 --skip-preflight-checks</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>03-k8s</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Drone-Github安装</title>
    <link href="/04-Linux/02-CICD/02-Drone/01-Drone-Github%E5%AE%89%E8%A3%85/"/>
    <url>/04-Linux/02-CICD/02-Drone/01-Drone-Github%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Drone-Github安装指南"><a href="#Drone-Github安装指南" class="headerlink" title="Drone-Github安装指南"></a>Drone-Github安装指南</h1><p>全人类都能看懂的Drone安装指南，阅读本文大约需要1小时，请做好心理准备。</p><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><ul><li>熟悉使用Git和Github</li><li>拥有一个域名，没有的可以买一个玩玩</li><li>知道Https协议是啥，听说过SSL证书</li><li>拥有一个公网IP，打电话给运营商可以开</li><li>拥有一台Linux服务器，或者win/Mac的Docker-Desktop，或者虚拟机设置为桥接模式</li><li>熟悉使用Docker 和 Docker-compose</li><li>对 CI/CD 有一定了解</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="创建OAuth应用程序"><a href="#创建OAuth应用程序" class="headerlink" title="创建OAuth应用程序"></a>创建OAuth应用程序</h3><p>OAuth2:简单理解就是一个优秀的登陆验证框架，就像我们使用微信/支付宝授权登陆一样，相信程序员们也经常使用<code>Github</code>授权登陆，这个时候就是走的OAuth验证了，现在我们要自己创建一个应用(就是Drone)能够直接使用<code>Github</code>账户授权登陆。</p><ol><li>登陆<code>Github</code></li><li>进入这个链接<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a>,如果链接失效，可以Setting &gt; Developer settings &gt; OAuth Apps &gt; New OAuth Apps</li><li>照着下面填</li></ol><p><img src="../images/01-01.png" alt="图片"></p><ol start="4"><li>创建成功之后，会有两个密钥一样的东西，待会要用到</li></ol><p><img src="../images/01-011.png" alt="图片"></p><h3 id="创建SSL证书"><a href="#创建SSL证书" class="headerlink" title="创建SSL证书"></a>创建SSL证书</h3><ol><li>买个免费证书，<a href="https://blog.csdn.net/testcs_dn/article/details/83903026">阿里云免费证书攻略</a></li><li>买到了长这样</li></ol><p><img src="../images/01-02.png" alt="图片"></p><ol start="3"><li>点击申请</li></ol><p><img src="../images/01-03.png" alt="图片"></p><ol start="4"><li>申请之后还要去验证这个域名是你的</li></ol><p><img src="../images/01-04.png" alt="图片"></p><ol start="5"><li>去域名管理界面，填域名解析，顺便把域名和公网IP绑定</li></ol><p><img src="../images/01-05.png" alt="图片"></p><ol start="6"><li><p>填完之后保存，回去阿里云点验证</p></li><li><p>审核通过之后长这样</p></li></ol><p><img src="../images/01-06.png" alt="图片"></p><ol start="8"><li>下载证书，类型选择Apache，待会要用到</li></ol><h3 id="安装Docker和Docker-compose"><a href="#安装Docker和Docker-compose" class="headerlink" title="安装Docker和Docker-compose"></a>安装Docker和Docker-compose</h3><p>此处省略1万字</p><h2 id="真正的安装"><a href="#真正的安装" class="headerlink" title="真正的安装"></a>真正的安装</h2><ul><li><a href="https://docs.drone.io/intro/github/single-machine/">官方指南</a></li></ul><ol><li>创建<code>docker-compose.yml</code>文件</li></ol><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">drone-server:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">drone/drone:1.0.0-rc.1</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">drone-data:/var/lib/drone/:rw</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">c:/home/czm/SSL:/etc/certs:rw</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_CAPACITY=2</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_SERVER=https://github.com</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_HOST=www.example.cn</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_PROTO=https</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_CLIENT_ID=4befxxxx894deec6xxxx</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_CLIENT_SECRET=eeaf3xxxx5bf4069047346c22e9xxxx1dd570786</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_TLS_AUTOCERT=false</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_TLS_CERT=/etc/certs/1573425_example.cn_public.crt</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_TLS_KEY=/etc/certs/1573425_example.cn.key</span><span class="hljs-attr">volumes:</span>  <span class="hljs-attr">drone-data:</span></code></pre><p>解释如下：</p><p><code>drone-data:/var/lib/drone/:rw</code> 数据挂载成数据卷</p><p><code>c:/home/czm/SSL:/etc/certs:rw</code> 将本地的SSL文件挂载到容器中访问</p><p><code>DRONE_RUNNER_CAPACITY</code> 允许同时处理的进程数</p><p><code>DRONE_GITHUB_SERVER</code> 授权的服务器</p><p><code>DRONE_SERVER_HOST</code> 你的域名</p><p><code>DRONE_SERVER_PROTO</code> 协议</p><p><code>DRONE_GITHUB_CLIENT_ID</code> 你的GitHub应用的 <code>Client ID</code></p><p><code>DRONE_GITHUB_CLIENT_SECRET</code> 你的GitHub应用的 <code>Client Secret</code></p><p><code>DRONE_TLS_AUTOCERT</code> 默认是false，这是说使用自动的证书，实测无效</p><p><code>DRONE_TLS_CERT</code> 你的证书在容器中的路径，这个名字是要对应改的</p><p><code>DRONE_TLS_KEY</code> 同上</p><ol start="2"><li>当前文件夹运行<code>docker compose up</code></li></ol><p><img src="../images/01-12.png" alt="图片"></p><ol start="3"><li>打开浏览器，访问你的域名，记得是Https开头噢</li></ol><p><img src="../images/01-13.png" alt="图片"></p><ol start="4"><li>授权登陆，就是这样啦</li></ol><p><img src="../images/01-14.png" alt="图片"></p><p>超级简洁，超级好看有没有</p><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/cases/ci/drone.html">中文Docker使用手册 - Drone安装指南</a></li><li><a href="https://blog.csdn.net/qcloudcommunity/article/details/81867422">参考文章1</a></li><li><a href="https://www.jianshu.com/p/1e5f819f8881">参考文章2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>02-Drone</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Drone-Github简单安装</title>
    <link href="/04-Linux/02-CICD/02-Drone/02-Drone-Github%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/"/>
    <url>/04-Linux/02-CICD/02-Drone/02-Drone-Github%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Drone-Github安装"><a href="#Drone-Github安装" class="headerlink" title="Drone-Github安装"></a>Drone-Github安装</h1><p>本文根据<a href="https://docs.drone.io/intro/github/single-machine/">官方文档</a>改编，故事纯属虚构，如有巧合，那就巧合咯。</p><h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><ol><li>拥有一个域名</li><li>拥有一个公网IP的服务器</li><li>拥有一个Github账号</li><li>安装好Docker和Docker-compose</li></ol><h2 id="1-Prerequisites"><a href="#1-Prerequisites" class="headerlink" title="1 Prerequisites"></a>1 Prerequisites</h2><h3 id="1-1-Create-an-OAuth-Application"><a href="#1-1-Create-an-OAuth-Application" class="headerlink" title="1.1 Create an OAuth Application"></a>1.1 Create an OAuth Application</h3><p>Create a GitHub OAuth application. The Consumer Key and Consumer Secret are used to authorize access to Bitbucket resources. The Authorization callback URL must match the below format and path, and must use your exact server scheme and host.</p><p><img src="https://docs.drone.io/screenshots/github_application_create.png"><br><img src="https://docs.drone.io/screenshots/github_application_created.png"></p><h3 id="1-2-将你的域名绑定你的服务器"><a href="#1-2-将你的域名绑定你的服务器" class="headerlink" title="1.2 将你的域名绑定你的服务器"></a>1.2 将你的域名绑定你的服务器</h3><h2 id="2-创建docker-compose-yml文件"><a href="#2-创建docker-compose-yml文件" class="headerlink" title="2.创建docker-compose.yml文件"></a>2.创建<code>docker-compose.yml</code>文件</h2><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">drone-server:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">drone/drone:1.0.0-rc.1</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/var/lib/drone/:rw</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./SSL:/etc/certs:rw</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_SERVER=https://github.com</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_CLIENT_ID=4befea1d894deec67717</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_GITHUB_CLIENT_SECRET=eeaf3574d5bf4069047346c22e9a2ee1dd570786</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_RUNNER_CAPACITY=2</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_HOST=www.airesource.cn</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_SERVER_PROTO=https</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">DRONE_TLS_AUTOCERT=true</span>      <span class="hljs-comment"># - DRONE_TLS_CERT=/etc/certs/1573425_airesource.cn_public.crt</span>      <span class="hljs-comment"># - DRONE_TLS_KEY=/etc/certs/1573425_airesource.cn.key</span></code></pre><h3 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h3><pre><code class="hljs sh">docker-compose up</code></pre><p>各种命令详解，请参考<a href="https://docs.drone.io/intro/github/single-machine/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>02-Drone</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-放弃Drone的第一天</title>
    <link href="/04-Linux/02-CICD/02-Drone/03-%E6%94%BE%E5%BC%83Drone%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/04-Linux/02-CICD/02-Drone/03-%E6%94%BE%E5%BC%83Drone%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>放弃原因</p><ol><li>文档不行</li><li>gitlab上的验证出问题了，没有办法拿到Athon2的验证，因此，用不下去了。。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>02-Drone</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-jenkins是什么</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/01-jenkins%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/01-jenkins%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins是什么"><a href="#Jenkins是什么" class="headerlink" title="Jenkins是什么"></a>Jenkins是什么</h1><p>Jenkins是一个支持分布式部署的在线 持续 测试 发布 软件.</p><h2 id="关于文档的使用"><a href="#关于文档的使用" class="headerlink" title="关于文档的使用"></a>关于文档的使用</h2><p><a href="https://jenkins.io/doc/">User Document</a>是直接使用Jenkins的插件进行使用的文档，适合JAVA开发，而<a href="https://jenkins.io/doc/developer">developer documentation</a>是自行开发插件，适合其他语言开发。</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-jenkins安装步骤(使用Docker)</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/02-jenkins%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4(%E4%BD%BF%E7%94%A8Docker)/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/02-jenkins%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4(%E4%BD%BF%E7%94%A8Docker)/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins项目记录"><a href="#Jenkins项目记录" class="headerlink" title="Jenkins项目记录"></a>Jenkins项目记录</h1><p>本次使用主机<code>host-1-git</code>，在路径<code>/root/czm/</code>路径下<br>文件映射和端口映射请看<code>docker run</code>命令</p><p><a href="https://jenkins.io/doc/book/installing/">参考文档</a></p><h2 id="1-使用Docker安装"><a href="#1-使用Docker安装" class="headerlink" title="1.使用Docker安装"></a>1.使用Docker安装</h2><pre><code class="hljs sh">docker run \  -u root \  -d \  -p 7690:8080 \  -p 50000:50000 \  --name jenkins-blueocean \  -v jenkins-data:/var/jenkins_home \  -v /var/run/docker.sock:/var/run/docker.sock \  jenkinsci/blueocean</code></pre><p>命令解析如下：</p><blockquote><p>docker run</p></blockquote><blockquote><p> -u root –&gt; 指定运行用户（容器内）</p></blockquote><blockquote><p> -d –&gt; 后台运行</p></blockquote><blockquote><p> -p 7690:8080 –&gt; 将容器内的8080端口转发到7690</p></blockquote><blockquote><p> -p 50000:50000 –&gt; **[可选]**将用于Jenkins分布式通讯的50000端口映射到host</p></blockquote><blockquote><p> –name jenkins-blueocean –&gt; 设置容器名称</p></blockquote><blockquote><p> -v jenkins-data:/var/jenkins_home –&gt; **[可选]**将Jenkins_home路径独立挂在jenkins-data卷中，如果卷存在，则使用旧的，若不存在则创建新容器卷</p></blockquote><blockquote><p> -v /var/run/docker.sock:/var/run/docker.sock –&gt; 此处与其说是挂载，不如说是映射。由于jenkins需要在容器中创建容器，需要与系统的<code>socket</code>通信</p></blockquote><blockquote><p> jenkinsci/blueocean –&gt; 容器的来源，若本地没有将到云中去下载，由于我们没有指定版本，默认使用最新版本</p></blockquote><h2 id="2-查看日志中生成的密钥，并复制出来，到界面中粘贴"><a href="#2-查看日志中生成的密钥，并复制出来，到界面中粘贴" class="headerlink" title="2.查看日志中生成的密钥，并复制出来，到界面中粘贴"></a>2.查看日志中生成的密钥，并复制出来，到界面中粘贴</h2><pre><code class="hljs sh">docker logs jenkins-blueocean</code></pre><h2 id="3-访问对应端口即可进行配置"><a href="#3-访问对应端口即可进行配置" class="headerlink" title="3.访问对应端口即可进行配置"></a>3.访问对应端口即可进行配置</h2><p>用户名    root<br>密码      Datainsights#6!<br>全名      cenzhongman<br>e-mail   <a href="mailto:&#x63;&#x65;&#x6e;&#x7a;&#104;&#x6f;&#110;&#x67;&#109;&#x61;&#x6e;&#64;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;">&#x63;&#x65;&#x6e;&#x7a;&#104;&#x6f;&#110;&#x67;&#109;&#x61;&#x6e;&#64;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>即使不是第一次运行，任然可以使用上述命令，可以使用<code>-rm</code>删掉之前的容器，只要数据卷还在，数据不会丢失</li></ol>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Jenkins基础配置</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/04-Jenkins%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/04-Jenkins%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins基础设置之安全设置"><a href="#Jenkins基础设置之安全设置" class="headerlink" title="Jenkins基础设置之安全设置"></a>Jenkins基础设置之安全设置</h1><h2 id="为管理员添加全部权限"><a href="#为管理员添加全部权限" class="headerlink" title="为管理员添加全部权限"></a>为管理员添加全部权限</h2><ol><li>系统管理</li><li>全局安全配置（英文）</li><li>授权策略 &gt; 安全矩阵 &gt; 添加用户 &gt; 管理员用户 &gt; 赋予全部权限</li></ol><h2 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h2>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Jenkins安装步骤(非Docker)</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/03-Jenkins%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4(%E9%9D%9EDocker)/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/03-Jenkins%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4(%E9%9D%9EDocker)/</url>
    
    <content type="html"><![CDATA[<h1 id="Download-and-run-Jenkins"><a href="#Download-and-run-Jenkins" class="headerlink" title="Download and run Jenkins"></a>Download and run Jenkins</h1><p>强烈建议！<strong>你熟悉什么系统的命令行就用什么系统来进行测试</strong>，比如我对window的命令行一点都不熟悉，那就别作死在windos中运行这个，毕竟它需要直接运行命令行。</p><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><ol><li><a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war">Download Jenkins.</a></li><li>Open up a terminal in the download directory.</li><li>Run java -jar jenkins.war –httpPort=8080.</li><li>Browse to <code>http://localhost:8080</code>.</li><li>copy the passwd follw the web tips.</li></ol><h2 id="创建第一个pipeline"><a href="#创建第一个pipeline" class="headerlink" title="创建第一个pipeline"></a>创建第一个pipeline</h2><ul><li>pipeline：我们可以认为是一套流程，步骤1234这样不断重复</li><li>Jenkinsfile：用于配置Jenkins的配置文件，我们需要在git中创建这个文件，用于构建和发布程序，有点像<code>dockerfile</code>，但是Jenkins是会不断扫描这个文件的变化的</li></ul><ol><li>新建项目 -&gt; 填写项目名称 -&gt; Multibranch Pipeline -&gt; 确定</li><li>增加源 -&gt; git(即使是GitHub也可以使用这个，其他的配置可以自己研究) -&gt; 填入git的完整地址 -&gt; 确定</li></ol><p>(提供一个测试例子，Linux)</p><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;echo &quot;Hello World&quot;&#x27;</span>                sh <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><span class="hljs-string">                    echo &quot;Multiline shell steps works too&quot;</span><span class="hljs-string">                    ls -lah</span><span class="hljs-string">                &#x27;</span><span class="hljs-string">&#x27;&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><p>在设置好之后，Jenkins会自动检测在你的版本库中创建的任何新的分支或合并请求，从你的git地址中不停地找Jenkinsfile文件，并开始为它们运行pipeline。</p><h2 id="运行多个步骤"><a href="#运行多个步骤" class="headerlink" title="运行多个步骤"></a>运行多个步骤</h2><ul><li>stages{很多个stage}</li><li>stage(‘步骤的官方描述如：Build/Deploy’){一个steps}</li><li>steps{在这里面描述这个stagr需要执行的步骤，使用<code>&#39;</code>单引号表示一行，使用<code>&#39;&#39;&#39;</code>表示多行}</li></ul><p>在Linux系统中,使用<code>sh</code>来执行程序，</p><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;echo &quot;Hello World&quot;&#x27;</span>                sh <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><span class="hljs-string">                    echo &quot;Multiline shell steps works too&quot;</span><span class="hljs-string">                    ls -lah</span><span class="hljs-string">                &#x27;</span><span class="hljs-string">&#x27;&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="设置步骤的超时，重试"><a href="#设置步骤的超时，重试" class="headerlink" title="设置步骤的超时，重试"></a>设置步骤的超时，重试</h3><ul><li>retry(3){sh ‘./123.py’}重试三次，三次都失败则退出</li><li>timeout(time: 3, unit: ‘MINUTES’) {sh ‘./123.sh’}三分钟内没有执行完成，将会直接退出</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Deploy&#x27;</span>) &#123;            steps &#123;                retry(3) &#123;                    sh <span class="hljs-string">&#x27;./flakey-deploy.sh&#x27;</span>                &#125;                timeout(time: 3, unit: <span class="hljs-string">&#x27;MINUTES&#x27;</span>) &#123;                    sh <span class="hljs-string">&#x27;./health-check.sh&#x27;</span>                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>也可以组合使用，这样就是<strong>重试3次，总共用时不超过三分钟</strong></p><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Deploy&#x27;</span>) &#123;            steps &#123;                timeout(time: 3, unit: <span class="hljs-string">&#x27;MINUTES&#x27;</span>) &#123;                    retry(3) &#123;                        sh <span class="hljs-string">&#x27;./flakey-deploy.sh&#x27;</span>                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="对项目执行结果进行判断"><a href="#对项目执行结果进行判断" class="headerlink" title="对项目执行结果进行判断"></a>对项目执行结果进行判断</h3><ul><li>post{}运行结果的选择，请参考下文代码</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;echo &quot;Fail!&quot;; exit 1&#x27;</span>            &#125;        &#125;    &#125;    post &#123;        always &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;不管结果是什么都会执行这句&#x27;</span>        &#125;        success &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This will run only if successful&#x27;</span>        &#125;        failure &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This will run only if failed&#x27;</span>        &#125;        unstable &#123;            <span class="hljs-comment"># 测试失败的项目</span>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This will run only if the run was marked as unstable&#x27;</span>        &#125;        changed &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;这个是在执行结果和以前不一样时候，比如一直成功的，这次失败了&#x27;</span>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This will run only if the state of the Pipeline has changed&#x27;</span>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;For example, if the Pipeline was previously failing but is now successful&#x27;</span>        &#125;    &#125;&#125;</code></pre><h2 id="指定运行环境（不在当前环境运行）"><a href="#指定运行环境（不在当前环境运行）" class="headerlink" title="指定运行环境（不在当前环境运行）"></a>指定运行环境（不在当前环境运行）</h2><p>有两种写法</p><ul><li>agent{docker ‘ubuntu:16.04’}</li><li>agent{docker {image ‘ubuntu:16.04’}}</li></ul><p>指定运行的<code>agent</code>的docker容器</p><pre><code class="hljs sh">pipeline &#123;    agent &#123;        docker &#123; image <span class="hljs-string">&#x27;node:7-alpine&#x27;</span> &#125;    &#125;    stages &#123;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;node --version&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>环境变量可以设置为全局(比如下面的例子)，也可以在<code>stage</code>中设置。</p><ul><li>environment {DISABLE_AUTH = ‘true’}多个变量之间直接换行</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    environment &#123;        DISABLE_AUTH = <span class="hljs-string">&#x27;true&#x27;</span>        DB_ENGINE    = <span class="hljs-string">&#x27;sqlite&#x27;</span>    &#125;    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;printenv&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="环境变量用于凭证"><a href="#环境变量用于凭证" class="headerlink" title="环境变量用于凭证"></a><a href="https://jenkins.io/doc/pipeline/tour/environment/">环境变量用于凭证</a></h3><p>? 并不太清楚凭证是什么?</p><p>我们不希望密码被知道，就可以继承已经设定好的运行环境中配置好的凭证，这样就可以在我们的pipeline中使用这个变量了。</p><pre><code class="hljs sh">environment &#123;    AWS_ACCESS_KEY_ID     = credentials(<span class="hljs-string">&#x27;AWS_ACCESS_KEY_ID&#x27;</span>)    AWS_SECRET_ACCESS_KEY = credentials(<span class="hljs-string">&#x27;AWS_SECRET_ACCESS_KEY&#x27;</span>)&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为了让测试结果不从终端输出，使用<code>junit</code>输出格式化的<code>XML</code>报告。</p><h3 id="使用Junit输出报告"><a href="#使用Junit输出报告" class="headerlink" title="使用Junit输出报告"></a>使用<code>Junit</code>输出报告</h3><ul><li>junit ‘build/reports/*<em>/</em>.xml’</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;./gradlew check&#x27;</span>            &#125;        &#125;    &#125;    post &#123;        always &#123;            junit <span class="hljs-string">&#x27;build/reports/**/*.xml&#x27;</span>        &#125;    &#125;&#125;</code></pre><h3 id="使用archive和文件表达式匹配测试失败的文件"><a href="#使用archive和文件表达式匹配测试失败的文件" class="headerlink" title="使用archive和文件表达式匹配测试失败的文件"></a>使用<code>archive</code>和文件表达式匹配测试失败的文件</h3><ul><li>archive ‘build/libs/*<em>/</em>.jar’</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;./gradlew build&#x27;</span>            &#125;        &#125;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;./gradlew check&#x27;</span>            &#125;        &#125;    &#125;    post &#123;        always &#123;            archive <span class="hljs-string">&#x27;build/libs/**/*.jar&#x27;</span>            junit <span class="hljs-string">&#x27;build/reports/**/*.xml&#x27;</span>        &#125;    &#125;&#125;</code></pre><h2 id="清理和通知"><a href="#清理和通知" class="headerlink" title="清理和通知"></a>清理和通知</h2><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>在post的阶段中可以增加删除目录等步骤。</p><ul><li>deleteDir() /* clean up our workspace */</li></ul><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;No-op&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;ls&#x27;</span>            &#125;        &#125;    &#125;    post &#123;        always &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;One way or another, I have finished&#x27;</span>            deleteDir() /* clean up our workspace */        &#125;        success &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;I succeeeded!&#x27;</span>        &#125;        unstable &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;I am unstable :/&#x27;</span>        &#125;        failure &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;I failed :(&#x27;</span>        &#125;        changed &#123;            <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Things were different before...&#x27;</span>        &#125;    &#125;&#125;</code></pre><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="Emai"><a href="#Emai" class="headerlink" title="Emai"></a>Emai</h4><pre><code class="hljs sh">post &#123;    failure &#123;        mail to: <span class="hljs-string">&#x27;team@example.com&#x27;</span>,             subject: <span class="hljs-string">&quot;Failed Pipeline: <span class="hljs-variable">$&#123;currentBuild.fullDisplayName&#125;</span>&quot;</span>,             body: <span class="hljs-string">&quot;Something is wrong with <span class="hljs-variable">$&#123;env.BUILD_URL&#125;</span>&quot;</span>    &#125;&#125;</code></pre><h4 id="Hipchat"><a href="#Hipchat" class="headerlink" title="Hipchat"></a>Hipchat</h4><h4 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h4><h2 id="部署Deploy"><a href="#部署Deploy" class="headerlink" title="部署Deploy"></a>部署Deploy</h2><p>一个程序的上线至少需要三个步骤，Build Test Deploy</p><h3 id="程序步骤"><a href="#程序步骤" class="headerlink" title="程序步骤"></a>程序步骤</h3><pre><code class="hljs sh">pipeline &#123;    agent any    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Building&#x27;</span>            &#125;        &#125;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Testing&#x27;</span>            &#125;        &#125;        stage(<span class="hljs-string">&#x27;Deploy&#x27;</span>) &#123;            steps &#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Deploying&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="需要输入"><a href="#需要输入" class="headerlink" title="需要输入"></a>需要输入</h3><pre><code class="hljs sh">stage(<span class="hljs-string">&#x27;Sanity check&#x27;</span>) &#123;    steps &#123;        input <span class="hljs-string">&quot;Does the staging environment look ok?&quot;</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-jenkins插件安装</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/06-jenkins%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/06-jenkins%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins插件安装"><a href="#Jenkins插件安装" class="headerlink" title="Jenkins插件安装"></a>Jenkins插件安装</h1><ol><li>进入jenkins界面</li><li>系统管理</li><li>插件管理</li><li>可选插件</li><li>Rebuilder</li><li>save restart</li></ol>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-实战篇-构建一个MAVEN工程</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/07-%E5%AE%9E%E6%88%98%E7%AF%87-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAMAVEN%E5%B7%A5%E7%A8%8B/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/07-%E5%AE%9E%E6%88%98%E7%AF%87-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAMAVEN%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux下构建一个Java的maven工程"><a href="#Linux下构建一个Java的maven工程" class="headerlink" title="Linux下构建一个Java的maven工程"></a>Linux下构建一个Java的maven工程</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>安装好Docker</li><li>安装好git</li></ul><h2 id="官方用例"><a href="#官方用例" class="headerlink" title="官方用例"></a>官方用例</h2><h3 id="在docker中运行jenkins"><a href="#在docker中运行jenkins" class="headerlink" title="在docker中运行jenkins"></a>在docker中运行jenkins</h3><p>尽管我们加了<code>--rm</code>用于在容器停止后删除容器，挂载的内容并不会随之删除，我们在重新使用这个命令启动容器，上次配置的一切都还在（亲测可用）。</p><pre><code class="hljs sh">docker run \  --rm \  -u root \  -p 8080:8080 \  -v jenkins-data:/var/jenkins_home \  -v /var/run/docker.sock:/var/run/docker.sock \  -v <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>&quot;</span>:/home \  --name jenkins \  jenkinsci/blueocean</code></pre><h4 id="填入token"><a href="#填入token" class="headerlink" title="填入token"></a>填入token</h4><p>查看日志中生成的密钥，并复制token</p><pre><code class="hljs sh">docker logs jenkins-blueocean</code></pre><h4 id="安装建议的插件"><a href="#安装建议的插件" class="headerlink" title="安装建议的插件"></a>安装建议的插件</h4><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><p>访问对应端口即可进行配置</p><p>用户名    root<br>密码      Datainsights#6!<br>全名      admin<br>e-mail   <a href="mailto:&#99;&#101;&#x6e;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#109;&#x61;&#110;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#99;&#101;&#x6e;&#x7a;&#x68;&#x6f;&#x6e;&#x67;&#109;&#x61;&#110;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></p><h3 id="官方的Github项目"><a href="#官方的Github项目" class="headerlink" title="官方的Github项目"></a>官方的Github项目</h3><p><a href="https://github.com/jenkins-docs/simple-java-maven-app">simple-java-maven-app</a></p><ol><li>fork：用于作为源</li><li>下载：用于更新和提交修改</li></ol><h3 id="创建一个工程"><a href="#创建一个工程" class="headerlink" title="创建一个工程"></a>创建一个工程</h3><ol><li>新建</li><li>输入任务名 如simple-java-maven-app</li><li>选择Multibranch Pipeline</li><li>[添加项目描述]–可选</li><li>添加源，增加一个git源，并填入git地址（如有必要，请添加凭证）</li><li>在git所在的跟文件夹中添加Jenkfile</li><li>git add .</li><li>git commit -m “Add Jenkinsfile”</li><li>git push</li></ol><p>这时候再次查看日志，应该就找到Jenkinsfile了</p><h3 id="观察执行过程"><a href="#观察执行过程" class="headerlink" title="观察执行过程"></a>观察执行过程</h3><p>Open Blue Ocean</p><p>执行结束界面就会变成绿色。</p><h2 id="项目文件详解"><a href="#项目文件详解" class="headerlink" title="项目文件详解"></a>项目文件详解</h2><p>Jenkinsfile</p><pre><code class="hljs sh">pipeline &#123;    agent &#123;        docker &#123;            image <span class="hljs-string">&#x27;maven:3-alpine&#x27;</span>            args <span class="hljs-string">&#x27;-v /root/.m2:/root/.m2&#x27;</span>        &#125;    &#125;    stages &#123;        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;mvn -B -DskipTests clean package&#x27;</span>            &#125;        &#125;        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;mvn test&#x27;</span>            &#125;            post &#123;                always &#123;                    junit <span class="hljs-string">&#x27;target/surefire-reports/*.xml&#x27;</span>                &#125;            &#125;        &#125;        stage(<span class="hljs-string">&#x27;Deliver&#x27;</span>) &#123;            steps &#123;                sh <span class="hljs-string">&#x27;./jenkins/scripts/deliver.sh&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><p>jenkins/scripts/deliver.sh</p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following Maven command installs your Maven-built Java application&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;into the local Maven repository, which will ultimately be stored in&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Jenkins&#x27;</span><span class="hljs-string">&#x27;s local Maven repository (and the &quot;maven-repository&quot; Docker data&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;volume).&#x27;</span><span class="hljs-built_in">set</span> -xmvn jar:jar install:install <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following complex command extracts the value of the &lt;name/&gt; element&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;within &lt;project/&gt; of your Java/Maven project&#x27;</span><span class="hljs-string">&#x27;s &quot;pom.xml&quot; file.&#x27;</span><span class="hljs-built_in">set</span> -xNAME=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following complex command behaves similarly to the previous one but&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;extracts the value of the &lt;version/&gt; element within &lt;project/&gt; instead.&#x27;</span><span class="hljs-built_in">set</span> -xVERSION=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.version | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following command runs and outputs the execution of your Java&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;application (which Jenkins built using Maven) to the Jenkins UI.&#x27;</span><span class="hljs-built_in">set</span> -xjava -jar target/<span class="hljs-variable">$&#123;NAME&#125;</span>-<span class="hljs-variable">$&#123;VERSION&#125;</span>.jar</code></pre><p>App.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycompany.app;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hello world!</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message = <span class="hljs-string">&quot;Hello Jenkins!&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-keyword">new</span> App().getMessage());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> message;    &#125;&#125;</code></pre><p>AppTest.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mycompany.app;<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<span class="hljs-keyword">import</span> java.io.PrintStream;<span class="hljs-keyword">import</span> org.junit.Before;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.After;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Unit test for simple App.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteArrayOutputStream outContent = <span class="hljs-keyword">new</span> ByteArrayOutputStream();    <span class="hljs-meta">@Before</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpStreams</span><span class="hljs-params">()</span> </span>&#123;        System.setOut(<span class="hljs-keyword">new</span> PrintStream(outContent));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAppConstructor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">new</span> App();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            fail(<span class="hljs-string">&quot;Construction failed.&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAppMain</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        App.main(<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">try</span> &#123;            assertEquals(<span class="hljs-string">&quot;Hello World!&quot;</span> + System.getProperty(<span class="hljs-string">&quot;line.separator&quot;</span>), outContent.toString());        &#125; <span class="hljs-keyword">catch</span> (AssertionError e) &#123;            fail(<span class="hljs-string">&quot;\&quot;message\&quot; is not \&quot;Hello Maven!\&quot;&quot;</span>);        &#125;    &#125;    <span class="hljs-meta">@After</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanUpStreams</span><span class="hljs-params">()</span> </span>&#123;        System.setOut(<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mycompany.app<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-app<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>my-app<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Build an executable JAR --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">classpathPrefix</span>&gt;</span>lib/<span class="hljs-tag">&lt;/<span class="hljs-name">classpathPrefix</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.mycompany.app.App<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h2 id="采坑日志"><a href="#采坑日志" class="headerlink" title="采坑日志"></a>采坑日志</h2><h3 id="1-使用官方例子，使用IDEA构建，报权限不足"><a href="#1-使用官方例子，使用IDEA构建，报权限不足" class="headerlink" title="1. 使用官方例子，使用IDEA构建，报权限不足"></a>1. 使用官方例子，使用IDEA构建，报权限不足</h3><pre><code class="hljs log">[simple-java-maven-app_czm-Q6E3SOTRXA6PJSVRFOQNYO2IPZPWTWJA6P6BAZKLYSG5PAFQAZAA] Running shell script+ .&#x2F;jenkins&#x2F;scripts&#x2F;deliver.sh&#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;simple-java-maven-app_czm-Q6E3SOTRXA6PJSVRFOQNYO2IPZPWTWJA6P6BAZKLYSG5PAFQAZAA@tmp&#x2F;durable-6de1ece4&#x2F;script.sh: line 1: .&#x2F;jenkins&#x2F;scripts&#x2F;deliver.sh: Permission deniedscript returned exit code 126</code></pre><ul><li>原因：Windows导致的文件权限不足？</li><li>解决：在JenkinsFile中增加<code>sh &#39;chmod 755 ./jenkins/scripts/deliver.sh&#39;</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-实战篇-使用blueOcean创建一个pipeline</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/08-%E5%AE%9E%E6%88%98%E7%AF%87-%E4%BD%BF%E7%94%A8blueOcean%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApipeline/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/08-%E5%AE%9E%E6%88%98%E7%AF%87-%E4%BD%BF%E7%94%A8blueOcean%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApipeline/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Blue-Ocean创建一个pipeline"><a href="#使用Blue-Ocean创建一个pipeline" class="headerlink" title="使用Blue Ocean创建一个pipeline"></a>使用Blue Ocean创建一个pipeline</h1><p><a href="https://jenkins.io/doc/tutorials/create-a-pipeline-in-blue-ocean/">https://jenkins.io/doc/tutorials/create-a-pipeline-in-blue-ocean/</a></p><ol><li>打开Jenkins</li><li>点击左侧Open Blue Ovean</li><li>新的pipeline</li><li>选择源码管理工具<ol><li>Github &gt; Create an access key here. &gt; 确定 &gt; 复制token</li><li>git &gt; 填入git地址</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-jenkins-SpringBoot开发指南</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/09-jenkins-SpringBoot%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/09-jenkins-SpringBoot%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins-SpringBoot开发文档"><a href="#Jenkins-SpringBoot开发文档" class="headerlink" title="Jenkins-SpringBoot开发文档"></a>Jenkins-SpringBoot开发文档</h1><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><ol><li>Jenkins</li><li>Docker</li></ol><h2 id="2-开始"><a href="#2-开始" class="headerlink" title="2. 开始"></a>2. 开始</h2><ol><li>新建Maven项目</li><li>添加<code>.gitignore</code></li></ol><pre><code class="hljs sh">*/target*.iml/.idea*.class*.<span class="hljs-built_in">log</span>target/out/.project.settings/.classpath</code></pre><ol start="3"><li>创建<code>jenkins</code>文件夹</li><li>添加<code>Jenkinsfile</code></li></ol><pre><code class="hljs Jenkinsfile">pipeline &#123;    agent &#123;        docker &#123;            image &#39;maven:3-alpine&#39;            args &#39;-v &#x2F;root&#x2F;.m2:&#x2F;root&#x2F;.m2&#39;        &#125;    &#125;    stages &#123;        stage(&#39;Build&#39;) &#123;            steps &#123;                sh &#39;mvn -B -DskipTests clean package&#39;            &#125;        &#125;        stage(&#39;Test&#39;) &#123;            steps &#123;                sh &#39;mvn test&#39;            &#125;        &#125;        stage(&#39;Deliver&#39;) &#123;            steps &#123;                sh &#39;chmod 755 .&#x2F;jenkins&#x2F;scripts&#x2F;deliver.sh&#39;                sh &#39;.&#x2F;jenkins&#x2F;scripts&#x2F;deliver.sh&#39;            &#125;        &#125;    &#125;&#125;</code></pre><ol start="5"><li>添加<code>scripts/deliver.sh</code>文件</li></ol><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-built_in">set</span> -xNAME=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目名&#x27;</span><span class="hljs-built_in">set</span> -xVERSION=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.version | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目版本&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;正在运行应用&#x27;</span><span class="hljs-built_in">set</span> -xjava -jar target/<span class="hljs-variable">$&#123;NAME&#125;</span>-<span class="hljs-variable">$&#123;VERSION&#125;</span>.jar</code></pre><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="0-执行脚本权限不足"><a href="#0-执行脚本权限不足" class="headerlink" title="0. 执行脚本权限不足"></a>0. 执行脚本权限不足</h3><ul><li>原因：可能是Windows转过去权限改变了？可是我同期的启动用户是root啊</li><li>解决：添加修改权限命令<code>chmod 755 ./jenkins/scripts/deliver.sh</code></li></ul><h3 id="1-测试类报错"><a href="#1-测试类报错" class="headerlink" title="1. 测试类报错"></a>1. 测试类报错</h3><pre><code class="hljs log">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project jenkinsSpringBoot: There are test failures.[ERROR] [ERROR] Please refer to &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q&#x2F;target&#x2F;surefire-reports for the individual test results.[ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream.[ERROR] The forked VM terminated without properly saying goodbye. VM crash or System.exit called?[ERROR] Command was &#x2F;bin&#x2F;sh -c cd &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q &amp;&amp; &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8-openjdk&#x2F;jre&#x2F;bin&#x2F;java -jar &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q&#x2F;target&#x2F;surefire&#x2F;surefirebooter360498965871164517.jar &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q&#x2F;target&#x2F;surefire 2018-09-04T08-59-23_243-jvmRun1 surefire9118733957466905321tmp surefire_05845387292710210948tmp[ERROR] Error occurred in starting fork, check output in log[ERROR] Process Exit Code: 1[ERROR] org.apache.maven.surefire.booter.SurefireBooterForkException: The forked VM terminated without properly saying goodbye. VM crash or System.exit called?[ERROR] Command was &#x2F;bin&#x2F;sh -c cd &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q &amp;&amp; &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8-openjdk&#x2F;jre&#x2F;bin&#x2F;java -jar &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q&#x2F;target&#x2F;surefire&#x2F;surefirebooter360498965871164517.jar &#x2F;var&#x2F;jenkins_home&#x2F;workspace&#x2F;jenkins-springboot_master-VSYHUUBYF4J3D5UJMVQ2TOAHXLVD5XLUEVI23CNDQQQG6ANJFM2Q&#x2F;target&#x2F;surefire 2018-09-04T08-59-23_243-jvmRun1 surefire9118733957466905321tmp surefire_05845387292710210948tmp[ERROR] Error occurred in starting fork, check output in log[ERROR] Process Exit Code: 1[ERROR] at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:671)[ERROR] at org.apache.maven.plugin.surefire.booterclient.ForkStarter.fork(ForkStarter.java:533)[ERROR] at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:278)[ERROR] at org.apache.maven.plugin.surefire.booterclient.ForkStarter.run(ForkStarter.java:244)[ERROR] at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeProvider(AbstractSurefireMojo.java:1149)[ERROR] at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPreconditionsChecked(AbstractSurefireMojo.java:978)[ERROR] at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(AbstractSurefireMojo.java:854)[ERROR] at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)[ERROR] at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)[ERROR] at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)[ERROR] at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)[ERROR] at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)[ERROR] at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)[ERROR] at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)[ERROR] at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)[ERROR] at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)[ERROR] at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993)[ERROR] at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345)[ERROR] at org.apache.maven.cli.MavenCli.main(MavenCli.java:191)[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[ERROR] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)[ERROR] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[ERROR] at java.lang.reflect.Method.invoke(Method.java:498)[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)[ERROR] at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)[ERROR] [ERROR] -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http:&#x2F;&#x2F;cwiki.apache.org&#x2F;confluence&#x2F;display&#x2F;MAVEN&#x2F;MojoExecutionExceptionscript returned exit code 1</code></pre><ul><li>原因：junit版本问题？</li><li>解决：<ul><li>方式1：忽略测试错误（不建议，且这不是SpringBoot的打包方式）</li></ul></li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">testFailureIgnore</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">testFailureIgnore</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><pre><code>* 方式2：升级到junit5（个人不喜欢junit5）</code></pre><ul><li><a href="https://stackoverflow.com/questions/23260057/the-forked-vm-terminated-without-saying-properly-goodbye-vm-crash-or-system-exi">参考</a></li></ul><h3 id="2-无法输出测试文件"><a href="#2-无法输出测试文件" class="headerlink" title="2. 无法输出测试文件"></a>2. 无法输出测试文件</h3><ul><li>描述：jenkins-test中使用了如下命令</li></ul><pre><code class="hljs sh">post &#123;    always &#123;        junit <span class="hljs-string">&#x27;target/surefire-reports/*.xml&#x27;</span>    &#125;&#125;</code></pre><ul><li>报错：</li></ul><pre><code class="hljs sh">Recording <span class="hljs-built_in">test</span> resultsNone of the <span class="hljs-built_in">test</span> reports contained any resultNone of the <span class="hljs-built_in">test</span> reports contained any result</code></pre><ul><li>原因：我的测试类没有输出任何结果，当时的测试代码如下</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            assertEquals(<span class="hljs-string">&quot;Hello World!&quot;</span>, <span class="hljs-keyword">new</span> Controller().hello());            System.out.println(<span class="hljs-string">&quot;Output is &quot;</span> + <span class="hljs-string">&quot;Hello World!&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            fail(<span class="hljs-string">&quot;Output is not &quot;</span> + <span class="hljs-string">&quot;Hello World!&quot;</span>);        &#125;    &#125;&#125;</code></pre><ul><li>解决：<ul><li>方式一：增加输出代码如下（失败，原因未知）</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteArrayOutputStream outContent = <span class="hljs-keyword">new</span> ByteArrayOutputStream();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            assertEquals(<span class="hljs-string">&quot;Hello World!&quot;</span>, <span class="hljs-keyword">new</span> Controller().hello(), outContent.toString());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            fail(<span class="hljs-string">&quot;Output is not &quot;</span> + <span class="hljs-string">&quot;Hello World!&quot;</span>);        &#125;    &#125;&#125;</code></pre><pre><code>* 方式二：删除Jenkins-test文件中的命令(成功)</code></pre><h3 id="3-构建命令出错"><a href="#3-构建命令出错" class="headerlink" title="3. 构建命令出错"></a>3. 构建命令出错</h3><ul><li>报错：</li></ul><pre><code class="hljs sh">no main manifest attribute, <span class="hljs-keyword">in</span> target/jenkinsSpringBoot-1.0-SNAPSHOT.jar</code></pre><ul><li>原因：构建命令不适合springBoot，且本地使用<code>mvn clean install</code>结果正常</li><li>解决：使用<code>mvn clean install</code>代替现有构建命令</li></ul><p>当时的构建脚本</p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following Maven command installs your Maven-built Java application&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;into the local Maven repository, which will ultimately be stored in&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Jenkins&#x27;</span><span class="hljs-string">&#x27;s local Maven repository (and the &quot;maven-repository&quot; Docker data&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;volume).&#x27;</span><span class="hljs-built_in">set</span> -xmvn jar:jar install:install <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following complex command extracts the value of the &lt;name/&gt; element&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;within &lt;project/&gt; of your Java/Maven project&#x27;</span><span class="hljs-string">&#x27;s &quot;pom.xml&quot; file.&#x27;</span><span class="hljs-built_in">set</span> -xNAME=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following complex command behaves similarly to the previous one but&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;extracts the value of the &lt;version/&gt; element within &lt;project/&gt; instead.&#x27;</span><span class="hljs-built_in">set</span> -xVERSION=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.version | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The following command runs and outputs the execution of your Java&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;application (which Jenkins built using Maven) to the Jenkins UI.&#x27;</span><span class="hljs-built_in">set</span> -xjava -jar target/<span class="hljs-variable">$&#123;NAME&#125;</span>-<span class="hljs-variable">$&#123;VERSION&#125;</span>.jar</code></pre><h3 id="4-构建顺序错误，导致找不到jar包"><a href="#4-构建顺序错误，导致找不到jar包" class="headerlink" title="4. 构建顺序错误，导致找不到jar包"></a>4. 构建顺序错误，导致找不到jar包</h3><ul><li>报错：</li></ul><pre><code class="hljs sh">Error: Unable to access jarfile target/jenkinsSpringBoot-1.0-SNAPSHOT.jar</code></pre><p>修改前的构建脚本</p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目名&#x27;</span><span class="hljs-built_in">set</span> -xNAME=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目版本&#x27;</span><span class="hljs-built_in">set</span> -xVERSION=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.version | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-comment"># 需要後期</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;正在打包应用&#x27;</span><span class="hljs-built_in">set</span> -xmvn clean install<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;正在运行应用&#x27;</span><span class="hljs-built_in">set</span> -xjava -jar target/<span class="hljs-variable">$&#123;NAME&#125;</span>-<span class="hljs-variable">$&#123;VERSION&#125;</span>.jar</code></pre><p>修改后的构建脚本</p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-comment"># 需要後期</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;正在打包应用&#x27;</span><span class="hljs-built_in">set</span> -xmvn clean install<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目名&#x27;</span><span class="hljs-built_in">set</span> -xNAME=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.name | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;获得项目版本&#x27;</span><span class="hljs-built_in">set</span> -xVERSION=`mvn <span class="hljs-built_in">help</span>:evaluate -Dexpression=project.version | grep <span class="hljs-string">&quot;^[^\[]&quot;</span>`<span class="hljs-built_in">set</span> +x<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;正在运行应用&#x27;</span><span class="hljs-built_in">set</span> -xjava -jar target/<span class="hljs-variable">$&#123;NAME&#125;</span>-<span class="hljs-variable">$&#123;VERSION&#125;</span>.jar</code></pre><ul><li>原因：获得项目名等方式可能会导致jar包丢失</li></ul>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-Jenkins从入门到进阶</title>
    <link href="/04-Linux/02-CICD/01-Jenkins/10-Jenkins%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"/>
    <url>/04-Linux/02-CICD/01-Jenkins/10-Jenkins%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Jenkins进阶入门"><a href="#Jenkins进阶入门" class="headerlink" title="Jenkins进阶入门"></a>Jenkins进阶入门</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p><code>docker-compose.yml</code>文件</p><pre><code class="hljs yml"><span class="hljs-comment"># 作者：岑忠满</span><span class="hljs-comment"># 日期：2018年12月3日</span><span class="hljs-comment"># 功能：jenkins-BlueOcean</span><span class="hljs-comment"># 说明：建议用户名使用root(必须为Docker用户组)，挂载的.m2路径也需要相同用户名</span><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">jenkins:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">jenkinsci/blueocean</span>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/var/jenkins_home</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span></code></pre><p>然后，访问<code>hostName:8080</code>就能看到界面了</p><h2 id="2-部署第一个Github应用"><a href="#2-部署第一个Github应用" class="headerlink" title="2. 部署第一个Github应用"></a>2. 部署第一个Github应用</h2><h3 id="2-1-创建并将Jenkinsfile放在工程跟路径下"><a href="#2-1-创建并将Jenkinsfile放在工程跟路径下" class="headerlink" title="2.1 创建并将Jenkinsfile放在工程跟路径下"></a>2.1 创建并将<code>Jenkinsfile</code>放在工程跟路径下</h3><pre><code class="hljs Jenkinsfile">pipeline &#123;    agent &#123;        docker &#123;            image &#39;maven:3-alpine&#39;            args &#39;-v maven-repository:&#x2F;root&#x2F;.m2&#39;        &#125;    &#125;    stages &#123;        stage(&#39;Build&#39;) &#123;            steps &#123;                sh &#39;mvn -B -DskipTests clean package&#39;            &#125;        &#125;        stage(&#39;Test&#39;) &#123;            steps &#123;                sh &#39;mvn test&#39;            &#125;        &#125;        stage(&#39;Deliver&#39;) &#123;            steps &#123;                sh &#39;java -jar target&#x2F;*.jar&#39;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="2-2-在Jenkins的BlueOcean中给添加流水线"><a href="#2-2-在Jenkins的BlueOcean中给添加流水线" class="headerlink" title="2.2 在Jenkins的BlueOcean中给添加流水线"></a>2.2 在Jenkins的<code>BlueOcean</code>中给添加流水线</h3><p>这时候，你的应用会在<code>Github</code>每次更新的时候自动构建啦。然而，肯定不只是这样的，这就叫进阶怕被打。。。</p><h2 id="3-构建特定分支"><a href="#3-构建特定分支" class="headerlink" title="3. 构建特定分支"></a>3. 构建特定分支</h2><p>我们肯定不是要每个分支都构建的呀，只有特定版本才需要构建。</p><pre><code class="hljs Jenkinsfile">stage(&#39;Deliver for development&#39;) &#123;    when &#123;        branch &#39;development&#39; &#x2F;&#x2F; 这里就写特定的分支啦    &#125;    steps &#123;        sh &#39;Do Something&#39;    &#125;&#125;stage(&#39;Deliver for development&#39;) &#123;    when &#123;        branch &#39;development&#39; &#x2F;&#x2F; 这里就写特定的分支啦    &#125;    steps &#123;        sh &#39;Do Something&#39;    &#125;&#125;</code></pre><h2 id="4-设置自动推送"><a href="#4-设置自动推送" class="headerlink" title="4. 设置自动推送"></a>4. 设置自动推送</h2><h3 id="4-1-Github"><a href="#4-1-Github" class="headerlink" title="4.1 Github"></a>4.1 Github</h3><p>Github将负责通知Jenkins去构建和发布你的代码</p><p><img src="../images/2018-12-04-00-25-58.png"></p><h3 id="4-2-Gitlab"><a href="#4-2-Gitlab" class="headerlink" title="4.2 Gitlab"></a>4.2 Gitlab</h3><p>gitlab太复杂了，就不搞了，人工吧</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>02-CICD</category>
      
      <category>01-Jenkins</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-netpaln-ubuntu18.04网络配置</title>
    <link href="/04-Linux/11-netpaln-ubuntu18.04%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <url>/04-Linux/11-netpaln-ubuntu18.04%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="NetPlan"><a href="#NetPlan" class="headerlink" title="NetPlan"></a>NetPlan</h1><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><pre><code class="hljs sh">sudo vim /etc/netplan/50-cloud-init.yaml</code></pre><ul><li>生效</li></ul><pre><code class="hljs sh">sudo netplan apply</code></pre><h2 id="静态Ip"><a href="#静态Ip" class="headerlink" title="静态Ip"></a>静态Ip</h2><p><img src="../images/11-01.png"></p><h2 id="动态IP"><a href="#动态IP" class="headerlink" title="动态IP"></a>动态IP</h2><p><img src="../images/11-02.png"></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Docker-Get-Started</title>
    <link href="/04-Linux/01-Docker/01-Docker-Get-Started/"/>
    <url>/04-Linux/01-Docker/01-Docker-Get-Started/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Get-Started"><a href="#Docker-Get-Started" class="headerlink" title="Docker-Get-Started"></a>Docker-Get-Started</h1><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>传统的虚拟技术是在操作系统之上使用虚拟化技术，每一个应用需要创建一个虚拟机(guest os)然后再在虚拟机上装应用，虚拟机有时比应用还要大(<strong>月饼盒比月饼还贵</strong>)，导致了过多的资源消耗。</p><p><img src="https://yeasy.gitbooks.io/docker_practice/introduction/_images/virtualization.png" alt="传统虚拟化"></p><p><img src="https://yeasy.gitbooks.io/docker_practice/introduction/_images/docker.png" alt="Docker"></p><p>而使用Docker引擎，直接使用宿主的内核，没有再进行硬件虚拟化。</p><h2 id="Docker的三大概念"><a href="#Docker的三大概念" class="headerlink" title="Docker的三大概念"></a>Docker的三大概念</h2><h3 id="镜像Image-（类）"><a href="#镜像Image-（类）" class="headerlink" title="镜像Image （类）"></a>镜像Image （类）</h3><p>镜像就是镜像，使用<strong>分层技术（就像继承）</strong>，每一层<strong>提交之后不能再改变</strong>，新的变化只能发生在自己的这一层，即使是删除文件，也仅仅是在新的一层标志为删除，文件依旧存在，举个栗子：</p><p>我在Ubuntu16.04的官方镜像作为基础层安装了MySQL，我在我的层上删除任何原生镜像的文件，文件就在我的层不能是使用了，整个镜像不会越来越小，只会越来越大。</p><p><img src="../images/01-01.png" alt="Picture1"></p><p><strong>因此，在提交的时候，请想清楚什么是没用的。</strong></p><h3 id="容器Container-（对象）"><a href="#容器Container-（对象）" class="headerlink" title="容器Container （对象）"></a>容器Container （对象）</h3><p>容器是镜像的实例，能够被创建，启动，停止，删除，暂停。一个镜像可以创建多个容器。</p><p><strong>容器的实质是进程</strong> ，容器拥有自己的命名空间（区别于宿主主机的命名空间），容器在运行时在镜像之上创建当前容器的存储层，这个存储层的数据会随着容器的删除而消失，就像虚拟机一样。官方不建议我们把任何数据放在存储层上，保持无状态化，使用<strong>数据卷</strong>或者绑定宿主主机的目录。(<em>在使用HDFS的时候文件应该放在哪？</em>)</p><h3 id="Docker-Registry-和仓库Repository"><a href="#Docker-Registry-和仓库Repository" class="headerlink" title="Docker Registry 和仓库Repository"></a>Docker Registry 和仓库Repository</h3><p>一个Docker Registry可以包含多个仓库，每个仓库包含多个和Tag，每个Tag对应一个镜像。</p><p><code>制作者/仓库名:Tag</code></p><h4 id="常见Docker-Registry"><a href="#常见Docker-Registry" class="headerlink" title="常见Docker Registry"></a>常见Docker Registry</h4><p><a href="https://hub.docker.com/">DockerHub</a></p><p><a href="https://cr.console.aliyun.com/#/accelerator">阿里云镜像</a></p><h4 id="允许用户在本地搭建自己的Docker-Registry"><a href="#允许用户在本地搭建自己的Docker-Registry" class="headerlink" title="允许用户在本地搭建自己的Docker Registry"></a>允许用户在本地搭建自己的Docker Registry</h4><p>见下文</p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>请移步<a href="https://docs.docker.com/">官方文档</a></p><h3 id="使用阿里云镜像"><a href="#使用阿里云镜像" class="headerlink" title="使用阿里云镜像"></a>使用阿里云镜像</h3><p>暂时没碰到速度上的问题</p><h3 id="镜像操控"><a href="#镜像操控" class="headerlink" title="镜像操控"></a>镜像操控</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>镜像在下载时候也是分层下载的，</p><p><code>docker pull [选项][Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt; </code></p><p><code>docker pull ubuntu:14.04 </code></p><h4 id="列举镜像"><a href="#列举镜像" class="headerlink" title="列举镜像"></a>列举镜像</h4><p><code>docker imaages</code></p><p><code>docker images ubuntu </code></p><p><code>docker images ubuntu:16.04</code></p><pre><div class="caption"><span>images -f since</span></div><code class="hljs docker">```docker images -f since=ubuntu:<span class="hljs-number">16.04</span>```列举下层镜像```docker images -q ```使用过滤器配合-q参数可以产生指定范围的ID<span class="hljs-comment">#### 删除镜像</span>```docker rmi ubuntu:<span class="hljs-number">16.04</span>```<span class="hljs-comment">#### 提交自己的镜像(创建类)</span>在使用镜像时候，所有的数据存在容器的存储层，使用commit命令可以将存储层的数据保存下来作为镜像，这种方法属于黑箱操作，应该使用Dockerfile来完成定制镜像制作。![r](../images/<span class="hljs-number">01</span>-<span class="hljs-number">03</span>.png)```docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] ```</code></pre><p>docker commit <br>–author “cenzhongman” <br>–message “修改的信息，支持中文” <br>webserver <br>nginx:v2</p><pre><code class="hljs clean">#### Dockerfile的使用Dockerfile是一个脚本文件，每一条指令构建一层。### 容器操控 #### 创建容器(实例化Container )```docker run -it --rm ubuntu:<span class="hljs-number">16.04</span> bash ```- -i 交互式操作- -t 终端- -rm 容器结束即删除，不会占用空间，不能与-d一起使用- 使用镜像ubuntu:<span class="hljs-number">16.04</span>作为基础层- bash 执行的命令- -d  Run container <span class="hljs-keyword">in</span> background and print container ID 不适用就当是前台进程- -p Publish all exposed ports to random ports 允许自己声明- --name 容器显示的名称，不给名称就#### 列举容器```docker ps```* -a 列举包括关闭的#### 关闭容器```docker stop```#### 启动容器```docker start```#### 查看输出信息```docker losg```#### 重启容器```docker restart```#### 导出容器(创建快照)```docker <span class="hljs-keyword">export</span> asd23123dsdr &gt; ubuntu.tar ```#### 导入容器(从快照恢复)```cat ubuntu.tar | sudo docker <span class="hljs-keyword">import</span> - test/ubuntu:v1<span class="hljs-number">.0</span> ```* 使用<span class="hljs-keyword">export</span>保存的快照包括了存储层的数据，丢失了历史记录和元数据信息版本。需要重新指定标签等元数据信息* 使用镜像文件load进来的保存了完整的记录，文件也要大一点#### 删除容器```docker rm ```删除一个```docker rm $(docker ps -a -q)```删除所有#### 进入容器```docker attach ```### 使用仓库#### 登陆仓库```docker login```文件存在用户目录的```.dockercfg```#### 查找镜像```docker search```#### 下载```docker pull```#### 上传```docker push```### 私有仓库这是一个服务器进程，构建一个私人的仓库服务器。(还有其他方式)#### 创建服务程序```shellsudo docker run -d -p <span class="hljs-number">5000</span>:<span class="hljs-number">5000</span> registry</code></pre><h4 id="标记镜像-注意只有两个参数"><a href="#标记镜像-注意只有两个参数" class="headerlink" title="标记镜像(注意只有两个参数)"></a>标记镜像(注意只有两个参数)</h4><p><code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] </code></p><pre><code class="hljs shell">docker tag ubuntu 127.0.0.1:5000/myubuntu:123</code></pre><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><pre><code class="hljs shell">docker push 127.0.0.1:5000/myubuntu # 是能使用REPOSITORY</code></pre><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><pre><code class="hljs angelscript">docker pull <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">5000</span>/myubuntu</code></pre><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h4><pre><code class="hljs shell">sudo docker run -d -P --name web -v /webapp training/webapp</code></pre><ul><li>允许一次创建多个数据卷，数据卷将加到容器的对应目录，数据卷中的数据将不会随容器删除</li></ul><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p>删除数据卷可以在删除容器的时候删除，如果不删除，那就没什么办法了。</p><pre><code class="hljs shell">socker rm -v</code></pre><h4 id="挂载本机文件夹作为数据卷"><a href="#挂载本机文件夹作为数据卷" class="headerlink" title="挂载本机文件夹作为数据卷"></a>挂载本机文件夹作为数据卷</h4><pre><code class="hljs shell">sudo docker run -d -P --name web -v /src/webapp:/opt/webapp</code></pre><ul><li>在希望在window server上使用的镜像不建议在Dockerfile中使用这种方式</li><li>Docker 挂载数据卷的默认权限是读写，用户也可以通过<code> :ro</code> 指定为只读 </li></ul><h4 id="查看数据卷信息"><a href="#查看数据卷信息" class="headerlink" title="查看数据卷信息"></a>查看数据卷信息</h4><pre><code class="hljs shell">docker inspect</code></pre><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>使用一个容器作为数据卷的挂载管理，用于不同容器间的文件互通，目前暂时没研究</p><h2 id="网络使用"><a href="#网络使用" class="headerlink" title="网络使用"></a>网络使用</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>使用-P随机完成网络端口映射，-p指定完成网络映射(<strong>多个端口多个-p</strong>)</p><pre><code class="hljs shell">docker run -d -p 80:80 ngnix</code></pre><h4 id="支持格式"><a href="#支持格式" class="headerlink" title="支持格式"></a>支持格式</h4><ul><li><code>ip:hostPort:containerPort </code></li><li><code>ip::containerPort </code>本机端口将随机分配</li><li><code>hostPort:containerPort </code></li></ul><h4 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a>查看网络状态</h4><ul><li><p>在<code>docker ps</code>或<code>docker port</code>中可以查看映射情况</p></li><li><p>window查看端口<code>netstat -ano</code>可结合<code>|findstr &quot;49157&quot;</code>使用</p></li><li><p>centos查看端口<code>netstat -ntlp</code>可结合<code>|grep</code>使用</p></li><li><p>ubuntu查看端口<code>netstat -ap</code>可结合<code>|grep</code>使用</p></li></ul><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>容器互联是在一台主机上的多个容器之间不向外暴露端口的一种连接方式</p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p><img src="../images/01-03.png" alt="2017-09-02_221807"></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Dockerfile</title>
    <link href="/04-Linux/01-Docker/02-Dockerfile/"/>
    <url>/04-Linux/01-Docker/02-Dockerfile/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Dockerfile的使用"><a href="#Dockerfile的使用" class="headerlink" title="Dockerfile的使用"></a>Dockerfile的使用</h1><h3 id="使用自己的Dockerfile"><a href="#使用自己的Dockerfile" class="headerlink" title="使用自己的Dockerfile"></a>使用自己的Dockerfile</h3><p>Dockerfile是一个脚本文件，每一条指令构建一层。</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像</span><span class="hljs-keyword">FROM</span> nginx<span class="hljs-comment"># 使用RUN来执行一条命令，注意一条指令作为一层，可以使用 / 换行，使用 # 注释 </span><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></code></pre><p>在Dockerfile所在文件夹执行</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t nginx:v<span class="hljs-number">3</span> .</code></pre><ul><li>-t  Name and optionally a tag in the ‘name:tag’ format</li></ul><h3 id="理解上下文"><a href="#理解上下文" class="headerlink" title="理解上下文"></a>理解上下文</h3><pre><div class="caption"><span>如果我需要的文件（Dockerfile和其他需要使用的文件）在```/home/ubuntu/```路径下，那么这个命令就该变成```docker build -t nginx:v3</span><a href="/home/ubuntu/```整个文件夹下的所有文件将会被复制到服务端作为上下文环境来打包镜像，可以使用```.dockerignore">```文件来忽略文件或在文件夹。</a></div><code class="hljs .```表示的不是当前路径下的Dockerfile文件，而是创造上下文，">当然，你可以指定Dockerfile是哪一个，如在&#x2F;home&#x2F;ubuntu&#x2F;上一级目录中&#96;&#96;&#96;docker build -t nginx:v3 -f ..&#x2F;imDockerfile &#x2F;home&#x2F;ubuntu&#x2F; &#96;&#96;&#96;容器中的复制和容器外的复制&#96;&#96;&#96;dockerfile# 这里的点表示上下文，不存在..&#x2F;这样的格式COPY .&#x2F;123.data&#x2F; &#x2F;opt&#x2F;RUN cp &#x2F;opt&#x2F;123.data &#x2F;opt&#x2F;data&#x2F;</code></pre><h3 id="使用来自URL的Dockerfile"><a href="#使用来自URL的Dockerfile" class="headerlink" title="使用来自URL的Dockerfile"></a>使用来自URL的Dockerfile</h3><pre><code class="hljs shell">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</code></pre><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h3><pre><code class="hljs shell">docker build http://server/context.tar.gz</code></pre><h1 id="命令剖析"><a href="#命令剖析" class="headerlink" title="命令剖析"></a>命令剖析</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><ul><li>基础镜像</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx</code></pre><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li>使用RUN来执行一条命令，注意一条指令作为一层，可以使用 / 换行，使用 # 注释 </li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></code></pre><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><ul><li>这里的点表示上下文，不存在../这样的格式，点可以不写，可以使用通配符 * ？ 等</li><li>后面是是目标目录，可以是容器内的<strong>绝对路径</strong>，或者使用<strong>WORKDIR来指定的工作目录</strong></li><li>目标目录不存在会自动创建</li><li>源文件的元数据将会保留</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="bash"> ./123.data/ /opt/</span></code></pre><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li>加强版COPY，源路径可以是URL，但是存在文件权限需要修改，压缩包需要解压等问题，不如直接使用wget</li><li>在ADD会自动解压到指定目录</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></code></pre><h3 id="CMD-用于主进程-，推荐使用json"><a href="#CMD-用于主进程-，推荐使用json" class="headerlink" title="CMD(用于主进程)，推荐使用json"></a>CMD(用于主进程)，推荐使用json</h3><ul><li>指定不到命令启动时候的默认命令</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span></span><span class="hljs-comment"># bash是使用-c参数执行的</span><span class="hljs-keyword">CMD</span><span class="bash"> [ <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo <span class="hljs-variable">$HOME</span>&quot;</span> ]</span></code></pre><ul><li>上述的命令是以sh为主进程的，sh执行结束，命令就结束了</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> service nginx start</span><span class="hljs-comment"># ==</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;service nginx start&quot;</span>]<span class="hljs-comment"># 这个程序在sh执行为守护进程，进程开启，sh命令执行完毕，接着就结束了主进程sh，这是错误的</span></span><span class="hljs-comment"># 正确做法是直接执行可执行文件作为主程序执行，，并且要求前台</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span></code></pre><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li>场景一：让镜像变成像命令一样使用 </li><li>场景二：应用运行前的准备工作 </li></ul><h3 id="ENV-全部"><a href="#ENV-全部" class="headerlink" title="ENV(全部)"></a>ENV(全部)</h3><ul><li>支持RUN的环境变量$HADOOP_HOME直接使用</li><li>同时作为容器内的应用作为环境变量</li><li>含有空格的值用双引号括起来 </li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;</code></pre><h3 id="ARG-不包含容器内"><a href="#ARG-不包含容器内" class="headerlink" title="ARG(不包含容器内)"></a>ARG(不包含容器内)</h3><ul><li>这里定义的参数可以使用</li></ul><pre><code class="hljs shell">docker build --build-arg &lt;参数名&gt;=&lt;值&gt; # 覆盖参数</code></pre><h3 id="VOLUME-挂载匿名卷"><a href="#VOLUME-挂载匿名卷" class="headerlink" title="VOLUME(挂载匿名卷)"></a>VOLUME(挂载匿名卷)</h3><ul><li>? 这个路径放到了文件系统的哪里</li><li>？这个命名卷是什么鬼</li></ul><pre><code class="hljs dockerfile">VALUME /data<span class="hljs-comment"># 使用命名卷mydada替代匿名卷</span>docker <span class="hljs-keyword">run</span><span class="bash"> -d -v mydata:/data xxxx</span></code></pre><h3 id="EXPOSE声明端口"><a href="#EXPOSE声明端口" class="headerlink" title="EXPOSE声明端口"></a>EXPOSE声明端口</h3><p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P时，会自动随机映射 EXPOSE 的端口。 </p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><ul><li>RUN的运行环境的工作目录（当前目录）</li><li>使用的是最新的WORKDIR</li></ul><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><ul><li>修改以后的用户</li></ul><h3 id="ONBUILD-其他指令"><a href="#ONBUILD-其他指令" class="headerlink" title="ONBUILD + 其他指令"></a>ONBUILD + 其他指令</h3><ul><li>当前镜像执行时候并不会执行，在构建下一级镜像时这里的zh</li></ul><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:jessie-backports<span class="hljs-keyword">RUN</span><span class="bash"> apt-get update \</span><span class="bash">    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y -t jessie-backports --no-install-recommends  openjdk-8-jre-headless ca-certificates-java \</span><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>    <span class="hljs-keyword">ENV</span> JAVA_HOME=/usr/lib/jvm/java-<span class="hljs-number">8</span>-openjdk-amd64/<span class="hljs-keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends net-tools curl</span><span class="hljs-keyword">RUN</span><span class="bash"> gpg --keyserver pool.sks-keyservers.net --recv-keys \</span><span class="bash">    07617D4968B34D8F13D56E20BE5AAA0BA210C095 \</span><span class="bash">    2CAC83124870D88586166115220F69801F27E622 \</span><span class="bash">    4B96409A098DBD511DF2BC18DBAF69BEA7239D59 \</span><span class="bash">    9DD955653083EFED6171256408458C39E964B5FF \</span><span class="bash">    B6B3F7EDA5BA7D1E827DE5180DFF492D8EE2F25C \</span><span class="bash">    6A67379BEFC1AE4D5595770A34005598B8F47547 \</span><span class="bash">    47660BC98BC433F01E5C90581209E7F13D0C92B9 \</span><span class="bash">    CE83449FDC6DACF9D24174DCD1F99F6EE3CD2163 \</span><span class="bash">    A11DF05DEA40DA19CE4B43C01214CF3F852ADB85 \</span><span class="bash">    686E5EDF04A4830554160910DF0F5BBC30CD0996 \</span><span class="bash">    5BAE7CB144D05AD1BB1C47C75C6CC6EFABE49180 \</span><span class="bash">    AF7610D2E378B33AB026D7574FB955854318F669 \</span><span class="bash">    6AE70A2A38F466A5D683F939255ADF56C36C5F0F \</span><span class="bash">    70F7AB3B62257ABFBD0618D79FDB12767CC7352A \</span><span class="bash">    842AAB2D0BC5415B4E19D429A342433A56D8D31A \</span><span class="bash">    1B5D384B734F368052862EB55E43CAB9AEC77EAF \</span><span class="bash">    785436A782586B71829C67A04169AA27ECB31663 \</span><span class="bash">    5E49DA09E2EC9950733A4FF48F1895E97869A2FB \</span><span class="bash">    A13B3869454536F1852C17D0477E02D33DD51430 \</span><span class="bash">    A6220FFCC86FE81CE5AAC880E3814B59E4E11856 \</span><span class="bash">    EFE2E7C571309FE00BEBA78D5E314EEF7340E1CB \</span><span class="bash">    EB34498A9261F343F09F60E0A9510905F0B000F0 \</span><span class="bash">    3442A6594268AC7B88F5C1D25104A731B021B57F \</span><span class="bash">    6E83C32562C909D289E6C3D98B25B9B71EFF7770 \</span><span class="bash">    E9216532BF11728C86A11E3132CF4BF4E72E74D3 \</span><span class="bash">    E8966520DA24E9642E119A5F13971DA39475BD5D \</span><span class="bash">    1D369094D4CFAC140E0EF05E992230B1EB8C6EFA \</span><span class="bash">    A312CE6A1FA98892CB2C44EBA79AB712DE5868E6 \</span><span class="bash">    0445B7BFC4515847C157ECD16BA72FF1C99785DE \</span><span class="bash">    B74F188889D159F3D7E64A7F348C6D7A0DCED714 \</span><span class="bash">    4A6AC5C675B6155682729C9E08D51A0A7501105C \</span><span class="bash">    8B44A05C308955D191956559A5CEE20A90348D47 </span><span class="hljs-keyword">ENV</span> HADOOP_VERSION <span class="hljs-number">2.7</span>.<span class="hljs-number">2</span><span class="hljs-keyword">ENV</span> HADOOP_URL https://www.apache.org/dist/hadoop/common/hadoop-$HADOOP_VERSION/hadoop-$HADOOP_VERSION.tar.gz<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">set</span> -x \</span><span class="bash">    &amp;&amp; curl -fSL <span class="hljs-string">&quot;<span class="hljs-variable">$HADOOP_URL</span>&quot;</span> -o /tmp/hadoop.tar.gz \</span><span class="bash">    &amp;&amp; curl -fSL <span class="hljs-string">&quot;<span class="hljs-variable">$HADOOP_URL</span>.asc&quot;</span> -o /tmp/hadoop.tar.gz.asc \</span><span class="bash">    &amp;&amp; gpg --verify /tmp/hadoop.tar.gz.asc \</span><span class="bash">    &amp;&amp; tar -xvf /tmp/hadoop.tar.gz -C /opt/ \</span><span class="bash">    &amp;&amp; rm /tmp/hadoop.tar.gz*</span>    <span class="hljs-keyword">RUN</span><span class="bash"> ln -s /opt/hadoop-<span class="hljs-variable">$HADOOP_VERSION</span>/etc/hadoop /etc/hadoop</span><span class="hljs-keyword">RUN</span><span class="bash"> cp /etc/hadoop/mapred-site.xml.template /etc/hadoop/mapred-site.xml</span><span class="hljs-keyword">RUN</span><span class="bash"> mkdir /opt/hadoop-<span class="hljs-variable">$HADOOP_VERSION</span>/logs</span><span class="hljs-keyword">RUN</span><span class="bash"> mkdir /hadoop-data</span><span class="hljs-keyword">ENV</span> HADOOP_PREFIX=/opt/hadoop-$HADOOP_VERSION<span class="hljs-keyword">ENV</span> HADOOP_CONF_DIR=/etc/hadoop<span class="hljs-keyword">ENV</span> MULTIHOMED_NETWORK=<span class="hljs-number">1</span><span class="hljs-keyword">ENV</span> <span class="hljs-keyword">USER</span>=root<span class="hljs-keyword">ENV</span> PATH $HADOOP_PREFIX/bin/:$PATH<span class="hljs-keyword">ADD</span><span class="bash"> entrypoint.sh /entrypoint.sh</span><span class="hljs-keyword">RUN</span><span class="bash"> chmod a+x /entrypoint.sh</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;/entrypoint.sh&quot;</span>]</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Docker Swarm 原理剖析</title>
    <link href="/04-Linux/01-Docker/04-Docker%20Swarm%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <url>/04-Linux/01-Docker/04-Docker%20Swarm%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="节点运行机制"><a href="#节点运行机制" class="headerlink" title="节点运行机制"></a>节点运行机制</h1><p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png"><br>分为两类节点，manegers和workers</p><h2 id="Manager-nodes"><a href="#Manager-nodes" class="headerlink" title="Manager nodes"></a>Manager nodes</h2><pre><code>监控集群状态调度服务作为HTTP服务的入口</code></pre><p><a href="http://thesecretlivesofdata.com/raft/">动画展示</a>使用<a href="http://www.sohu.com/a/168147592_659549">Raft</a>算法，在Raft中，有三种角色（这三种节点都管理者才有的，工人阶级是不能当选民的）</p><pre><code>* Leader:当权者* Follower：选民* Candidate:候选人(最先发现皇上驾崩了的人，发出选举，投票给自己)（如果同时又两个Follower变成Candidate参与Leader的竞选，则进入分裂选举（Split Vote）谁先得到50%以上选票，则当选） 选举流程，使备用端口通信</code></pre><p>三个magnager最多允许丢失一个naneger 五个manager最多允许丢失一个naneger N个manager最多允许丢失(N-1)/2个naneger 但是不是说越多就越好，过多的主节点将意味着过多资源消耗</p><h1 id="服务运行机制"><a href="#服务运行机制" class="headerlink" title="服务运行机制"></a>服务运行机制</h1><p>服务可以配置的项目</p><ul><li>the port where the swarm will make the service available outside the swarm 对外的IP </li><li>an overlay network for the service to connect to other services in the swarm 集群中的IP</li><li>CPU and memory limits and reservations </li><li>a rolling update policy 更新策略</li><li>the number of replicas of the image to run in the swarm　副本数</li></ul><h2 id="Services-tasks-和-containers-的区别"><a href="#Services-tasks-和-containers-的区别" class="headerlink" title="Services tasks 和 containers 的区别"></a>Services tasks 和 containers 的区别</h2><p>docker servie可以快速部署，多节点自动均衡，使用一致对外的端口，也就是说一个service是由一到多个container组成的，对外看起来却是一致的，作为一个服务<br><img src="https://docs.docker.com/engine/swarm/images/services-diagram.png"></p><p>Swarm调度的是任务而不是容器。<br>一个任务会启动一个容器，任务是存放容器的漕，任务失败之后将会删除任务，重新创建任务和容器。</p><h4 id="Pending-services"><a href="#Pending-services" class="headerlink" title="Pending services"></a>Pending services</h4><p>服务可以处于等待状态，就是没有任何任务和容器可以处理任务，依然处于等待(pending)状态。<br>    如果用于防止这个服务被创建，使用配置scale数量为0而不是配置成pending状态<br>以下是会出现的场景<br>(这里的任务是真的任务，上文的任务是实例)</p><ul><li>If all nodes are paused中止 or drained耗尽, and you create a service, it will be pending until a node becomes available. In reality, the first node to become available will get all of the tasks, so this is not a good thing to do in a production environment.资源耗尽等待</li><li>You can reserve a specific amount of memory for a service. If no node in the swarm has the required amount of memory, the service will remain in a pending state until a node is available which can run its tasks. If you specify a very large value, such as 500 GB, the task will be pending forever, unless you really have a node which can satisfy it.资源不足等待</li><li>You can impose placement constraints on the service, and the constraints may not be able to be honored at a given time.约束配置等待</li></ul><h4 id="Replicated-and-global-services"><a href="#Replicated-and-global-services" class="headerlink" title="Replicated and global services"></a>Replicated and global services</h4><p>For a replicated service, you specify the number of identical tasks you want to run. For example, you decide to deploy an HTTP service with three replicas, each serving the same content.</p><p>A global service is a service that runs one task on every node. There is no pre-specified number of tasks. Each time you add a node to the swarm, the orchestrator creates a task and the scheduler assigns the task to the new node. Good candidates for global services are monitoring agents, an anti-virus scanners or other types of containers that you want to run on every node in the swarm.不能指定Tasks数量，每个节点一个<br><img src="https://docs.docker.com/engine/swarm/images/replicated-vs-global.png"><br><a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#learn-more">https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#learn-more</a></p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Docker Swarm安装</title>
    <link href="/04-Linux/01-Docker/03-Docker%20Swarm%E5%AE%89%E8%A3%85/"/>
    <url>/04-Linux/01-Docker/03-Docker%20Swarm%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Swarm安装"><a href="#Docker-Swarm安装" class="headerlink" title="Docker Swarm安装"></a>Docker Swarm安装</h1><p>centos版本：7.0<br>Docker版本：17.06.2.ce-1.el7.centos</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><a href="http://blog.csdn.net/sannerlittle/article/details/76199087">参考博客</a><br><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/#open-protocols-and-ports-between-the-hosts">官方文档说明</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-the-linux-firewall-for-docker-swarm-on-centos-7">centos7开放端口</a></p><h4 id="开放端口而不是关闭防火墙"><a href="#开放端口而不是关闭防火墙" class="headerlink" title="开放端口而不是关闭防火墙"></a>开放端口而不是关闭防火墙</h4><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=2376/tcp --permanent</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=2377/tcp --permanent</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=7946/tcp --permanent</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=7946/udp --permanent</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=4789/udp --permanent</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --reload</span></code></pre><p>!!<strong>关闭防火墙为错误做法</strong>，详情参照BUG部分<br>!!<strong>改用iptable为错误做法</strong>，参照BUG部分</p><h4 id="配置自己的ssh定时发送空包"><a href="#配置自己的ssh定时发送空包" class="headerlink" title="配置自己的ssh定时发送空包"></a>配置自己的ssh定时发送空包</h4><pre><code class="hljs routeros">touch ~/.ssh/config<span class="hljs-comment"># 增加内容</span>ServerAliveInterval 60</code></pre><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="一-Centos安装Docker-使用rpm安装"><a href="#一-Centos安装Docker-使用rpm安装" class="headerlink" title="一.Centos安装Docker(使用rpm安装)"></a>一.Centos安装Docker(使用rpm安装)</h2><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/">官方文档</a></p><h4 id="登录主节点"><a href="#登录主节点" class="headerlink" title="登录主节点"></a>登录主节点</h4><pre><code class="hljs shell">ssh root@114.67.37.2 -p 10376</code></pre><h4 id="免秘钥登录-建议修改-etc-hosts文件"><a href="#免秘钥登录-建议修改-etc-hosts文件" class="headerlink" title="免秘钥登录(建议修改/etc/hosts文件)"></a>免秘钥登录(建议修改/etc/hosts文件)</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成本地秘钥</span><span class="hljs-meta">$</span><span class="bash"> ssh-keygen -t rsa</span><span class="hljs-meta">#</span><span class="bash"> 复制秘钥</span><span class="hljs-meta">$</span><span class="bash"> ssh-copy-id root@HOSTNAME</span>10.173.38.37 win2008.gci.com win200810.173.38.43 ubuntu.gci.com ubuntu10.173.38.34 centos6.gci.com centos610.173.38.40 centos5.gci.com centos510.173.38.42 centos4.gci.com centos410.173.38.38 centos3.gci.com centos310.173.38.39 centos2.gci.com centos210.173.38.41 centos1.gci.com centos1</code></pre><h4 id="主节点下载docker-需要网络"><a href="#主节点下载docker-需要网络" class="headerlink" title="主节点下载docker(需要网络)"></a>主节点下载docker(需要网络)</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> stable:稳定版本</span><span class="hljs-meta">#</span><span class="bash"> Edge:  月更新版</span>mkdir docker &amp;&amp; cd docker &amp;&amp; wget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-17.06.2.ce-1.el7.centos.x86_64.rpmtouch install_docker.shchmod 755 install_docker.shvim install_docker.sh<span class="hljs-meta">#</span><span class="bash"> 增加以下内容</span>scp docker-ce-17.06.2.ce-1.el7.centos.x86_64.rpm root@HOSTNAME:/rootsudo yum -y install docker-cexite-17.06.2.ce-1.el7.centos.x86_64.rpmsudo systemctl start dockersudo docker run hello-world</code></pre><h4 id="从节点安装-cnetos７需要网络"><a href="#从节点安装-cnetos７需要网络" class="headerlink" title="从节点安装(cnetos７需要网络)"></a>从节点安装(cnetos７需要网络)</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 使用scp复制文件(无网络时使用)</span>scp -r /root/docker root@HOSTNAME:/rootcd /root/docker &amp;&amp; ./install_docker.sh</code></pre><h4 id="从节点安装-ubuntu需要网络"><a href="#从节点安装-ubuntu需要网络" class="headerlink" title="从节点安装(ubuntu需要网络)"></a>从节点安装(ubuntu需要网络)</h4><p>ubuntu需要区分指令集。。。我们使用AMD64 == X86-64</p><pre><code class="hljs shell">wget https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/docker-ce_17.06.2~ce-0~ubuntu_amd64.deb</code></pre><h1 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h1><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><table><thead><tr><th>roles</th><th>主机IP</th><th>hostname</th><th>hostname</th><th>memory</th></tr></thead><tbody><tr><td>worker</td><td>10.173.38.43</td><td>ubuntu.gci.com</td><td>ubuntu</td><td>16</td></tr><tr><td>worker</td><td>10.173.38.34</td><td>centos6.gci.com</td><td>centos6</td><td>16</td></tr><tr><td>manager</td><td>10.173.38.40</td><td>centos5.gci.com</td><td>centos5</td><td>32</td></tr><tr><td>manager</td><td>10.173.38.42</td><td>centos4.gci.com</td><td>centos4</td><td>32</td></tr><tr><td>manager</td><td>10.173.38.38</td><td>centos3.gci.com</td><td>centos3</td><td>32</td></tr><tr><td>manager</td><td>10.173.38.39</td><td>centos2.gci.com</td><td>centos2</td><td>32</td></tr><tr><td>manager</td><td>10.173.38.41</td><td>centos1.gci.com</td><td>centos1</td><td>32</td></tr></tbody></table><h4 id="初始化主节点"><a href="#初始化主节点" class="headerlink" title="初始化主节点"></a>初始化主节点</h4><p>发现服务IP:10.173.38.41<br>使用默认的发现服务端口0.0.0.0:2377</p><pre><code class="hljs livecodeserver">$ docker swarm init <span class="hljs-comment">--advertise-addr 10.173.38.41</span>Swarm initialized: current node (opahbosilatnpnzhx0vjo2ta3) is now <span class="hljs-keyword">a</span> manager.To <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> worker <span class="hljs-built_in">to</span> this swarm, run <span class="hljs-keyword">the</span> following <span class="hljs-keyword">command</span>:    docker swarm join <span class="hljs-comment">--token SWMTKN-1-387gar9i50krvemwr02sacr1z48k8wb4q20oe6puvw1nzy92gg-0ynx45u6aruxbox3zaqvch2pp 10.173.38.41:2377</span>To <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> manager <span class="hljs-built_in">to</span> this swarm, run <span class="hljs-string">&#x27;docker swarm join-token manager&#x27;</span> <span class="hljs-keyword">and</span> follow <span class="hljs-keyword">the</span> instructions.</code></pre><h4 id="加入主节点"><a href="#加入主节点" class="headerlink" title="加入主节点"></a>加入主节点</h4><p>在主节点运行<code>docker swarm join-token manager</code>来输出加入mamager的token</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> swarm join --token SWMTKN-<span class="hljs-number">1</span>-<span class="hljs-number">387</span>gar<span class="hljs-number">9</span>i<span class="hljs-number">50</span>krvemwr<span class="hljs-number">02</span>sacr<span class="hljs-number">1</span>z<span class="hljs-number">48</span>k<span class="hljs-number">8</span>wb<span class="hljs-number">4</span>q<span class="hljs-number">20</span>oe<span class="hljs-number">6</span>puvw<span class="hljs-number">1</span>nzy<span class="hljs-number">92</span>gg-<span class="hljs-number">920</span>f<span class="hljs-number">6</span>a<span class="hljs-number">6</span>xj<span class="hljs-number">58</span>kzmfwp<span class="hljs-number">2</span>z<span class="hljs-number">26</span>t<span class="hljs-number">1</span>fb <span class="hljs-number">10.173.38.41:2377</span></code></pre><h4 id="加入从节点"><a href="#加入从节点" class="headerlink" title="加入从节点"></a>加入从节点</h4><p>在主节点运行<code>docker swarm join-token worker</code>来输出加入worker的token</p><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> swarm join --token SWMTKN-<span class="hljs-number">1</span>-<span class="hljs-number">387</span>gar<span class="hljs-number">9</span>i<span class="hljs-number">50</span>krvemwr<span class="hljs-number">02</span>sacr<span class="hljs-number">1</span>z<span class="hljs-number">48</span>k<span class="hljs-number">8</span>wb<span class="hljs-number">4</span>q<span class="hljs-number">20</span>oe<span class="hljs-number">6</span>puvw<span class="hljs-number">1</span>nzy<span class="hljs-number">92</span>gg-<span class="hljs-number">0</span>ynx<span class="hljs-number">45</span>u<span class="hljs-number">6</span>aruxbox<span class="hljs-number">3</span>zaqvch<span class="hljs-number">2</span>pp <span class="hljs-number">10.173.38.41:2377</span></code></pre><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><pre><code class="hljs crmsh"><span class="hljs-comment"># 删除主节点(需要排空容器，降级为worker，保证容器不受影响)</span>docker <span class="hljs-keyword">node</span> <span class="hljs-title">update</span> --availability drain NODE_IDdocker <span class="hljs-keyword">node</span> <span class="hljs-title">update</span> --<span class="hljs-keyword">role</span> <span class="hljs-title">worker</span> NODE_IDdocker swarm rm NODE_ID<span class="hljs-comment"># 删除从节点</span>docker swarm rm NODE_ID</code></pre><h4 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h4><pre><code class="hljs crmsh">docker <span class="hljs-keyword">node</span> <span class="hljs-title">ls</span></code></pre><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h4 id="创建overlay网络docker1"><a href="#创建overlay网络docker1" class="headerlink" title="创建overlay网络docker1"></a>创建overlay网络docker1</h4><p>子网掩码:255.255.255.0</p><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create \--driver overlay \--subnet 10.0.0.0/24 \docker1</code></pre><h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><h2 id="网络通信测试"><a href="#网络通信测试" class="headerlink" title="网络通信测试"></a>网络通信测试</h2><h4 id="跨服务跨主机通信-DNS测试-–成功"><a href="#跨服务跨主机通信-DNS测试-–成功" class="headerlink" title="跨服务跨主机通信(DNS测试)–成功"></a>跨服务跨主机通信(DNS测试)–成功</h4><p>安装一个服务</p><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>create \<span class="hljs-attribute">--network</span>=docker1 \<span class="hljs-attribute">--dns</span>=8.8.8.8 \<span class="hljs-attribute">--constraint</span>=node.HOSTNAME==host-10-173-38-39 \--name nginx1 \--replicas 1 \nginx</code></pre><p>安装用于ping测试的centos</p><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>create \<span class="hljs-attribute">--network</span>=docker1 \<span class="hljs-attribute">--constraint</span>=node.HOSTNAME==host-10-173-38-41 \--name centos1 \--replicas 1 \-t \sequenceiq/pam /bin/bash</code></pre><p>测试容器互通</p><pre><code class="hljs apache"><span class="hljs-attribute">ping</span> nginx<span class="hljs-number">1</span></code></pre><h4 id="访问外部网络测试–成功"><a href="#访问外部网络测试–成功" class="headerlink" title="访问外部网络测试–成功"></a>访问外部网络测试–成功</h4><p>默认的DNS是127.0.0.1<br>在创建服务/启动容器时候配置DNS是必要的，使用宿主主机的DNS并不可靠</p><pre><code class="hljs css"><span class="hljs-selector-tag">ping</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span></code></pre><h4 id="内网访问容器测试–成功"><a href="#内网访问容器测试–成功" class="headerlink" title="内网访问容器测试–成功"></a>内网访问容器测试–成功</h4><p>使用非集群中内内网主机，如win2008访问集群</p><pre><code class="hljs routeros"><span class="hljs-comment"># 由service nginx1 update 来实现暴露端口给主机</span>docker<span class="hljs-built_in"> service </span>update --publish-<span class="hljs-builtin-name">add</span> 80:80 nginx1</code></pre><p>宿主主机中查看端口信息<code>docker service ps nginx1</code></p><pre><code class="hljs properties"><span class="hljs-comment"># 查看端口信息</span><span class="hljs-attr">netstat</span> <span class="hljs-string">-lntp</span><span class="hljs-comment"># 安装net工具(如果不存在)</span><span class="hljs-attr">yum</span> <span class="hljs-string">install net-tools</span></code></pre><p>在win2008中访问10.173.38.39:80</p><h4 id="外网访问集群–失败"><a href="#外网访问集群–失败" class="headerlink" title="外网访问集群–失败"></a>外网访问集群–失败</h4><p>内网能访问，外网访问失败，防火墙问题</p><h2 id="容灾测试"><a href="#容灾测试" class="headerlink" title="容灾测试"></a>容灾测试</h2><h4 id="单节点故障"><a href="#单节点故障" class="headerlink" title="单节点故障"></a>单节点故障</h4><p>查看节点信息，当前leader节点：host-10-173-38-39</p><pre><code class="hljs angelscript">docker node lsID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSwppwtdiypmrueqe8lc5kn6pu9     host<span class="hljs-number">-10</span><span class="hljs-number">-173</span><span class="hljs-number">-38</span><span class="hljs-number">-39</span>   Ready               Active              Leader</code></pre><p>在leader节点执行<code>systemctl restart docker.service</code>重启Docker守护进程<br>再次查看节点信息，重启的节点自动加入作为Candidate</p><pre><code class="hljs angelscript">docker node lsID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSukcoq5i20pkzgjy07dez5xtqp     host<span class="hljs-number">-10</span><span class="hljs-number">-173</span><span class="hljs-number">-38</span><span class="hljs-number">-38</span>   Ready               Active              Leaderwppwtdiypmrueqe8lc5kn6pu9 *   host<span class="hljs-number">-10</span><span class="hljs-number">-173</span><span class="hljs-number">-38</span><span class="hljs-number">-39</span>   Ready               Active              Reachable</code></pre><h4 id="多节点故障-5manager"><a href="#多节点故障-5manager" class="headerlink" title="多节点故障(5manager)"></a>多节点故障(5manager)</h4><p>连续关闭manager节点<code>systemctl stop docker.service</code></p><table><thead><tr><th>次数</th><th>集群状态</th><th>Reachable</th><th>Uneachable</th></tr></thead><tbody><tr><td>0</td><td>正常</td><td>5</td><td>0</td></tr><tr><td>1</td><td>正常</td><td>4</td><td>1</td></tr><tr><td>2</td><td>正常</td><td>3</td><td>2</td></tr><tr><td>3</td><td>管理功能异常，集群程序正常</td><td>*</td><td>*</td></tr></tbody></table><ul><li>报错如下：<code>rpc error: code = 2 desc = The swarm does not have a leader. It&#39;s possible that too few managers are online. Make sure more than half of the managers are online.</code></li><li>恢复：直接重启服务即可恢复集群管理功能</li></ul><h2 id="负载均衡测试"><a href="#负载均衡测试" class="headerlink" title="负载均衡测试"></a>负载均衡测试</h2><p><img src="https://docs.docker.com/engine/swarm/images/ingress-lb.png"></p><h4 id="开启全局任务"><a href="#开启全局任务" class="headerlink" title="开启全局任务"></a>开启全局任务</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>create \--network docker1 \<span class="hljs-attribute">--dns</span>=8.8.8.8 \--mode global \--name global-nginx \-p 8080:80 \nginx</code></pre><p>查看任务<code>docker service ls</code></p><h4 id="创建HAProxy"><a href="#创建HAProxy" class="headerlink" title="创建HAProxy"></a>创建HAProxy</h4><p><a href="https://docs.docker.com/engine/swarm/ingress/#configure-an-external-load-balancer">Docker Swarm</a><br><a href="http://cbonte.github.io/haproxy-dconv/1.6/intro.html">HAPorxy</a></p><h2 id="创建服务例子"><a href="#创建服务例子" class="headerlink" title="创建服务例子"></a>创建服务例子</h2><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>create \--network docker1 \<span class="hljs-attribute">--dns</span>=8.8.8.8 \<span class="hljs-attribute">--constraint</span>=node.HOSTNAME==NODE-NAME \   # 运行节点--mode replicated | global \              # 运行模式--name SERVICE-NAME \--hostname HOSTNAME \--replicas 1 \--user USER-NAME \--public 8080:2020 \IMAGE</code></pre><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h4 id="跨机器启动服务报错"><a href="#跨机器启动服务报错" class="headerlink" title="跨机器启动服务报错"></a>跨机器启动服务报错</h4><p>陈旧的<a href="http://blog.jobbole.com/98869/">原因解析</a><br>iptable的<a href="http://www.cnblogs.com/silent2012/archive/2015/07/28/4682770.html">防火墙配置</a></p><ul><li>报错：No chain/target/match by that name</li><li>描述：无法在其他机器启动自定义overlay网络，怀疑为防火墙问题，但是防火墙已经关了，最后发现防火墙不能关</li><li>原因：Docker依然依赖防火墙iptables，需要在防火墙上开放部分端口，因此开启Docker之前需要开启iptables，然而使用iptable为错误的陈旧的做法</li><li>错误的解决:</li></ul><pre><code class="hljs properties"><span class="hljs-comment"># 安装</span><span class="hljs-attr">yum</span> <span class="hljs-string">-y install iptables-services</span><span class="hljs-comment"># 重启防火墙</span><span class="hljs-attr">systemctl</span> <span class="hljs-string">restart iptables.service</span><span class="hljs-comment"># 重启docker</span><span class="hljs-attr">systemctl</span> <span class="hljs-string">restart docker.service</span><span class="hljs-comment"># 关闭firewalld</span><span class="hljs-attr">systemctl</span> <span class="hljs-string">stop firewalld.service &amp;&amp; systemctl disable firewalld.service</span><span class="hljs-comment"># 安装iptables</span><span class="hljs-attr">yum</span> <span class="hljs-string">-y install iptables-services</span></code></pre><p>真正的解决请看开头</p><ul><li>不要使用iptable</li><li>使用<code>firewall-cmd --add-port=2376/tcp --permanent</code>修改开放端口</li></ul><h4 id="如果误入歧途，开启了iptable关闭了firewall的解决办法"><a href="#如果误入歧途，开启了iptable关闭了firewall的解决办法" class="headerlink" title="如果误入歧途，开启了iptable关闭了firewall的解决办法"></a>如果误入歧途，开启了iptable关闭了firewall的解决办法</h4><pre><code class="hljs sas">systemctl <span class="hljs-meta">stop</span> iptables.service <span class="hljs-variable">&amp;&amp;</span> systemctl disable iptables.service <span class="hljs-variable">&amp;&amp;</span>systemctl start firewalld.service <span class="hljs-variable">&amp;&amp;</span> systemctl enable firewalld.service <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --<span class="hljs-meta">add</span>-port=2376/tcp --permanent <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --<span class="hljs-meta">add</span>-port=2377/tcp --permanent <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --<span class="hljs-meta">add</span>-port=7946/tcp --permanent <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --<span class="hljs-meta">add</span>-port=7946/udp --permanent <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --<span class="hljs-meta">add</span>-port=4789/udp --permanent <span class="hljs-variable">&amp;&amp;</span>firewall-cmd --reload <span class="hljs-variable">&amp;&amp;</span>systemctl restart docker.service</code></pre><h4 id="开启防火墙端口"><a href="#开启防火墙端口" class="headerlink" title="开启防火墙端口"></a>开启防火墙端口</h4><pre><code class="hljs dockerfile"><span class="hljs-comment"># 开启</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --add-port=80/tcp --permanent</span><span class="hljs-comment"># 查看</span>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --list-all</span></code></pre><h4 id="运行非守护进程作为服务"><a href="#运行非守护进程作为服务" class="headerlink" title="运行非守护进程作为服务"></a>运行非守护进程作为服务</h4><p>-t image</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Docker swarm使用</title>
    <link href="/04-Linux/01-Docker/05-Docker%20swarm%E4%BD%BF%E7%94%A8/"/>
    <url>/04-Linux/01-Docker/05-Docker%20swarm%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-swarm是什么"><a href="#Docker-swarm是什么" class="headerlink" title="Docker swarm是什么"></a>Docker swarm是什么</h1><p>集群中会自动通过 Raft 协议分布式选举出manager节点,无需额外的发现服务支持,避免了单点瓶颈。<br>Docker 集群管理需要使用服务发现(Service Discover)功能,Swarm支持以下的几种方式:DockerHub、本地文件、etcd、consul、zookeeper手动指定节点IP地址信息等。<br>基于consul服务发现后端来配置一个本地Swarm集群。其中,consul也可以被替换为 etcd、zookeeper</p><p>优势在哪</p><ul><li>滚动升级</li><li>自动均衡</li><li>发现服务：Swarm为每个容器分配一个DNS名字，集群中可以互相发现</li><li>指定容器数量</li><li>分布式高可用</li><li>单机管理(配合docker mershine)</li></ul><h1 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h1><h2 id="所有的命令"><a href="#所有的命令" class="headerlink" title="所有的命令"></a><a href="https://docs.docker.com/compose/reference/overview/">所有的命令</a></h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在新版本的Linux上Docker Engine已经自带了Docker Swarm无需安装</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h4 id="启动主节点"><a href="#启动主节点" class="headerlink" title="启动主节点"></a>启动主节点</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker swarm init --advertise-addr 129.1.8.70</span>Swarm initialized: current node (3khl48ukc6h3ytee38g906kcn) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join \    --token SWMTKN-1-03qdhlinx6140lq80mtphh93757a2d09pzoxii4idfeidsece8-5o90zte0cvk9s0apf7pgrzsf9 \    129.1.8.70:2377To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</code></pre><h4 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h4><p>根据上述描述，添加从节点，如果上述消息找不到了呢<code>docker swarm join-token worker</code></p><pre><code class="hljs shell">docker swarm join \    --token SWMTKN-1-03qdhlinx6140lq80mtphh93757a2d09pzoxii4idfeidsece8-5o90zte0cvk9s0apf7pgrzsf9 \    129.1.8.70:2377</code></pre><h4 id="查看从节点"><a href="#查看从节点" class="headerlink" title="查看从节点"></a>查看从节点</h4><pre><code class="hljs crmsh">docker <span class="hljs-keyword">node</span> <span class="hljs-title">ls</span></code></pre><h4 id="部署服务-开机启动"><a href="#部署服务-开机启动" class="headerlink" title="部署服务(开机启动)"></a>部署服务(开机启动)</h4><pre><code class="hljs routeros">$ docker<span class="hljs-built_in"> service </span>create --replicas 1 --name helloworld alpine<span class="hljs-built_in"> ping </span>docker.com9uk4639qpg7npwf3fn2aasksr</code></pre><ul><li>The <code>docker service create</code> command creates the service.创建服务命令</li><li>The <code>--name</code> flag names the service helloworld.服务名称</li><li>The <code>--replicas</code> flag specifies the desired state of 1 running instance.设置服务运行的副本数</li><li>The arguments <code>alpine ping docker.com</code> define the service as an Alpine Linux container that executes the command ping docker.com.运行一个Alpine Linux容器来执行ping docker.com命令</li></ul><h4 id="列举服务"><a href="#列举服务" class="headerlink" title="列举服务"></a>列举服务</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>ls</code></pre><h4 id="查看服务细节（使用–pretty格式化输出）inspect：查看"><a href="#查看服务细节（使用–pretty格式化输出）inspect：查看" class="headerlink" title="查看服务细节（使用–pretty格式化输出）inspect：查看"></a>查看服务细节（使用–pretty格式化输出）inspect：查看</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>inspect --pretty &lt;SERVICE-ID&gt;</code></pre><h4 id="查看哪一个节点在运行服务"><a href="#查看哪一个节点在运行服务" class="headerlink" title="查看哪一个节点在运行服务"></a>查看哪一个节点在运行服务</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>ps &lt;SERVICE-ID&gt;</code></pre><h4 id="修改节点阶级"><a href="#修改节点阶级" class="headerlink" title="修改节点阶级"></a>修改节点阶级</h4><pre><code class="hljs crmsh">docker <span class="hljs-keyword">node</span> <span class="hljs-title">promote</span> <span class="hljs-keyword">NODE</span> <span class="hljs-title">[NODE</span>...]</code></pre><h2 id="集群中拓展服务"><a href="#集群中拓展服务" class="headerlink" title="集群中拓展服务"></a>集群中拓展服务</h2><h4 id="批量部署同一个服务"><a href="#批量部署同一个服务" class="headerlink" title="批量部署同一个服务"></a>批量部署同一个服务</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>scale <span class="hljs-attribute">helloworld</span>=5</code></pre><p>查看本机运行的服务(跟本机运行是一样的)</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span></code></pre><h4 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>rm helloworld</code></pre><p>再次查看服务，发现服务已经找不到了(<code>docker ps</code>还需要一点时间才会结束)</p><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>inspect helloworld</code></pre><h2 id="动态升级服务rolling-updates"><a href="#动态升级服务rolling-updates" class="headerlink" title="动态升级服务rolling updates"></a>动态升级服务rolling updates</h2><h4 id="创建一个低版本的服务"><a href="#创建一个低版本的服务" class="headerlink" title="创建一个低版本的服务"></a>创建一个低版本的服务</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker service create \</span>  --replicas 3 \  --name redis \  --update-delay 10s \  redis:3.0.6</code></pre><ul><li>The <code>--update-delay</code> flag configures the time delay between updates to a service task or sets of tasks. 这个标志用来设置部署到服务/服务集的时间间隔You can describe the time T as a combination of the number of seconds Ts, minutes Tm, or hours Th. So 10m30s indicates a 10 minute 30 second delay.</li><li><code>--update-parallelism</code> flag to configure the maximum number of service tasks that the scheduler updates simultaneously.这个标志设置了最多同时同步多少个tasks(默认全部同时)</li></ul><h4 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h4><p>(参考上文)，服务在指定时间后才会完成部署<br>此时的版本为redis:3.0.6@sha256:6a692a76c2081888b589e26e6ec835743119fe453d67ecf03df7de5b73d69842</p><h4 id="动态升级"><a href="#动态升级" class="headerlink" title="动态升级"></a>动态升级</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> service </span>update --image redis:3.0.7 redis</code></pre><p>升级后的版本为redis:3.0.7@sha256:730b765df9fe96af414da64a2b67f3a5f70b8fd13a31e5096fee4807ed802e20<br>执行步骤如下：</p><ul><li>Stop the first task.</li><li>Schedule update for the stopped task.</li><li>Start the container for the updated task.</li><li>If the update to a task returns RUNNING, wait for the specified delay period then start the next task.</li><li>If, at any time during the update, a task returns FAILED, pause the update.</li></ul><h2 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h2><p>在一些应用场景中（如服务器维护），需要把一些节点变成<code>DRAIN</code>状态，这以为着这个节点将不再从主节点接受任何命令，并把执行中的任务切换给别的<code>Active的````节点去执行。 ####　切换节点状态 列举当前服务的节点</code>docker service ps redis```</p><pre><code class="hljs crmsh">docker <span class="hljs-keyword">node</span> <span class="hljs-title">update</span> --availability drain <span class="hljs-tag">&lt;NODE-ID&gt;</span></code></pre><h1 id="集群网络"><a href="#集群网络" class="headerlink" title="集群网络"></a>集群网络</h1><p>学了大半天，终于到了我要的部分了。激动啊！！</p><h2 id="外部访问容器的HA实现"><a href="#外部访问容器的HA实现" class="headerlink" title="外部访问容器的HA实现"></a>外部访问容器的HA实现</h2><p>先讲讲原理，所有节点加入到ingress路由，路由网路使得每一个节点都能够接受来自已发布端口的连接请求</p><h4 id="为服务发布一个公共端口-创建"><a href="#为服务发布一个公共端口-创建" class="headerlink" title="为服务发布一个公共端口(创建)"></a>为服务发布一个公共端口(创建)</h4><pre><code class="hljs routeros"><span class="hljs-comment"># --pubilc == -p</span>$ docker<span class="hljs-built_in"> service </span>create \  --name &lt;SERVICE-NAME&gt; \  --publish &lt;PUBLISHED-PORT&gt;:&lt;TARGET-PORT&gt; \  &lt;IMAGE&gt;</code></pre><ul><li>&lt;PUBLISHED-PORT&gt; 对外暴露的端口</li><li>&lt;TARGET-PORT&gt;　容器中的端口<br>如：下面的程序打开了8080端口给这个Docker集群，swarm将进行负载均衡。然后将请求分发给容器的80端口。<pre><code class="hljs routeros">$ docker<span class="hljs-built_in"> service </span>create \  --name my-web \  --publish 8080:80 \  --replicas 2 \  nginx</code></pre><img src="https://docs.docker.com/engine/swarm/images/ingress-routing-mesh.png"></li></ul><p>####　修改原来的服务的端口转发规则(修改)</p><pre><code class="hljs routeros">$ docker<span class="hljs-built_in"> service </span>update \  --publish-<span class="hljs-builtin-name">add</span> &lt;PUBLISHED-PORT&gt;:&lt;TARGET-PORT&gt; \  &lt;SERVICE&gt;</code></pre><h2 id="配置一个高可用的代理HAPorxy"><a href="#配置一个高可用的代理HAPorxy" class="headerlink" title="配置一个高可用的代理HAPorxy"></a>配置一个高可用的代理HAPorxy</h2><p><img src="https://docs.docker.com/engine/swarm/images/ingress-lb.png"></p><h4 id="编辑文件-etc-haproxy-haproxy-cfg-详情参阅官方文档"><a href="#编辑文件-etc-haproxy-haproxy-cfg-详情参阅官方文档" class="headerlink" title="编辑文件/etc/haproxy/haproxy.cfg(详情参阅官方文档)"></a>编辑文件<code>/etc/haproxy/haproxy.cfg</code>(<a href="https://docs.docker.com/engine/swarm/ingress/">详情参阅官方文档</a>)</h4><pre><code class="hljs routeros">global        log /dev/log    local0        log /dev/log    local1 notice<span class="hljs-built_in">..</span>.snip<span class="hljs-built_in">..</span>.<span class="hljs-comment"># Configure HAProxy to listen on port 80</span>frontend http_front   bind *:80   stats uri /haproxy?stats   default_backend http_back<span class="hljs-comment"># Configure HAProxy to route requests to swarm nodes on port 8080</span>backend http_back   balance roundrobin  <span class="hljs-built_in"> server </span>node1 192.168.99.100:8080 check  <span class="hljs-built_in"> server </span>node2 192.168.99.101:8080 check  <span class="hljs-built_in"> server </span>node3 192.168.99.102:8080 check</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-Docker的网络</title>
    <link href="/04-Linux/01-Docker/06-Docker%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <url>/04-Linux/01-Docker/06-Docker%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/engine/userguide/networking/">Docker的网络</a></p><h4 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h4><ul><li>none 不使用网络，意味着容器中只有本地回环网lo</li><li>bridge <code>docker run --network=&lt;NETWORK&gt;</code>可以配置使用的网桥，<code>docker network create --subnet=172.18.0.0/16 hadoopnet</code>可以创建一个网桥，只有自定义网桥允许使用<code>--ip=172.18.0.10</code>选项</li><li>host 直接使用宿主主机的网络，甚至可修改宿主主机的网络配置，这个做法是非常烂的，因为每个容器都有root权限</li><li></li></ul><h4 id="默认网桥"><a href="#默认网桥" class="headerlink" title="默认网桥"></a>默认网桥</h4><p>查看网桥信息</p><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>inspect bridge</code></pre><h4 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h4><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create --driver<span class="hljs-built_in"> bridge </span><span class="hljs-attribute">--subnet</span>=172.18.0.0/16 hadoopnet</code></pre><h4 id="docker-gwbridge"><a href="#docker-gwbridge" class="headerlink" title="docker_gwbridge"></a>docker_gwbridge</h4><p>在以下情况下 docker 自动创建的一种网桥，自己也可以创建，见文档</p><ul><li>创建或加入Swarm,用于物理主机之间的通信(容器被分配的也是docker0网桥的地址)</li><li>一个容器的网络连接毁掉了，消防通道</li></ul><h4 id="自定义-overlay-Swarm-集群网络"><a href="#自定义-overlay-Swarm-集群网络" class="headerlink" title="自定义 overlay Swarm 集群网络"></a>自定义 overlay Swarm 集群网络</h4><p>主节点将会自动扩散这个网络给别的主机<br>    仅允许集群中的容器相互通信，集群外的单独的节点</p><pre><code class="hljs routeros">$ docker<span class="hljs-built_in"> network </span>create \  --driver overlay \  --subnet 10.0.9.0/24 \  my-multi-host-network400g6bwzd68jizzdx5pgyoe95<span class="hljs-comment"># 创建服务时候需要指定网桥，能指定主机名，指定挂载卷，但是不能指定IP因为一个服务可能有多个容器</span>$ docker<span class="hljs-built_in"> service </span>create --replicas 2 --network my-multi-host-network --name my-web nginx716thylsndqma81j6kkkb5aus</code></pre><h2 id="集群网络有三种"><a href="#集群网络有三种" class="headerlink" title="集群网络有三种"></a><a href="https://docs.docker.com/engine/swarm/networking/">集群网络有三种</a></h2><ul><li>overlay 用于分配节点IP可自定义，不定义就使用docker0</li><li>docker_gwbridge 用于物理主机通信，一般自动</li><li>ingress 用于负载均衡，一般自动</li></ul><h4 id="关于DNS-在作为服务器时候需考虑关闭DNS"><a href="#关于DNS-在作为服务器时候需考虑关闭DNS" class="headerlink" title="关于DNS(在作为服务器时候需考虑关闭DNS)"></a>关于DNS(在作为服务器时候需考虑关闭DNS)</h4><p>在使用用户自定义网络模式中，集群中嵌入DNS服务，容器能够互相通信。无需额外配置</p><h4 id="关于HAProxy"><a href="#关于HAProxy" class="headerlink" title="关于HAProxy"></a>关于HAProxy</h4><p>主要用于均衡http请求，<code>https</code>请求，<code>ftp</code>请求等，可编辑<code>～/.config.json</code>配置，详见文档</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-Dcoker容器默认IP</title>
    <link href="/04-Linux/01-Docker/07-Dcoker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4IP/"/>
    <url>/04-Linux/01-Docker/07-Dcoker%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4IP/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/gobitan/article/details/51104362">参考博客</a><br>需要自定义静态IP需要使用自定义网桥。</p><h3 id="创建网桥"><a href="#创建网桥" class="headerlink" title="创建网桥"></a>创建网桥</h3><pre><code class="hljs routeros">docker<span class="hljs-built_in"> network </span>create <span class="hljs-attribute">--subnet</span>=172.18.0.0/16 hadoopnet</code></pre><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><pre><code class="hljs angelscript">docker run --ip=<span class="hljs-number">172.18</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span> --net hadoopnet -it hadoop:<span class="hljs-number">2.7</span><span class="hljs-number">.1</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-Docker数据存储</title>
    <link href="/04-Linux/01-Docker/08-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <url>/04-Linux/01-Docker/08-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker中的数据"><a href="#Docker中的数据" class="headerlink" title="Docker中的数据"></a>Docker中的数据</h1><p><img src="https://docs.docker.com/engine/admin/volumes/"><br>数据在存储层的危害</p><ul><li>容器中的数据会随着容器删除而删除，更有甚者服务中的容器的不可控性，将导致数据毁灭</li><li>存储层的数据是跟主机精密关联的，因此，不同主机之间的容器是不可能直接使用的，验证了集群中容器重启无状态的</li><li>存储层写入是对Linux文件系统的抽象，这个抽象降低了存储的效率</li></ul><h2 id="选择挂载方式"><a href="#选择挂载方式" class="headerlink" title="选择挂载方式"></a>选择挂载方式</h2><p>对于容器来说，使用任何的挂载方式是无区别的</p><ul><li><p><strong>Volumes</strong> are stored in a part of the host filesystem which is managed by Docker (<code>/var/lib/docker/volumes/ </code>on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.</p></li><li><p><strong>Bind mounts</strong> may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</p></li><li><p><strong>tmpfs mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</p></li></ul><p><img src="https://docs.docker.com/engine/admin/volumes/images/types-of-mounts.png"></p><h2 id="数据卷（推荐）"><a href="#数据卷（推荐）" class="headerlink" title="数据卷（推荐）"></a>数据卷（推荐）</h2><p>数据卷可以在容器或服务启动的时候创建</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 容器创建</span>docker run -d -P --name ubuntu -v /webapp ubuntudocker inspect ubuntu<span class="hljs-meta">#</span><span class="bash"> 服务创建todo</span>docker service create -d \  --name devtest-service \  --mount source=myvol2,target=/app \  nginx:latest</code></pre><p>也可以提前创建好，也叫数据卷容器，可以被多台主机共享</p><pre><code class="hljs shell">docker volume create NAME--mount type=bind<span class="hljs-meta">#</span><span class="bash"> 删除</span>docker volume prune</code></pre><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>挂载本机文件到容器</p><pre><code class="hljs awk">sudo docker run --rm -it -v ~<span class="hljs-regexp">/.bash_history:/</span>.bash_history ubuntu <span class="hljs-regexp">/bin/</span>bash</code></pre><h2 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h2><pre><code class="hljs ada"><span class="hljs-comment">--tmpfs</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-Docker数据卷备份与恢复</title>
    <link href="/04-Linux/01-Docker/09-Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <url>/04-Linux/01-Docker/09-Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker数据卷的备份和恢复"><a href="#Docker数据卷的备份和恢复" class="headerlink" title="Docker数据卷的备份和恢复"></a>Docker数据卷的备份和恢复</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><pre><code class="hljs sh">docker run  -v /home/czm/docker_data:/backup -v dockerfuseki_fuseki-data:/data busybox tar cvf /backup/dockerfuseki_fuseki-data.tar /data</code></pre><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><pre><code class="hljs sh">docker run -v fuseki-data:/data -v $(<span class="hljs-built_in">pwd</span>):/backup busybox tar xvf /backup/dockerfuseki_fuseki-data.tar -C /</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-Docker实战之世界观与方法论</title>
    <link href="/04-Linux/01-Docker/10-Docker%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%96%E7%95%8C%E8%A7%82%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <url>/04-Linux/01-Docker/10-Docker%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%96%E7%95%8C%E8%A7%82%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="关于大数据组件的分布式搭建"><a href="#关于大数据组件的分布式搭建" class="headerlink" title="关于大数据组件的分布式搭建"></a>关于大数据组件的分布式搭建</h1><h2 id="数据存储问题"><a href="#数据存储问题" class="headerlink" title="数据存储问题"></a>数据存储问题</h2><h4 id="OK-HDFS数据去哪了？"><a href="#OK-HDFS数据去哪了？" class="headerlink" title="(OK)HDFS数据去哪了？"></a>(OK)HDFS数据去哪了？</h4><p>在官方hdfs-site.xml中可知数据其实是对Linux文件系统可见的(由于之前经验不足,错误认为不可见)。<br>由配置<code>dfs.datanode.data.dir</code>可知在<code> file://$&#123;hadoop.tmp.dir&#125;/dfs/data</code>中</p><h4 id="如果多个数据卷挂载数据卷到宿主主机，那么多个容器将使用同一份文件？"><a href="#如果多个数据卷挂载数据卷到宿主主机，那么多个容器将使用同一份文件？" class="headerlink" title="如果多个数据卷挂载数据卷到宿主主机，那么多个容器将使用同一份文件？"></a>如果多个数据卷挂载数据卷到宿主主机，那么多个容器将使用同一份文件？</h4><p>如果上述说法成立，是否说明这个数据卷的作用并不是存储数据的，而是用来存储配置文件的？<br>在第三方服务器挂载配置卷的方案可行？(可移植性，你可以在任意集群一键部署而不需要考虑配置)</p><h4 id="Swarm在容器GG之后将会创建一个新的容器保证服务数量，那么这个新的容器的存储层是使用之前的存储层？"><a href="#Swarm在容器GG之后将会创建一个新的容器保证服务数量，那么这个新的容器的存储层是使用之前的存储层？" class="headerlink" title="Swarm在容器GG之后将会创建一个新的容器保证服务数量，那么这个新的容器的存储层是使用之前的存储层？"></a>Swarm在容器GG之后将会创建一个新的容器保证服务数量，那么这个新的容器的存储层是使用之前的存储层？</h4><p>如果是这个机制的话，那么重启旧的容器是否能成功？</p><h4 id="选举机制下的集群是否足够安全，容灾性与节点数的比例（所有节点都有健康监护进程？OK）一旦集群删除-遭受破坏无法启动，数据恢复可行性"><a href="#选举机制下的集群是否足够安全，容灾性与节点数的比例（所有节点都有健康监护进程？OK）一旦集群删除-遭受破坏无法启动，数据恢复可行性" class="headerlink" title="选举机制下的集群是否足够安全，容灾性与节点数的比例（所有节点都有健康监护进程？OK）一旦集群删除/遭受破坏无法启动，数据恢复可行性"></a>选举机制下的集群是否足够安全，容灾性与节点数的比例（所有节点都有健康监护进程？OK）一旦集群删除/遭受破坏无法启动，数据恢复可行性</h4><p>集群安全性问题。像Zookeeper一样，使用选举方式选举出主节点，manager可以多个，但保证了同时只有一个在运行。manager为单数个，5-7个为最合理</p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><h4 id="如何指定集群的网络-应该是配置docker的网桥"><a href="#如何指定集群的网络-应该是配置docker的网桥" class="headerlink" title="如何指定集群的网络(应该是配置docker的网桥)"></a>如何指定集群的网络(应该是配置docker的网桥)</h4><p><a href="https://www.oschina.net/translate/docker-network-configuration">https://www.oschina.net/translate/docker-network-configuration</a><br>Swarm默认使用的是docker0网桥</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">使用自己的IP</span><span class="hljs-meta">$</span><span class="bash"> docker network create \</span>  --driver overlay \  --subnet 10.0.0.0/24 \  my-multi-host-network</code></pre><h4 id="跨硬件之间的网络传输的带宽大小？"><a href="#跨硬件之间的网络传输的带宽大小？" class="headerlink" title="跨硬件之间的网络传输的带宽大小？"></a>跨硬件之间的网络传输的带宽大小？</h4><h4 id="Swarm集群中的网络是互通的？HAPorxy对于Hadoop集群有什么作用？"><a href="#Swarm集群中的网络是互通的？HAPorxy对于Hadoop集群有什么作用？" class="headerlink" title="Swarm集群中的网络是互通的？ＨＡＰｏｒｘｙ对于Ｈａｄｏｏｐ集群有什么作用？"></a>Swarm集群中的网络是互通的？ＨＡＰｏｒｘｙ对于Ｈａｄｏｏｐ集群有什么作用？</h4><h4 id="应该使用什么DNS方案"><a href="#应该使用什么DNS方案" class="headerlink" title="应该使用什么ＤＮＳ方案"></a>应该使用什么ＤＮＳ方案</h4><ul><li>DNS 服务器(HA问题)</li><li>改主机名和域名映射(麻烦)</li></ul><h4 id="什么办法可以直接SSH到容器内-这个可以是不必要的-，整体网络拓扑长什么样子"><a href="#什么办法可以直接SSH到容器内-这个可以是不必要的-，整体网络拓扑长什么样子" class="headerlink" title="什么办法可以直接SSH到容器内(这个可以是不必要的)，整体网络拓扑长什么样子"></a>什么办法可以直接SSH到容器内(这个可以是不必要的)，整体网络拓扑长什么样子</h4><ul><li>云平台是如何实现的</li></ul><h2 id="更符合运维习惯的修改"><a href="#更符合运维习惯的修改" class="headerlink" title="更符合运维习惯的修改"></a>更符合运维习惯的修改</h2><p>####　容器主机名</p><pre><code class="hljs livecodeserver">docker <span class="hljs-built_in">create</span> <span class="hljs-comment">--hostname master</span></code></pre><h4 id="容器密码"><a href="#容器密码" class="headerlink" title="容器密码"></a>容器密码</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 只有centos需要步骤1,2</span>rpm -e cracklib-dicts --nodepsyum -y install cracklib-dicts(echo &quot;ubuntu&quot;;sleep 1;echo &quot;ubuntu&quot;) | passwd</code></pre><h4 id="docker集群可视化方案"><a href="#docker集群可视化方案" class="headerlink" title="docker集群可视化方案"></a>docker集群可视化方案</h4><p>参考<a href="https://github.com/Cenzhongman/shipyard">Github</a></p><pre><code class="hljs awk">curl -s https:<span class="hljs-regexp">//</span>shipyard-project.com/deploy | bash -s</code></pre><p>访问8080端口就可以看到</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="哪些容器不应该在集群中？有状态服务（数据库等）是什么概念OK？"><a href="#哪些容器不应该在集群中？有状态服务（数据库等）是什么概念OK？" class="headerlink" title="哪些容器不应该在集群中？有状态服务（数据库等）是什么概念OK？"></a>哪些容器不应该在集群中？有状态服务（数据库等）是什么概念OK？</h4><p>有状态服务：这个请求跟上一个请求有关系，有上下文的（cookie），游戏登录后所有的信息都是有上下文的<br>无状态服务：这个请求仅仅决定于请求自身携带的信息和服务器中保存的信息</p><h4 id="日志管理服务怎么使用？"><a href="#日志管理服务怎么使用？" class="headerlink" title="日志管理服务怎么使用？"></a>日志管理服务怎么使用？</h4><h4 id="一台主机中跑多个容器的意义在哪里？-作为服务器，不考虑卖给别人做云服务"><a href="#一台主机中跑多个容器的意义在哪里？-作为服务器，不考虑卖给别人做云服务" class="headerlink" title="一台主机中跑多个容器的意义在哪里？(作为服务器，不考虑卖给别人做云服务)"></a>一台主机中跑多个容器的意义在哪里？(作为服务器，不考虑卖给别人做云服务)</h4><h4 id="集群中的节点离群之后只能从节点添加？"><a href="#集群中的节点离群之后只能从节点添加？" class="headerlink" title="集群中的节点离群之后只能从节点添加？"></a>集群中的节点离群之后只能从节点添加？</h4><pre><code class="hljs crmsh">docker <span class="hljs-keyword">node</span> <span class="hljs-title">update</span> --availability active node1.example.com</code></pre><p>状态剖析</p><ul><li>AVAILABILITY 用于说明是否接收来自主节点的任务</li><li>STATUS 用于说明主机是否在集群中(为什么还能active)</li></ul><h4 id="隔离性问题，如果我在容器中配置最大线程数，但是主机没有，能用吗？"><a href="#隔离性问题，如果我在容器中配置最大线程数，但是主机没有，能用吗？" class="headerlink" title="隔离性问题，如果我在容器中配置最大线程数，但是主机没有，能用吗？"></a>隔离性问题，如果我在容器中配置最大线程数，但是主机没有，能用吗？</h4><h4 id="服务和容器的区别"><a href="#服务和容器的区别" class="headerlink" title="服务和容器的区别"></a>服务和容器的区别</h4><ul><li>HDFS 的datanode是一个service？还是多个service？</li><li>如果作为一个云服务器，是一个service还是多个service</li></ul><h1 id="证明有两条路可选"><a href="#证明有两条路可选" class="headerlink" title="证明有两条路可选"></a>证明有两条路可选</h1><p>1.使用docker Swarm 的节点管理服务，使用DNS嵌入式引擎，使用overlay实现网络通信(不可用)，但是不使用service</p><pre><code class="hljs routeros">docker <span class="hljs-attribute">-H</span>=localhost.localdomain <span class="hljs-builtin-name">run</span> centos:1.0</code></pre><p>2.使用service</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 指定节点运行</span>docker service create --constraint=node.HOSTNAME==cen-ubuntu --name=test_centos --replicas 2 ubuntu</code></pre><p>–replicas 副本数量<br>–publish 服务发现，端口映射<br>–mount 挂载文件</p><p>–mount type=bind,src=/home,dst=/home,readonly<br>–name service名称</p><pre><code>docker swarm：集群管理，子命令有init, join,join-token, leave, updatedocker node：节点管理，子命令有demote, inspect,ls, promote, rm, ps, updatedocker service：服务管理，子命令有create, inspect, ps, ls ,rm , scale, updatedocker stack/deploy：试验特性，用于多应用部署</code></pre><p>所以集群的容器可以使用服务名称当做IP地址来互相访问。<br><a href="http://www.cnblogs.com/Javame/p/6739184.html">http://www.cnblogs.com/Javame/p/6739184.html</a><br><a href="https://testerhome.com/topics/6904">https://testerhome.com/topics/6904</a></p><h4 id="两种挂载方式"><a href="#两种挂载方式" class="headerlink" title="两种挂载方式"></a>两种挂载方式</h4><p><a href="http://www.ttlsa.com/docker/docker-swarm-deploy-services/">http://www.ttlsa.com/docker/docker-swarm-deploy-services/</a><br>volume<br>bind</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-使用Docker搭建Hadoop</title>
    <link href="/04-Linux/01-Docker/11-%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAHadoop/"/>
    <url>/04-Linux/01-Docker/11-%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAHadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Docker搭建Hadoop"><a href="#使用Docker搭建Hadoop" class="headerlink" title="使用Docker搭建Hadoop"></a>使用Docker搭建Hadoop</h1><p>说明：</p><ul><li>docke集群的ssh端口统一使用2222(后期改进)</li><li>统一使用宿主主机名作为节点主机名</li><li>所有操作使用root用户执行</li><li>密码使用模块名，如hadoop hbase…</li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h4 id="http服务器-同时担任文件传输任务"><a href="#http服务器-同时担任文件传输任务" class="headerlink" title="http服务器,同时担任文件传输任务"></a>http服务器,同时担任文件传输任务</h4><p>为了更加便捷地使用网络，我们使用centos6作为ftp服务器</p><pre><code class="hljs plain"></code></pre><p>####　ntp服务器</p><h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><h4 id="复制hadoop-master文件夹"><a href="#复制hadoop-master文件夹" class="headerlink" title="复制hadoop-master文件夹"></a>复制hadoop-master文件夹</h4><p>若使用网络安装，执行需编辑Dockerfile注释本地版部分<br>若使用本地安装，请往下执行</p><h4 id="在文件夹下运行"><a href="#在文件夹下运行" class="headerlink" title="在文件夹下运行"></a>在文件夹下运行</h4><pre><code class="hljs crmsh">sudo docker build -t hadoop-<span class="hljs-literal">master</span>:latest .</code></pre><h4 id="复制hadoop-slaver文件夹"><a href="#复制hadoop-slaver文件夹" class="headerlink" title="复制hadoop-slaver文件夹"></a>复制hadoop-slaver文件夹</h4><p>若使用网络安装，执行需编辑Dockerfile注释本地版部分<br>若使用本地安装，请往下执行</p><h4 id="在文件夹下运行-1"><a href="#在文件夹下运行-1" class="headerlink" title="在文件夹下运行"></a>在文件夹下运行</h4><pre><code class="hljs css"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">build</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">hadoop-slaver</span><span class="hljs-selector-pseudo">:latest</span> .</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><h4 id="启动namenode"><a href="#启动namenode" class="headerlink" title="启动namenode"></a>启动namenode</h4><p>暂时不挂载数据，这个数据能不能供第二个容器使用，还得探讨<br>我该挂载什么？<br>hdfs-env.sh</p><p>首次启动</p><pre><code class="hljs angelscript">docker rm $(docker ps -a -q)docker \run \-p <span class="hljs-number">50010</span>:<span class="hljs-number">50010</span> \-p <span class="hljs-number">50020</span>:<span class="hljs-number">50020</span> \-p <span class="hljs-number">50070</span>:<span class="hljs-number">50070</span> \-p <span class="hljs-number">50075</span>:<span class="hljs-number">50075</span> \-p <span class="hljs-number">50090</span>:<span class="hljs-number">50090</span> \-p <span class="hljs-number">8020</span>:<span class="hljs-number">8020</span> \-p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> \-p <span class="hljs-number">10020</span>:<span class="hljs-number">10020</span> \-p <span class="hljs-number">19888</span>:<span class="hljs-number">19888</span> \-p <span class="hljs-number">8030</span>:<span class="hljs-number">8030</span> \-p <span class="hljs-number">8031</span>:<span class="hljs-number">8031</span> \-p <span class="hljs-number">8032</span>:<span class="hljs-number">8032</span> \-p <span class="hljs-number">8033</span>:<span class="hljs-number">8033</span> \-p <span class="hljs-number">8040</span>:<span class="hljs-number">8040</span> \-p <span class="hljs-number">8042</span>:<span class="hljs-number">8042</span> \-p <span class="hljs-number">8088</span>:<span class="hljs-number">8088</span> \-p <span class="hljs-number">49707</span>:<span class="hljs-number">49707</span> \-p <span class="hljs-number">2222</span>:<span class="hljs-number">2222</span> \--name namenode \--hostname $(hostname) \-d \hadoop-master \/etc/bootstrap.sh -bash</code></pre><p>第二次启动</p><pre><code class="hljs awk">docker exec -it namenode <span class="hljs-regexp">/bin/</span>bash</code></pre><h4 id="启动datanode"><a href="#启动datanode" class="headerlink" title="启动datanode"></a>启动datanode</h4><p>首次启动</p><pre><code class="hljs angelscript">docker rm $(docker ps -a -q)docker \run \-p <span class="hljs-number">50010</span>:<span class="hljs-number">0010</span> \-p <span class="hljs-number">50020</span>:<span class="hljs-number">50020</span> \-p <span class="hljs-number">50070</span>:<span class="hljs-number">50070</span> \-p <span class="hljs-number">50075</span>:<span class="hljs-number">50075</span> \-p <span class="hljs-number">50090</span>:<span class="hljs-number">50090</span> \-p <span class="hljs-number">8020</span>:<span class="hljs-number">8020</span> \-p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> \-p <span class="hljs-number">10020</span>:<span class="hljs-number">10020</span> \-p <span class="hljs-number">19888</span>:<span class="hljs-number">19888</span> \-p <span class="hljs-number">8030</span>:<span class="hljs-number">8030</span> \-p <span class="hljs-number">8031</span>:<span class="hljs-number">8031</span> \-p <span class="hljs-number">8032</span>:<span class="hljs-number">8032</span> \-p <span class="hljs-number">8033</span>:<span class="hljs-number">8033</span> \-p <span class="hljs-number">8040</span>:<span class="hljs-number">8040</span> \-p <span class="hljs-number">8042</span>:<span class="hljs-number">8042</span> \-p <span class="hljs-number">8088</span>:<span class="hljs-number">8088</span> \-p <span class="hljs-number">49707</span>:<span class="hljs-number">49707</span> \-p <span class="hljs-number">2222</span>:<span class="hljs-number">2222</span> \--name datanode \--hostname $(hostname) \-d \hadoop-slaver \/etc/bootstrap.sh -bash</code></pre><p>第二次启动</p><pre><code class="hljs awk">docker exec -it datanode <span class="hljs-regexp">/bin/</span>bash</code></pre><h4 id="测试HDFS"><a href="#测试HDFS" class="headerlink" title="测试HDFS"></a>测试HDFS</h4><pre><code>访问centos1:50070即可看到自己的节点状态</code></pre><p>测试内容</p><ul><li><p>文件上传</p></li><li><p>mapreduce</p><pre><code class="hljs gradle">#!<span class="hljs-regexp">/bin/</span>bashmkdir inputcp etc<span class="hljs-regexp">/hadoop/</span>* inputbin<span class="hljs-regexp">/hdfs dfs -mkdir -p /u</span>ser/rootbin<span class="hljs-regexp">/hdfs dfs -put input /u</span>ser<span class="hljs-regexp">/root/</span>bin<span class="hljs-regexp">/yarn jar share/</span>hadoop<span class="hljs-regexp">/mapreduce/</span>hadoop-mapreduce-examples-<span class="hljs-number">2.7</span>.<span class="hljs-number">4</span>.jar wordcount <span class="hljs-regexp">/user/</span>root<span class="hljs-regexp">/input /u</span>ser<span class="hljs-regexp">/root/</span>data/output</code></pre><p>  访问centos1:8088即可看到自己的程序运行状态和日志</p></li></ul><h1 id="搭建HBase"><a href="#搭建HBase" class="headerlink" title="搭建HBase"></a>搭建HBase</h1><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h4 id="22端口冲突"><a href="#22端口冲突" class="headerlink" title="22端口冲突"></a>22端口冲突</h4><ul><li>容器统一使用2222作为ssh通信端口</li></ul><h4 id="无法使用start-dfs-sh-start-yarn-sh等命令"><a href="#无法使用start-dfs-sh-start-yarn-sh等命令" class="headerlink" title="无法使用start-dfs.sh start-yarn.sh等命令"></a>无法使用start-dfs.sh start-yarn.sh等命令</h4><ul><li>提示：只显示了启动，并没输出日志文件</li><li>原因：ssh崩了</li><li>解决:使用-it启动就会发现，需要密码，免秘钥没有成功<br>因此，我们可以不使用ssh登录，直接使用发现服务？<br>也就不会有ssh秘钥问题<br>开一个分支去实现这个计划、<br>dev分支目前继续使用ssh方案</li></ul><h4 id="遇到namenode的hostname问题-DNS服务器不通"><a href="#遇到namenode的hostname问题-DNS服务器不通" class="headerlink" title="遇到namenode的hostname问题,DNS服务器不通"></a>遇到namenode的hostname问题,DNS服务器不通</h4><ul><li>临时解决方案，在bootstrap.sh上编辑/etc/hosts文件，只需要声明主节点</li><li>后期方案，使用本地DNS服务器     </li></ul><h4 id="namenode无法绑定到内网IP10-173-38-41"><a href="#namenode无法绑定到内网IP10-173-38-41" class="headerlink" title="namenode无法绑定到内网IP10.173.38.41"></a>namenode无法绑定到内网IP10.173.38.41</h4><ul><li>因为没有内部没有这个网卡有这个IP的，因此绑定失败，我们要绑定0.0.0.0</li></ul><h4 id="nodemanager显示不满足内存需要，被resource关闭"><a href="#nodemanager显示不满足内存需要，被resource关闭" class="headerlink" title="nodemanager显示不满足内存需要，被resource关闭"></a>nodemanager显示不满足内存需要，被resource关闭</h4><ul><li>能够被主节点通知，说明没问题</li><li>接下来测试本机能否运行namanode</li></ul><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>docker \run \-p 8000:8000 \-p 8001:8001 \-p 8002:8002 \-p 8003:8003 \-p 8004:8004 \-p 8005:8005 \-p 8006:8006 \-p 8007:8007 \-p 8008:8008 \-p 8009:8009 \-p 8010:8010 \-p 8011:8011 \-p 8012:8012 \-p 8013:8013 \-p 8014:8014 \-p 8015:8015 \-p 8016:8016 \-p 8017:8017 \-p 8018:8018 \-p 8019:8019 \-p 8020:8020 \-v ~/data:/etc/haproxy/haproxy:1.1</code></pre><h2 id="cdm"><a href="#cdm" class="headerlink" title="cdm"></a>cdm</h2><h4 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h4><p>docker rm $(docker ps -a -q)</p><h4 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h4><p>docker rmi $(docker images -q)</p>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-普通用户使用docker</title>
    <link href="/04-Linux/01-Docker/12-%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8docker/"/>
    <url>/04-Linux/01-Docker/12-%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8docker/</url>
    
    <content type="html"><![CDATA[<h1 id="普通用户使用Docker"><a href="#普通用户使用Docker" class="headerlink" title="普通用户使用Docker"></a>普通用户使用Docker</h1>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-删除中间镜像</title>
    <link href="/04-Linux/01-Docker/13-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E9%95%9C%E5%83%8F/"/>
    <url>/04-Linux/01-Docker/13-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="删除中间镜像"><a href="#删除中间镜像" class="headerlink" title="删除中间镜像"></a>删除中间镜像</h1><pre><code class="hljs sh"><span class="hljs-comment"># 停止包含Exited的容器</span>sudo docker ps -a | grep <span class="hljs-string">&quot;Exited&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1 &#125;&#x27;</span>|xargs sudo docker stop<span class="hljs-comment"># 删除包含Exited的容器</span>sudo docker ps -a | grep <span class="hljs-string">&quot;Exited&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1 &#125;&#x27;</span>|xargs sudo docker rm<span class="hljs-comment"># 删除包含none的镜像</span>sudo docker images|grep none|awk <span class="hljs-string">&#x27;&#123;print $3 &#125;&#x27;</span>|xargs sudo docker rmi</code></pre>]]></content>
    
    
    <categories>
      
      <category>04-Linux</category>
      
      <category>01-Docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-fastText入门</title>
    <link href="/06-AI/01-NLP/01-fastText%E5%85%A5%E9%97%A8/"/>
    <url>/06-AI/01-NLP/01-fastText%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="FastText入门"><a href="#FastText入门" class="headerlink" title="FastText入门"></a>FastText入门</h1><p>我就不介绍了，直接看Github地址吧，我们这里只看问文本分类功能</p><p><a href="https://github.com/salestock/fastText.py">Github地址</a></p><h2 id="安装踩坑"><a href="#安装踩坑" class="headerlink" title="安装踩坑"></a>安装踩坑</h2><ol><li>FastText基于Cython</li></ol><p><a href="https://pypi.python.org/packages/be/08/bb5ffd1c32a951cbc26011ecb8557e59dc7a0a4975f0ad98b2cd7446f7dd/Cython-0.28.1.tar.gz#md5=c549effadb52d90bdcb1affc1e5dbb97">下载</a>Cython，解压，进入安装路径</p><pre><code class="hljs sh">sudo python3 setup.py install</code></pre><ol start="2"><li>安装FastText</li></ol><pre><code class="hljs sh">sudo pip3 install fasttext</code></pre><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><p>如代码中描述，先下载测试数据，创建文件<code>classification-example.sh</code></p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-comment">#</span><span class="hljs-comment"># Copyright (c) 2016-present, Facebook, Inc.</span><span class="hljs-comment"># All rights reserved.</span><span class="hljs-comment">#</span><span class="hljs-comment"># This source code is licensed under the BSD-style license found in the</span><span class="hljs-comment"># LICENSE file in the root directory of this source tree. An additional grant</span><span class="hljs-comment"># of patent rights can be found in the PATENTS file in the same directory.</span><span class="hljs-comment">#</span><span class="hljs-function"><span class="hljs-title">myshuf</span></span>() &#123;  perl -MList::Util=shuffle -e <span class="hljs-string">&#x27;print shuffle(&lt;&gt;);&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-title">normalize_text</span></span>() &#123;  tr <span class="hljs-string">&#x27;[:upper:]&#x27;</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> | sed -e <span class="hljs-string">&#x27;s/^/__label__/g&#x27;</span> | \    sed -e <span class="hljs-string">&quot;s/&#x27;/ &#x27; /g&quot;</span> -e <span class="hljs-string">&#x27;s/&quot;//g&#x27;</span> -e <span class="hljs-string">&#x27;s/\./ \. /g&#x27;</span> -e <span class="hljs-string">&#x27;s/&lt;br \/&gt;/ /g&#x27;</span> \        -e <span class="hljs-string">&#x27;s/,/ , /g&#x27;</span> -e <span class="hljs-string">&#x27;s/(/ ( /g&#x27;</span> -e <span class="hljs-string">&#x27;s/)/ ) /g&#x27;</span> -e <span class="hljs-string">&#x27;s/\!/ \! /g&#x27;</span> \        -e <span class="hljs-string">&#x27;s/\?/ \? /g&#x27;</span> -e <span class="hljs-string">&#x27;s/\;/ /g&#x27;</span> -e <span class="hljs-string">&#x27;s/\:/ /g&#x27;</span> | tr -s <span class="hljs-string">&quot; &quot;</span> | myshuf&#125;RESULTDIR=resultDATADIR=datamkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RESULTDIR&#125;</span>&quot;</span>mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>&quot;</span><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.train&quot;</span> ]<span class="hljs-keyword">then</span>  wget -c <span class="hljs-string">&quot;https://github.com/le-scientifique/torchDatasets/raw/master/dbpedia_csv.tar.gz&quot;</span> -O <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia_csv.tar.gz&quot;</span>  tar -xzvf <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia_csv.tar.gz&quot;</span> -C <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>&quot;</span>  cat <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia_csv/train.csv&quot;</span> | normalize_text &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.train&quot;</span>  cat <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia_csv/test.csv&quot;</span> | normalize_text &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.test&quot;</span><span class="hljs-keyword">fi</span>make./fasttext supervised -input <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.train&quot;</span> -output <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RESULTDIR&#125;</span>/dbpedia&quot;</span> -dim 10 -lr 0.1 -wordNgrams 2 -minCount 1 -bucket 10000000 -epoch 5 -thread 4./fasttext <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RESULTDIR&#125;</span>/dbpedia.bin&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.test&quot;</span>./fasttext predict <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RESULTDIR&#125;</span>/dbpedia.bin&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DATADIR&#125;</span>/dbpedia.test&quot;</span> &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RESULTDIR&#125;</span>/dbpedia.test.predict&quot;</span></code></pre><p>加权限，执行之</p><h2 id="文本分类的使用"><a href="#文本分类的使用" class="headerlink" title="文本分类的使用"></a>文本分类的使用</h2><p>代码基于Github的<code>examples/classification_example.py</code>来改的</p><pre><code class="hljs py"><span class="hljs-keyword">import</span> fasttext <span class="hljs-keyword">as</span> ft<span class="hljs-comment"># First download the dbpedia.train using https://github.com/facebookresearch/fastText/blob/master/classification-example.sh</span><span class="hljs-comment"># on test/ and move to the example directory</span>current_dir = path.dirname(__file__)input_file = path.join(current_dir, <span class="hljs-string">&#x27;dbpedia.train&#x27;</span>)output = <span class="hljs-string">&#x27;/tmp/classifier&#x27;</span>test_file = <span class="hljs-string">&#x27;../test/classifier_test.txt&#x27;</span><span class="hljs-comment"># set params</span>dim=<span class="hljs-number">10</span>lr=<span class="hljs-number">0.005</span>epoch=<span class="hljs-number">1</span>min_count=<span class="hljs-number">1</span>word_ngrams=<span class="hljs-number">3</span>bucket=<span class="hljs-number">2000000</span>thread=<span class="hljs-number">4</span>silent=<span class="hljs-number">1</span><span class="hljs-comment"># 训练文本的前缀</span>label_prefix=<span class="hljs-string">&#x27;__label__&#x27;</span><span class="hljs-comment"># Train the classifier</span>classifier = ft.supervised(input_file, output, dim=dim, lr=lr, epoch=epoch,    min_count=min_count, word_ngrams=word_ngrams, bucket=bucket,    thread=thread, silent=silent, label_prefix=label_prefix)<span class="hljs-comment"># Test the classifier</span>result = classifier.test(test_file)<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;P@1:&#x27;</span>, result.precision)<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;R@1:&#x27;</span>, result.recall)<span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;Number of examples:&#x27;</span>, result.nexamples)<span class="hljs-comment"># Predict some text</span><span class="hljs-comment"># (Example text is from dbpedia.train)</span>texts = [<span class="hljs-string">&#x27;birchas chaim , yeshiva birchas chaim is a orthodox jewish mesivta \</span><span class="hljs-string">        high school in lakewood township new jersey . it was founded by rabbi \</span><span class="hljs-string">        shmuel zalmen stein in 2001 after his father rabbi chaim stein asked \</span><span class="hljs-string">        him to open a branch of telshe yeshiva in lakewood . as of the 2009-10 \</span><span class="hljs-string">        school year the school had an enrollment of 76 students and 6 . 6 \</span><span class="hljs-string">        classroom teachers ( on a fte basis ) for a student–teacher ratio of \</span><span class="hljs-string">        11 . 5 1 .&#x27;</span>]labels = classifier.predict(texts)<span class="hljs-keyword">print</span> (labels)</code></pre><p>项目终止，暂不研究</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Word2vec词向量构建计划</title>
    <link href="/06-AI/01-NLP/03-Word2vec/03-Word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E6%9E%84%E5%BB%BA%E8%AE%A1%E5%88%92/"/>
    <url>/06-AI/01-NLP/03-Word2vec/03-Word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E6%9E%84%E5%BB%BA%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Word2Vec词向量构建计划"><a href="#Word2Vec词向量构建计划" class="headerlink" title="Word2Vec词向量构建计划"></a>Word2Vec词向量构建计划</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>由于中英文词向量不一致(两个文件)，导致问题如下：</p><ol><li>需要重复导入文件</li><li>进行语义判断前需要判断中英文</li><li>出现中文和英文即使意思相近，也无法判断，如：”Big Data”和”大数据”</li><li>对于同时含有中英文的情况无法判断</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="1-如何处理繁体问题"><a href="#1-如何处理繁体问题" class="headerlink" title="1. 如何处理繁体问题"></a>1. 如何处理繁体问题</h3><ul><li>决    策: 繁体统一转换成简体中文处理，需要判断繁体中文的语义也只能使用简体中文计算</li><li>决策依据: 参考 <a href="https://github.com/Embedding/Chinese-Word-Vectors#corpus">https://github.com/Embedding/Chinese-Word-Vectors#corpus</a> 的做法</li></ul><h3 id="2-如何处理大小写问题"><a href="#2-如何处理大小写问题" class="headerlink" title="2. 如何处理大小写问题"></a>2. 如何处理大小写问题</h3><p>如 Big Data 和 big data 算两个词还是一个词??</p><ul><li>决    策: 一个词，全部使用小写</li><li>决策依据: </li></ul><h3 id="3-如何训练及使用特定领域词库？"><a href="#3-如何训练及使用特定领域词库？" class="headerlink" title="3. 如何训练及使用特定领域词库？"></a>3. 如何训练及使用特定领域词库？</h3><ul><li>决    策: 留下训练的工具，在特定的场景能够使用，支持从0开始训练，也支持基于模型训练</li><li>决策依据: 无</li></ul><h3 id="4-英文词向量还是字向量"><a href="#4-英文词向量还是字向量" class="headerlink" title="4. 英文词向量还是字向量"></a>4. 英文词向量还是字向量</h3><p>Big Data是一个词组吗</p><ul><li>决    策: 是一个词组</li><li>决策依据: 参考 <a href="https://code.google.com/archive/p/word2vec/">https://code.google.com/archive/p/word2vec/</a> 的<code>From words to phrases and beyond</code>做法<pre><code>     参考 https://github.com/chrisjmccormick/inspect_word2vec 的说明</code></pre></li></ul><h3 id="5-中文分词问题"><a href="#5-中文分词问题" class="headerlink" title="5. 中文分词问题"></a>5. 中文分词问题</h3><p>中文使用Hanlp-1.6.8作为分词工具，使用默认的分词模式</p><h2 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h2><p>原因是，中文词库中可能包含一部分英文，这导致英文无法正确使用，只能继续训练，但是这样的工作量太过庞大</p><h2 id="值得一读的文章"><a href="#值得一读的文章" class="headerlink" title="值得一读的文章"></a>值得一读的文章</h2><p><a href="https://code.google.com/archive/p/word2vec/">谷歌官方Word2vec介绍</a><br><a href="https://github.com/chrisjmccormick/inspect_word2vec">谷歌的300万词的说明(英文)</a><br><a href="https://github.com/cenzhongman/Chinese-Word-Vectors">上百种预训练中文词向量 </a><br><a href="https://github.com/3Top/word2vec-api">英文词向量</a><br><a href="https://fasttext.cc/docs/en/crawl-vectors.html">157种语言词向量</a></p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>03-Word2vec</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-自然语言处理的所有问题和解决办法</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/00-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%9A%84%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/00-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%9A%84%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="NLP问题和解决办法"><a href="#NLP问题和解决办法" class="headerlink" title="NLP问题和解决办法"></a>NLP问题和解决办法</h1><ul><li>jieba：Python的中文分词工具</li><li>Hanlp：JAVA的分词工具，分词的同时做实体命名识别</li><li>CoreNlp：Stanford开源的JAVA的自然语言处理工具，支持中英文</li></ul><h2 id="1-分词"><a href="#1-分词" class="headerlink" title="1 分词"></a>1 分词</h2><h3 id="1-1-工具"><a href="#1-1-工具" class="headerlink" title="1.1 工具"></a>1.1 工具</h3><ul><li>jieba：规则分词、HMM</li><li>Hanlp：HMM-Bigram、感知机分词、CRF分词、规则分词</li><li>CoreNlp：</li></ul><h3 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h3><ol><li>规则分词：词典分词<ol><li>正向最大匹配</li><li>逆向最大匹配</li><li>双向最大匹配</li></ol></li><li>统计分词：概率学模型<ol><li>HMM – 隐马尔可夫，通过标注的方式，使用B(Begin)M(Middle)E(End)S(Simgle)来进行标注，假设特征独立(不考虑上下文)，只考虑前一个词的可能性</li><li>CRF – 条件随机场，考虑前后一个词</li><li>感知机</li></ol></li><li>混合1和2</li></ol><h2 id="2-词性标注"><a href="#2-词性标注" class="headerlink" title="2. 词性标注"></a>2. 词性标注</h2><h3 id="2-1-工具"><a href="#2-1-工具" class="headerlink" title="2.1 工具"></a>2.1 工具</h3><ul><li>jieba：规则标注 统计标注 HMM</li><li>Hanlp：HMM词性标注（速度快）、感知机词性标注、CRF词性标注（精度高）</li><li>coreNlp：</li></ul><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a>2.2 算法</h3><ol><li>规则标注：词典标注</li><li>统计标注：概率学<ol><li>HMM</li><li>CRF</li></ol></li></ol><h2 id="3-实体命名识别NER"><a href="#3-实体命名识别NER" class="headerlink" title="3. 实体命名识别NER"></a>3. 实体命名识别NER</h2><p>3大类(实体、时间、数字)，7小类(人名、地名、组织机构名、时间、日期、货币、百分比)</p><h3 id="3-1-工具"><a href="#3-1-工具" class="headerlink" title="3.1 工具"></a>3.1 工具</h3><ol><li>Hanlp：</li><li>CoreNlp：</li></ol><h3 id="3-2-算法"><a href="#3-2-算法" class="headerlink" title="3.2 算法"></a>3.2 算法</h3><p>对于不同的分类使用不同的识别方法</p><h4 id="3-2-1-时间-数量-日期-货币"><a href="#3-2-1-时间-数量-日期-货币" class="headerlink" title="3.2.1 时间 数量 日期 货币"></a>3.2.1 时间 数量 日期 货币</h4><ol><li>模式匹配</li></ol><h4 id="3-2-2-人名-地名-机构名"><a href="#3-2-2-人名-地名-机构名" class="headerlink" title="3.2.2 人名 地名 机构名"></a>3.2.2 人名 地名 机构名</h4><p>由于英文的实体名大多以大写开头，主要工作是<strong>结尾边界</strong>和<strong>实体类型</strong></p><p>中文中的难题：<strong>实体边界</strong>、<strong>实体类型</strong></p><ol><li>基于规则 如：XX有限公司、广东省</li><li>基于统计<ol><li>HMM</li><li>最大熵模型</li><li>CRF</li></ol></li><li>混合1和2</li></ol><h2 id="4-关键词句提取"><a href="#4-关键词句提取" class="headerlink" title="4. 关键词句提取"></a>4. 关键词句提取</h2><h3 id="4-1-工具"><a href="#4-1-工具" class="headerlink" title="4.1 工具"></a>4.1 工具</h3><ol><li>Hanlp：Textrank</li></ol><h3 id="4-2-算法"><a href="#4-2-算法" class="headerlink" title="4.2 算法"></a>4.2 算法</h3><ol><li>TF/IDF :TF(Term-Frequency)计算该词在当篇文章中的词频，出现越多越重要；IFD(Inverse Document Frequency)计算该词在其他文档中出现的次数，出现的越少越重要</li><li>TextRank: TF-IDF 需要其他语料才能计算IDF，而Textank仅需要单篇文章，计算词之间相互关联的次数和句子相似度权重</li><li>LSA/LSI/LDA：这个算法是一个主题模型，文章通篇在讲 恐龙 狮子 猴子，却没有提到<strong>动物</strong><ol><li>LAS/LSI: 潜在语义分析，</li><li>LSD: </li></ol></li></ol><h2 id="5-句法分析"><a href="#5-句法分析" class="headerlink" title="5. 句法分析"></a>5. 句法分析</h2><h3 id="5-1-工具"><a href="#5-1-工具" class="headerlink" title="5.1 工具"></a>5.1 工具</h3><ol><li>Hanlp: 神经网络分类模型与转移系统、最大熵依存句法分析</li><li>CoreNlp: </li></ol><h3 id="5-2-算法"><a href="#5-2-算法" class="headerlink" title="5.2 算法"></a>5.2 算法</h3><ol><li>基于规则</li><li>基于统计</li><li>结合1和2<ol><li>PCFG</li><li>最大间隔马科尔夫网络</li><li>CRF</li><li>移进-归约句法分析</li></ol></li></ol><h2 id="6-词向量"><a href="#6-词向量" class="headerlink" title="6. 词向量"></a>6. 词向量</h2><h3 id="6-1-工具"><a href="#6-1-工具" class="headerlink" title="6.1 工具"></a>6.1 工具</h3><h3 id="6-2-算法"><a href="#6-2-算法" class="headerlink" title="6.2 算法"></a>6.2 算法</h3><ol><li>NNLM</li><li>C&amp;W</li><li>CBOW &amp; Skip-gram</li><li>word2vec</li><li>doc2vec</li></ol><h2 id="7-文本分类"><a href="#7-文本分类" class="headerlink" title="7. 文本分类"></a>7. 文本分类</h2><ol><li>逻辑回归</li><li>朴素贝叶斯</li><li>支持向量机</li><li>K近邻居</li><li>决策树</li><li>神经网络(RNN LSTM)</li></ol><h2 id="8-聚类问题"><a href="#8-聚类问题" class="headerlink" title="8. 聚类问题"></a>8. 聚类问题</h2>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-朴素贝叶斯</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/02-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/02-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/marc01in/p/4775440.html">朴素贝叶斯算法 &amp; 应用实例</a></p><p>贝叶斯公式</p><p><img src="../images/2018-12-11-11-19-45.png"></p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-隐马尔可夫</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/04-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/04-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="HMM隐马尔可夫模型"><a href="#HMM隐马尔可夫模型" class="headerlink" title="HMM隐马尔可夫模型"></a>HMM隐马尔可夫模型</h1><h2 id="数学化"><a href="#数学化" class="headerlink" title="数学化"></a>数学化</h2><p>隐马尔可夫，通过标注的方式，使用B(Begin)M(Middle)E(End)S(Simgle)来进行标注，假设特征独立(不考虑上下文)，</p><ul><li>文字表示：</li></ul><p>标注前：<code>你好，我是中国人</code></p><p>标注后：<code>你/B好/E，/S我/S是/S中/B国/E人/S</code></p><ul><li>数学表示：</li></ul><p>标注前：<br>$$λ_1 λ_2…λ_n$$</p><p>标注：</p><p>$$O_1 O_2…O_n$$</p><p>理想中的公式</p><p>$$P(O|λ)⁡=maxP(O_1 O_2…O_n |λ_1 λ_2…λ_n)$$</p><p>这句话是将以一个句子丢进去，输出一整个句子的标注，但是这样的数学公式关于2n个变量复杂度太高，基本无法计算，若<code>假设特征独立</code>(不考虑上下文)，则变成了</p><p>$$P(O_1 O_2…O_n│λ_1 λ_2…λ_n )= P(O_1│λ_1 )P(O_2│λ_2 )…P(O_n |λ_n)$$</p><p>但是这样算出来的，可能会出现 BEM 的情况，引入<code>贝叶斯公式</code></p><p>$$P(O│λ)=\frac{P(o,λ)}{P(λ)}=\frac{P(λ|o)P(o)}{P(λ)}$$</p><p>结合隐马尔可夫特征<code>独立假设</code></p><p>$$P(λ│o) = P(λ<em>1│O_1 )  P(λ_2│O_2 )… P(λ_n│O_n )$$<br>$$P(o) = P(o_1 )P(o_2│o_1 )P(o_3│o_1,o_2 )…P(o_n |o_1,o_2,…o</em>{n-1} )$$</p><p>引入<code>齐次隐马尔可夫假设</code>，每次输入仅与上一个有关</p><p>$$P(λ│o)P(o)= P(λ_1│O_1 )  P(λ_2│O_2 )… P(λ_n│O_n ) × P(o_1 )P(o_2│o_1 )P(o_3│o_2 )…P(o_n |o_{n-1} )$$</p><p>化简</p><p>$$P(λ│o)P(o)= P(λ<em>1│O_1 )P(o_2│o_1 )  P(λ_2│O_2 )P(o_3│o_2 )…P(o_n |o</em>(n-1) )P(λ_n│O_n )$$</p><p>在HMM中，$P(λ<em>k|o_k)$称为发射概率$P(o_k|o</em>{k-1})$称为转移概率，通过设置某些$P(o_k|o_{k-1})=0$可以规避BEM问题，如:M的前面一定不能是E</p><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>求解HMM的一般做法是<code>Veterbi</code>方法，这是一种最优路径问题的解法</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-CRF</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/05-CRF/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/05-CRF/</url>
    
    <content type="html"><![CDATA[<h1 id="CRF条件随机场"><a href="#CRF条件随机场" class="headerlink" title="CRF条件随机场"></a>CRF条件随机场</h1><p>CRF有两种特征函数，分别为转移函数和状态函数都依赖于<strong>当前</strong>和<strong>前一个</strong>位置，表示从$i-1$的位置$y_{i-1}$转移到$i$的位置$y_i$的可能性</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-TF-IDF</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/06-TF-IDF/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/06-TF-IDF/</url>
    
    <content type="html"><![CDATA[<h1 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h1><ul><li>TF(Term-Frequency)计算该词在当篇文章中的词频，出现越多越重要</li><li>IFD(Inverse Document Frequency)计算该词在其他文档中出现的次数，出现的越少越重要</li></ul><h2 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h2><p>$n_i$目标词，$n_k$其他词</p><p>$$tf_{ij} = \frac{n_{ij}}{\sum_k{n_{kj}}}$$</p><h2 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h2><p>$|D|$所有文档，$|D_i|$出现目标词的文档，分母+1是使用了拉普拉斯平滑，同时防止分母为0</p><p>$$idf_i=log(\frac{|D|}{1+|D_i|})$$</p><h2 id="TF-IDF-1"><a href="#TF-IDF-1" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>两者相乘就是最终的算法啦</p><p>$$tf_{ij} * idf_i = \frac{n_{ij}}{\sum_k{n_{kj}}} × log(\frac{|D|}{1+|D_i|})$$</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-LAS&amp;LSI&amp;LDA</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/07-LAS&amp;LSI&amp;LDA/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/07-LAS&amp;LSI&amp;LDA/</url>
    
    <content type="html"><![CDATA[<h1 id="LSA-amp-LSI-amp-LAD"><a href="#LSA-amp-LSI-amp-LAD" class="headerlink" title="LSA&amp;LSI&amp;LAD"></a>LSA&amp;LSI&amp;LAD</h1><h2 id="LSA-amp-LSI"><a href="#LSA-amp-LSI" class="headerlink" title="LSA &amp; LSI"></a>LSA &amp; LSI</h2><p>LSA Latent Semantic Analysis 潜在语义分析，这个算法是一个主题模型，文章通篇在讲 恐龙 狮子 猴子，却没有提到<strong>动物</strong></p><p>LSA 使用的是词向量，直接用词向量跟已知类型的文档向量比较，得到向量最高的，为文章类型</p><h2 id="LAD"><a href="#LAD" class="headerlink" title="LAD"></a>LAD</h2>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-TextRank自动摘要</title>
    <link href="/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/01-TextRank%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/"/>
    <url>/06-AI/01-NLP/05-%E7%AE%97%E6%B3%95/01-TextRank%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="TextRank自动摘要算法"><a href="#TextRank自动摘要算法" class="headerlink" title="TextRank自动摘要算法"></a>TextRank自动摘要算法</h1><p><a href="http://www.hankcs.com/nlp/textrank-algorithm-java-implementation-of-automatic-abstract.html">Hanlp中的自动摘要算法</a></p><h2 id="pageRank"><a href="#pageRank" class="headerlink" title="pageRank"></a>pageRank</h2><p>pageRank是TextRank的前身，pagerank Google是用于计算网页价值的算法</p><p><img src="../images/2018-12-11-15-33-28.png"></p><p>一个网页的权重由入链的<strong>数量</strong>和<strong>质量</strong>决定，同时决定了<strong>出链</strong>的质量，形成<strong>有向无权图</strong></p><h2 id="TextRank"><a href="#TextRank" class="headerlink" title="TextRank"></a>TextRank</h2><h3 id="关键句抽取"><a href="#关键句抽取" class="headerlink" title="关键句抽取"></a>关键句抽取</h3><p>textRank是利用词语之间的链接，同时加上句子相似度作为，进行句子权重的计算，形成<strong>有向有权图</strong></p><h3 id="关键字抽取"><a href="#关键字抽取" class="headerlink" title="关键字抽取"></a>关键字抽取</h3><p>关键字抽取比关键句抽取少了两个东西</p><ol><li>词与词之间没有相似度权重，这就变成了PageRank的<strong>有向无权图</strong></li><li>不是每个词之间都有链接，有些词就是独立存在的</li></ol><p>问题1：很简单，那就不要权啊</p><p>问题2：使用窗口的概念，将前后文关联起来</p><p>如设置窗口为5，你好，我是中国人，这里的人名热情好客</p><p>[你好 我 是 中国人 这里]<br>[的 人民 热情 好客]</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>05-算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-机器学习没入门</title>
    <link href="/06-AI/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B2%A1%E5%85%A5%E9%97%A8/"/>
    <url>/06-AI/01-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B2%A1%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习定义及概念"><a href="#机器学习定义及概念" class="headerlink" title="机器学习定义及概念"></a>机器学习定义及概念</h1><p>不会啊～～～</p><h2 id="1-1学习问题的标准描述"><a href="#1-1学习问题的标准描述" class="headerlink" title="1.1学习问题的标准描述"></a>1.1学习问题的标准描述</h2><p>对于任务<strong>T</strong>和性能度量<strong>P</strong>，使用<strong>E</strong>经验自我完善，就称为从经验<strong>E</strong>中学习。</p><h2 id="1-2设计一个学习系统"><a href="#1-2设计一个学习系统" class="headerlink" title="1.2设计一个学习系统"></a>1.2设计一个学习系统</h2><ul><li>任务T:下西洋跳棋</li><li>性能标准P：击败AI的百分比</li><li>训练经验E:？？</li></ul><h3 id="1-2-1选择训练经验E"><a href="#1-2-1选择训练经验E" class="headerlink" title="1.2.1选择训练经验E"></a>1.2.1选择训练经验E</h3><ul><li>训练经验能否为决策提供<strong>直接</strong>或<strong>间接</strong>反馈<ul><li>直接，经验告诉程序什么是对的</li><li>间接：从结果来看推断之前的每一步的正确性，这时候涉及到信用分配问题，要考虑每一步的贡献程序</li></ul></li><li>训练经验能够多大程度控制训练样例序列(一般使用框架)<ul><li>无控制：训练经验是随机的</li><li>限定范围：能够在一定范围训练，就像专项练习</li><li>自动探索：顺藤摸瓜</li></ul></li><li>训练样例能够多好地表现实际环境<ul><li>自我训练会出现从没出现的情况</li></ul></li></ul><p>系统完善:</p><ul><li>任务T:下西洋跳棋</li><li>性能标准P：击败AI的百分比</li><li>训练经验E:自己和自己对弈:间接，随机，不能反应实际</li></ul><h3 id="1-2-2选择理想目标函数"><a href="#1-2-2选择理想目标函数" class="headerlink" title="1.2.2选择理想目标函数"></a>1.2.2选择理想目标函数</h3><ul><li>限定合法的走法<ol><li>在合法的选项中选择出最佳的走法，ChooseMove:B-&gt;M<ul><li>B表示可选</li><li>M表示最佳结果<br>(直接找到这个函数是不存在的)</li></ul></li><li>评估函数，将所有(递归)合法棋局做一个分数评估，就这么下有可能赢吗作为评判标准，再做出选择，V：B-&gt;h<br>(由于递归，这个函数是不可操作的)</li></ol></li></ul><h3 id="1-2-3选择目标函数的表示"><a href="#1-2-3选择目标函数的表示" class="headerlink" title="1.2.3选择目标函数的表示"></a>1.2.3选择目标函数的表示</h3>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-MySQL安装使用</title>
    <link href="/03-Database/01-MySQL/01-MySQL%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <url>/03-Database/01-MySQL/01-MySQL%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs sh">sudo apt-get install mysql-server,mysql-client,libmysqlclient-dev</code></pre><h2 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h2><pre><code class="hljs sh"><span class="hljs-comment">#启动</span>sudo service mysql start<span class="hljs-comment">#停止</span>sudo service mysql stop<span class="hljs-comment">#状态</span>sudo service mysql status</code></pre><h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><pre><code class="hljs sh">mysql -u用户名 -p密码(可以非明文输入) -h主机/IP -D端口 --prompt 提示符</code></pre><h3 id="允许远程登陆"><a href="#允许远程登陆" class="headerlink" title="允许远程登陆"></a>允许远程登陆</h3><ul><li>将/etc/mysql/my.cnf中的bind_address那一行注释掉或修改为“bind_address=0.0.0.0”：</li></ul><p>bind_address并没有在/etc/mysql/my.cnf文件中，这个文件除去注释只有如下两行内容：</p><pre><code class="hljs sh">!includedir /etc/mysql/conf.d/!includedir /etc/mysql/mysql.conf.d/</code></pre><p>根据这个内容，应该查看一下/etc/mysql/conf.d/和/etc/mysql/mysql.conf.d/这两个文件夹中的.cnf文件，发现/etc/mysql/mysql.conf.d/mysqld.cnf文件里面配置了“bind_address=127.0.0.1”，将其注释掉。</p><ul><li>修改mysql.user表中相关用户（例如root)的host域，可以修改为具体的IP地址，或者是用“%”作通配符（例如用“%”代表任何地址）：UPDATE user SET host=’%’ WHERE user=’root’</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="查看表详细信息"><a href="#查看表详细信息" class="headerlink" title="查看表详细信息"></a>查看表详细信息</h3><pre><code class="hljs sh">SHOW COLUMNS FROM tablename;</code></pre><h3 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h3><pre><code class="hljs sh">SELECT database();</code></pre><h3 id="查看数据库的编码信息"><a href="#查看数据库的编码信息" class="headerlink" title="查看数据库的编码信息"></a>查看数据库的编码信息</h3><pre><code class="hljs sh">show variables like <span class="hljs-string">&#x27;character_set_database&#x27;</span>;<span class="hljs-comment"># 修改编码信息</span>alter database xxx CHARACTER SET gb2312;</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="../images/01-01.png"><br><img src="../images/01-02.png"><br><img src="../images/01-03.png"><br><img src="../images/01-04.png"></p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Mysql复制表</title>
    <link href="/03-Database/01-MySQL/03-Mysql%E5%A4%8D%E5%88%B6%E8%A1%A8/"/>
    <url>/03-Database/01-MySQL/03-Mysql%E5%A4%8D%E5%88%B6%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库复制表指令"><a href="#数据库复制表指令" class="headerlink" title="数据库复制表指令"></a>数据库复制表指令</h1><p><code>select into from</code> 和 <code>insert into select</code>都是用来复制表，两者的主要区别为： <code>select into from</code> 要求目标表不存在，因为在插入时会自动创建。<code>insert into select from</code> 要求目标表存在。</p><p>备份表数据： <code>create table emp as select * from scott.emp</code><br>还原表数据：<code>insert into emp select * from scott.emp</code></p><p>复制表结构及其数据：</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name_new <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table_name_old</code></pre><p>只复制表结构：</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name_new <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table_name_old <span class="hljs-keyword">where</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span>;</code></pre><p>或者：</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name_new <span class="hljs-keyword">like</span> table_name_old</code></pre><p>只复制表数据：</p><p>如果两个表结构一样：</p><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name_new <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table_name_old</code></pre><p>如果两个表结构不一样：</p><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name_new(column1,column2...) <span class="hljs-keyword">select</span> column1,column2...<span class="hljs-keyword">from</span> table_name_old pasting</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-MySQL 5.7远程连接</title>
    <link href="/03-Database/01-MySQL/04-MySQL%205.7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <url>/03-Database/01-MySQL/04-MySQL%205.7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql远程连接"><a href="#Mysql远程连接" class="headerlink" title="Mysql远程连接"></a>Mysql远程连接</h1><ul><li>将/etc/mysql/my.cnf中的bind_address那一行注释掉或修改为“bind_address=0.0.0.0”：<br>  bind_address并没有在/etc/mysql/my.cnf文件中，这个文件除去注释只有如下两行内容：</li></ul><pre><code class="hljs sh">!includedir /etc/mysql/conf.d/!includedir /etc/mysql/mysql.conf.d/</code></pre><p>根据这个内容，应该查看一下/etc/mysql/conf.d/和/etc/mysql/mysql.conf.d/这两个文件夹中的.cnf文件，发现/etc/mysql/mysql.conf.d/mysqld.cnf文件里面配置了“bind_address=127.0.0.1”，将其注释掉。</p><ul><li>修改mysql.user表中相关用户（例如root)的host域，可以修改为具体的IP地址，或者是用“%”作通配符（例如用“%”代表任何地址）：UPDATE user SET host=’%’ WHERE user=’root’</li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-不存在插入&amp;存在则更新</title>
    <link href="/03-Database/01-MySQL/05-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8F%92%E5%85%A5&amp;%E5%AD%98%E5%9C%A8%E5%88%99%E6%9B%B4%E6%96%B0/"/>
    <url>/03-Database/01-MySQL/05-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8F%92%E5%85%A5&amp;%E5%AD%98%E5%9C%A8%E5%88%99%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="不存在插入-amp-存在则更新"><a href="#不存在插入-amp-存在则更新" class="headerlink" title="不存在插入&amp;存在则更新"></a>不存在插入&amp;存在则更新</h1><ul><li>注意：这个是Mysql专有的</li></ul><h2 id="SQL实现"><a href="#SQL实现" class="headerlink" title="SQL实现"></a>SQL实现</h2><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.<span class="hljs-string">`User`</span>(uid,<span class="hljs-keyword">name</span>,sex,age)  <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiaowang2&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-number">22</span>)<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DUPLICATE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">name</span>=<span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">name</span>),sex=<span class="hljs-keyword">VALUES</span>(sex),age=<span class="hljs-keyword">VALUES</span>(age)</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-数据库设计</title>
    <link href="/03-Database/01-MySQL/08-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/03-Database/01-MySQL/08-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="ERD"><a href="#ERD" class="headerlink" title="ERD"></a>ERD</h2><ul><li>ERD - Entity Relationship Diagram 实体关系图</li></ul><h3 id="一多对"><a href="#一多对" class="headerlink" title="一多对"></a>一多对</h3><p>使用鸟足结构</p><p><img src="../images/2019-01-02-10-26-50.png"></p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一关系不常见(表的垂直切分时会用到)</p><p><img src="../images/2019-01-02-10-33-18.png"></p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><img src="../images/2019-01-02-10-34-48.png"></p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-存储引擎</title>
    <link href="/03-Database/01-MySQL/11-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/03-Database/01-MySQL/11-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>与Innodb的区别</p><ol><li>Innodb支持数据库事务</li><li>Innodb支持外键</li><li>均使用B+Tree作为索引，但Innodb子结点存储文件，MyISAM存储指针</li><li>MyISAM存储行数，Innodb不存储行数，需要在树上遍历 在不包含Where情况下，MyISAM查询更快</li><li>。。。</li></ol><h2 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h2><p>Innodb使用B+树</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>01-MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JDBC概述</title>
    <link href="/03-Database/04-JDBC/01-JDBC%E6%A6%82%E8%BF%B0/"/>
    <url>/03-Database/04-JDBC/01-JDBC%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><ul><li>JDBC：java database connectivity 是JAVA连接数据库的规格，由SUN公司统一制定，JAVA<strong>只能</strong>通过JDBC连接数据库</li><li>JPA：JAVAEE定义的JAVA持久层接口（JAVA Persistence API）</li><li>Hibernate：实现了JPA接口</li></ul><h2 id="连接数据库的方式"><a href="#连接数据库的方式" class="headerlink" title="连接数据库的方式"></a>连接数据库的方式</h2><ol><li>JDBC直接操纵数据库</li><li>使用第三方的O/R Mapping工具实现操作，如Hibernate\Mbaties 等（<strong>底层使用JDBC连接数据库</strong>）</li></ol><h2 id="使用JDBC的好处"><a href="#使用JDBC的好处" class="headerlink" title="使用JDBC的好处"></a>使用JDBC的好处</h2><p>对于不同数据库，有不同的规范，数据结构和SQL语言都不尽相同。JDBC制定了一套接口规范，由数据库厂商实现(数据库驱动包)</p><ol><li>JDBC使得JAVA程序员可以使用同一套操作方法操作数据库，无需关心数据库的差别</li><li>涉及到中途切换数据库时只需要更换JDBC连接驱动，无需更改代码</li></ol><p>如果不实用JDBC，可以想像，你需要像连接Elasticsearch那样天天在翻每一个数据库的开发手册</p><h2 id="JDBC的位置"><a href="#JDBC的位置" class="headerlink" title="JDBC的位置"></a>JDBC的位置</h2><p>JDBC的接口在jdk的java.sql包中，隶属于javaee<br>javax.sql中包含增强的jdbc规范</p><p>只能使用接口，不能使用类，且<strong>在使用时，只能引入只能是java.sql包，不能使用驱动包中的接口</strong></p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-JDBC连接主流数据库</title>
    <link href="/03-Database/04-JDBC/03-JDBC%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/03-Database/04-JDBC/03-JDBC%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC连接主流数据库"><a href="#JDBC连接主流数据库" class="headerlink" title="JDBC连接主流数据库"></a>JDBC连接主流数据库</h1><h2 id="oracle"><a href="#oracle" class="headerlink" title="oracle"></a>oracle</h2><p>driverClass：oracle.jdbc.driver.OracleDriver<br>url：jdbc:oracle:thin:@127.0.0.1:1521:dbname</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>driverClass：com.mysql.jdbc.Driver<br>url：jdbc:mysql://localhost:3306/mydb</p><h2 id="DB2"><a href="#DB2" class="headerlink" title="DB2"></a>DB2</h2><p>driverClass：com.ibm.db2.jcc.DB2Driver<br>url：jdbc:db2://127.0.0.1:50000/dbname</p><h2 id="syBase"><a href="#syBase" class="headerlink" title="syBase"></a>syBase</h2><p>driverClass：com.sybase.jdbc.SybDriver<br>url：jdbc:sybase:Tds:localhost:5007/dbname</p><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><p>driverClass：org.postgresql.Driver<br>url：jdbc:postgresql://localhost/dbname</p><h2 id="Sql-Server2000"><a href="#Sql-Server2000" class="headerlink" title="Sql Server2000"></a>Sql Server2000</h2><p>driverClass：com.microsoft.jdbc.sqlserver.SQLServerDriver<br>url：jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=dbname</p><h2 id="Sql-Server2005"><a href="#Sql-Server2005" class="headerlink" title="Sql Server2005"></a>Sql Server2005</h2><p>driverClass：com.microsoft.sqlserver.jdbc.SQLServerDriver<br>url：jdbc:sqlserver://localhost:1433; DatabaseName=dbname</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-JDBC操作手册</title>
    <link href="/03-Database/04-JDBC/02-JDBC%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <url>/03-Database/04-JDBC/02-JDBC%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC操作手册"><a href="#JDBC操作手册" class="headerlink" title="JDBC操作手册"></a>JDBC操作手册</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><ul><li>pom.xml</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="2-获取连接对象"><a href="#2-获取连接对象" class="headerlink" title="2. 获取连接对象"></a>2. 获取连接对象</h2><p>通过<code>java.sql.DriverManager</code>获得连接器<code>java.sql.Connection</code></p><pre><code class="hljs java"><span class="hljs-comment">// 1. 加载注册驱动--注册这个类，将字节码加载进虚拟机，即开始执行Driver的静态代码块，代码块中进行了驱动的实例化和注册</span>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="hljs-comment">// 2. 获取JDBC连接器</span>Connection connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;Mysql679077&quot;</span>);</code></pre><ul><li>【可选】加载注册驱动，JDBC4.0即jdk6开始不需要注册，java.sql.DriverManager文档中说明了，需要驱动包中包含META-INF/services/java.sql.Driver文件，用于存放驱动器的类名（可以包含多行），但由于JAVAweb中的加载方式不同，必须声明驱动，因此 <strong>不建议省略</strong></li><li>jdbc:mysql://localhost:3306/databaseName?generateSimpleParameterMetadata=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</li></ul><p><a href="03-JDBC%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E5%BA%93/">其他数据库的包名和URL</a></p><h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><pre><code class="hljs java"><span class="hljs-comment">// 3. 创建sql语句</span>String sql = <span class="hljs-string">&quot;CREATE TABLE user (id INT NOT NULL AUTO_INCREMENT, user_name VARCHAR (255), primary key(id));&quot;</span>;<span class="hljs-comment">// 4. 执行sql语句</span>Statement statement = connection.createStatement();<span class="hljs-keyword">boolean</span> execute = statement.execute(sql);<span class="hljs-comment">// 5. 释放资源</span>connection.close();statement.close();</code></pre><h2 id="4-DQL-SQL注入风险"><a href="#4-DQL-SQL注入风险" class="headerlink" title="4. DQL(SQL注入风险)"></a>4. DQL(SQL注入风险)</h2><pre><code class="hljs java"><span class="hljs-comment">// 3. 创建sql语句</span>String sql = <span class="hljs-string">&quot;SELECT * FROM USER WHERE id=1&quot;</span>;<span class="hljs-comment">// 4. 执行sql语句</span>Statement statement = connection.createStatement();ResultSet rs = statement.executeQuery(sql);<span class="hljs-keyword">while</span>(rs.next())&#123;    <span class="hljs-comment">// 通过列序号index获得值，从1开始</span>    rs.getInt(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 通过列名获得值</span>    rs.getString(<span class="hljs-string">&quot;name&quot;</span>);&#125;<span class="hljs-comment">// 5. 释放资源</span>connection.close();statement.close();rs.close();</code></pre><h2 id="4-DQL（PreparedStatement）"><a href="#4-DQL（PreparedStatement）" class="headerlink" title="4. DQL（PreparedStatement）"></a>4. DQL（PreparedStatement）</h2><pre><code class="hljs java">String sql = <span class="hljs-string">&quot;SELECT * FROM USER WHERE id=1&quot;</span>;<span class="hljs-comment">// 3. 创建sql语句</span>PreparedStatement statement = connection..prepareStatement(    <span class="hljs-string">&quot;SELECT * FROM USER WHERE id=?&quot;</span>);statment.setInt(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">// 4. 执行sql语句</span>ResultSet rs = statement.executeQuery();<span class="hljs-keyword">while</span>(rs.next())&#123;    <span class="hljs-comment">// 通过列序号index获得值，从1开始</span>    rs.getInt(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 通过列名获得值</span>    rs.getString(<span class="hljs-string">&quot;name&quot;</span>);&#125;<span class="hljs-comment">// 5. 释放资源</span>connection.close();statement.close();rs.close();</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-PreparedStatement</title>
    <link href="/03-Database/04-JDBC/05-PreparedStatement/"/>
    <url>/03-Database/04-JDBC/05-PreparedStatement/</url>
    
    <content type="html"><![CDATA[<h1 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h1><p>PreparedStatement是一种非静态的SQL，而是带有占位符[?]的SQL</p><p>这种SQL的好处有</p><ol><li>不需要手动拼接字符串，同时增加了代码可读性</li><li>校验输入的类型</li><li>使用占位符的SQL能够防止SQL注入问题啊</li><li>提高数据库的执行效率（MYSQL不支持）<br> 预编译SQL语句，发送到数据库中执行时经历以下步骤<ol><li>安全性分析</li><li>语法分析</li><li>语法编译</li><li>执行语句</li><li>返回结果<br>若，预编译SQL在缓存池中，直接跳过1、2、3执行第4步</li></ol></li></ol><pre><code class="hljs java">String sql=<span class="hljs-string">&quot;select * from xxx where username=? and password=?&quot;</span>;<span class="hljs-comment">//使用预编译</span>PreparedStatement ps = conn.prepareStatement(sql);ps.setString(<span class="hljs-number">1</span>, username);ps.setString(<span class="hljs-number">2</span>, password);ResultSet rs = ps.executeQuery();</code></pre><p>我们常看到数据库DEBUG日志也是通过发送预编译SQL到数据库，然后传参数的方式。<em>这个占位符不是在JAVA层面进行拼接，而是直接将模版和参数发送到数据库中，由数据库进行处理</em></p><p>这也就解释了，预编译语句能够<code>提高执行效率</code>和<code>杜绝SQL注入问题</code>了</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-JDBC数据库事务</title>
    <link href="/03-Database/04-JDBC/06-JDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/03-Database/04-JDBC/06-JDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>默认情况下，JDBC执行DML操作就是在提交事务，一行一个事务</p><p>手动事务提交</p><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">// 交易金额</span>    <span class="hljs-keyword">int</span> tranBalance = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 关闭自动事务</span>    connection.setAutoCommit(<span class="hljs-keyword">false</span>);    sql = <span class="hljs-string">&quot;UPDATE account SET balance = balance - ? WHERE name = ?&quot;</span>    PrepareStatement ps = connection.prepareStatement(sql);    ps.setInt(tranBalance);    ps.setString(<span class="hljs-string">&quot;a&quot;</span>);    <span class="hljs-comment">// 异常发生</span>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;    sql = <span class="hljs-string">&quot;UPDATE account SET balance = balance + ? WHERE name = ?&quot;</span>    PrepareStatement ps = connection.prepareStatement(sql);    ps.setInt(tranBalance);    ps.setString(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">// 提交事务</span>    connction.commit();&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;    <span class="hljs-keyword">try</span>&#123;        e.printStacktrace();        connction.callback();    &#125;<span class="hljs-keyword">catch</span>(Exception e1)&#123;        e1.printStacktrace();    &#125;&#125;<span class="hljs-keyword">finally</span>&#123;    connction.close();&#125;</code></pre><ul><li><code>CREATE</code>和<code>DROP</code>操作不会被回退（可以写在事务中）</li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-JDBC获得自动生成的主键</title>
    <link href="/03-Database/04-JDBC/07-JDBC%E8%8E%B7%E5%BE%97%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%BB%E9%94%AE/"/>
    <url>/03-Database/04-JDBC/07-JDBC%E8%8E%B7%E5%BE%97%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%BB%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="获取自动生成的主键"><a href="#获取自动生成的主键" class="headerlink" title="获取自动生成的主键"></a>获取自动生成的主键</h1><p>需求：减少一次查询操作，直接拿到主键ID可以进行手动关联外键等操作，如用户注册时需要在多张表中保存数据。</p><pre><code class="hljs java">String sql = <span class="hljs-string">&quot;INSERT INTO user (name,age) VALUES (?,?)&quot;</span>;PrepareStatement ps = connection.createStatement(sql,Statement.RETURN_GENERATED_KEYS);ps.setString(<span class="hljs-string">&quot;czm&quot;</span>);ps.setInt(<span class="hljs-number">18</span>);ResultSet rs = ps.executeUpdate();<span class="hljs-keyword">if</span> (rs.next())&#123;    <span class="hljs-keyword">long</span> id = rs.getLong(<span class="hljs-string">&quot;id&quot;</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-DAO</title>
    <link href="/03-Database/06-DAO/01-DAO/"/>
    <url>/03-Database/06-DAO/01-DAO/</url>
    
    <content type="html"><![CDATA[<h1 id="DAO是什么"><a href="#DAO是什么" class="headerlink" title="DAO是什么"></a>DAO是什么</h1><p>DAO(Data Access Object)是数据访问对象，在JAVA中常表现为数据库的统一访问接口，这些接口实现了数据持久化的增删改查等接口，使得业务代码与存储代码结偶。</p><ul><li>优点1: 持久层的结偶，业务代码只需通过这些持久层接口访问数据库等持久层操作，即使持久层更换，业务代码可以不受到任何影响</li><li>优点2: 统一的实现使得代码重用行大大提高，减少重复的代码</li><li>优点3: 统一的存储层，更加方便缓存等操作</li></ul><h2 id="DAO命名规范"><a href="#DAO命名规范" class="headerlink" title="DAO命名规范"></a>DAO命名规范</h2><pre><code class="hljs reasonml">├─ domain│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span>java│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Authority</span>.</span></span>java└──dao    │──<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IUserDAO</span>.</span></span>java    │──<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IAuthorityDAO</span>.</span></span>java    └──impl      │──<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserDAOImpl</span>.</span></span>java      └──AuthorityDAOImpl.Java</code></pre><h2 id="JPA风格的命名规范"><a href="#JPA风格的命名规范" class="headerlink" title="JPA风格的命名规范"></a>JPA风格的命名规范</h2><pre><code class="hljs reasonml">├── domain│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Authority</span>.</span></span>java│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span>java└── repository    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorityRepository</span>.</span></span>java    └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserRepository</span>.</span></span>java</code></pre><h2 id="Mybatis风格的命名规范"><a href="#Mybatis风格的命名规范" class="headerlink" title="Mybatis风格的命名规范"></a>Mybatis风格的命名规范</h2><pre><code class="hljs reasonml">src├── domain│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Authority</span>.</span></span>java│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">User</span>.</span></span>java│── mapper│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorityMapper</span>.</span></span>java│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserMapper</span>.</span></span>java│resources└── mapper    ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorityMapper</span>.</span></span>java    └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserMapper</span>.</span></span>java</code></pre><h2 id="一般性操作流程"><a href="#一般性操作流程" class="headerlink" title="一般性操作流程"></a>一般性操作流程</h2><ol><li>数据库</li><li>创建domain</li><li>DAO接口，CURD方法</li><li>DAO实现类，暂不实现</li><li>DAO测试</li><li>DAO实现类，实现CURD方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>06-DAO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-SQL语句优化</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/01-SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/01-SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ol><li>开启慢查询日志</li></ol><pre><code class="hljs sql"><span class="hljs-comment">-- 查询慢查询日志状态</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log%&#x27;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log_file=<span class="hljs-string">&#x27;/home/mysql/sql_log/mysql-slow.log&#x27;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> log_queries_not_using_indexes=<span class="hljs-keyword">on</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time=<span class="hljs-number">1</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log=<span class="hljs-keyword">on</span>;</code></pre><p>慢日志的格式</p><pre><code class="hljs log"># Time: 2019-12-26T11:30:01.198416Z# User@Host: root[root] @ localhost []  Id:     9# Query_time: 0.000812  Lock_time: 0.000194 Rows_sent: 0  Rows_examined: 0  &#x2F;&#x2F; 执行时间 锁定时间 发送行数 扫描行数use canal_example;SET timestamp&#x3D;1577359801;select * from user;</code></pre><ol start="2"><li>mysqldumpslow</li></ol><p>Mysql官方提供的慢查询日志分析工具，能够统计相同代码的执行次数 执行时间等</p><pre><code class="hljs sh">mysqldumpslow -t 20 slow.log</code></pre><ul><li>-t: top n条统计</li><li>-h: 帮助文档</li></ul><ol start="3"><li>pt-query-digest</li></ol><pre><code class="hljs sh">pt-query-digest show.log</code></pre><p>Rows Send：发送行数<br>Rows examine：扫描行数</p><h2 id="发现有问题的SQL"><a href="#发现有问题的SQL" class="headerlink" title="发现有问题的SQL"></a>发现有问题的SQL</h2><ol><li>查询次数多，查询时间长的SQL（pt-query-digest前几个查询）</li><li>IO大的SQL（pt-query-digest中Rows examine）</li><li>未命中索引的SQL（pt-query-digest中Rows examine 和 Rows Send对比）</li></ol><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>发现SQL有问题之后怎么优化？</p><p>使用<code>explain</code>查看SQL的计划执行过程。</p><pre><code class="hljs sql">mysql&gt; EXPLAIN SELECT id,&#x27;name&#x27; FROM user;+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span>| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span>| id | select_type |查询的表| partitions |连接类型| 可能应用的索引   |实际用的索引|索引长度|索引的列|查询的行|filtered | Extra       |+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span>|  1 | SIMPLE      | user  | NULL       | index | NULL          | PRIMARY |4(越小越好)| NULL |    1 |   100.00 | Using index |+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span>1 row in <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-keyword">warning</span> (<span class="hljs-number">0.00</span> sec)</code></pre><p>type</p><ul><li>const: 常数 主键 唯一索引查找</li><li>eq_reg: 主键 唯一索引的范围查找</li><li>ref: </li><li>range</li><li>index: 索引扫描</li><li>ALL</li></ul><p>Extra</p><ul><li>Useing filesort:使用文件排序 =&gt; 需要优化</li><li>Useing temporary:使用临时表存储结果 =&gt; 需要优化 常出现在OrderBy上</li></ul><h2 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h2><h3 id="优化max"><a href="#优化max" class="headerlink" title="优化max()"></a>优化<code>max()</code></h3><p>payment_date不是一个index的时候</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(payment_date) <span class="hljs-keyword">from</span> payment;+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>|  1 | SIMPLE      |payment| NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10000|   100.00 | NULL  |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><span class="hljs-comment">-- 分析：type 为 ALL 差；rows为表的所有行 差；</span><span class="hljs-comment">-- 优化：为payment_date增加索引</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_paydate <span class="hljs-keyword">on</span> payment(payment_date);+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span>|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | <span class="hljs-keyword">Select</span> <span class="hljs-keyword">tables</span> optimized away |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+</span><span class="hljs-comment">-- 分析：Select tables optimized away 表明不需要查询</span></code></pre><h3 id="优化count"><a href="#优化count" class="headerlink" title="优化count()"></a>优化<code>count()</code></h3><p>count(<em>)和count(id)的区别<br>count(</em>)    包含<code>NULL</code>行<br>count(id) 不包含<code>NULL</code>行 利用<code>NULL</code>不计数的特点 可以OR来实现特定的统计 </p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(age = <span class="hljs-number">100</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;100岁的人&#x27;</span>, <span class="hljs-keyword">count</span>(age = <span class="hljs-number">99</span> <span class="hljs-keyword">OR</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;99岁的人&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;</code></pre><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询的优化一般的优化方法为使用join连接的方式, 可以提高查询效率</p><pre><code class="hljs sql"></code></pre><h3 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a>GROUP BY优化</h3><p>在使用group by操作时 如果explain出现临时表或者文件排序</p><p>改写为子查询加上join的操作</p><h3 id="limit分页优化"><a href="#limit分页优化" class="headerlink" title="limit分页优化"></a>limit分页优化</h3><p>假设一共20000行 </p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span>|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |200000|   100.00 | NULL  |+<span class="hljs-comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><span class="hljs-comment">-- 分析：使用了表扫描 且 有可能出现文件排序（Mysql8好像没有）</span><span class="hljs-comment">-- 优化：使用index的列进行Order By</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span>| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span>|  1 | SIMPLE      | user  | NULL       | index | NULL          | PRIMARY | 4       | NULL |1000010|   100.00 | NULL  |+<span class="hljs-comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><span class="hljs-comment">-- 分析：解决了整个表扫描的问题 且type为index 但依然扫描了较多行 特别是当分页数据特别大的情况下</span><span class="hljs-comment">-- 优化：使用子查询限制查询范围</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; (<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;  <span class="hljs-comment">-- 这里的子查询为覆盖索引查询，速度比select * 快</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">100000</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<span class="hljs-comment">-- 分析：依然是慢的</span><span class="hljs-comment">-- 优化：只查id 然后在根据ID拿*</span><span class="hljs-keyword">select</span> u.* <span class="hljs-keyword">from</span> u <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> tmp <span class="hljs-keyword">on</span> tmp.id=table.id;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>设置<code>log_queries_not_using_indexes=on</code>打开<code>slow_query_log=on</code></li><li>通过<code>mysqldumpslow</code>或者<code>tp-query-digest</code>统计慢查询日志</li><li>通过<code>Explain</code>分析SQL语句，避免出现<code>type=ALL</code>,<code>rows=表的全部行</code>,使用文件排序 使用临时表的。<ol><li>为max()增加索引</li><li>使用join代替子查询()</li><li>在limit分页数量大的情况下，<ol><li>order by使用索引列</li><li>方式1: 使用子查询限制遍历的行数，在代码中记录上一次的ID（也可以通过子查询查出来）</li><li>方式2: 先查出索引列，再通过索引列查询 （最快）</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-数据库结构优化</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/03-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/03-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><h2 id="选择合适的数据库类型"><a href="#选择合适的数据库类型" class="headerlink" title="选择合适的数据库类型"></a>选择<strong>合适</strong>的数据库类型</h2><ol><li>可以存储数组的最小数据类类型</li><li>尽可能使用简单的数据类型<ol><li>使用使用<code>int</code>存储时间（需要在SQL中进行时间和int转换）<ol><li>FROM_UNIXTIME(12342123123)</li><li>UNIX_TIMESTAMP(‘2018-01-01 00:00:00’)</li></ol></li><li>使用<code>bigint</code>存储IP地址<ol><li>INET_ATON(‘192.168.10.32’)</li><li>INET_NTOA(192168010032)</li></ol></li></ol></li><li>尽可能使用<code>not null</code>来限制表结构，并给出默认值</li><li>尽可能少用text，非要使用最好考虑分表 (通过ID来关联查询，如专利的全文描述)</li></ol><h2 id="范式化优化"><a href="#范式化优化" class="headerlink" title="范式化优化"></a>范式化优化</h2><p><a href="../../01-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/">数据三范式</a> 范式化主要指第三范式 要求<strong>表的非主键列必须直接依赖于主键，不能存在传递依赖</strong></p><p>问题：<br>    1. 数据冗余<br>    2. 删除异常<br>    3. 更新异常<br>    4. 插入异常<br>解决：对存在依赖传递的表进行表拆分<br>分析：从问题我们也可以看出，问题基本出现修改，因此对于一些<code>查多改少的操作</code>可以进行反范式化操作</p><h2 id="反范式化优化"><a href="#反范式化优化" class="headerlink" title="反范式化优化"></a>反范式化优化</h2><p>范式化的表结构在查询时需要关联多张表进行关联查询，在适当情况下对表进行反范式化操作，用冗余来换取用于查询时间</p><p>比如用户订单查询</p><p><img src="../images/2019-12-29-16-25-07.png"></p><p>反范式化</p><p><img src="../images/2019-12-29-16-25-40.png"></p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>解决表 <strong>列太多</strong> 或 <strong>行太多</strong> 的问题</p><h3 id="垂直拆分-专利表"><a href="#垂直拆分-专利表" class="headerlink" title="垂直拆分(专利表)"></a>垂直拆分(专利表)</h3><p>垂直拆分 == 垂直切分</p><ol><li>将不常用的字段放一个表   </li><li>将大字段单独放一个表     如 专利表中的专利全文描述</li><li>将常用的字段放在一起</li></ol><h3 id="水平拆分（附属表，法律状态表）"><a href="#水平拆分（附属表，法律状态表）" class="headerlink" title="水平拆分（附属表，法律状态表）"></a>水平拆分（附属表，法律状态表）</h3><p>水平拆封 == 水平切分</p><ol><li>通过<code>mod()</code>函数进行取余操作，决定存放的表 就想ES中的路由一样</li></ol><p>挑战：</p><ol><li>跨分区表进行数据查询</li><li>统计和后台报表操作</li></ol><p>做法：在不要求时效的情况下，后台统计任务可以依然使用汇总表进行查询操作</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04- 数据库配置优化</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/04-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/04-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库配置优化"><a href="#数据库配置优化" class="headerlink" title="数据库配置优化"></a>数据库配置优化</h1><h2 id="系统优化-次要"><a href="#系统优化-次要" class="headerlink" title="系统优化(次要)"></a>系统优化(次要)</h2><ol><li>修改网络连接数</li><li>修改打开文件限制（Mysql是基于文件的数据库）</li></ol><h2 id="数据库配置优化-1"><a href="#数据库配置优化-1" class="headerlink" title="数据库配置优化"></a>数据库配置优化</h2><p>/etc/my.cnf  /etc/mysql/my.cnf</p><pre><code class="hljs sh"><span class="hljs-comment"># innodb缓冲池的大小，如果只有innodb可以为总内存的75%</span>innodb_buffer_pool_size=128M<span class="hljs-comment"># 配置缓冲池的个数，默认1 提高有利于多线程</span>innodb_buffer_pool_instances=1</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-服务器硬件优化</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/05-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/05-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>99-数据库优化总结</title>
    <link href="/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/99-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <url>/03-Database/07-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/99-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>07-数据库优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-jene-fuseki</title>
    <link href="/06-AI/02-KnowledgeGraph/01-jene-fuseki/"/>
    <url>/06-AI/02-KnowledgeGraph/01-jene-fuseki/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuseki"><a href="#Fuseki" class="headerlink" title="Fuseki"></a>Fuseki</h1><p><a href="http://jena.apache.org/documentation/fuseki2/">Fuseki官方文档</a></p><p><a href="https://github.com/cenzhongman/docker-jena-fuseki">docker-jena-fuseki</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里使用了Docker-compose安装，就不折腾了，直接clone吧</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>访问Host:3030即可访问Fuseki的可视化界面</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol><li>创建新的数据库</li></ol><h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><h4 id="方式一：使用update"><a href="#方式一：使用update" class="headerlink" title="方式一：使用update"></a>方式一：使用update</h4><ol><li>点击查询</li><li>更改路径为<code>http://192.168.142.128:3030/test/update</code></li><li>增加数据</li></ol><pre><code class="hljs sparql">PREFIX rdf:   &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;PREFIX rdfs:   &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;PREFIX ex:   &lt;http:&#x2F;&#x2F;example.org&#x2F;&gt;PREFIX zoo:   &lt;http:&#x2F;&#x2F;example.org&#x2F;zoo&#x2F;&gt;PREFIX owl: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2002&#x2F;07&#x2F;owl#&gt;INSERT DATA &#123;ex:dog1    rdf:type         ex:animal .ex:cat1    rdf:type         ex:cat .ex:cat     rdfs:subClassOf  ex:animal .zoo:host   rdfs:range       ex:animal .ex:zoo1    zoo:host         ex:cat2 .ex:cat3    owl:sameAs       ex:cat2 .&#125;</code></pre><p><img src="../images/01-01.png"></p><h4 id="方式二：使用upload"><a href="#方式二：使用upload" class="headerlink" title="方式二：使用upload"></a>方式二：使用upload</h4><p><img src="../images/01-02.png"></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询</p><pre><code class="hljs sparql">PREFIX rdf: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&gt;PREFIX rdfs: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;01&#x2F;rdf-schema#&gt;SELECT * WHERE &#123;  ?sub ?pred ?obj .&#125;LIMIT 10</code></pre><p>页面中提供了help我们可以进行学习，暂时不写这方面了。</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-RDFS</title>
    <link href="/06-AI/02-KnowledgeGraph/02-RDFS/"/>
    <url>/06-AI/02-KnowledgeGraph/02-RDFS/</url>
    
    <content type="html"><![CDATA[<h1 id="RDFS"><a href="#RDFS" class="headerlink" title="RDFS"></a>RDFS</h1><p>RDFS是Jena支持的最弱的本体语言</p><p>RDFS的特征</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-知识本体与Jena</title>
    <link href="/06-AI/02-KnowledgeGraph/02-%E7%9F%A5%E8%AF%86%E6%9C%AC%E4%BD%93%E4%B8%8EJena/"/>
    <url>/06-AI/02-KnowledgeGraph/02-%E7%9F%A5%E8%AF%86%E6%9C%AC%E4%BD%93%E4%B8%8EJena/</url>
    
    <content type="html"><![CDATA[<h1 id="知识本体与Jena"><a href="#知识本体与Jena" class="headerlink" title="知识本体与Jena"></a>知识本体与Jena</h1><table><thead><tr><th>本体语言</th><th>链接</th></tr></thead><tbody><tr><td>RDFS</td><td><a href="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</a></td></tr><tr><td>OWL Full</td><td><a href="http://www.w3.org/2002/07/owl#">http://www.w3.org/2002/07/owl#</a></td></tr><tr><td>OWL DL</td><td><a href="http://www.w3.org/TR/owl-features/#term_OWLDL">http://www.w3.org/TR/owl-features/#term_OWLDL</a></td></tr><tr><td>OWL Lite</td><td><a href="http://www.w3.org/TR/owl-features/#term_OWLLite">http://www.w3.org/TR/owl-features/#term_OWLLite</a></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-SPARQL</title>
    <link href="/06-AI/02-KnowledgeGraph/04-SPARQL/"/>
    <url>/06-AI/02-KnowledgeGraph/04-SPARQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SPARQL"><a href="#SPARQL" class="headerlink" title="SPARQL"></a>SPARQL</h1><ul><li><a href="https://blog.csdn.net/guotong1988/article/details/79397235">参考博客</a></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>RDF<ul><li>subject: 主体</li><li>predocate: 描述</li><li>object: 主题</li></ul></li><li>TDB<ul><li>Model: RDF的载体</li></ul></li><li>Fuseki<ul><li>databases: 库</li><li>graph: 独立的图，相当于数据库的的表</li></ul></li></ol><h2 id="常用语句-–-无GRAPH篇"><a href="#常用语句-–-无GRAPH篇" class="headerlink" title="常用语句 – 无GRAPH篇"></a>常用语句 – 无GRAPH篇</h2><ol><li>查询所有内容 – <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#WritingSimpleQueries">query</a> <pre><code class="hljs sparql">SELECT ?subject ?predicate ?object WHERE &#123;?subject ?predicate ?object&#125;LIMIT 25</code></pre></li><li>增加数据 – <a href="https://www.w3.org/TR/2013/REC-sparql11-update-20130321/#insertData">update</a> <pre><code class="hljs sparql">PREFIX dc: &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;&gt;INSERT DATA&#123;&lt;http:&#x2F;&#x2F;example&#x2F;book1&gt; dc:title &quot;A new book&quot; ;                        dc:creator &quot;A.N.Other&quot; .&#125;</code></pre></li><li>删除数据 – <a href="https://www.w3.org/TR/2013/REC-sparql11-update-20130321/#deleteData">update</a> <pre><code class="hljs sparql">DELETE DATA&#123;    &lt;http:&#x2F;&#x2F;example&#x2F;book1&gt; &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;title&gt; &quot;A new book&quot;&#125;</code></pre></li><li>更改数据 – 先delete后insert <pre><code class="hljs sparql">DELETE DATA&#123;    &lt;http:&#x2F;&#x2F;example&#x2F;book1&gt; &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;title&gt; &quot;A old book&quot;&#125;;INSERT DATA&#123;    &lt;http:&#x2F;&#x2F;example&#x2F;book1&gt; &lt;http:&#x2F;&#x2F;purl.org&#x2F;dc&#x2F;elements&#x2F;1.1&#x2F;title&gt; &quot;A new book&quot;&#125;</code></pre></li></ol><h2 id="常用语句-–-GRAPH篇"><a href="#常用语句-–-GRAPH篇" class="headerlink" title="常用语句 – GRAPH篇"></a>常用语句 – GRAPH篇</h2><ol><li><p>查询所有Graph</p> <pre><code class="hljs sparql">select ?graph &#123;GRAPH ?graph &#123;&#125;&#125;</code></pre></li><li><p>查询所有内容 – <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#WritingSimpleQueries">query</a></p> <pre><code class="hljs sparql">SELECT ?subject ?predicate ?objectFROM &lt;http:&#x2F;&#x2F;test&#x2F;person&#x2F;&gt;&#123;?subject ?predicate ?object&#125;LIMIT 25</code></pre></li><li><p>增加数据 – <a href="https://www.w3.org/TR/2013/REC-sparql11-update-20130321/#insertData">update</a></p> <pre><code class="hljs sparql">INSERT DATA&#123; GRAPH &lt;http:&#x2F;&#x2F;test&#x2F;person&#x2F;&gt; &#123;     &lt;http:&#x2F;&#x2F;test&#x2F;岑忠满1&gt; &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#type&gt; &quot;http:&#x2F;&#x2F;test&#x2F;Prople&quot; &#125; &#125;</code></pre></li><li><p>删除数据 – <a href="https://www.w3.org/TR/2013/REC-sparql11-update-20130321/#deleteData">update</a></p> <pre><code class="hljs sparql">DELETE DATA&#123;    GRAPH &lt;http:&#x2F;&#x2F;test&#x2F;person&#x2F;&gt; &#123;    &lt;http:&#x2F;&#x2F;test&#x2F;岑忠满1&gt; &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#type&gt; &quot;http:&#x2F;&#x2F;test&#x2F;Prople&quot;&#125;&#125;</code></pre></li><li><p>更改数据 – 先delete后insert</p> <pre><code class="hljs sparql">DELETE DATA&#123;    GRAPH &lt;http:&#x2F;&#x2F;test&#x2F;person&#x2F;&gt; &#123;    &lt;http:&#x2F;&#x2F;test&#x2F;岑忠满1&gt; &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#type&gt; &quot;http:&#x2F;&#x2F;test&#x2F;Prople&quot;&#125;&#125;;INSERT DATA&#123; GRAPH &lt;http:&#x2F;&#x2F;test&#x2F;person&#x2F;&gt; &#123;     &lt;http:&#x2F;&#x2F;test&#x2F;岑忠满2&gt; &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#type&gt; &quot;http:&#x2F;&#x2F;test&#x2F;Prople&quot; &#125; &#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-数据结构选型</title>
    <link href="/06-AI/02-KnowledgeGraph/05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B/"/>
    <url>/06-AI/02-KnowledgeGraph/05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.drupal.org/docs/7/modules/schemaorg-metatag/json-ld-microdata-or-rdfa">JSON-LD, Microdata or RDFa?</a></p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-sawtooth简介</title>
    <link href="/06-AI/03-BolckChain/01-sawtooth%E7%AE%80%E4%BB%8B/"/>
    <url>/06-AI/03-BolckChain/01-sawtooth%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="sawtooth简介"><a href="#sawtooth简介" class="headerlink" title="sawtooth简介"></a>sawtooth简介</h1><h2 id="sawtooth的作用"><a href="#sawtooth的作用" class="headerlink" title="sawtooth的作用"></a>sawtooth的作用</h2><h2 id="sawtooth的优势"><a href="#sawtooth的优势" class="headerlink" title="sawtooth的优势"></a>sawtooth的优势</h2><ul><li>并行事务执行，为了保证区块链的稳定性，区块链的事务一般是串行执行的（线程安全）</li><li>支持事件广播系统，系统可以订阅区块链的变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>03-BolckChain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Tensorflow入门</title>
    <link href="/06-AI/05-TensorFlow/01-Tensorflow%E5%85%A5%E9%97%A8/"/>
    <url>/06-AI/05-TensorFlow/01-Tensorflow%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Tensorflow安装和使用"><a href="#Tensorflow安装和使用" class="headerlink" title="Tensorflow安装和使用"></a><a href="https://www.tensorflow.org/get_started/premade_estimators">Tensorflow安装和使用</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.tensorflow.org/install/index">官方安装教程</a>请自带梯子</p><ul><li>Windows 64</li><li>Python3.5 3.6 64位</li><li>有英伟达GPU</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># 单GPU版本</span>pip3 install --upgrade tensorflow<span class="hljs-comment"># GPU支持版本</span>pip3 install --upgrade tensorflow-gpu</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在使用之前，需要安装pandas,pandas提供了大量的库和标准数据模型</li></ul><pre><code class="hljs sh">pip install pandas</code></pre><h3 id="2-1-TF提供的API"><a href="#2-1-TF提供的API" class="headerlink" title="2.1 TF提供的API"></a>2.1 TF提供的API</h3><p><img src="../images/01-01tensorflow_programming_environment.png"></p><ul><li>Estimators预测, which represent代表 a complete model. The Estimator API provides methods to train the model, to judge the model’s accuracy准确性, and to generate生成 predictions预测.</li><li>Datasets, which build a data input pipeline管道. The Dataset API has methods to load and manipulate操控 data, and feed it into your model. The Dataset API meshes well with the Estimators API.</li></ul><h3 id="2-2-什么是Tensor"><a href="#2-2-什么是Tensor" class="headerlink" title="2.2 什么是Tensor"></a>2.2 什么是Tensor</h3><p>一维的时候，是数<br>二维的时候，是向量<br>多维的时候，矩阵</p><h3 id="2-3-TensorFlow怎么用"><a href="#2-3-TensorFlow怎么用" class="headerlink" title="2.3 TensorFlow怎么用"></a>2.3 TensorFlow怎么用</h3><p><a href="https://www.bilibili.com/video/av15474715?spm_id_from=333.338.__bofqi.35">参考视频</a></p><pre><code class="hljs py"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-comment"># 定义节点</span>node1 = tf.constant(<span class="hljs-number">1.0</span>,dtype=float32)node2 = tf.constant(<span class="hljs-number">2.0</span>,dtype=float32)node3 = tf.add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)print(node1)<span class="hljs-comment"># Tensor(&quot;Const:0&quot;, shape=(), dtype=int32)</span>print(node3)<span class="hljs-comment"># Tensor(&quot;Add:0&quot;, shape=(), dtype=int32)</span><span class="hljs-comment"># 运算节点</span>sess = tf.Session()print(sess.run([node1,node2]))<span class="hljs-comment"># [1.0,2.0]</span>print(sess.run(node3))<span class="hljs-comment"># 2</span>node4 = tf.add(node1,node2)print(sess.run(node4))<span class="hljs-comment"># 2.0</span></code></pre><p><a href="https://web.stanford.edu/class/cs20si/syllabus.html">斯坦福的TF视频</a><br><a href="https://www.bilibili.com/video/av9156347/?from=search&seid=6905181275544516403">BiliBili参考视频</a></p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>05-TensorFlow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-TensorFlow模型的读写</title>
    <link href="/06-AI/05-TensorFlow/02-TensorFlow%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <url>/06-AI/05-TensorFlow/02-TensorFlow%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow模型的读写"><a href="#TensorFlow模型的读写" class="headerlink" title="TensorFlow模型的读写"></a>TensorFlow模型的读写</h1><ul><li>加载模型</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 保存模型max_to_keep是保存次数</span>saver = tf.train.Saver(max_to_keep=<span class="hljs-number">5</span>)<span class="hljs-comment"># 若这个文件存在则加载模型</span><span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-string">&#x27;ckpt/checkpoint&#x27;</span>):    print(<span class="hljs-string">&#x27;加载模型文件&#x27;</span>)    model_file = tf.train.latest_checkpoint(<span class="hljs-string">&#x27;ckpt/&#x27;</span>)    saver.restore(session, model_file)</code></pre><ul><li>保存模型</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 保存模型</span>saver = tf.train.Saver(max_to_keep=<span class="hljs-number">5</span>)saver.save(session, <span class="hljs-string">&#x27;ckpt/mnist.ckpt&#x27;</span>, global_step=step + <span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>05-TensorFlow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-知识图谱介绍</title>
    <link href="/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%BB%8B%E7%BB%8D/"/>
    <url>/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="知识图谱介绍"><a href="#知识图谱介绍" class="headerlink" title="知识图谱介绍"></a>知识图谱介绍</h1><p>rdfs定义了rdf的格式，只能定义上下级别之间的关系，不能约束，自然也不能推理<br>owl是rdfs的丰富，和继承</p><p>owl示例：</p><pre><code>* 约束属性：父母一定要有个是人的孩子* 对称属性：小红的伴侣是小明* 传递属性：小明的爸爸的爸爸的爸爸* 属性链，对于属性是可以传递的</code></pre><p>知识抽取：<br>    CootStrap一种会学习的模式匹配，种子法</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
      <category>01-知识图谱课程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-知识表示和建模</title>
    <link href="/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/02-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%BB%BA%E6%A8%A1/"/>
    <url>/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/02-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="知识表示和建模"><a href="#知识表示和建模" class="headerlink" title="知识表示和建模"></a>知识表示和建模</h1><!-- TOC --><ul><li><a href="#%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%BB%BA%E6%A8%A1">知识表示和建模</a><ul><li><a href="#11-%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA">1.1 知识表示</a><ul><li><a href="#111-%E6%97%A9%E6%9C%9F%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA">1.1.1 早期知识表示</a></li><li><a href="#112-rdf%E5%92%8Crdfs">1.1.2 RDF和RDFS</a><ul><li><a href="#1121-rdf">1.1.2.1 RDF</a></li><li><a href="#1122-annotated-rdf">1.1.2.2 Annotated RDF</a></li><li><a href="#1123-rdfs">1.1.2.3 RDFS</a></li></ul></li><li><a href="#113-owl">1.1.3 OWL</a><ul><li><a href="#%E7%B1%BB%E7%AD%89%E4%BB%B7%E6%80%A7%E5%B1%9E%E6%80%A7%E7%AD%89%E4%BB%B7%E5%AE%9E%E4%BD%93%E7%AD%89%E4%BB%B7%E5%A3%B0%E6%98%8E">类等价性、属性等价、实体等价声明</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB">属性传递关系</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E4%BA%92%E5%8F%8D%E5%85%B3%E7%B3%BB">属性互反关系</a></li><li><a href="#%E5%87%BD%E6%95%B0%E6%80%A7%E5%B1%9E%E6%80%A7%E5%94%AF%E4%B8%80%E6%80%A7%E5%B1%9E%E6%80%A7">函数性属性（唯一性属性）</a></li><li><a href="#%E8%BF%98%E6%9C%89%E5%88%AB%E7%9A%84%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%98%E7%BD%91%E7%9C%8B%E5%90%A7">还有别的自己去官网看吧</a></li></ul></li><li><a href="#114-owl2">1.1.4 OWL2</a></li><li><a href="#sparql">SPARQL</a><ul><li><a href="#sparql%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">SparQL可以进行嵌套查询</a></li><li><a href="#sparql%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9F%A5%E8%AF%A2">SparQL可以进行跨数据库的查询</a></li></ul></li><li><a href="#114-%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E5%81%87%E8%AE%BE">1.1.4 开放世界假设</a></li><li><a href="#115-%E5%9B%BE%E8%A1%A8%E7%A4%BA">1.1.5 图表示</a></li></ul></li><li><a href="#%E7%9F%A5%E8%AF%86%E5%BB%BA%E6%A8%A1">知识建模</a></li></ul></li></ul><!-- /TOC --><h2 id="1-1-知识表示"><a href="#1-1-知识表示" class="headerlink" title="1.1 知识表示"></a>1.1 知识表示</h2><h3 id="1-1-1-早期知识表示"><a href="#1-1-1-早期知识表示" class="headerlink" title="1.1.1 早期知识表示"></a>1.1.1 早期知识表示</h3><p>早期知识表示在此不进行赘述，都是一些RDF的前生的之类的东西，可以参考PDF课件</p><h3 id="1-1-2-RDF和RDFS"><a href="#1-1-2-RDF和RDFS" class="headerlink" title="1.1.2 RDF和RDFS"></a>1.1.2 RDF和RDFS</h3><ul><li>W3C推荐的语义网络标准栈</li></ul><p><img src="../images/02-01.png" alt="W3C推荐的语义网络标准栈"></p><ul><li>绿色：表示</li><li>黄色：查询</li><li>蓝色：推理</li><li>红色：授信</li></ul><h4 id="1-1-2-1-RDF"><a href="#1-1-2-1-RDF" class="headerlink" title="1.1.2.1 RDF"></a>1.1.2.1 RDF</h4><p>现行的知识图谱都使用RDF作为存储，RDF是一种资源描述框架（<strong>Resource Description Framework</strong>），<strong>它是一种数据模型不是数据格式</strong>，支持的保存格式有<code>Turtle</code>、<code>JSON-LD</code>、<code>RDF/XML</code>、<code>RDFa</code>等</p><p><a href="http://docs.rdf4j.org/rdf-tutorial/">RDF4j对RDF的讲解</a></p><ol><li>使用RDF存储一元数据</li></ol><p><img src="http://docs.rdf4j.org/images//rdf-graph-1.png"></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">http:</span>//<span class="hljs-attr">example.org</span>/<span class="hljs-attr">Picasso</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">foaf:FirstName</span>&gt;</span> &quot;Pablo&quot;</code></pre><ol start="2"><li>使用RDF存储多元数据</li></ol><p><img src="http://docs.rdf4j.org/images//rdf-graph-4.png"></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">http:</span>//<span class="hljs-attr">example.org</span>/<span class="hljs-attr">Picasso</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">rdf:type</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">art:Artist</span>&gt;</span> ;    <span class="hljs-tag">&lt;<span class="hljs-name">foaf:FirstName</span>&gt;</span> &quot;Pablo&quot; ;    <span class="hljs-tag">&lt;<span class="hljs-name">_:node1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ex:street</span> &quot;<span class="hljs-attr">31</span> <span class="hljs-attr">Art</span> <span class="hljs-attr">Gallery</span>&quot;&gt;</span> ;          <span class="hljs-tag">&lt;<span class="hljs-name">ex:city</span> &quot;<span class="hljs-attr">Madrid</span>&quot;&gt;</span> ;          <span class="hljs-tag">&lt;<span class="hljs-name">ex:country</span> &quot;<span class="hljs-attr">Spain</span>&quot;&gt;</span> .</code></pre><p>这样的结构可以用于一对多的知识存储：如家庭成员，等一对多关系，<code>_:node1</code>中，空白节点的URI使用<code>_</code>表示，<code>node1</code>是自动生成的节点名</p><h4 id="1-1-2-2-Annotated-RDF"><a href="#1-1-2-2-Annotated-RDF" class="headerlink" title="1.1.2.2 Annotated RDF"></a>1.1.2.2 Annotated RDF</h4><p>基于RDF能够存储知识，但是，对于有时间变化的知识是无法存储的</p><pre><code class="hljs xml">国家:美国 职位:总统 人物:奥巴马国家:美国 职位:总统 人物:川普</code></pre><p>在不同的时间，这个知识是不一样的</p><p><a href="https://www.mpi-inf.mpg.de/departments/databases-and-information-systems/research/yago-naga/yago/">YAGO2</a>提出了基于标注的知识库，语法形式<code>(s,p,o):λ</code></p><pre><code class="hljs xml">(国家:美国 职位:总统 人物:奥巴马):2014年(国家:美国 职位:总统 人物:川普):2017年</code></pre><p>然而，据观察Yago使用的语法形式更像是</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 存储事实 --&gt;</span>#@ <span class="hljs-tag">&lt;<span class="hljs-name">id_Wq5jXTd2go_mTj_FAKRDnCYUq</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">infobox</span>/<span class="hljs-attr">nl</span>/<span class="hljs-attr">londeg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>/<span class="hljs-attr">appearsIn</span>&gt;</span>&quot;waterschap nederland&quot;@nl .<span class="hljs-comment">&lt;!-- 存储朔源信息 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id_Wq5jXTd2go_mTj_FAKRDnCYUq</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">extractionSource</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">http:</span>//<span class="hljs-attr">ro.wikipedia.org</span>/<span class="hljs-attr">wiki</span>/<span class="hljs-attr">Adobe_Photoshop</span>&gt;</span> .<span class="hljs-tag">&lt;<span class="hljs-name">id_Wq5jXTd2go_mTj_FAKRDnCYUq</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">extractionTechnique</span>&gt;</span>&quot;InfoboxExtractor&quot; .</code></pre><p>使用的JAVA方法如下</p><pre><code class="hljs java">String id = <span class="hljs-string">&quot;id&quot;</span> +             <span class="hljs-string">&quot;_&quot;</span> + Sha256Util.getSha256(rdf.getSubject(), <span class="hljs-number">10</span>) +             <span class="hljs-string">&quot;_&quot;</span> + Sha256Util.getSha256(rdf.getPredicate(), <span class="hljs-number">3</span>) +             <span class="hljs-string">&quot;_&quot;</span> + Sha256Util.getSha256(rdf.getObject(), <span class="hljs-number">10</span>);</code></pre><h4 id="1-1-2-3-RDFS"><a href="#1-1-2-3-RDFS" class="headerlink" title="1.1.2.3 RDFS"></a>1.1.2.3 RDFS</h4><p><a href="https://www.w3.org/2000/01/rdf-schema">RDFS的全部内容</a></p><p>RDFS是用来定义资源框架的Schema，RDFS 即 <strong>RDFSchema</strong> ，是OWL的简单版本</p><p><img src="../images/02-02.png"></p><ul><li>Class:实体定义</li><li>SubClassOf</li><li>rdf:type</li><li>Property:属性定义，杯子的<strong>颜色</strong>是红色</li><li>SubPropertyOf</li><li>Domain:主语，投资的Domain是人</li><li>Range:对象，投资的Range是公司</li></ul><p>借助RDFS可以进行简单的知识推理</p><p><img src="../images/02-03.png"></p><p>如何写一个RDFS，参考<a href="http://www.w3school.com.cn/rdf/rdf_schema.asp">W3CSchool</a></p><p>马和动物的简单定义如下</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rdf:RDF</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:rdf</span>= <span class="hljs-string">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:rdfs</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/01/rdf-schema#&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xml:base</span>=  <span class="hljs-string">&quot;http://www.animals.fake/animals#&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rdfs:Class</span> <span class="hljs-attr">rdf:ID</span>=<span class="hljs-string">&quot;animal&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rdfs:Class</span> <span class="hljs-attr">rdf:ID</span>=<span class="hljs-string">&quot;horse&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:subClassOf</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;#animal&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:Class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rdf:RDF</span>&gt;</span></code></pre><h3 id="1-1-3-OWL"><a href="#1-1-3-OWL" class="headerlink" title="1.1.3 OWL"></a>1.1.3 OWL</h3><p><img src="https://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/" alt="官方快速入门"></p><p>OWL Ontology Web Language的缩写</p><p>有三个版本的语言</p><ol><li>OWL Lite</li><li>OWL DL</li><li>OWL Full</li></ol><p>选用哪一种语言需要继续对比和学习，我们先讲一下基础的OWL词汇<a href="https://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">owl的2.5</a></p><h4 id="类等价性、属性等价、实体等价声明"><a href="#类等价性、属性等价、实体等价声明" class="headerlink" title="类等价性、属性等价、实体等价声明"></a>类等价性、属性等价、实体等价声明</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 等价类 --&gt;</span>ex:运动员 owl:equivalentClass ex:体育选手<span class="hljs-comment">&lt;!-- 等价属性 --&gt;</span>ex:获得 owl:equivalentProperty ex:取得<span class="hljs-comment">&lt;!-- 等价实体 --&gt;</span>ex:运动员 owl:SameAs ex:姚明</code></pre><h4 id="属性传递关系"><a href="#属性传递关系" class="headerlink" title="属性传递关系"></a>属性传递关系</h4><pre><code class="hljs xml">ex:ancestor rdf:type owl:TransitiveProperty.</code></pre><p>祖先是可以传递的,但是:爸爸是不可以传递的</p><h4 id="属性互反关系"><a href="#属性互反关系" class="headerlink" title="属性互反关系"></a>属性互反关系</h4><pre><code class="hljs xml">ex:hasFather rdf:type owl:hasChild</code></pre><p>小明 ex:hasFather 大明 &gt;&gt; 大明 ex:hasChild 小明</p><h4 id="函数性属性（唯一性属性）"><a href="#函数性属性（唯一性属性）" class="headerlink" title="函数性属性（唯一性属性）"></a>函数性属性（唯一性属性）</h4><pre><code class="hljs xml">ex:hasMother rdf：type owl：FunctionalProperty</code></pre><p>唯一性属性，人只有一个妈妈，只有一个省份证</p><h4 id="还有别的自己去官网看吧"><a href="#还有别的自己去官网看吧" class="headerlink" title="还有别的自己去官网看吧"></a>还有别的自己去官网看吧</h4><h3 id="1-1-4-OWL2"><a href="#1-1-4-OWL2" class="headerlink" title="1.1.4 OWL2"></a>1.1.4 OWL2</h3><p>owl2也有几种语言</p><ol><li><p>OWL2-QL 基于DL-lite定义的查询语言 支持子类查询等 非常快 适合大规模处理</p><ul><li>rdfs:subClassOf</li><li>rdfs:subPropertyOf</li><li>rdfs:domain</li><li>rdfs:range</li><li>owl:inverseOf</li><li>owl:disjointWith 交集</li></ul></li><li><p>OWL2-EL 基于EL++描述逻辑语言 用于推理 一般快 适合复杂概念层的描述</p><ul><li>rdfs:subClassOf</li><li>rdfs:subPropertyOf</li><li>owl:someValuesOf</li><li>owl:intersectionOf</li><li>owl:TransitiveProperty</li></ul></li><li><p>OWL2-RL</p></li></ol><h3 id="SPARQL"><a href="#SPARQL" class="headerlink" title="SPARQL"></a>SPARQL</h3><pre><code class="hljs sparql">SELETE ?person ?sexWHERE &#123;    ?s ex:age &quot;18&quot; .    OPCTIONAL&#123;        ?s ex:sex ?sex .        FILTER(?sex&#x3D;&quot;man&quot;)    &#125;&#125;</code></pre><p>用户可能没有性别这个字段，但是只返回男人</p><p>SPARQL还支持UNION操作</p><h4 id="SparQL可以进行嵌套查询"><a href="#SparQL可以进行嵌套查询" class="headerlink" title="SparQL可以进行嵌套查询"></a>SparQL可以进行嵌套查询</h4><p><img src="../images/02-04.png"></p><h4 id="SparQL可以进行跨数据库的查询"><a href="#SparQL可以进行跨数据库的查询" class="headerlink" title="SparQL可以进行跨数据库的查询"></a>SparQL可以进行跨数据库的查询</h4><p>详情参考课程课件</p><h3 id="1-1-4-开放世界假设"><a href="#1-1-4-开放世界假设" class="headerlink" title="1.1.4 开放世界假设"></a>1.1.4 开放世界假设</h3><ul><li>开放世界假设：我 有 钱 = 我只知道你有钱，说不定你还有别的东西</li><li>封闭世界假设：我 有 钱 = 我知道你只有钱，肯定没有别的东西了</li></ul><h3 id="1-1-5-图表示"><a href="#1-1-5-图表示" class="headerlink" title="1.1.5 图表示"></a>1.1.5 图表示</h3><ul><li>one hop 单跳，由A到B只需要一次连接</li><li>two hop 二跳</li></ul><p>几跳是由连接的跳数有关，与箭头方向无关<br>两个实体之间会有不止一种跳的数量</p><h2 id="知识建模"><a href="#知识建模" class="headerlink" title="知识建模"></a>知识建模</h2>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
      <category>01-知识图谱课程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-知识抽取与挖掘</title>
    <link href="/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/03-%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%8C%96%E6%8E%98/"/>
    <url>/06-AI/02-KnowledgeGraph/01-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%AF%BE%E7%A8%8B/03-%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%8C%96%E6%8E%98/</url>
    
    <content type="html"><![CDATA[<h1 id="知识抽取与挖掘"><a href="#知识抽取与挖掘" class="headerlink" title="知识抽取与挖掘"></a>知识抽取与挖掘</h1><h2 id="1-1-非结构化数据"><a href="#1-1-非结构化数据" class="headerlink" title="1.1 非结构化数据"></a>1.1 非结构化数据</h2><h3 id="1-1-1-实体识别与实体链接"><a href="#1-1-1-实体识别与实体链接" class="headerlink" title="1.1.1 实体识别与实体链接"></a>1.1.1 实体识别与实体链接</h3><h4 id="实体识别和链接的流程"><a href="#实体识别和链接的流程" class="headerlink" title="实体识别和链接的流程"></a>实体识别和链接的流程</h4><p><img src="../images/03-01.png"></p><h4 id="实体识别方法"><a href="#实体识别方法" class="headerlink" title="实体识别方法"></a>实体识别方法</h4><ol><li>序列标注<ol><li>基于前后词语的序列特征（李XX/王XX/XX省/XX洲）</li><li>基于词本省的特征（词性/依存关系/边界特征–是否在开头结尾）</li><li>基于字本身的特征（数字/符号）</li></ol></li><li>HMM隐马尔可夫模型<ol><li>有向图模型</li><li>生成式模型 – 直接生成预测</li><li>假定特征独立</li></ol></li><li>CRT条件随机场<ol><li>无向图模型</li><li>判别式模型 – 判断是否是 – 适合小数据</li><li>没有假定特征独立</li></ol></li><li>LSTM + CRF – 最流行 – 最准确<ol><li>Word embeddings &gt; Bi-LSTM &gt; CRF (也就是说CRT的输入是LSTM的输出)</li></ol></li></ol><h4 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h4><ul><li><a href="http://wikipedia-miner.cms.waikato.ac.nz/">wikipedia-miner</a> – 已经不见了</li><li><a href="https://www.dbpedia-spotlight.org/">dbpedia-spotlight</a> – 不知道是否支持中文</li><li><a href="www.opencalais.com/">opencalais/</a> – 非开源 - 被Thomson Reuters收购 – PremID创建者</li></ul><h4 id="实体链接消歧"><a href="#实体链接消歧" class="headerlink" title="实体链接消歧"></a>实体链接消歧</h4><p>实体链接过程中出现的消歧可以通过</p><ol><li>用户反馈消歧</li><li>属性消歧（如同义词、简称）</li><li>基于机器学习的方法消歧</li><li>上下文消歧</li></ol><h3 id="1-1-2-关系挖掘"><a href="#1-1-2-关系挖掘" class="headerlink" title="1.1.2 关系挖掘"></a>1.1.2 关系挖掘</h3><h4 id="关系挖掘流程"><a href="#关系挖掘流程" class="headerlink" title="关系挖掘流程"></a>关系挖掘流程</h4><p>文本 &gt; 实体识别 &gt; 关系挖掘 &gt; 实体消歧 &gt; 关系清理/融合/人工审核</p><h3 id="1-2-1-关系抽取的方法"><a href="#1-2-1-关系抽取的方法" class="headerlink" title="1.2.1 关系抽取的方法"></a>1.2.1 关系抽取的方法</h3><ol><li>基于模板的方法<ol><li>触发词</li><li>关系依存的方法</li></ol></li><li>监督学习的方法<ol><li>机器学习的方法</li><li>深度学习的方法</li></ol></li><li>弱监督学习方法<ol><li>远程监督</li><li>Bootstrapping</li></ol></li></ol><h4 id="1-2-1-1-基于模板的方法"><a href="#1-2-1-1-基于模板的方法" class="headerlink" title="1.2.1.1 基于模板的方法"></a>1.2.1.1 基于模板的方法</h4><p>模板方法的流程</p><p><img src="../images/03-03.png"></p><ol><li>基于触发词的方法 – ConceptMapper的方法 – 适用于专业领域<ul><li>模板是关键词</li></ul></li><li>基于依存句法分析的方法 – 以谓语为中心构建规则的依存关系 – 适用于开放关系挖掘<ul><li>模板是依存关系 – 如：主谓宾</li><li>需要三元组评价</li></ul></li></ol><ul><li>优点：<ul><li>简单</li></ul></li><li>缺点：<ul><li>需要专业构建</li><li>难维护，移植性差</li><li>成效一般</li></ul></li></ul><h4 id="1-2-1-2-监督学习的方法"><a href="#1-2-1-2-监督学习的方法" class="headerlink" title="1.2.1.2 监督学习的方法"></a>1.2.1.2 监督学习的方法</h4><p>机器学习的流程</p><p><img src="../images/03-04.png"></p><p>监督学习的特征分类</p><p><img src="../images/03-05.png"></p><p>深度学习模型</p><p><img src="../images/03-06.png"></p><ul><li>优点：<ul><li>准确率高</li><li>模型容易拓展</li></ul></li><li>缺点：<ul><li>大量人工标注</li></ul></li></ul><h4 id="1-2-1-3-半监督学习"><a href="#1-2-1-3-半监督学习" class="headerlink" title="1.2.1.3 半监督学习"></a>1.2.1.3 半监督学习</h4><ol><li>远程监督<ol><li>一句话建立一种特征表述</li><li>找出同样特征表示的话</li><li>这些话作为机器学习的训练数据</li></ol></li><li>Bootstrapping – 学习找的不是句子，是模板<ol><li>根据互联网中的冗余，进行统计计算，模板聚类，从而找到最科学的模板 – 上海天气不错 – 广州天气不错 &gt; XX天气XX</li><li>将这些模板用于基于模板方法的匹配 – 茂名天气不好</li><li>这些匹配结果能够继续发现新的模板</li></ol></li></ol><p>远程监督</p><ul><li>优点：<ul><li>不需要大量人工标注</li></ul></li><li>缺点：<ul><li>引入噪声</li><li>无法学习新的关系</li></ul></li></ul><p>Bootstrapping</p><ul><li>优点：<ul><li>成本低，适合大规模</li><li>可以发现新关系</li></ul></li><li>缺点:<ul><li>对初始种子敏感（小米是一家公司）&gt; (水稻是一家公司)</li><li>存在语义漂移问题（小米是一家公司）&gt; (水稻是一家公司)</li><li>准确率低</li></ul></li></ul><h3 id="1-1-4-事件抽取"><a href="#1-1-4-事件抽取" class="headerlink" title="1.1.4 事件抽取"></a>1.1.4 事件抽取</h3><ol><li>事件分类，并制作事件模板</li><li>从触发词/词向量判断事件的类型</li><li>将文本中的实体进行实体识别</li><li>将实体填入已有的模板中进行关联</li></ol><p><img src="../images/03-08.png"></p><p>事件检测与跟踪</p><p>事件支持事件的嵌套</p><p><img src="../images/03-07.png"></p><h2 id="1-2-关系型数据"><a href="#1-2-关系型数据" class="headerlink" title="1.2 关系型数据"></a>1.2 关系型数据</h2><p>R2RML</p><ul><li>ontop</li><li>D2R</li></ul><h2 id="1-3-半结构化数据"><a href="#1-3-半结构化数据" class="headerlink" title="1.3 半结构化数据"></a>1.3 半结构化数据</h2><p><img src="../images/03-09.png"></p><p>通过机器学习的方法找到包装器（css选择器/Xpath）从而实现自动化抽取</p><p>包装器的生成流程</p><p><img src="../images/03-10.png"></p><ul><li>工具推荐</li></ul><p>RoadRunner</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>02-KnowledgeGraph</category>
      
      <category>01-知识图谱课程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-数据库三范式</title>
    <link href="/03-Database/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
    <url>/03-Database/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h1><h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><ol><li>列的原子性，即列不能再分</li></ol><p>如：【通讯录】表</p><p>错误：名字，年龄，电话<br>正确：名字，年龄，个人电话，家庭电话</p><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><ol><li>列必须有主键</li><li>没有包含在主键中的列必须完全依赖于主键</li></ol><p>如：【OrderDetail】表（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）</p><p>错误：主键应为复合主键(OrderID，ProductID)，因为一个订单ID可以包含多个产品。Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。<br>正确：在更常用的场景下，我们会避免使用复合主键，而使用中间表的设计，这样就能完全符合第二范式</p><h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><ol><li>非主键列必须直接依赖于主键，不能存在传递依赖</li></ol><p>如：【Order】表</p><p>错误：OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 中 CustomerName，CustomerAddr 依赖于非主键列 CustomerID<br>正确：拆分为【Order】（OrderID，OrderDate，CustomerID）和 【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-数据库备份和恢复</title>
    <link href="/03-Database/02-Postgresql/02-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <url>/03-Database/02-Postgresql/02-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库备份和恢复"><a href="#数据库备份和恢复" class="headerlink" title="数据库备份和恢复"></a>数据库备份和恢复</h1><p><a href="http://www.postgres.cn/docs/9.6/backup.html">官方文档</a></p><p>PostgreSQL 支持三种数据备份方式</p><ol><li>SQL转储</li><li>文件系统级别备份</li><li>连续归档和时间点恢复（PITR）</li></ol><h2 id="SQL转存"><a href="#SQL转存" class="headerlink" title="SQL转存"></a>SQL转存</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><pre><code class="hljs sh">pg_dump [-h <span class="hljs-variable">$Hostname</span>] [-p 5432] -U <span class="hljs-variable">$UserName</span> -d <span class="hljs-variable">$Database</span> &gt; <span class="hljs-variable">$Backupfile</span></code></pre><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><pre><code class="hljs sh">psql -h <span class="hljs-variable">$Hostname</span> -p 5432 -U <span class="hljs-variable">$UserName</span> -d <span class="hljs-variable">$Database</span> -f <span class="hljs-variable">$Backupfile</span></code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>pg_dump的输出可以很容易地在新版本的PostgreSQL中载入</li><li>pg_dump工作的时候并不阻塞其他的对数据库的操作。 （但是会阻塞那些需要排它锁的操作，比如大部分形式的ALTER TABLE）</li></ul><p>pg_dump -h localhost -p 5432 -U bmw -d bmw -f /</p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>02-Postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-角色和用户权限管理</title>
    <link href="/03-Database/02-Postgresql/03-%E8%A7%92%E8%89%B2%E5%92%8C%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/03-Database/02-Postgresql/03-%E8%A7%92%E8%89%B2%E5%92%8C%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="角色和用户管理"><a href="#角色和用户管理" class="headerlink" title="角色和用户管理"></a>角色和用户管理</h1><p><a href="http://www.postgres.cn/docs/9.6/role-attributes.html">官方-用户管理</a><br><a href="https://www.postgresql.org/docs/current/sql-grant.html">官方-权限管理</a><br>[博客-权限]](<a href="http://blog.itpub.net/27039319/viewspace-2079613/">http://blog.itpub.net/27039319/viewspace-2079613/</a>)</p><pre><code class="hljs sql"><span class="hljs-comment">-- 创建角色 需在管理员下操作</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">role</span> bmw_admin CREATEDB CREATEROLE <span class="hljs-keyword">REPLICATION</span> LOGIN <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;BMWAdminData*2018*&#x27;</span>;<span class="hljs-keyword">create</span> <span class="hljs-keyword">role</span> bmw_operator LOGIN <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;BMWOperatorData*2018*&#x27;</span>;<span class="hljs-keyword">create</span> <span class="hljs-keyword">role</span> bmw_browser LOGIN <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;BMWBrowserData*2018*&#x27;</span>;<span class="hljs-comment">-- 查看角色</span>\du<span class="hljs-comment">-- 查看角色表</span>psql postgrest $USER_NAME<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> pg_roles;</code></pre><pre><code class="hljs sql"><span class="hljs-comment">-- 设置权限 需在设置权限的表中 由管理员操作</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">schema</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">to</span> bmw_browser;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span>, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">schema</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">to</span> bmw_operator;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">schema</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">to</span> bmw_admin;<span class="hljs-comment">-- 查看权限 详情看官方文档</span>\dp $TABLE_NAME</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>02-Postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-触发器</title>
    <link href="/03-Database/02-Postgresql/09-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/03-Database/02-Postgresql/09-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="更新自己的update-time"><a href="#更新自己的update-time" class="headerlink" title="更新自己的update_time"></a>更新自己的update_time</h2><ul><li>本小节基于postgresql无法使用<code>on update CURRENT_TIMESTAMP</code>语句导致<code>update_time</code>不能自动更新的问题使用触发器解决</li></ul><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><ul><li><code>updated_time</code>类型需为<strong>timestamp</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (    <span class="hljs-keyword">id</span> <span class="hljs-built_in">serial</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),    email <span class="hljs-built_in">varchar</span>(<span class="hljs-number">200</span>),    updated_time <span class="hljs-built_in">timestamp</span>)</code></pre><h3 id="创建触发器函数"><a href="#创建触发器函数" class="headerlink" title="创建触发器函数"></a>创建触发器函数</h3><pre><code class="hljs sql"><span class="hljs-comment">-- NEW指的是insert/update的行</span><span class="hljs-comment">-- OLD指的是delete的行</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">FUNCTION</span> <span class="hljs-string">&quot;public&quot;</span>.<span class="hljs-string">&quot;update_update_time&quot;</span>() <span class="hljs-keyword">RETURNS</span> <span class="hljs-string">&quot;pg_catalog&quot;</span>.<span class="hljs-string">&quot;trigger&quot;</span> <span class="hljs-keyword">AS</span> $<span class="hljs-keyword">BODY</span>$ <span class="hljs-keyword">BEGIN</span>     NEW.update_time := <span class="hljs-keyword">CURRENT_TIMESTAMP</span>;     RETURN NEW; <span class="hljs-keyword">END</span>; $BODY$ LANGUAGE plpgsql VOLATILE COST 100;</code></pre><h3 id="在表中增加触发器-每张表一次"><a href="#在表中增加触发器-每张表一次" class="headerlink" title="在表中增加触发器(每张表一次)"></a>在表中增加触发器(每张表一次)</h3><pre><code class="hljs sql"><span class="hljs-comment">-- UPDATE、INSERT必须使用**BEFORE**，提前设置更新行（NEW）中的时间为当前时间，然后执行UPDATE OR INSERT</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> trigger_update_user <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-string">&quot;updated_time&quot;</span> <span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-string">&quot;user&quot;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">&quot;public&quot;</span>.<span class="hljs-string">&quot;update_update_time&quot;</span>();<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> trigger_update_user <span class="hljs-keyword">ON</span> company;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-string">&quot;updated_time&quot;</span> <span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-string">&quot;company&quot;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> <span class="hljs-string">&quot;public&quot;</span>.<span class="hljs-string">&quot;update_update_time&quot;</span>();</code></pre><h2 id="更新其他表的update-time"><a href="#更新其他表的update-time" class="headerlink" title="更新其他表的update_time"></a>更新其他表的update_time</h2><ul><li>本小节，由从表一更新表二的更新时间</li></ul><h3 id="创建触发器函数-1"><a href="#创建触发器函数-1" class="headerlink" title="创建触发器函数"></a>创建触发器函数</h3><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">FUNCTION</span> update_company_update_time() <span class="hljs-keyword">RETURNS</span> <span class="hljs-string">&quot;pg_catalog&quot;</span>.<span class="hljs-string">&quot;trigger&quot;</span> <span class="hljs-keyword">AS</span> $<span class="hljs-keyword">BODY</span>$ <span class="hljs-keyword">BEGIN</span>     <span class="hljs-comment">-- 通过判断，delete只有OLD，insert/update需要更新到NEW</span>    <span class="hljs-keyword">IF</span> TG_OP = <span class="hljs-string">&#x27;DELETE&#x27;</span> <span class="hljs-keyword">THEN</span>         <span class="hljs-keyword">update</span> company <span class="hljs-keyword">set</span> edit_time = <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = OLD.company_id;     ELSE         <span class="hljs-keyword">update</span> company <span class="hljs-keyword">set</span> edit_time = <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = NEW.company_id;     <span class="hljs-keyword">END</span> <span class="hljs-keyword">IF</span>;     RETURN NEW; <span class="hljs-keyword">END</span>; $BODY$ LANGUAGE plpgsql VOLATILE COST 100;</code></pre><h3 id="在表中增加触发器"><a href="#在表中增加触发器" class="headerlink" title="在表中增加触发器"></a>在表中增加触发器</h3><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> trigger_update_company_product <span class="hljs-keyword">ON</span> product;<span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> trigger_update_company_product <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">on</span> product <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">execute</span> <span class="hljs-keyword">procedure</span> update_company_update_time();</code></pre><p>参考：<a href="https://www.cnblogs.com/lonecloud/p/10031454.html">https://www.cnblogs.com/lonecloud/p/10031454.html</a></p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>02-Postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-jedis</title>
    <link href="/03-Database/03-Redis/02-jedis/"/>
    <url>/03-Database/03-Redis/02-jedis/</url>
    
    <content type="html"><![CDATA[<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>jedis是Redis的Java-client<strong>之一</strong></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);String value = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);jedis.close();</code></pre><h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><pre><code class="hljs java">JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<span class="hljs-comment">// 设置最大连接数</span>config.setMaxTotal(<span class="hljs-number">30</span>);<span class="hljs-comment">// 设置最大空闲连接数</span>config.setMaxIdle(<span class="hljs-number">10</span>);<span class="hljs-comment">// 设置最长等待时间</span>config.setMaxWaitMillis(<span class="hljs-number">5000</span>);<span class="hljs-comment">// 创建连接池</span>JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(config,<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<span class="hljs-keyword">try</span> (Jedis jedis = jedisPool.getResource();)&#123;    <span class="hljs-comment">// 获得对象</span>    jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);    String value = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);    System.out.println(value);&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;    log.error(e.getMessage());&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>03-Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Redis数据结构</title>
    <link href="/03-Database/03-Redis/03-Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/03-Database/03-Redis/03-Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><ul><li>字符串 </li><li>散列 存Map，如Session</li><li>列表 存List</li><li>集合 存Set</li><li>有序集合 存TOP10的场景</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>安全：使用二进制作为存储，不进行编码解码，保证了数据的安全</li><li>长度：key不能操作1024字节，value最大512M</li></ul><pre><code class="hljs java"><span class="hljs-comment">// set</span>jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">// get</span>jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">// delete</span>jedis.del(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">// 自增，当自增字段不存在时，设置为0，然后加1</span>jedis.incr(<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">// 自减，当自增字段不存在时，设置为0，然后减1</span>jedis.decr(<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">// 加指定值</span>jedis.incrBy(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">// 减指定值</span>jedis.decrBy(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">// 字符串拼接,返回值为字符串长度</span>jedis.append(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;append_value&quot;</span>);<span class="hljs-comment">// 可以对自增字段进行append操作，且可以append非数字类型的值，只是加了非数字类型就不能再执行自增或自减操作</span>jedis.append(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>);</code></pre><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><ul><li>长度：一个Hash可以存储4294967295个键值对</li></ul><pre><code class="hljs java"></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>03-Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Redis常见问题</title>
    <link href="/03-Database/03-Redis/04-Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/03-Database/03-Redis/04-Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis常见问题"><a href="#Redis常见问题" class="headerlink" title="Redis常见问题"></a>Redis常见问题</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>问题：原有缓存同一时间失效，造成大量的缓存更新，导致CPU，内存压力过大连锁反应</li><li>解决：<ol><li>使用加锁或者队列的方式保证不会有大量线程同时访问数据库</li><li>避免缓存同时到期</li></ol></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>问题：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</li><li>解决：<ol><li>布隆过滤器</li><li>在缓存中存空值，并设置较短的过期时间</li></ol></li></ul><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><ul><li>问题：系统上线后，缓存为空，导致用户访问慢</li><li>解决：<ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存。</li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Butterfly_resting/article/details/89668661">几率大的Redis面试题（含答案）</a></p>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>03-Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Redis为什么快</title>
    <link href="/03-Database/03-Redis/05-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
    <url>/03-Database/03-Redis/05-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h1><ul><li>纯内存操作</li><li>单线程，避免了频繁的上下文切换</li><li>非阻塞I/O的多路复用，使用单独的线程COPY数据进行磁盘的写入</li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>03-Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-什么是连接池</title>
    <link href="/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/00-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/00-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h2><p>JDBC在操作数据库时，需要不断创建Connection对象，并在语句执行结束之后释放连接对象。创建一个连接对象需要校验用户名和密码等操作，耗费巨大的资源。</p><p>而数据库连接池 会创建一定个数的连接对象在连接池中，每个查询命令从连接池中获取连接对象，执行SQL语句之后，不进行关闭，而是将连接对象释放回连接池中。连接池技术减少了连接对象的创建资源消耗，提高了系统的并发。</p><h2 id="什么是Druid"><a href="#什么是Druid" class="headerlink" title="什么是Druid"></a>什么是Druid</h2><p>现在常用的数据源</p><ul><li>Druid<ul><li>厂家：阿里巴巴</li><li>优点：性能超群，功能完备、附送数据库监控、日志、密码加密等</li><li>缺点：</li></ul></li><li>C3P0<br>·   * 厂家：Hibernate推荐的连接池<ul><li>优点：</li><li>缺点：07年之后就不再更新，性能太太差</li></ul></li><li>DBCP<ul><li>厂家：apache-comment旗下产品，Spring推荐的连接池</li><li>优点：性能还不错</li><li>缺点：</li></ul></li><li>PROXOOL</li></ul><p>而阿里巴巴的Druid作为后起之秀，拥有最好的性能。</p><p>连接池使用<code>java.sql.DataSource</code>接口来表示，<em>注意DataSource也是一个规范定义</em>，具体有各大服务器厂商来实现，如Tomcat等</p><h2 id="不同的连接池之间的使用区别"><a href="#不同的连接池之间的使用区别" class="headerlink" title="不同的连接池之间的使用区别"></a>不同的连接池之间的使用区别</h2><ol><li>创建DataSource的方式不同</li><li>配置属性不完全相同</li></ol><h2 id="Druid中的配置-供参考"><a href="#Druid中的配置-供参考" class="headerlink" title="Druid中的配置(供参考)"></a>Druid中的配置(供参考)</h2><pre><code class="hljs properties"><span class="hljs-comment"># 数据库基本配置</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/tianjinb2b?useUnicode=true&amp;characterEncoding=UTF-8</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">88888888</span><span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver        </span><span class="hljs-comment"># 数据库访问配置</span><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-comment"># 初始化连接数</span><span class="hljs-meta">spring.datasource.initialSize</span>=<span class="hljs-string">5</span><span class="hljs-comment"># 最小连接数</span><span class="hljs-meta">spring.datasource.minIdle</span>=<span class="hljs-string">5</span><span class="hljs-comment"># 最大连接池数</span><span class="hljs-meta">spring.datasource.maxActive</span>=<span class="hljs-string">20</span><span class="hljs-comment"># 最大等待获得连接的时间 默认ms</span><span class="hljs-meta">spring.datasource.maxWait</span>=<span class="hljs-string">60000</span><span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><span class="hljs-meta">spring.datasource.timeBetweenEvictionRunsMillis</span>=<span class="hljs-string">60000</span><span class="hljs-comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><span class="hljs-meta">spring.datasource.minEvictableIdleTimeMillis</span>=<span class="hljs-string">300000</span><span class="hljs-meta">spring.datasource.validationQuery</span>=<span class="hljs-string">SELECT 1 FROM DUAL</span><span class="hljs-meta">spring.datasource.testWhileIdle</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.datasource.testOnBorrow</span>=<span class="hljs-string">false</span><span class="hljs-meta">spring.datasource.testOnReturn</span>=<span class="hljs-string">false</span><span class="hljs-comment"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span><span class="hljs-meta">spring.datasource.filters</span>=<span class="hljs-string">stat,wall,log4j</span><span class="hljs-meta">spring.datasource.logSlowSql</span>=<span class="hljs-string">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>05-连接池</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-新手JDBC常见的不该犯的错误</title>
    <link href="/03-Database/04-JDBC/04-%E6%96%B0%E6%89%8BJDBC%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8D%E8%AF%A5%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/03-Database/04-JDBC/04-%E6%96%B0%E6%89%8BJDBC%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8D%E8%AF%A5%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="DAO实现类中不该出现的问题"><a href="#DAO实现类中不该出现的问题" class="headerlink" title="DAO实现类中不该出现的问题"></a>DAO实现类中不该出现的问题</h2><ul><li>数据库配置，如密码，在代码中硬编码 –&gt; 使用配置文件</li><li>获取connection的方法重复 –&gt; 使用静态的公共方法创建/自动注入唯一的Connection</li><li>密码明文保存 –&gt; 使用jasypt加密</li><li>所有的资源都要自己手动关闭 –&gt; 使用JDBCTemplate（Spring）/JPA</li><li>直接使用SQL拼接，导致SQL注入风险 –&gt; 使用PreparedStatement</li><li>没有使用数据库连接池，频繁开启关闭连接 –&gt; 使用资源连接池Druid等</li><li>DML模版是重复的（增删改），DQL模版也是重复的（查）–&gt; </li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>04-JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-druid</title>
    <link href="/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/01-druid/"/>
    <url>/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/01-druid/</url>
    
    <content type="html"><![CDATA[<h1 id="Druid的使用"><a href="#Druid的使用" class="headerlink" title="Druid的使用"></a>Druid的使用</h1><p>Druid在设计上参考了</p><h2 id="Maven中使用Druid"><a href="#Maven中使用Druid" class="headerlink" title="Maven中使用Druid"></a>Maven中使用Druid</h2><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>DruidDataSource.properties</p><pre><code class="hljs properties"><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/application?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;allowMultiQueries=true</span><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">PASSWORD</span><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-comment"># 下面为连接池的补充设置，应用到上面所有数据源中</span><span class="hljs-attr">initialSize</span>=<span class="hljs-string">0</span><span class="hljs-comment"># 最大空闲连接数</span><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 最小空闲连接数</span><span class="hljs-attr">minIdle</span>=<span class="hljs-string">0</span><span class="hljs-comment"># 最大连接数</span><span class="hljs-attr">maxTotal</span>=<span class="hljs-string">8</span><span class="hljs-comment"># 获取连接最长等待时间</span><span class="hljs-attr">maxWaitMillis</span>=<span class="hljs-string">-1</span><span class="hljs-comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><span class="hljs-attr">timeBetweenEvictionRunsMillis</span>=<span class="hljs-string">-1</span><span class="hljs-comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><span class="hljs-attr">minEvictableIdleTimeMillis</span>=<span class="hljs-string">300000</span></code></pre><p>Application.java</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.PreparedStatement;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这里是常用的配置的配置的 默认配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> https://commons.apache.org/proper/commons-dbcp/configuration.html</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 方式1：通过设置字段属性</span>        DruidDataSource druidDataSource = <span class="hljs-keyword">new</span> DruidDataSource();        druidDataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);        druidDataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);        druidDataSource.setPassword(<span class="hljs-string">&quot;PASSWORD&quot;</span>);        druidDataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/application?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;allowMultiQueries=true&quot;</span>);        dataSource = druidDataSource;        <span class="hljs-comment">// 方式2：通过加载配置文件</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-keyword">try</span> &#123;            properties.load(Application.class.getResourceAsStream(&quot;/DruidDataSource.properties&quot;));            dataSource = DruidDataSourceFactory.createDataSource(properties);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;        String sql = <span class="hljs-string">&quot;SELECT * FROM company WHERE id = ?&quot;</span>;        Connection connection = dataSource.getConnection();        PreparedStatement ps = connection.prepareStatement(sql);        ps.setLong(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        ResultSet resultSet = ps.executeQuery();        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;            String chineseName = resultSet.getString(<span class="hljs-string">&quot;chinese_name&quot;</span>);            System.out.println(chineseName);        &#125;        <span class="hljs-comment">// 关闭资源，这里的close是将连接对象还给连接池</span>        connection.close();        ps.close();        resultSet.close();    &#125;&#125;</code></pre><h2 id="Spring中使用Druid"><a href="#Spring中使用Druid" class="headerlink" title="Spring中使用Druid"></a>Spring中使用Druid</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_33326449/article/details/86608917">非常牛逼的一个druid文章</a></li><li><a href="https://blog.csdn.net/biejiuyingshang/article/details/79277373">连接池的配置和使用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>05-连接池</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-DBCP</title>
    <link href="/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/02-DBCP/"/>
    <url>/03-Database/05-%E8%BF%9E%E6%8E%A5%E6%B1%A0/02-DBCP/</url>
    
    <content type="html"><![CDATA[<h1 id="DBCP连接池"><a href="#DBCP连接池" class="headerlink" title="DBCP连接池"></a>DBCP连接池</h1><h2 id="Maven中使用DBCP"><a href="#Maven中使用DBCP" class="headerlink" title="Maven中使用DBCP"></a>Maven中使用DBCP</h2><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>DBCPDataSource.properties</p><pre><code class="hljs peroperties">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;application?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;useLegacyDatetimeCode&#x3D;false&amp;serverTimezone&#x3D;UTC&amp;allowMultiQueries&#x3D;trueusername&#x3D;rootpassword&#x3D;PASSWORDdriverClassName&#x3D;com.mysql.jdbc.Driver# 下面为连接池的补充设置，应用到上面所有数据源中initialSize&#x3D;0# 最大空闲连接数maxIdle&#x3D;8# 最小空闲连接数minIdle&#x3D;0# 最大连接数maxTotal&#x3D;8# 获取连接最长等待时间maxWaitMillis&#x3D;-1# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis&#x3D;-1# 配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis&#x3D;300000</code></pre><p>Application.java</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.PreparedStatement;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BasicDataSource dataSource;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这里是常用的配置的配置的 默认配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> https://commons.apache.org/proper/commons-dbcp/configuration.html</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 方式1：通过设置字段属性</span>        dataSource = <span class="hljs-keyword">new</span> BasicDataSource();        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);        dataSource.setPassword(<span class="hljs-string">&quot;PASSWORD&quot;</span>);        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/application?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;allowMultiQueries=true&quot;</span>);        <span class="hljs-comment">// 方式2：通过加载配置文件</span>        Properties properties = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-keyword">try</span> &#123;            properties.load(Application.class.getResourceAsStream(&quot;/DBCPDataSource.properties&quot;));            dataSource = BasicDataSourceFactory.createDataSource(properties);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;        String sql = <span class="hljs-string">&quot;SELECT * FROM company WHERE id = ?&quot;</span>;        Connection connection = dataSource.getConnection();        PreparedStatement ps = connection.prepareStatement(sql);        ps.setLong(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        ResultSet resultSet = ps.executeQuery();        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;            String chineseName = resultSet.getString(<span class="hljs-string">&quot;chinese_name&quot;</span>);            System.out.println(chineseName);        &#125;        <span class="hljs-comment">// 关闭资源，这里的close是将连接对象还给连接池</span>        connection.close();        ps.close();        resultSet.close();    &#125;&#125;</code></pre><h2 id="SpringBoot中的DBCP"><a href="#SpringBoot中的DBCP" class="headerlink" title="SpringBoot中的DBCP"></a>SpringBoot中的DBCP</h2>]]></content>
    
    
    <categories>
      
      <category>03-Database</category>
      
      <category>05-连接池</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Hadoop集群搭建</title>
    <link href="/07-Bigdata/01-Hadoop/01-Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/07-Bigdata/01-Hadoop/01-Hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hadoop集群搭建（双版本）"><a href="#Hadoop集群搭建（双版本）" class="headerlink" title="Hadoop集群搭建（双版本）"></a>Hadoop集群搭建（双版本）</h1><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h3 id="一、版本信息"><a href="#一、版本信息" class="headerlink" title="一、版本信息"></a>一、版本信息</h3><table><thead><tr><th>资源</th><th>版本</th><th>下载地址</th></tr></thead><tbody><tr><td>操作系统</td><td>centos6.4/ubuntu16.04</td><td></td></tr><tr><td>JDK</td><td>JDK1.7.0_80</td><td><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html">oracle</a></td></tr><tr><td>Hadoop</td><td>cdh5.10.0</td><td><a href="http://archive.cloudera.com/cdh5/cdh/5/">cloudera</a></td></tr><tr><td>impala</td><td></td><td><a href="http://archive.cloudera.com/impala/">cloudera</a></td></tr><tr><td>kudu</td><td></td><td><a href="http://kudu.apache.org/docs/installation.html">apache</a></td></tr><tr><td>MySQL</td><td>5.6</td><td><a href="http://mirrors.sohu.com/mysql/">sohu</a></td></tr></tbody></table><h3 id="二、集群规划"><a href="#二、集群规划" class="headerlink" title="二、集群规划"></a>二、集群规划</h3><p><img src="../images/01-01.png" alt="集群规划"></p><h3 id="三、基础配置"><a href="#三、基础配置" class="headerlink" title="三、基础配置"></a>三、基础配置</h3><h4 id="1-增加普通用户hadoop"><a href="#1-增加普通用户hadoop" class="headerlink" title="1.增加普通用户hadoop"></a>1.增加普通用户hadoop</h4><pre><code># 增加普通用户(root)$ useradd hadoop# 修改用户密码(root)$ passwd hadoop# 增加超级用户权限(root)$ vim /etc/sudoers# 在 root  ALL=(ALL)   ALL 这一行下面$ hadoop  ALL=(ALL)     ALL</code></pre><h4 id="2-主机名-不允许下划线"><a href="#2-主机名-不允许下划线" class="headerlink" title="2.主机名(不允许下划线)"></a>2.主机名(不允许下划线)</h4><pre><code># 临时修改主机名$ hostname new-hostname# 永久修改主机名# centos$ vim /etc/sysconfig/network# ubuntu$ vim /etc/hostname# 更新显示$ bash</code></pre><h4 id="3-固定IP（ubuntu）"><a href="#3-固定IP（ubuntu）" class="headerlink" title="3.固定IP（ubuntu）"></a>3.固定IP（ubuntu）</h4><pre><code class="hljs yaml"><span class="hljs-comment"># 固定IP</span><span class="hljs-string">vim</span> <span class="hljs-string">/etc/network/interfaces</span><span class="hljs-string">auto</span> <span class="hljs-string">eth0</span><span class="hljs-string">iface</span> <span class="hljs-string">eth0</span> <span class="hljs-string">inet</span> <span class="hljs-string">static</span><span class="hljs-string">address</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span><span class="hljs-string">netmask</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><span class="hljs-string">gateway</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-comment"># nameserver</span><span class="hljs-string">sudo</span> <span class="hljs-string">vim</span> <span class="hljs-string">/etc/resolv.conf</span><span class="hljs-string">nameserver</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><span class="hljs-comment"># 永久修改</span><span class="hljs-string">vim</span> <span class="hljs-string">/etc/resolvconf/resolv.conf.d/base</span><span class="hljs-string">nameserver</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><span class="hljs-comment"># 重启电脑/网卡</span><span class="hljs-string">/etc/init.d/networking</span> <span class="hljs-string">restart</span></code></pre><h4 id="3-IP地址映射-同时修改客户端"><a href="#3-IP地址映射-同时修改客户端" class="headerlink" title="3.IP地址映射(同时修改客户端)"></a>3.IP地址映射(同时修改客户端)</h4><pre><code># linux$ vim /etc/hosts# windowsC:\Windows\System32\drivers\etc\hosts    </code></pre><h4 id="4-关闭防火墙-或者开放用到的端口"><a href="#4-关闭防火墙-或者开放用到的端口" class="headerlink" title="4.关闭防火墙(或者开放用到的端口)"></a>4.关闭防火墙(或者开放用到的端口)</h4><pre><code># 查看防火墙状态$ service iptables status# 临时关闭防火墙$ service iptables stop# 永久关闭防火墙$ chkconfig iptables off# ubuntu$ sudo  ufw enable|disable|status</code></pre><h4 id="5-禁用ipv6hadoop暂时不支持ipv6-重启生效-Root"><a href="#5-禁用ipv6hadoop暂时不支持ipv6-重启生效-Root" class="headerlink" title="5.禁用ipv6hadoop暂时不支持ipv6(重启生效)(Root)"></a>5.禁用ipv6<a href="https://wiki.apache.org/hadoop/HadoopIPv6">hadoop暂时不支持ipv6</a>(重启生效)(Root)</h4><pre><code># 查看ipv6$ ifconfig#!/bin/sh# 文件尾行添加两行cat &lt;&lt;EOF&gt;&gt;/etc/modprobe.d/dist.confalias net-pf-10 offalias ipv6 offEOF# ubuntu# 编辑文件 - /etc/sysctl.conf$ sudo gedit /etc/sysctl.conf# IPv6 disablednet.ipv6.conf.all.disable_ipv6 =1net.ipv6.conf.default.disable_ipv6 =1net.ipv6.conf.lo.disable_ipv6 =1重启sysctl$ sudo sysctl -p</code></pre><h4 id="6-禁用selinux-这是一个懒运维行为"><a href="#6-禁用selinux-这是一个懒运维行为" class="headerlink" title="6.禁用selinux(这是一个懒运维行为)"></a>6.禁用selinux(这是一个懒运维行为)</h4><pre><code># 查看SELinux状态$ /usr/sbin/sestatus -vSELinux status:                 enabled# 临时关闭$ sudo setenforce 0# 永久关闭(重启生效)$ sudo vim /etc/selinx/configSELINUX=disabled</code></pre><h4 id="7-卸载openJDK"><a href="#7-卸载openJDK" class="headerlink" title="7.卸载openJDK"></a>7.卸载openJDK</h4><pre><code># 查看openJDK$ rpm -qa | grep java# 全部卸载rpm -e --nodeps java-xxx# ubuntu(默认没装)$ sudo apt-get autoremove openjdk-</code></pre><h4 id="8-设置文件打开数量和用户最大进程数目-大数据"><a href="#8-设置文件打开数量和用户最大进程数目-大数据" class="headerlink" title="8.设置文件打开数量和用户最大进程数目(大数据)"></a>8.设置文件打开数量和用户最大进程数目(大数据)</h4><pre><code># 查看打开文件数$ ulimit -aopen files         (-n)1024# 查看用户最大进程数$ ulimit -u# 设置(重启生效)$ sudo vim /etc/security/limits.conf# 添加(*表示所有用户)* soft nofile 65536* hard nofile 65536* soft nproc 32000* hard nproc 32000# 这个文件限制了设置的上限$ sudo vim /etc/security/limits.d/90-nproc.conf </code></pre><h4 id="9-ssh无密钥登录-注意主机名问题，需要把slaves中的主机名ssh跑通一遍-错误"><a href="#9-ssh无密钥登录-注意主机名问题，需要把slaves中的主机名ssh跑通一遍-错误" class="headerlink" title="9.ssh无密钥登录(注意主机名问题，需要把slaves中的主机名ssh跑通一遍)错误"></a>9.ssh无密钥登录(注意主机名问题，需要把slaves中的主机名ssh跑通一遍)<a href="%E9%94%99%E8%AF%AF%E5%A4%A7%E9%9B%86%E5%90%88">错误</a></h4><pre><code># 生成密钥$ ssh-keygen -t rsa# 复制密钥(不添加用户名表示同名用户)(需要包括自己)$ ssh-copy-id hostname</code></pre><h4 id="10-重启所有机器，并检查所有配置"><a href="#10-重启所有机器，并检查所有配置" class="headerlink" title="10.重启所有机器，并检查所有配置"></a>10.重启所有机器，并检查所有配置</h4><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>安装路径/usr/local/cdh5.10.0</li><li>目录所有者：hadoop</li></ul><h2 id="1-JDK"><a href="#1-JDK" class="headerlink" title="1. JDK"></a>1. JDK</h2><ul><li><p>安装路径/usr/java/jdk1.7.0_79</p><h4 id="a-编辑环境变量"><a href="#a-编辑环境变量" class="headerlink" title="a.编辑环境变量"></a>a.编辑环境变量</h4><p>  $ sudo vim /etc/profile</p><h1 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h1><p>  JAVA_HOME=/usr/java/jdk1.7.0_79<br>  PATH=$JAVA_HOME/bin:$PATH<br>  CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar<br>  export PATH JAVA_HOME CLASSPATH</p></li></ul><h2 id="2-Hadoop"><a href="#2-Hadoop" class="headerlink" title="2. Hadoop"></a>2. Hadoop</h2><h4 id="a-编辑-ete-hadoop-hadoop-env-sh"><a href="#a-编辑-ete-hadoop-hadoop-env-sh" class="headerlink" title="a.编辑/ete/hadoop/hadoop-env.sh"></a>a.编辑/ete/hadoop/hadoop-env.sh</h4><pre><code>$ vim /ete/hadoop/hadoop-env.shexport JAVA_HOME=/usr/java/jdk1.7.0_79</code></pre><h4 id="b-创建临时文件目录"><a href="#b-创建临时文件目录" class="headerlink" title="b.创建临时文件目录"></a>b.创建临时文件目录</h4><pre><code>$ mkdir -p usr/local/cdh5.10.0//hadoop-2.6.0-cdh5.10.0/data/tmp</code></pre><h4 id="c-编辑-etc-hadoop-core-site-sh-非HA"><a href="#c-编辑-etc-hadoop-core-site-sh-非HA" class="headerlink" title="c.编辑/etc/hadoop/core-site.sh(非HA)"></a>c.编辑/etc/hadoop/core-site.sh(非HA)</h4><pre><code>&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://centos1.gci.com:8020&lt;/value&gt;    &lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/local/cdh5.10.0/hadoop-2.6.0-cdh5.10.0/data/tmp&lt;/value&gt; &lt;/property&gt;</code></pre><h4 id="d-初始化NameNode"><a href="#d-初始化NameNode" class="headerlink" title="d.初始化NameNode()"></a>d.初始化NameNode()</h4><pre><code>$ bin/hdfs namenode -format</code></pre><h4 id="e-启动HDFS"><a href="#e-启动HDFS" class="headerlink" title="e.启动HDFS"></a>e.启动HDFS</h4><pre><code>  $sbin/hadoop-daemon.sh start namenode   $sbin/hadoop-daemon.sh start datanode </code></pre><h4 id="f-查看集群情况"><a href="#f-查看集群情况" class="headerlink" title="f.查看集群情况"></a>f.查看集群情况</h4><pre><code>centos1.gci.com:50070</code></pre><h4 id="g-创建用户目录"><a href="#g-创建用户目录" class="headerlink" title="g.创建用户目录"></a>g.创建用户目录</h4><pre><code>$ bin/hdfs dfs -mkdir -p /user/hadoop</code></pre><h2 id="2-YARN"><a href="#2-YARN" class="headerlink" title="2.YARN"></a>2.YARN</h2><h4 id="a-编辑etc-hadoop-yarn-env-sh"><a href="#a-编辑etc-hadoop-yarn-env-sh" class="headerlink" title="a.编辑etc/hadoop/yarn-env.sh"></a>a.编辑etc/hadoop/yarn-env.sh</h4><pre><code>export JAVA_HOME=/usr/java/jdk1.7.0_79</code></pre><h4 id="b-配置etc-hadoop-yarn-site-xml"><a href="#b-配置etc-hadoop-yarn-site-xml" class="headerlink" title="b.配置etc/hadoop/yarn-site.xml"></a>b.配置etc/hadoop/yarn-site.xml</h4><pre><code>&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;centos3.gci.com&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;        &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt; </code></pre><h4 id="c-编辑slaves文件"><a href="#c-编辑slaves文件" class="headerlink" title="c.编辑slaves文件"></a>c.编辑slaves文件</h4><pre><code>centos1.gci.comcentos2.gci.comcentos3.gci.comcentos4.gci.comcentos5.gci.com</code></pre><h4 id="d-启动YARN"><a href="#d-启动YARN" class="headerlink" title="d.启动YARN"></a>d.启动YARN</h4><pre><code>$sbin/yarn-daemon.sh start resourcemanager$sbin/yarn-daemon.sh start nodemanager$ sbin/mr-jobhistory-deamon.sh start historyserver</code></pre><h2 id="3-Mapreduce"><a href="#3-Mapreduce" class="headerlink" title="3.Mapreduce"></a>3.Mapreduce</h2><h4 id="a-配置etc-hadoop-mapred-env-sh"><a href="#a-配置etc-hadoop-mapred-env-sh" class="headerlink" title="a.配置etc/hadoop/mapred-env.sh"></a>a.配置etc/hadoop/mapred-env.sh</h4><pre><code>JAVA_HOME=/usr/java/jdk1.7.0_79</code></pre><h4 id="b-配置etc-hadoop-mapred-site-xml"><a href="#b-配置etc-hadoop-mapred-site-xml" class="headerlink" title="b.配置etc/hadoop/mapred-site.xml"></a>b.配置etc/hadoop/mapred-site.xml</h4><pre><code>&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><h4 id="c-测试"><a href="#c-测试" class="headerlink" title="c.测试"></a>c.测试</h4><pre><code># 其中 input 和 output 是HDFS上相对路径，input必须存在且存在文件，output 不能存在$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.5.2.jar wordcount input output</code></pre><h2 id="4-动态增加Slave节点"><a href="#4-动态增加Slave节点" class="headerlink" title="4.动态增加Slave节点"></a>4.动态增加Slave节点</h2><h4 id="a-拷贝hadoop文件夹-root-删除data-tmp"><a href="#a-拷贝hadoop文件夹-root-删除data-tmp" class="headerlink" title="a.拷贝hadoop文件夹(root) 删除data/tmp/*"></a>a.拷贝hadoop文件夹(root) 删除data/tmp/*</h4><pre><code>$ scp -r /usr/local/cdh5.10.0 centos2:/usr/local/$ rm -r data/tmp/*</code></pre><h4 id="b-修改文件所有者-root"><a href="#b-修改文件所有者-root" class="headerlink" title="b.修改文件所有者(root)"></a>b.修改文件所有者(root)</h4><pre><code>$ chown -R chown hadoop:hadoop /usr/local/cdh5.10.0</code></pre><h4 id="c-编辑slaves文件-1"><a href="#c-编辑slaves文件-1" class="headerlink" title="c.编辑slaves文件"></a>c.编辑slaves文件</h4><h4 id="d-启动各个datanode节点"><a href="#d-启动各个datanode节点" class="headerlink" title="d.启动各个datanode节点"></a>d.启动各个datanode节点</h4><h4 id="e-刷新节点信息"><a href="#e-刷新节点信息" class="headerlink" title="e.刷新节点信息"></a>e.刷新节点信息</h4><pre><code>bin/hdfs dfsadmin -refreshNodes</code></pre><h4 id="f-负载均衡"><a href="#f-负载均衡" class="headerlink" title="f.负载均衡"></a>f.负载均衡</h4><pre><code>$ bin/hdfs dfsadmin -setBalancerBandwidth 67108864</code></pre><h2 id="5-ntp时间同步"><a href="#5-ntp时间同步" class="headerlink" title="5.ntp时间同步"></a>5.ntp时间同步</h2><h4 id="a-检查ntpd服务是否安装"><a href="#a-检查ntpd服务是否安装" class="headerlink" title="a.检查ntpd服务是否安装"></a>a.检查ntpd服务是否安装</h4><pre><code>$ sudo rpm -qa | grep ntp</code></pre><h4 id="b-编辑作为-ntp-server-节点的配置文件-etc-ntp"><a href="#b-编辑作为-ntp-server-节点的配置文件-etc-ntp" class="headerlink" title="b.编辑作为 ntp server 节点的配置文件/etc/ntp"></a>b.编辑作为 <strong>ntp server</strong> 节点的配置文件/etc/ntp</h4><pre><code># 注释三行，关闭上层时间服务器# server 0.centos.pool.ntp.org# server 1.centos.pool.ntp.org# server 2.centos.pool.ntp.org# 去掉两行注释，开启本地市时间同步server    127.0.0.1fudge    127.127.1.0    stratum    10# 去掉一行注释，作为时间服务器，允许本网段时间同步restrict    10.173.38.0    mask    255.255.255.0    nomodify notrap</code></pre><h4 id="c-硬件时间同步"><a href="#c-硬件时间同步" class="headerlink" title="c.硬件时间同步"></a>c.硬件时间同步</h4><pre><code>$ sudo vim /etc/sysconfig/ntpd# 增加SYNC_HWCLOCK=yes</code></pre><h4 id="d-启动服务"><a href="#d-启动服务" class="headerlink" title="d.启动服务"></a>d.启动服务</h4><pre><code># 临时启动$ sudo service ntpd start# 开机启动$ sudo chkconfig ntpd on# 检查开机启动项$ sudo chkconfig --list | grep ntpd</code></pre><h4 id="e-新增作为-ntp-client-节点创建定时任务-root"><a href="#e-新增作为-ntp-client-节点创建定时任务-root" class="headerlink" title="e.新增作为 ** ntp client** 节点创建定时任务(root)"></a>e.新增作为 ** ntp client** 节点创建定时任务(root)</h4><p>问题：</p><ul><li>问题描述：在使用kudu的时候出现问题，检测时间服务器状态（ntpstat）需要由ntpd server 同步才能生效，手动同步不能生效</li><li>解决办法：使用比上述方法更加简单的同步方法，编辑/etc/ntp.conf文件添加server指向自己的 <strong>ntp server</strong><br>开启定时任务</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># 设置一个错误时间，用于检验</span>$ date -s 20160101<span class="hljs-comment"># 查看crontab列表</span>$ crontab -l<span class="hljs-comment"># 增加定时任务(root)</span>$ crontal -e<span class="hljs-comment"># sync cluster time</span>0-59/10 * * * *  /bin/bash /home/hadoop/crontab/sync_cluster_time.sh</code></pre><h2 id="6-Zookeeper"><a href="#6-Zookeeper" class="headerlink" title="6.Zookeeper"></a>6.Zookeeper</h2><h4 id="a-创建数据文件目录"><a href="#a-创建数据文件目录" class="headerlink" title="a.创建数据文件目录"></a>a.创建数据文件目录</h4><pre><code>$ mkdir -p data/zkData</code></pre><h4 id="b-重命名配置文件并修改conf-zoo-cfg"><a href="#b-重命名配置文件并修改conf-zoo-cfg" class="headerlink" title="b.重命名配置文件并修改conf/zoo.cfg"></a>b.重命名配置文件并修改conf/zoo.cfg</h4><pre><code># $&#123;ZOOKEEPER_HOME&#125;用实际路径代替dataDir=$&#123;ZOOKEEPER_HOME&#125;/data/zkData#server.IP =  hostname  : port  :vote_portserver.1=hostname-ubuntu.cenzhongman.com:2888:3888server.2=hostname-ubuntu2.cenzhongman.com:2888:3888server.3=hostname-ubuntu3.cenzhongman.com:2888:3888</code></pre><h4 id="c-在数据文件夹下增加id声明文件"><a href="#c-在数据文件夹下增加id声明文件" class="headerlink" title="c.在数据文件夹下增加id声明文件"></a>c.在数据文件夹下增加id声明文件</h4><pre><code># $&#123;ZOOKEEPER_HOME&#125;用实际路径代替$ touch $&#123;ZOOKEEPER_HOME&#125;/data/zkData/myid$ vim $&#123;ZOOKEEPER_HOME&#125;/data/zkData/data/zkData/myid1</code></pre><h4 id="d-复制到其他节点，并修改myid"><a href="#d-复制到其他节点，并修改myid" class="headerlink" title="d.复制到其他节点，并修改myid"></a>d.复制到其他节点，并修改myid</h4><h4 id="e-启动各个节点，没有统一启动"><a href="#e-启动各个节点，没有统一启动" class="headerlink" title="e.启动各个节点，没有统一启动"></a>e.启动各个节点，没有统一启动</h4><pre><code># 启动$ bin/zkServer.sh start# 状态$ bin/zkServer.sh status# 客户端$ bin/zkCli.sh</code></pre><h2 id="7-HBase"><a href="#7-HBase" class="headerlink" title="7.HBase"></a>7.HBase</h2><h4 id="a-修改用户环境变量"><a href="#a-修改用户环境变量" class="headerlink" title="a.修改用户环境变量"></a>a.修改用户环境变量</h4><pre><code>$ sudo vim ~/.bashrcexport HBASE_HOME=/usr/local/cdh5.10.0/hbase-1.2.0-cdh5.10.0export PATH=$HBASE_HOME/bin:$PATH</code></pre><h4 id="b-配置hbase-env-sh文件"><a href="#b-配置hbase-env-sh文件" class="headerlink" title="b.配置hbase-env.sh文件"></a>b.配置hbase-env.sh文件</h4><pre><code># JAVE_HOMEexport JAVA_HOME=/usr/java/jdk1.7.0_79# 使用上面装的Zookeeperexport HBASE_MANAGES_ZK=false</code></pre><h4 id="c-配置hbase-site-xml"><a href="#c-配置hbase-site-xml" class="headerlink" title="c.配置hbase-site.xml"></a>c.配置hbase-site.xml</h4><pre><code>&lt;configuration&gt;    &lt;!--根目录，在HDFS的路径--&gt;    &lt;property&gt;        &lt;name&gt;hbase.rootdir&lt;/name&gt;        &lt;value&gt;hdfs://centos1.gci.com:8020/hbase&lt;/value&gt;    &lt;/property&gt;    &lt;!--是否分布式--&gt;    &lt;property&gt;        &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;        &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt;    &lt;!--所有节点,逗号隔开--&gt;    &lt;property&gt;        &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;        &lt;value&gt;centos1.gci.com,centos2.gci.com,centos3.gci.com,centos4.gci.com,centos5.gci.com&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h4 id="d-配置-regionservers-类似-Slaves"><a href="#d-配置-regionservers-类似-Slaves" class="headerlink" title="d.配置 regionservers 类似(Slaves)"></a>d.配置 regionservers 类似(Slaves)</h4><pre><code>centos1.gci.comcentos2.gci.comcentos3.gci.comcentos4.gci.comcentos5.gci.com</code></pre><h4 id="e-启动-HBase-在启动-Zookeper-server后"><a href="#e-启动-HBase-在启动-Zookeper-server后" class="headerlink" title="e.启动 HBase(在启动 Zookeper server后)"></a>e.启动 HBase(在启动 Zookeper server后)</h4><pre><code># 单独启动$ bin/hbase-daemon.sh start regionserver$ bin/hbase-daemon.sh start master# 集群启动(非HA)$ bin/start-hbase.sh</code></pre><h4 id="f-Web-查看"><a href="#f-Web-查看" class="headerlink" title="f. Web 查看"></a>f. Web 查看</h4><pre><code>$ hostname:60010</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-HaDoop错误大集合</title>
    <link href="/07-Bigdata/01-Hadoop/02-HaDoop%E9%94%99%E8%AF%AF%E5%A4%A7%E9%9B%86%E5%90%88/"/>
    <url>/07-Bigdata/01-Hadoop/02-HaDoop%E9%94%99%E8%AF%AF%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="错误大集合"><a href="#错误大集合" class="headerlink" title="错误大集合"></a>错误大集合</h1><h3 id="1、启动HDFS集群-ssh-问题"><a href="#1、启动HDFS集群-ssh-问题" class="headerlink" title="1、启动HDFS集群 ssh 问题"></a>1、启动HDFS集群 ssh 问题</h3><ul><li>问题描述：在ssh无密钥登录时会识别主机名，用于登录的主机名需要加入一个已知列表，不在表中的需要输入 yes 同意添加，但是在 HDFS 启动过程无法交互式输入 yes 导致 datanode  启动失败</li><li>错误信息：The authenticity of host hostname can’t be established.</li><li>解决办法：使用slaves中的那些主机名，ssh 登录一遍</li></ul><h3 id="2、复制后的-Datanode不显示"><a href="#2、复制后的-Datanode不显示" class="headerlink" title="2、复制后的 Datanode不显示"></a>2、复制后的 Datanode不显示</h3><ul><li>问题描述：直接复制的Hadoop文件，会导致Datanode的UUID也就是身份信息相同，在Web显示的时候轮流显示，但只有一个。</li><li>错误信息：无</li><li>解决办法：删除data/tmp/目录下的所有文件(该目录在hcore-site.sh中配置)</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>问题描述：</li><li>错误信息：</li><li>解决办法：</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-脚本管理集群</title>
    <link href="/07-Bigdata/01-Hadoop/03-%E8%84%9A%E6%9C%AC%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4/"/>
    <url>/07-Bigdata/01-Hadoop/03-%E8%84%9A%E6%9C%AC%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="脚本管理集群"><a href="#脚本管理集群" class="headerlink" title="脚本管理集群"></a>脚本管理集群</h1><h1 id="一-集群介绍"><a href="#一-集群介绍" class="headerlink" title="一. 集群介绍"></a>一. 集群介绍</h1><h2 id="1-1-集群规划"><a href="#1-1-集群规划" class="headerlink" title="1.1 集群规划"></a>1.1 集群规划</h2><p><img src="http://img.blog.csdn.net/20151231155320991" alt="集群规划"></p><hr><h2 id="1-2-正确的启动顺序"><a href="#1-2-正确的启动顺序" class="headerlink" title="1.2 正确的启动顺序"></a>1.2 正确的启动顺序</h2><p><strong>1. ZooKeeper -&gt; <a href="http://lib.csdn.net/base/hadoop" title="Hadoop知识库">Hadoop</a> -&gt; <a href="http://lib.csdn.net/base/hbase" title="Hbase知识库">Hbase</a></strong></p><p><strong>2. ZooKeeper -&gt; JournalNode (<a href="http://lib.csdn.net/base/hadoop" title="Hadoop知识库">hadoop</a>) -&gt; NameNode (Hadoop) -&gt; DataNode (Hadoop) -&gt; 主 ResourceManager/NodeManager (Hadoop) -&gt; 备份 ResourceManager (Hadoop) -&gt; ZKFC (Hadoop) -&gt; MapReduce JobHistory (Hadoop) -&gt; 主 Hmaster/HRegionServer (<a href="http://lib.csdn.net/base/hbase" title="Hbase知识库">hbase</a>) -&gt;备份 Hmaster (HBase)</strong></p><p><strong>关闭集群的顺序则相反</strong></p><hr><h1 id="二-集群管理脚本"><a href="#二-集群管理脚本" class="headerlink" title="二. 集群管理脚本"></a>二. 集群管理脚本</h1><p>笔者的脚本部署在下面的路径下</p><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/cluster/</span>cluster-manager</code></pre><hr><h2 id="2-1-Slaves-配置文件"><a href="#2-1-Slaves-配置文件" class="headerlink" title="2.1 Slaves 配置文件"></a>2.1 Slaves 配置文件</h2><p><strong>1. 文件名</strong>：slaves</p><p><strong>2. 功能</strong>：记录运行 datanode 、nodemanager、HRegionServer、QuorumPeerMain、JournalNode 的节点 IP 地址或主机名</p><p><strong>3. 内容</strong></p><pre><code class="hljs">slave51slave52slave53</code></pre><hr><h2 id="2-2-ZooKeeper-管理脚本"><a href="#2-2-ZooKeeper-管理脚本" class="headerlink" title="2.2 ZooKeeper 管理脚本"></a>2.2 ZooKeeper 管理脚本</h2><p><strong>1. 文件名</strong>：zk-manager.sh</p><p><strong>2. 功能</strong>：启动、关闭与重启 ZooKeeper 集群，并可查看运行 ZK 服务的的模式（leader or follower？）</p><p><strong>3. 内容</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>SLAVES=$(cat slaves)start_time=`date +%s`<span class="hljs-keyword">for</span> slave <span class="hljs-keyword">in</span> <span class="hljs-variable">$SLAVES</span><span class="hljs-keyword">do</span>        <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>                start)  ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;source ~/.bash_profile;zkServer.sh start&quot;</span> 1&gt;/dev/null;;                stop)   ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;source ~/.bash_profile;zkServer.sh stop&quot;</span> 1&gt;/dev/null ;;                status) ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;source ~/.bash_profile;zkServer.sh status&quot;</span> ;;                restart)ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;source ~/.bash_profile;zkServer.sh restart&quot;</span> 1&gt;/dev/null;;                *)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Usage: sh zk-manager.sh &#123;start|stop|restart&#125; ^_^\n&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> ;;        <span class="hljs-keyword">esac</span><span class="hljs-keyword">done</span>end_time=`date +%s`elapse_time=$((<span class="hljs-variable">$&#123;end_time&#125;</span>-<span class="hljs-variable">$&#123;start_time&#125;</span>))<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n<span class="hljs-variable">$1</span> ZooKeeper Server takes <span class="hljs-variable">$&#123;elapse_time&#125;</span> seconds\n&quot;</span></code></pre><hr><h2 id="2-3-JournalNode-管理脚本"><a href="#2-3-JournalNode-管理脚本" class="headerlink" title="2.3 JournalNode 管理脚本"></a>2.3 JournalNode 管理脚本</h2><p><strong>1. 文件名</strong>：journal-manager.sh</p><p><strong>2. 功能</strong>：启动、关闭运行在各个 slaves 上的 JournalNode 进程</p><p><strong>3. 内容</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>start_time=`date +%s`SLAVES=$(cat slaves)<span class="hljs-keyword">for</span> slave <span class="hljs-keyword">in</span> <span class="hljs-variable">$SLAVES</span><span class="hljs-keyword">do</span>        <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>                start)  ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh start journalnode&quot;</span> ;;                stop)   ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh stop journalnode&quot;</span> ;;                *)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Usage: sh journal-manager.sh &#123;start|stop&#125; ^_^\n&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> ;;        <span class="hljs-keyword">esac</span><span class="hljs-keyword">done</span>end_time=`date +%s`elapse_time=$((<span class="hljs-variable">$&#123;end_time&#125;</span>-<span class="hljs-variable">$&#123;start_time&#125;</span>))<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n<span class="hljs-variable">$1</span> JournalNode Server takes <span class="hljs-variable">$&#123;elapse_time&#125;</span> seconds\n&quot;</span></code></pre><hr><h2 id="2-4-Hadoop-管理脚本"><a href="#2-4-Hadoop-管理脚本" class="headerlink" title="2.4 Hadoop 管理脚本"></a>2.4 Hadoop 管理脚本</h2><p><strong>1. 文件名</strong>：hadoop-manager.sh</p><p><strong>2. 功能</strong>：管理 hadoop 的启动与关闭</p><p><strong>3. 内容</strong></p><pre><code class="hljs routeros"><span class="hljs-comment"># which machine to be active NameNode</span><span class="hljs-attribute">NameNode_1</span>=master5<span class="hljs-comment"># which machine to be standy NameNode</span><span class="hljs-attribute">NameNode_2</span>=master52<span class="hljs-comment"># which machine to be active ResourceManager</span><span class="hljs-attribute">ResourceManager_1</span>=master5<span class="hljs-comment"># which machine to be standby ResourceManager</span><span class="hljs-attribute">ResourceManager_2</span>=master52<span class="hljs-comment"># which machine to be JobHistoryServer</span><span class="hljs-attribute">HistoryServer</span>=master5<span class="hljs-comment"># make sure which namenode is active and which resourcemanager is active</span>function getServiceState () &#123;        hdfs haadmin -getServiceState <span class="hljs-variable">$&#123;NameNode_1&#125;</span> | grep <span class="hljs-string">&#x27;active&#x27;</span> &gt;&gt; /dev/<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-attribute">NameNode_Active</span>=<span class="hljs-variable">$&#123;NameNode_1&#125;</span> &amp;&amp; <span class="hljs-attribute">NameNode_Standby</span>=<span class="hljs-variable">$&#123;NameNode_2&#125;</span>        hdfs haadmin -getServiceState <span class="hljs-variable">$&#123;NameNode_2&#125;</span> | grep <span class="hljs-string">&#x27;active&#x27;</span> &gt;&gt; /dev/<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-attribute">NameNode_Active</span>=<span class="hljs-variable">$&#123;NameNode_2&#125;</span> &amp;&amp; <span class="hljs-attribute">NameNode_Standby</span>=<span class="hljs-variable">$&#123;NameNode_1&#125;</span>        yarn rmadmin -getServiceState rm1 | grep <span class="hljs-string">&#x27;active&#x27;</span> &gt;&gt; /dev/<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-attribute">ResourceManager_Active</span>=<span class="hljs-variable">$&#123;ResourceManager_1&#125;</span> &amp;&amp; <span class="hljs-attribute">ResourceManager_Standby</span>=<span class="hljs-variable">$&#123;ResourceManager_2&#125;</span>        yarn rmadmin -getServiceState rm2 | grep <span class="hljs-string">&#x27;active&#x27;</span> &gt;&gt; /dev/<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-attribute">ResourceManager_Active</span>=<span class="hljs-variable">$&#123;ResourceManager_2&#125;</span> &amp;&amp; <span class="hljs-attribute">ResourceManager_Standby</span>=<span class="hljs-variable">$&#123;ResourceManager_1&#125;</span>&#125;case <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>        start)  ssh -t <span class="hljs-variable">$&#123;NameNode_1&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh start namenode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_1&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh start zkfc&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_2&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh start namenode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_2&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh start zkfc&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_1&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemons.sh start datanode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;ResourceManager_1&#125;</span>     <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/start-yarn.sh&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;ResourceManager_2&#125;</span>     <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/yarn-daemon.sh start resourcemanager&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;HistoryServer&#125;</span>         <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/mr-jobhistory-daemon.sh start historyserver&quot;</span> ;                ;;        stop)   getServiceState                ssh -t <span class="hljs-variable">$&#123;HistoryServer&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/mr-jobhistory-daemon.sh stop historyserver&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;ResourceManager_Standby&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/yarn-daemon.sh stop resourcemanager&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;ResourceManager_Active&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/stop-yarn.sh&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_Active&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemons.sh stop datanode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_Standby&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh stop namenode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_Active&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh stop namenode&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_Standby&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh stop zkfc&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;NameNode_Active&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hadoop/sbin/hadoop-daemon.sh stop zkfc&quot;</span> ;                ;;        * )     echo -e <span class="hljs-string">&quot;Usage: hadoop-manager.sh &#123;start|stop&#125; ^_^\n&quot;</span> &amp;&amp; exit ;                ;;esac<span class="hljs-attribute">end_time</span>=`date +%s`<span class="hljs-attribute">elapse_time</span>=$(($&#123;end_time&#125;-<span class="hljs-variable">$&#123;start_time&#125;</span>))echo -e <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> Hadoop Server takes <span class="hljs-variable">$&#123;elapse_time&#125;</span> seconds\n&quot;</span></code></pre><p><strong>4. 注意事项</strong></p><ul><li><strong>NameNode_1</strong>、<strong>NameNode_2</strong>、<strong>ResourceManager_1</strong>、<strong>ResourceManager_2</strong>、<strong>HistoryServer</strong> 按实际填写，比如想让 master5 称为 active 则将其赋值给 NameNode_1</li><li>上述的启动顺序也许和 <a href="http://blog.csdn.net/u011414200/article/details/50437356">HA 集群启动与关闭的顺序</a> 略微有点不同，这是因为笔者要在故障自动切换下实现特意选择其中一台作为 active</li></ul><hr><h2 id="2-5-HBase-管理脚本"><a href="#2-5-HBase-管理脚本" class="headerlink" title="2.5 HBase 管理脚本"></a>2.5 HBase 管理脚本</h2><p><strong>1. 文件名</strong>：hbase-manager.sh</p><p><strong>2. 功能</strong>：启动、关闭 HBase 集群</p><p><strong>3. 内容</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>HMaster_1=master5HMaster_2=master52start_time=`date +%s`SLAVES=$(cat slaves)<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">HRegionServer</span></span> ()&#123;        <span class="hljs-keyword">for</span> slave <span class="hljs-keyword">in</span> <span class="hljs-variable">$SLAVES</span>        <span class="hljs-keyword">do</span>                ssh -t <span class="hljs-variable">$slave</span> <span class="hljs-string">&quot;/usr/local/cluster/hbase/bin/hbase-daemon.sh <span class="hljs-variable">$1</span> regionserver&quot;</span>        <span class="hljs-keyword">done</span>&#125;<span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>        start)  ssh -t <span class="hljs-variable">$&#123;HMaster_1&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hbase/bin/hbase-daemon.sh start master&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;HMaster_2&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hbase/bin/hbase-daemon.sh start master&quot;</span> ;                HRegionServer   start                ;;        stop)   HRegionServer   stop                ssh -t <span class="hljs-variable">$&#123;HMaster_2&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hbase/bin/hbase-daemon.sh stop master&quot;</span> ;                ssh -t <span class="hljs-variable">$&#123;HMaster_1&#125;</span> <span class="hljs-string">&quot;/usr/local/cluster/hbase/bin/hbase-daemon.sh stop master&quot;</span> ;                ;;        * )     <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Usage: sh hbase-manager.sh &#123;start|stop&#125; ^_^\n&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span>;;<span class="hljs-keyword">esac</span>end_time=`date +%s`elapse_time=$((<span class="hljs-variable">$&#123;end_time&#125;</span>-<span class="hljs-variable">$&#123;start_time&#125;</span>))<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n<span class="hljs-variable">$1</span> Hbase Server takes <span class="hljs-variable">$&#123;elapse_time&#125;</span> seconds\n&quot;</span></code></pre><hr><h2 id="2-7-整个集群管理脚本"><a href="#2-7-整个集群管理脚本" class="headerlink" title="2.7 整个集群管理脚本"></a>2.7 整个集群管理脚本</h2><p><strong>1. 文件名</strong>：Bigdata-Cluster.sh</p><p><strong>2. 功能</strong>：统一启动、关闭及查看 ZooKeeper+Hadoop+HBase 大集群</p><p><strong>3. 内容</strong></p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>CLUSTER_CONF_PATH=$(<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>)</span>&quot;</span>; <span class="hljs-built_in">pwd</span>)NameNode_1=master5NameNode_2=master52SLAVE_1=slave51start_time=`date +%s`<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">showJps</span></span>() &#123;        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n**********************************************************************************&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;当前 <span class="hljs-variable">$&#123;NameNode_1&#125;</span> 上的进程为:&quot;</span> &amp;&amp; ssh -t <span class="hljs-variable">$&#123;NameNode_1&#125;</span> <span class="hljs-string">&quot;source ~/.bash_profile; jps&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n**********************************************************************************&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;当前 <span class="hljs-variable">$&#123;NameNode_2&#125;</span> 上的进程为:&quot;</span> &amp;&amp; ssh -t <span class="hljs-variable">$&#123;NameNode_2&#125;</span> <span class="hljs-string">&quot;source ~/.bash_profile; jps&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n**********************************************************************************&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;当前 <span class="hljs-variable">$&#123;SLAVE_1&#125;</span> 上的进程为:&quot;</span> &amp;&amp; ssh -t <span class="hljs-variable">$&#123;SLAVE_1&#125;</span> <span class="hljs-string">&quot;source ~/.bash_profile; jps&quot;</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;************************************************************************************&quot;</span>&#125;<span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>        start)  sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/zk-manager.sh  start ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/journal-manager.sh  start ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/hadoop-manager.sh  start ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/hbase-manager.sh  start ;                showJps                ;;        stop)   sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/hbase-manager.sh  stop ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/hadoop-manager.sh  stop ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/journal-manager.sh  stop ;                sh <span class="hljs-variable">$CLUSTER_CONF_PATH</span>/zk-manager.sh  stop ;                showJps                ;;        status) showJps                ;;        *)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Usage: sh Bigdata-Cluster.sh &#123;start|stop|status&#125; ^_^\n&quot;</span>  ;;<span class="hljs-keyword">esac</span>end_time=`date +%s`elapse_time=$((<span class="hljs-variable">$&#123;end_time&#125;</span>-<span class="hljs-variable">$&#123;start_time&#125;</span>))<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n<span class="hljs-variable">$1</span> Bigdata Cluster takes <span class="hljs-variable">$&#123;elapse_time&#125;</span> seconds\n&quot;</span></code></pre><hr><h2 id="2-8-配置文件统一分发管理脚本"><a href="#2-8-配置文件统一分发管理脚本" class="headerlink" title="2.8 配置文件统一分发管理脚本"></a>2.8 配置文件统一分发管理脚本</h2><p><strong>1. 文件名</strong>：cluster-rsync.sh</p><p><strong>2. 功能</strong>：在已经<a href="http://blog.csdn.net/u011414200/article/details/50411347">安装 rsync 服务器</a>的情况下，在配合该脚本，即可实现在主节点上修改配置文件，其他节点迅速更新 (因为采用的 <strong>增量备份</strong>)</p><p><strong>3. 内容</strong></p><pre><code class="hljs bash">!/bin/bashRSYN_SECRET_PATH=/home/hadoop5/softwares/rsyncd/rsyncd.secretsNN_STANDBY=master52SLAVES=$(cat slaves)RSYNC_PORT=1873RSYNC_SERVER=master5<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">updateHadoopConf</span></span> () &#123;        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n****************************** Hadoop **********************************************\n&quot;</span>        <span class="hljs-keyword">for</span> slave <span class="hljs-keyword">in</span> <span class="hljs-variable">$SLAVES</span>        <span class="hljs-keyword">do</span>                ssh -t <span class="hljs-variable">$&#123;slave&#125;</span> <span class="hljs-string">&quot;rsync  -avz  --port=<span class="hljs-variable">$&#123;RSYNC_PORT&#125;</span> --password-file=<span class="hljs-variable">$&#123;RSYN_SECRET_PATH&#125;</span>  <span class="hljs-variable">$&#123;RSYNC_SERVER&#125;</span>::hadoop <span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop&quot;</span> <span class="hljs-comment">#1&gt;/dev/null</span>                <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>        <span class="hljs-keyword">done</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>        ssh -t <span class="hljs-variable">$&#123;NN_STANDBY&#125;</span> <span class="hljs-string">&quot;rsync  -avz  --port=<span class="hljs-variable">$&#123;RSYNC_PORT&#125;</span> --password-file=<span class="hljs-variable">$&#123;RSYN_SECRET_PATH&#125;</span>  <span class="hljs-variable">$&#123;RSYNC_SERVER&#125;</span>::hadoop <span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop&quot;</span> <span class="hljs-comment">#1&gt;/dev/null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">updateHbaseConf</span></span> () &#123;        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n***************************** Hbase **********************************************\n&quot;</span>        <span class="hljs-keyword">for</span> slave <span class="hljs-keyword">in</span> <span class="hljs-variable">$SLAVES</span>        <span class="hljs-keyword">do</span>                ssh -t <span class="hljs-variable">$&#123;slave&#125;</span> <span class="hljs-string">&quot;rsync  -avz  --port=<span class="hljs-variable">$&#123;RSYNC_PORT&#125;</span> --password-file=<span class="hljs-variable">$&#123;RSYN_SECRET_PATH&#125;</span>  <span class="hljs-variable">$&#123;RSYNC_SERVER&#125;</span>::hbase <span class="hljs-variable">$HBASE_HOME</span>/conf&quot;</span> <span class="hljs-comment">#1&gt;/dev/null</span>                <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>        <span class="hljs-keyword">done</span>        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\n&quot;</span>        ssh -t <span class="hljs-variable">$&#123;NN_STANDBY&#125;</span> <span class="hljs-string">&quot;rsync  -avz  --port=<span class="hljs-variable">$&#123;RSYNC_PORT&#125;</span> --password-file=<span class="hljs-variable">$&#123;RSYN_SECRET_PATH&#125;</span>  <span class="hljs-variable">$&#123;RSYNC_SERVER&#125;</span>::hbase <span class="hljs-variable">$HBASE_HOME</span>/conf&quot;</span> <span class="hljs-comment">#1&gt;/dev/null</span>&#125;<span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span>        hadoop) updateHadoopConf ;;        hbase)  updateHbaseConf ;;        all )   updateHadoopConf;updateHbaseConf ;;        *)      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;Usage: sh cluster-rsync.sh &#123;hadoop|hbase|all&#125; ^_^\n&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> ;;<span class="hljs-keyword">esac</span></code></pre><hr><h1 id="三-验证"><a href="#三-验证" class="headerlink" title="三. 验证"></a>三. 验证</h1><h2 id="3-1-同步集群配置文件"><a href="#3-1-同步集群配置文件" class="headerlink" title="3.1 同步集群配置文件"></a>3.1 同步集群配置文件</h2><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> <span class="hljs-keyword">cluster</span>-rsync.<span class="hljs-keyword">sh</span>  all</code></pre><p><img src="http://img.blog.csdn.net/20151231172254625" alt="这里写图片描述"></p><hr><h2 id="3-2-启动整个大集群"><a href="#3-2-启动整个大集群" class="headerlink" title="3.2 启动整个大集群"></a>3.2 启动整个大集群</h2><p><strong>1. 启动前查看大集群的状态</strong></p><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> Bigdata-<span class="hljs-keyword">Cluster</span>.<span class="hljs-keyword">sh</span> status</code></pre><p><img src="http://img.blog.csdn.net/20151231172420172" alt="这里写图片描述"></p><p><strong>2. 启动大集群</strong></p><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> Bigdata-<span class="hljs-keyword">Cluster</span>.<span class="hljs-keyword">sh</span> start</code></pre><p><img src="http://img.blog.csdn.net/20151231183436363" alt="这里写图片描述"></p><p><strong>3. 启动后的进程</strong></p><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> Bigdata-<span class="hljs-keyword">Cluster</span>.<span class="hljs-keyword">sh</span> status</code></pre><p><img src="http://img.blog.csdn.net/20151231183827846" alt="这里写图片描述"></p><p><strong>4. 关闭大集群</strong></p><pre><code class="hljs stata"><span class="hljs-keyword">sh</span> Bigdata-<span class="hljs-keyword">Cluster</span>.<span class="hljs-keyword">sh</span> stop</code></pre><p><img src="http://img.blog.csdn.net/20151231184629344" alt="这里写图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HDFS HA(High Availability)高可用性</title>
    <link href="/07-Bigdata/01-Hadoop/HDFS%20HA(High%20Availability)%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
    <url>/07-Bigdata/01-Hadoop/HDFS%20HA(High%20Availability)%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>HDFS HA(High Availability)高可用性<br>参考文献：<br>####<a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html">官方文档</a><br>####<a href="http://savagegarden.iteye.com/blog/1464504">全文翻译</a><br>####<a href="http://www.cnblogs.com/nucdy/p/5892196.html">Hadoop组件之-HDFS(HA实现细节)</a><br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170709180827650-225612677.png"><br>这张图片的个人理解<br>由于NameNode在Hadoop1只有一个节点，可能存在(SPOF)single point of file单节点故障。包括机器故障，软件硬件升级等。<br>在Hadoop2砍死你使用两台机器配置为NameNode，在任何时候，只有一个处于Active状态。为了保证两个NameNode节点的数据统一性，1：datanode同时向两个NameNode发送心跳和块报告；2：NameNode中磁盘存储的文件主要有镜像文件和编辑日志，通过JournalNode日志节点保证edits文件的可靠性。如下图：</p><center>![](http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170709182235228-2073804790.png)</center><center>无ZKFC</center><center>![](http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170710113906134-727438154.jpg)</center><center>有ZKFC</center>active的NameNode向JournalNode写如日志文件，standby的NameNode读取JournalNode中的数据，以达到编辑日志文件的同步。通过Zookeeper的ZKFailoverContral来监控active的健康状态，一旦出现问题，安排Client访问第二个NameNode，从而实现熱备。<p>###需要配置的四个地方（遵循官方文档即可）<br>    1.share edits<br>        JournalNode<br>    2.NameNode<br>        Active,Standby<br>    3.Client<br>        Proxy代理(Zookper)<br>    4.fence(篱笆)<br>        同一时刻仅有一个NameNode对外提供服务<br>        隔离方式：<br>            SSHfence:两个NameNode之间相互能够无密码登录<br><a href="http://www.cnblogs.com/cenzhongman/p/7143700.html">hdfs-site.xml</a><br><a href="http://www.cnblogs.com/cenzhongman/p/7143707.html">core-site.xml</a><br>###启动HA<br>    #1.在各个journalnode节点上启动journalNode服务<br>    $ sbin/hadoop-daemon.sh start journalnode<br>    #2.在nn1上对其进行格式化并启动<br>    $ bin/hdfs namenode -format<br>    $ sbin/hadoop-daemon.sh start namenode<br>    #3.在nn2上同步nn1上的源数据<br>    $ bin/hdfs namenode -bootstrapStandby<br>    #4.在nn2上启动NameNode节点<br>    $ sbin/hadoop-daemon.sh start namenode<br>    #此时，两个节点都是standby状态<br>    #5.将nn1节点的NameNode设置为activity<br>    $ bin/hdfs haadmin -transitionToActive nn1<br>    #获取状态<br>    $ bin/hdfs haadmin -getServiceState nn1<br>    #6.开启各个节点的DataNode<br>    $ sbin/hadoop-deamon.sh start datanode</p><p>集群规划</p><table><thead><tr><th>123</th><th>124</th><th>125</th></tr></thead><tbody><tr><td>NameNode</td><td>NameNode</td><td></td></tr><tr><td>ZKFC</td><td>ZKFC</td><td></td></tr><tr><td>JournalNode</td><td>JournalNode</td><td>JournalNode</td></tr></tbody></table><pre><code>不需要SecondaryNameNode，因为不会出现重启情况</code></pre><p>####Zookeeper用于自动故障转移<br>配置依据官方文档即可<br>###启动带监控的HDFS HA服务器集群<br>    #1.关闭所有hdfs服务<br>    #2.启动ZK集群<br>    $ bin/zkServer.sh start<br>    #3.初始化HA在ZooKeeper中状态<br>    $ bin/hdfs zkfc -formatZK<br>    #4.启动HDFS文件系统，看到所有的NameNode节点上多了一个DFSZKFailoverController即zkfc启动成功<br>    可以通过kill -9 1234来验证</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop2.8.0 源码编译</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop2.8.0%20%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop2.8.0%20%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>###一、下载源码并解压<br>###二、检查以下几项</p><ul><li><p>必须有网络！！！</p></li><li><p>JDK 1.7+<br><a href="http://blog.csdn.net/licongcong_0224/article/details/12756959">安装方法</a><br>  java -version</p></li><li><p>Maven 3.0 or later<br><a href="http://www.cnblogs.com/cenzhongman/p/7093672.html">安装方法</a><br>  mvn -version</p></li><li><p>Findbugs 1.3.9，需要解压到/usr/share/目录下，并添加环境变量<br><a href="https://dun.so/linux-ubuntu-14-04-findbugs/">安装方法</a></p></li><li><p>ProtocolBuffer 2.5.0 必须是这个版本，官方文档的方法会安装最新版本2.6.1<br><a href="http://www.cnblogs.com/cenzhongman/p/7191094.html">安装方法</a><br>  protoc –version</p></li><li><p>Native libraries<br>  $ sudo apt-get -y install build-essential autoconf automake libtool cmake zlib1g-dev pkg-config libssl-dev</p></li><li><p>安装ant<br>  $ sudo apt-get install ant</p></li></ul><p>###三、运用maven编译源码</p><pre><code># 此处为一个例子，一切以文档为准，添加snappy(官方编译版本无)$ mvn package -Pdist,native,docs,src -DskipTests -Dtar -Drequire.snappy</code></pre><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170717181552113-1774108765.png"><br>中间经历了好几次错误，耗时两天。</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop三大发行版本</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E4%B8%89%E5%A4%A7%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E4%B8%89%E5%A4%A7%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>#<a href="http://hadoop.apache.org/">apache</a><br><img src="http://hadoop.apache.org/images/hadoop-logo.jpg"></p><pre><code>提供基础版本</code></pre><p>#<a href="https://www.cloudera.com/">cloudera</a><br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170710171547743-266162854.jpg"></p><pre><code>主要是修改Hadoop，提供更加稳定的发行版本，以及可视化的管理服务，主要产品如下：CDH:Cloudera Distributed HadoopCloudera Manager 集群分发管理监控平台Cloudera Support</code></pre><p>#<a href="https://hortonworks.com/">Hortonworks</a><br><img src="https://2xbbhjxc6wk3v21p62t8n4d4-wpengine.netdna-ssl.com/wp-content/themes/hortonworks/images/svg/ui_logo.svg"></p><pre><code>贡献了 Hadoop **80%** 的源码，厉害了大雅虎！文档写得很好，主要产品如下：HDP Hortonworks Data Plafrom    Ambari 一款开源的安装和管理系统</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop出现的错误及处理</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%8F%8A%E5%A4%84%E7%90%86/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>###1.local host is: (unknown); destination host is: “yun-ubuntu”:8031;<br>原因：yun-ubuntu这个host 并不能ping通</p><pre><code>  $ ping yun-ubuntu  $ SHUTDOWN_MSG: Shutting down NodeManager at localhost/127.0.0.1</code></pre><p>解决办法：</p><pre><code>    $ vi /etc/hosts    增加127.0.0.1的映射</code></pre><p>###2.多次初始化NameNode导致DataNode启动失败<br><a href="blog.csdn.net/zhangt85/article/details/42078347">datanode的clusterID 和 namenode的clusterID 不匹配</a></p><p>###3.默认进入safemode ,由于块错误率阈值太高<br><a href="http://www.cnblogs.com/cenzhongman/p/7188337.html">进入saftmode解决方案</a></p><p>###异常：Class org.apache.hadoop.hive.contrib.serde2.RegexSerDe not found<br>原因：hive找不到正则的包  hive-contrib-x.x.x.jar<br>解决：临时配置包路径 add jar /opt/softwares/hive-1.2.2/lib/hive-contrib-1.2.2.jar，永久配置路径</p>  <!--添加正则表达式的包--><pre><code>&lt;property&gt;  &lt;name&gt;hive.aux.jars.path&lt;/name&gt;  &lt;value&gt;file:///opt/softwares/hive-1.2.2/lib/hive-contrib-1.2.2.jar&lt;/value&gt;  &lt;description&gt;Added by tiger.zeng on 20120202.These JAR file are available to all users for all jobs&lt;/description&gt;&lt;/property&gt;</code></pre><p>###异常：No enum constant org.apache.hadoop.hive.ql.io.orc.CompressionKind.snappy<br>原因：版本不同包名改变？<br>解决：重新创建子表<br>(“orc.compress”=”snappy”) –&gt; (“orc.compression”=”snappy”)</p><p>###腾讯云namenode启动失败<br>原因：hopsts中无法绑定公网IP地址，本机地址需要用内网IP</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop各种进程的配置文件及其位置说明</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%90%84%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%90%84%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BD%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>hdfs</p><pre><code>DameNode    core-site.xml        &lt;!--设置主机的IP和端口--&gt;        &lt;property&gt;            &lt;name&gt;fs.defaultFS&lt;/name&gt;            &lt;value&gt;hdfs://cen-ubuntu:8020&lt;/value&gt;        &lt;/property&gt;DataNode    slaves        cen-ubuntuSecondaryNameNode    hdfs-site.xml        &lt;property&gt;            &lt;name&gt;dfs.namenode.secondary.https-address&lt;/name&gt;            &lt;value&gt;cen-ubuntu:50091&lt;/value&gt;        &lt;/property&gt;</code></pre><p>YARN</p><pre><code>Resourcemanager    yarn-site.xml        &lt;!--配置nodemaneger服务--&gt;        &lt;property&gt;            &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;            &lt;value&gt;mapreduce_shuffle&lt;/value&gt;        &lt;/property&gt;NodeManager    slaves        cen-ubuntu</code></pre><p>MapReduce HistoryServer</p><pre><code>jobHistory    mapred-site.xml        &lt;property&gt;            &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;            &lt;value&gt;0.0.0.0:10020&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;            &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;            &lt;value&gt;0.0.0.0:19888&lt;/value&gt;        &lt;/property&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop启动方式</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>###启动方式<br>####1.逐一启动</p><pre><code>hdfs    hadoop-daemon.sh start|stop namenode|datanode|secondrynamenodeyarn    yarn-daemon.sh start|stop resourcemanager|nodemanagermapreduce    mr-historyserver-daemon.sh start|stop historyserver</code></pre><p>####2.使用现成脚本,按模块启动</p><pre><code>hdfs    start-dfs.sh    stop-dfs.shyarn    start-yarn.sh    stop-yarn.shmapreduce跟上面一致</code></pre><p>####3.实现现成脚本，全部一起启动</p><pre><code>start-all.sh    stop-all.sh</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop学习笔记</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><p>##Hadoop生态系统图解<a href="http://www.cnblogs.com/cenzhongman/p/6921978.html">&gt;&gt;&gt;</a></p><p>####什么是Hadoo   <a href="http://www.cnblogs.com/cenzhongman/p/6775371.html">&gt;&gt;&gt;</a><br>####hdfs文件系统架构详解<a href="http://www.cnblogs.com/cenzhongman/p/7055390.html">&gt;&gt;&gt;</a><br>####YARN框架详解<a href="http://www.cnblogs.com/cenzhongman/p/7125342.html">&gt;&gt;&gt;</a><br>####MapReduce执行流程及程序编写<a href="http://www.cnblogs.com/cenzhongman/p/7128140.html">&gt;&gt;&gt;</a></p><hr><p>##Hadoop本地安装<a href="http://www.cnblogs.com/cenzhongman/p/6925520.html">&gt;&gt;&gt;</a></p><p>####安装配置文件解析<a href="http://www.cnblogs.com/cenzhongman/p/7052425.html">&gt;&gt;&gt;</a><br>####Hadoop三种启动方式<a href="http://www.cnblogs.com/cenzhongman/p/7052413.html">&gt;&gt;&gt;</a></p><hr><p>##Hadoop开发<a href="">&gt;&gt;&gt;</a></p><p>####Maven搭建Hadoop开发环境<a href="http://www.cnblogs.com/cenzhongman/p/7093672.html">&gt;&gt;&gt;</a><br>####Maven下从HDFS文件系统读取文件内容<a href="http://www.cnblogs.com/cenzhongman/p/7096028.html">&gt;&gt;&gt;</a><br>####MapReduce执行流程及程序编写<a href="http://www.cnblogs.com/cenzhongman/p/7128140.html">&gt;&gt;&gt;</a><br>####自定义MapReduce中数据类型<a href="http://www.cnblogs.com/cenzhongman/p/7133904.html">&gt;&gt;&gt;</a></p><hr><p>##Hadoop分布式搭建<a href="http://www.cnblogs.com/cenzhongman/p/7138064.html">&gt;&gt;&gt;</a><br>####Hadoop集群时间同步<a href="http://www.cnblogs.com/cenzhongman/p/7141330.html">&gt;&gt;&gt;</a></p><hr><p>####学习过程出现的错误及处理<a href="http://www.cnblogs.com/cenzhongman/p/7050635.html">&gt;&gt;&gt;</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop安装</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>###最好的安装手册<br><a href="http://hadoop.apache.org/docs/r2.5.2/hadoop-project-dist/hadoop-common/SingleCluster.html">Hadoop官方文档2.5.2</a></p><p>###1.安装jdk<br><a href="http://blog.csdn.net/licongcong_0224/article/details/12756959">JDK安装</a><br>###2.配置java环境变量</p><pre><code>$vi /etc/profile#在末尾添加以下内容#JAVA_HOMEexport JAVA_HOME=/usr/java/jre1.8.0_131    export PATH=$PATH:$JAVA_HOME/bin</code></pre><p>###3.hadoop下载与安装<br><a href="http://archive.apache.org/dist/">apache仓库地址</a></p><p>本次试验安装版本为2.5.0</p><p>Unpack the downloaded Hadoop distribution. In the distribution, edit the file etc/hadoop/hadoop-env.sh to define some parameters as follows:（按照以下说明修改安装路径的etc/hadoop/hadoop-env.sh文件）</p><pre><code>  # set to the root of your Java installation(修改JAVA_HOME的路径)  export JAVA_HOME=/usr/java/latest  # Assuming your installation directory is /usr/local/hadoop(设置你的安装路径，可以忽略这一步)  export HADOOP_PREFIX=/usr/local/hadoop</code></pre><p>这样，你就已经装好了Hadoop</p><p>###I 单节点运行(Standalone Operation)</p><pre><code>    By default, Hadoop is configured to run in a non-distributed mode, as a single Java process. This is useful for debugging.    The following example copies the unpacked conf directory to use as input and then finds and displays every match of the given regular expression. Output is written to the given output directory.（Hadoop默认就是单节点模式，就像一个单独的Java进程，下面是一个使用Hadoop跑一个程序的例子）  $ mkdir input  $ cp etc/hadoop/*.xml input  $ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.5.2.jar grep input output &#39;dfs[a-z.]+&#39;  # 启动Hadoop 文件，传入参数jar   从example包打开一个范例 grep 设置输入输出文件目录，设置参数  $ cat output/*</code></pre><p>###II 伪分布式的搭建(Pseudo-Distributed Operation)<br>Hadoop can also be run on a single-node in a pseudo-distributed mode where each Hadoop daemon runs in a separate Java process.<br>(hadoop)也可以在一台机器上模拟分布式模式</p><p>####Configuration</p><p>Use the following:(修改以下文件)<br><a href="http://hadoop.apache.org/docs/r2.5.2/hadoop-project-dist/hadoop-common/core-default.xml">core-site.xml文件的全部属性</a></p><p>etc/hadoop/core-site.xml:</p><pre><code>&lt;configuration&gt;    &lt;!--设置主机的IP和端口--&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:8020&lt;/value&gt;    #老师说习惯用8020端口，还要改主机名。我就暂时不改吧，看看再说    &lt;/property&gt;    &lt;!--设置临时文件的存储目录--&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/opt/modules/hadoop-2.5.0/data/tmp&lt;/value&gt;     &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>etc/hadoop/hdfs-site.xml:(HDFS文件系统配置文件)<br>    <a href="http://hadoop.apache.org/docs/r2.5.2/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hdfs-site.xml全部属性</a></p><pre><code>&lt;!--修改备份文件数量为1，因为只有一台机子，默认的3份没卵用--&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>需要设置ssh才能继续后面的工作<br>Execution</p><p>The following instructions are to run a MapReduce job locally. If you want to execute a job on YARN, see YARN on Single Node.</p><pre><code>1.Format the filesystem:（格式化文件系统,这Y好像只能执行一次，以后不用执行）  $ bin/hdfs namenode -format2.Start NameNode daemon and DataNode daemon:（启动 NameNode  和 DataNode ）  $ sbin/start-dfs.sh  The hadoop daemon log output is written to the $HADOOP_LOG_DIR directory (defaults to $HADOOP_HOME/logs).  or(老师说用第二种方法)  $sbin/hadoop-deamon.sh start namenode   $sbin/hadoop-deamon.sh start datanode  这时候使用jps可以查看Java进程,有 NameNode DataNode 进程  这里如果出现问题可能是文件没有更新或者JDK安装错误3.Browse the web interface for the NameNode; by default it is available at:(使用浏览器打开localhost:50070可以查看可视化界面)    NameNode - http://localhost:50070/4.Make the HDFS directories required to execute MapReduce jobs:（使用 dfs 创建用户目录）  $ bin/hdfs dfs -mkdir /user  $ bin/hdfs dfs -mkdir /user/&lt;username&gt;  or  $ bin/hdfs dfs -mkdir -p /user/username/        # -p 同时多个目录  #使用命令行查看  $ bin/hdfs dfs -ls -R /                             # -R 递归查看 后面必须加上路径，否则为 . 即当前目录 4.Copy the input files into the distributed filesystem:（复制输出目录到hdfs系统，其实你完全可以自己创建一个）  $ bin/hdfs dfs -put etc/hadoop input5.Run some of the examples provided:（运行范例）  $ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.5.2.jar grep input output &#39;dfs[a-z.]+&#39;  #（这里建议还是写绝对路径的）7.Examine the output files:（查看结果）  Copy the output files from the distributed filesystem to the local filesystem and examine them:  $ bin/hdfs dfs -get output output  $ cat output/*or  View the output files on the distributed filesystem:  $ bin/hdfs dfs -cat output/*8.When you&#39;re done, stop the daemons with:（关闭dfs）  $ sbin/stop-dfs.sh</code></pre><p>###YARN配置及启动<br>####1.YARN配置环境文件etc/hadoop/yarn-env.sh文件</p><pre><code>#配置JAVA_HOMEexport JAVA_HOME=/usr/java/jdk1.8.0_131/</code></pre><p>####2.配置etc/hadoop/yarn-site.xml文件</p><pre><code>&lt;!--配置nodemaneger服务--&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;&lt;!--配置主机名--&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;        &lt;value&gt;cen-ubuntu&lt;/value&gt;    &lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;        &lt;value&gt;true&lt;/value&gt;    &lt;/property&gt; </code></pre><p>####3.配置slaves（奴隶）文件</p><pre><code>&lt;!--填写主机名--&gt;cen-ubuntu</code></pre><p>####4.启动YARN</p><pre><code>$sbin/yarn-daemon.sh start resourcemanager$sbin/yarn-daemon.sh start nodemanager可视化界面cen-ubuntu:8088</code></pre><p>###在YARN上运行MapReduce<br>####1.配置etc/hadoop/mapred-env.sh文件（mapred环境配置）</p><pre><code>配置JAVA_HOME</code></pre><p>####2.配置etc/hadoop/mapred-site.xml</p><pre><code>&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p>####3.在YARN上运行MapReduce</p><pre><code>bin/yarn jar ...跟上面步骤一样。。。注意：output文件夹不能存在，否则报错</code></pre><p>####4.启动历史服务</p><pre><code>$ sbin/mr-jobhistory-deamon.sh start historyservice</code></pre><p>####5.启动Aggregation（日志聚集）功能</p><pre><code>修改yran-site.sh文件（看官方文档）</code></pre><p>####6.设置日志文件保存时间（同上）</p><pre><code>yarn.log-aggregation.retain-seconds</code></pre><p>到这里，Hadoop已经成功地运行在HDFS文件系统之上，中间过程太坎坷，但是都度过来了，大象会跳舞，加油</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop常用高级特性</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>###HDFS HA<br><a href="http://www.cnblogs.com/cenzhongman/p/7142409.html">HDFS HA(High Availability)高可用性</a><br>###相同版本拷贝工具，分布式集群拷贝工具，使用MapReduce实现<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-distcp/DistCp.html">DistCp Version2 Guide</a><br>###HFTP协议，用于不同版本Hadoop拷贝 For example, you can do things like: hadoop distcp -i h<a href="ftp://sourcefs:50070/src">ftp://sourceFS:50070/src</a> hdfs://destFS:8020/dest<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/Hftp.html">HFTP Guide</a><br>###HDFS联盟，用于多NameNode节点共用一套DataNode系统<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/Federation.html">HDFS Federation</a><br>###文件系统快照，可用于存储一个时间点的文件系统情况，用于数据备份，防止用户错误和容灾<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/HdfsSnapshots.html">HDFS Snapshots</a><br>###集中式缓管理系统，用于频繁使用的文件存储在NameNode节点的内存中，如hive中的fact表<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/CentralizedCacheManagement.html">Centralized Cache Management</a><br>###YARN的ResourceManager HA 生产环境需要，防止单一节点的RM错误导致集群奔溃<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-yarn/hadoop-yarn-site/ResourceManagerHA.html">ResourceManager High Availability</a><br>###设置机器重启后从继续工作，ResourceManager Restart<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-yarn/hadoop-yarn-site/ResourceManagerRestart.html">ResourceManager Restart</a></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop生态系统图解</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>##Hadoop生态架构图<br><img src="http://images2015.cnblogs.com/blog/1047249/201705/1047249-20170531113639993-1977347120.png" alt="Hadoop生态架构图"></p><p>参考文章：<br>        <a href="http://blog.csdn.net/woshiwanxin102213/article/details/19688393">Hadoop生态系统介绍 </a></p><p>###HDFS架构<br><img src="http://images2015.cnblogs.com/blog/1047249/201705/1047249-20170531003024086-1644047367.png" alt="HDFS架构"></p><pre><code>1.NaneDode:主节点，**存储文件的元数据**如文件名，文件目录结构，文件属性（生成时间，副本数量，文件权限），以及每个文件的块列表所在DataNode等    一个JAVA进程：数据存储在内存中，为了速度读写（本地还有备份）        本地磁盘：1、fsimage:镜像文件                  2、edits  :编辑日志2.DataNode:数据节点，实际的本地文件系统，**存储文件块数据，以及快数据的检验和**    真正的存储：数据在磁盘中3.Secondary NameNode用来**监控HDFS状态的辅助后台程序**，每隔一段时间**获取HDFS元数据快照**，就是定时对本地磁盘的 NameNode 的 fsimage 和 edits 进行合并，不断更新镜像</code></pre><p>###数据以block方式存储<br>    Hadoop2.x块大小：128M</p><p>参考文章：<br>        <a href="http://www.open-open.com/lib/view/open1376228205209.html">HDFS 原理、架构与特性介绍</a><br>    <a href="http://www.open-open.com/lib/view/open1328763454608.html">谷歌三大核心技术（一）Google File System中文版</a></p><p>###YARN架构<br><img src="http://images2015.cnblogs.com/blog/1047249/201705/1047249-20170531005943993-81105951.png"></p><pre><code>1.ResourceManager         资源管理者        *接收客户端请求    *启动/监控ApplicationMaster    *监控NodeManager    *资源分配与调度2.NodeManager             节点管理者    *管理节点资源    *处理来自ResourceManager的任务    *处理来自ApplicationMaster的任务3.ApplicationMaster     应用主管    *数据切分    *为应用程序向ResourceManager提出资源申请，并分配给内部任务    *任务监控与容错4.container             容器    *对任务运行环境的抽象，封装了CPU,内存等多维资源以及环境变量，启动命令等运行任务的相关信息</code></pre><p>参考文章：<br>        <a href="http://www.open-open.com/lib/view/open1453097214370.html">Hadoop构架概览</a></p><p>###MapReduce框架（离线运算框架）</p><pre><code>1.将数据计算过程分为两个阶段 Map 和 Reduce    *Map将数据进行并行处理    *Reduce将处理结果进行汇总2.shuffle 连接 Map 和 Reduce 阶段    *Map Task 将数据存储到本地磁盘    *Reduce Task 将数据从 Map Task 上读一份数据特点：    *仅适合离线数据处理，有极高的容错性和拓展性，适合简单批处理任务    *启动开销大，过多使用磁盘导致效率低下</code></pre><p>###MapReduce on YRAN<br><img src="http://images2015.cnblogs.com/blog/1047249/201705/1047249-20170531011621039-1893688724.png"><br>从客户端到客户端中间的过程详解图</p><p>注：图片来源见水印，侵删</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop集群时间同步</title>
    <link href="/07-Bigdata/01-Hadoop/Hadoop%E9%9B%86%E7%BE%A4%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    <url>/07-Bigdata/01-Hadoop/Hadoop%E9%9B%86%E7%BE%A4%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>7788###1.安装ntp服务<br>    $ sudo apt-get install ntp<br>###2.修改配置文件<br>参考<a href="http://blog.csdn.net/bluishglc/article/details/41413031">配置NTP服务ntpd/ntp.conf（搭建Hadoop集群可参考）</a><br>    $ vim /etc/ntp.conf</p><pre><code>#配置客户端的授权，也就是给指定的机器（客户端）设置访问NTP Server的权限，这是通过restrict配置项实现的#local network net ---czmrestrict 192.168.2.0 mask 255.255.255.0 nomodify notrap#如果集群是在一个封闭-的局域网内，可以屏蔽掉默认的server:#we don&#39;t need internet time server---czm #pool 0.ubuntu.pool.ntp.org iburst#pool 1.ubuntu.pool.ntp.org iburst#pool 2.ubuntu.pool.ntp.org iburst#pool 3.ubuntu.pool.ntp.org iburst#将本机的本地时钟作为时间供给源，这样，即便它失去网络连接，它也可以继续为网络提供服务#local server ---czmserver 127.127.1.0fudge 127.127.1.0 stratum 10</code></pre><p>###3.启动服务<br>    $ service ntpd start<br>###4.非服务器主机设置定时时间同步任务(root任务)<br>    $ crontab -e<br>    0-59/10 * * * * /user/sbin/ntpdate TimeServerDostname</p><p>注解：然而我失败了。。。以上步骤仅供参考，我的集群时间好像是同步的，我暂时就不折腾了，以后遇到再去解决。以上步骤参考自centos ，ubuntu下试验失败</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce执行流程及程序编写</title>
    <link href="/07-Bigdata/01-Hadoop/MapReduce%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/"/>
    <url>/07-Bigdata/01-Hadoop/MapReduce%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>MapReduce<br>一种分布式计算模型，解决海量数据的计算问题，MapReduce将计算过程抽象成两个函数<br>####Map(映射):对一些独立元素（拆分后的小块）组成的列表的每一个元素进行指定的操作，可以高度并行。<br>####Reduce(化简)：对一个列表的元素进行合并</p><pre><code>input -&gt; map -&gt; reduce -&gt; output数据流通格式&lt;kay,value&gt;eg:原始数据                -&gt;    map input                 map        map output(reduce input)            shuffle                            reduce            reduce outputexample example            -&gt;    &lt;0,example example&gt;        -&gt;        &lt;example,1&gt; &lt;example,1&gt;                -&gt;        &lt;example,list(1,1,1)&gt;        -&gt;            &lt;example,3&gt;helo wrold example         -&gt;    &lt;16,helo wrold example&gt;    -&gt;         &lt;hello,1&gt; &lt;wrold,1&gt; &lt;example,1&gt;        -&gt;        &lt;hello,list(1)&gt; &lt;...&gt;        -&gt;            &lt;hello,1&gt; &lt;wrold,1&gt;</code></pre><p>##MapReduce底层执行流程<br>###一.Input<br>####InputFormat<br>    读取数据<br>    转换成&lt;key,value&gt;<br>####FileInputFormat<br>    TextInputFormat 文本初始化，一行变成一个KY对，用偏移量作为Key、<br>###二.Map<br>####ModuleMapper类继承Mapper类<br>    执行map(KEYIN,VALUEIN,KETOUT,VALUEOUT)，<br>        默认情况下<br>        KEYIN：LongWritable<br>        KEYVALUE：TEXT<br>###三.shuffle(洗牌)<br>####map，output&lt;key,value&gt;<br>    a)先存在内存中<br>    b)合并combiner[可选] -&gt;  &lt;hadoop,1&gt; &lt;hadoop,1&gt; =&gt;&gt;  &lt;hadoop,2&gt;<br>    c)spill，溢写到磁盘中，存储成很多小文件，过程如下<br>        1.分区Partition(数量跟Reduce数量一致)<br>        2.在分区内进行排序sort<br>    d)合并，Merge    -&gt;大文件(Map Task任务运行的机器的本地磁盘中)<br>    e)排序sort<br>    f)压缩[可选]<br>###四.reduce<br>####reduce Task会到Map Task运行的机器上COPY要处理的数据<br>    a)合并merge<br>    b)排序<br>    c)分组Group(相同的key的value放在一起)<br>####ModuleReduceper类继承Reduce类<br>    执行reduce(KEYIN,VALUEIN,KETOUT,VALUEOUT)<br>        map的输出类型就是reduce的输入类型，中间的shuffle只是进行合并分组排序，不会改变数据类型<br>###五.output<br>####OutputFormat<br>    写数据<br>####FileOutputFormat<br>    TextInputFormat 每个KeyValue对输出一行，key和value之间使用分隔符\t，默认调用key和value的toString方法</p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170707222631878-1355239332.png"></p><p>###代码如下：</p><pre><code>package com.cenzhongman.mapreduce;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.conf.Configured;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.Tool;import org.apache.hadoop.util.ToolRunner;//继承Configured类，从而继承了该类的getConf();line 81//实现Tool方法，实现run方法 line79//通过Toolrunner工具类的run方法实现，setConf(),达到conf传递的效果public class WordCount extends Configured implements Tool &#123;    // 1.Map class    public static class WordcountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;        private Text mapOutputKey = new Text();        private final static IntWritable mapOutputValue = new IntWritable(1);        @Override        public void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)                throws IOException, InterruptedException &#123;            // line value            String lineValue = value.toString();            // split            // String[] strs = lineValue.split(&quot; &quot;);            StringTokenizer stringTokennizer = new StringTokenizer(lineValue);            // iterator            while (stringTokennizer.hasMoreTokens()) &#123;                // get word value                String wordValue = stringTokennizer.nextToken();                // set value                mapOutputKey.set(wordValue);                // output                context.write(mapOutputKey, mapOutputValue);            &#125;        &#125;        @Override        public void cleanup(Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)                throws IOException, InterruptedException &#123;            // nothing            // 在执行map之前会执行该函数，可用于JDBC等            // Reduce同理，不再重复        &#125;        @Override        public void setup(Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)                throws IOException, InterruptedException &#123;            // nothing            // 在执行map之后会执行该函数，可用于JDBC断开等        &#125;    &#125;    // 2.Reduce class    public static class WordcountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;        private IntWritable reduceOutputValue = new IntWritable();        @Override        public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)                throws IOException, InterruptedException &#123;            // sum tmp            int sum = 0;            // iterator            for (IntWritable value : values) &#123;                // total                sum += value.get();            &#125;            // set value            reduceOutputValue.set(sum);            // output            context.write(key, reduceOutputValue);        &#125;    &#125;    // 3.driver    public int run(String[] args) throws Exception &#123;        // 1.get configuration        Configuration conf = getConf();        // 2.create Job        Job job = Job.getInstance(conf, this.getClass().getSimpleName());        // run jar        job.setJarByClass(this.getClass());        // 3.set job        // input -&gt; map -&gt; reduce -&gt; output        // 3.1 input from type        Path inPath = new Path(args[0]);        FileInputFormat.addInputPath(job, inPath);        // 3.2 map        job.setMapperClass(WordcountMapper.class);        job.setMapOutputKeyClass(Text.class);        job.setMapOutputValueClass(IntWritable.class);        //****************shuffle配置***********************        //1)Partition分区//        job.setPartitionerClass(cls);        //2)sort排序//        job.setSortComparatorClass(cls);        //combiner[可选]Map中的合并//        job.setCombinerClass(cls);        //Group分组//        job.setGroupingComparatorClass(cls);        //压缩设置在配置文件中设置，也可以在conf对象中设置        //****************shuffle配置***********************        // 3.3 reduce        job.setReducerClass(WordcountReducer.class);        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(IntWritable.class);        // 3.4 output        Path outPath = new Path(args[1]);        FileOutputFormat.setOutputPath(job, outPath);        // 4 submit job        boolean isSuccess = job.waitForCompletion(true);            //set reduce number[可选，优化方式之一，默认值为1]配置文件mapreduce.job.reduces            job.setNumReduceTasks(2);        return isSuccess ? 0 : 1;    &#125;    public static void main(String[] args) throws Exception &#123;        Configuration conf = new Configuration();        //set compress设置压缩方式，可以从官方文件和源码中得到-----可选，优化方式之一        conf.set(&quot;mapreduce.map.output.compress&quot;, &quot;true&quot;);        conf.set(&quot;mapreduce.map.output.compress.codec&quot;, &quot;org.apache.hadoop.io.compress.SnappyCodec&quot;);        // int status = new WordCount().run(args);        int status = ToolRunner.run(conf, new WordCount(), args);        System.exit(status);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven下从HDFS文件系统读取文件内容</title>
    <link href="/07-Bigdata/01-Hadoop/Maven%E4%B8%8B%E4%BB%8EHDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/"/>
    <url>/07-Bigdata/01-Hadoop/Maven%E4%B8%8B%E4%BB%8EHDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>需要注意以下几点<br>1.所以的包都是org.apache.hadoop.XXX<br>2.三个配置文件要放到指定文件夹中等待文件系统读取（src/main/resources）:core-site.xml hdfs-site.xml log4j.properties<br>3.文件路径指向要正确</p><pre><code>package com.cenzhongman.hadoop.hdfs;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class HdfsApp &#123;    /**     * to get fileSystem     *      * @return fileSystem     */    public static FileSystem getFileSystem() &#123;        // 1.read configuration information : core-site.xml core-default.xml        // hdfs-site.xml hdfs-default.xml        Configuration conf = new Configuration();        // 2.get fileSystem        org.apache.hadoop.fs.FileSystem fileSystem = null;        try &#123;            fileSystem = org.apache.hadoop.fs.FileSystem.get(conf);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 3.return fileSystem        return fileSystem;    &#125;    /**     * read data form fileSystem     *      * @param fileName     */    public static void read(String fileName) &#123;        // 1.get fileSystem        FileSystem fileSystem = getFileSystem();        System.out.println(fileSystem);        // 2.read path        Path readPath = new Path(fileName);        // 3.open file and get FSDataInputStream        FSDataInputStream inStream = null;        try &#123;            inStream = fileSystem.open(readPath);        &#125; catch (IOException e1) &#123;            e1.printStackTrace();        &#125;        // 4.read file info        try &#123;            // read            IOUtils.copyBytes(inStream, System.out, 4096, false);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            // close stream            IOUtils.closeStream(inStream);        &#125;    &#125;    public static void uploadFile(String fromFilePath, String putFilePath) &#123;        // 1.get fileSystem        FileSystem fileSystem = getFileSystem();        // 2.write path        Path weitePath = new Path(putFilePath);        // 3.Output Stream        FSDataOutputStream ourStream = null;        try &#123;            ourStream = fileSystem.create(weitePath);        &#125; catch (IOException e1) &#123;            e1.printStackTrace();        &#125;        // 4.input Stream        FileInputStream inStream = null;        try &#123;            inStream = new FileInputStream(new File(fromFilePath));        &#125; catch (FileNotFoundException e1) &#123;            // TODO Auto-generated catch block            e1.printStackTrace();        &#125;        // 5.stream read/write        try &#123;            // read            IOUtils.copyBytes(inStream, ourStream, 4096, false);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            // close stream            IOUtils.closeStream(inStream);            IOUtils.closeStream(ourStream);        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        String fileName = &quot;/tmp/hadoop-yarn/staging/history/done_intermediate/cen/job_1497948413653_0001_conf.xml&quot;;        read(fileName);        String putFilePath = &quot;/user/cen/output/file-output-test.xml&quot;;        String fromFilePath = &quot;/usr/local/hadoop-2.5.0/input/core-site.xml&quot;;        uploadFile(fromFilePath, putFilePath);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven搭建Hadoop开发环境</title>
    <link href="/07-Bigdata/01-Hadoop/Maven%E6%90%AD%E5%BB%BAHadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/07-Bigdata/01-Hadoop/Maven%E6%90%AD%E5%BB%BAHadoop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>###1.安装maven（用于管理仓库，jar包的管理）<br>    1.解压maven安装包<br>    2.把maven添加到环境变量/etc/profile<br>    3.添加maven目录下的conf/setting.xml文件到～/.m2文件夹下<br>###2.安装eclipse<br>    1.解压eclipse安装文件<br>    2.执行eclipse.inst文件<br>    3.按步骤操作<br>###3.在eclipse中配置自己的maven仓库<br>    1.window&gt;&gt;perfoemence&gt;&gt;maven&gt;&gt;installations(添加使用的maven目录，步骤1.1)<br>    add&gt;&gt;选择1.1中的路径<br>    2.window&gt;&gt;perfoemence&gt;&gt;maven&gt;&gt;User settings(选择本地仓库的配置文件，步骤1.3)<br>    Uesr Settings&gt;&gt;选择1.3中的文件<br>###4.创建maven工程<br>    1.new&gt;&gt;maven project&gt;&gt;next&gt;&gt;next&gt;&gt;Group Id:域名倒置&gt;&gt;Artfact Id:项目名&gt;&gt;finish<br>    2.添加资源文件夹(用于存储配置文件)new&gt;&gt;source floder&gt;&gt;folder name:src/main/resources<br>    3.设置resources输出目录Build path&gt;&gt;configure bulid path&gt;&gt;output foler:hdfs/target/classes<br>    4.修改pom.xml文件<br>pom.xml文件如下</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;      &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;      &lt;version&gt;2.5.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;        &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;        &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;        &lt;version&gt;2.5.1&lt;/version&gt;    &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;      &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;      &lt;version&gt;2.5.0&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>YARN框架详解</title>
    <link href="/07-Bigdata/01-Hadoop/YARN%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/07-Bigdata/01-Hadoop/YARN%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>YARN框架详解<br><a href="http://hadoop.apache.org/docs/r2.8.0/hadoop-yarn/hadoop-yarn-site/YARN.html">YARN官方解释</a><br>####YARN是什么<br>The fundamental(定义) idea of YARN is to split(分开) up the functionalities(功能) of resource management and job scheduling/monitoring(进程调度) into separate(独立) daemons(守护进程). The idea is to have a global ResourceManager (RM) and per-application ApplicationMaster (AM). An application is either a single job or a DAG(有向无环图(Directed Acyclic Graph)) of jobs.<br><img src="http://hadoop.apache.org/docs/r2.8.0/hadoop-yarn/hadoop-yarn-site/yarn_architecture.gif"></p><p>####ResourceManager<br>全局的资源管理器，整个集群只有一个，负责集群资源的统一管理和调度分配。</p><pre><code>*处理客户端请求*启动/监控ApplicationMaster*监控NodeManerger*资源分配与调度</code></pre><p>####NodeManager<br>整个集群有多个，负责单个节点的资源管理和使用</p><pre><code>*单个节点上的资源管理和任务管理*处理来自ResourceManeger的命令*处理来自ApplicationMaster的命令</code></pre><p>NodeManager管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源<br>定时向ResourceManager汇报本节点上的资源使用情况和各个Container的运行情况</p><p>####ApplicationMaster<br>管理一个在YARN内运行的应用程序的每个实例</p><pre><code>*为应用程序申请资源，进一步分配给内部任务*任务监控与容错</code></pre><p>负责协调来自ResourceManager的资源，并通过NodeManager监控容器的执行和资源使用(CPU、内存等的资源分配)</p><p>####Container<br>YARN中的资源抽象，封装某个节点上多维度资源，如内存、CPU、磁盘、网络等。当ApplicationManager向ResourceManager申请资源时便是用的Container表示的<br>YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源</p><pre><code>*对任务运行环境的抽象*描述一系列信息*任务运行资源（节点、内存、CPU）*任务启动命令*任务运行环境</code></pre><p>###资源的管理<br>(资源：CPU、内存和IO，YARN支持CPU和内存的调度，内存的多少会决定任务的生死，CPU仅仅决定了任务运行速度)<br>资源的调度和隔离是YARN作为一个资源管理系统，最重要和最基础的两个功能。资源调度由ResourceManager完成，而资源的隔离由各个NodeManager实现。<br>####资源调度<br>    ResourceManager将某个NodeManager上资源分配给任务。<br>####资源隔离<br>    NodeManager需按要求为任务提供相应的资源，甚至保证这些资源具有独占性，为任务运行提供基础的保证</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hadoop 文件合并</title>
    <link href="/07-Bigdata/01-Hadoop/hadoop%20%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6/"/>
    <url>/07-Bigdata/01-Hadoop/hadoop%20%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs sh">bin/hdfs dfs -getmerge PATH-part-0001 PATH-part-0001 file-path</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个数据仓库的设计架构</title>
    <link href="/07-Bigdata/01-Hadoop/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/07-Bigdata/01-Hadoop/%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723215645455-2139180162.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723215652971-815026177.png"></p><p>来自服务器大型 RDBMS 的数据通过 Sqoop 工具导入 HDFS/HBase<br>来自服务器的日志文件通过 Flume 工具导入 HDFS/HBase<br>数据通过 MapReduce 程序 ，Hive/pig/impala(一个类似 hive 的内存计算框架) 工具进行数据分析，并使用 Oozie/宙斯 进行任务调度<br>分析以后的数据存到HDFS上，由 sqoop 工具导入 RDBMS 中，供 WEB 服务器使用等</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>protobuf-2.5.0的下载与安装</title>
    <link href="/07-Bigdata/01-Hadoop/protobuf-2.5.0%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/01-Hadoop/protobuf-2.5.0%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>###1.下载<br>Hadoop使用protocol buffer进行通信，需要下载和安装protobuf-2.5.0.tar.gz。由于现在protobuf-2.5.0.tar.gz已经无法在官网<a href="https://code.google.com/p/protobuf/downloads/list%E4%B8%AD%E4%B8%8B%E8%BD%BD%E4%BA%86">https://code.google.com/p/protobuf/downloads/list中下载了</a><br><a href="http://pan.baidu.com/s/1gf7WnEr">下载地址</a><br>###2.安装</p><p>使用tar -zxf protobuf-2.5.0.tar.gz命令解压后得到是protobuf-2.5.0的源码，</p><pre><code>cd protobuf-2.5.0 进入目录</code></pre><p>假如你希望编译成功后输出的目录为/home/work/protobuf/ 则输入如下两条命令：</p><pre><code>./configure --prefix=/home/work/protobuf/  make &amp;&amp; make install</code></pre><p>编译成功后将export PATH=/home/work/protobuf/bin:$PATH加入到环境变量中</p><p>最后输入 protoc –version命令，如显示libprotoc 2.5.0则安装成功</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hdfs文件系统架构详解</title>
    <link href="/07-Bigdata/01-Hadoop/hdfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <url>/07-Bigdata/01-Hadoop/hdfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>###hdfs文件系统架构详解<br><a href="http://hadoop.apache.org/docs/r2.5.2/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">官方hdfs分布式介绍</a><br>####NameNode<br>    *Namenode负责文件系统的namespace以及客户端文件访问<br>    *NameNode负责文件元数据操作，DataNode负责文件内容的处理，跟文件有关的额数据不会经过NameNode<br>    *NameNode负责安排数据存在那台机器上，负责控制和调配最近的副本给用户读取（调节hdfs的balance属性，执行balance命令）<br>        For the common case, when the replication factor is three, HDFS’s placement policy is to put one replica on one node in the local rack, another on a different node in the local rack, and the last on a different node in a different rack.<br>        通常，当备份数为3的时候，HDFS的分配策略会将一个放置在本地节点，另一个放在同一个机架的不同节点上，最后一个放置在不同机架的节点上<br>    *NameNode管理数据块的复制，周期性地接收心跳包（3s/次 10分钟GG）和blockreport（1h/次）<br>####Datanode<br>    *一个块保存了两个文件1：元文件（长度，校验，时间戳） 2：数据文件<br>    *可以随时安全加入退出机器<br>    *周期性地发送心跳包（3s/次 10分钟GG）和blockreport（1h/次）<br>    datanode路径如下（由etc/hadoop/core-site.xml文件决定）<br>        data/tmp/dfs/data/current/BP-1645940924-127.0.1.1-1497948488160/current/finalized/<br>            -rw-rw-r– 1 cen cen  3589 6月  20 16:50 blk_1073741825                     #(数据文件)<br>            -rw-rw-r– 1 cen cen    39 6月  20 16:50 blk_1073741825_1001.meta        #(元数据)<br>    !!!值得一提的是，文件一旦创建，不能修改文件内容<br>####文件损坏处理<br>    *datanode读取block的时候会计算checksum<br>    *与创建时候的checksum进行比对，若不一致则执行损坏处理<br>    *让客户端读取其他datanode节点的数据<br>    *NameNode标记此block已GG，用其他块数据覆盖本节点<br>    *datanode每三周进行一次cehecksum工作<br>####HDFS-NameNode存储在<br>    *内存<br>    *本地磁盘<br>        1.fsimage(镜像文件)<br>        2.edits(编辑日志)</p><p>####第一次启动ＨＤＦＳ过程详解<br>    0-&gt; format                    (初始化文件系统)<br>    1-&gt; fsimage                    (生成镜像文件)<br>    2-&gt;　Start NameNode     　　 (启动NameNode)<br>        *read fsimage              (读取镜像文件)</p><pre><code>=======&gt;&gt;&gt; SafeMode(进入HDFS文件系统的安全模式)&lt;&lt;&lt;=======3-&gt; Start DataNode             (启动DataNode)    *注册                    (向NameNode注册)    *block report            (向Namenode反馈块报告)当 DataNodes blocks / total blocks = 99.999%    =============&gt;&gt;&gt; 30秒 CD 后退出安全模式&lt;&lt;&lt;================&lt;&lt;&lt;安全模式期间，不能改变文件系统命名空间(元数据)，如增 删 改，允许查看文件&gt;&gt;&gt;4-&gt; create dir XXX          (用户进行操作时候，内存中保存了修改，同时磁盘中修改了edits)5-&gt; put files XXX            (同上)6-&gt; delete files XX　        (同上)</code></pre><p>####第二次启动ＨＤＦＳ<br>    1-&gt; NameNode<br>        *read fsimage            (读取镜像文件)<br>        *read edits                (读取编辑日志)<br>        *gen write fsimage        (合并编辑日志，生成新的镜像文件，替换原来的文件)<br>        *gen write edits        (生成空的编辑日志，替换原来的文件)<br>    2-&gt; DataNode<br>    …<br>    …<br>    …</p><h4 id="SecondaryNameNode"><a href="#SecondaryNameNode" class="headerlink" title="SecondaryNameNode"></a>SecondaryNameNode</h4><pre><code> 功能：定时合并编辑日志和镜像文件，用于辅助NameNode</code></pre><p>###手动进入安全模式<br>        bin/hdfs dfsadmin -safemode &lt;enter | leave | get | wait&gt;<br>                                                        进入   |离开   |查看状态|等待|</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进入saftmode解决方案</title>
    <link href="/07-Bigdata/01-Hadoop/%E8%BF%9B%E5%85%A5saftmode%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/07-Bigdata/01-Hadoop/%E8%BF%9B%E5%85%A5saftmode%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>Name node is in safe mode.The reported blocks 356 needs additional 2 blocks to reach the threshold 0.9990 of total blocks 358. Safe mode will be turned off automatically.<br>解决办法：<br>法一、暴力的直接将整个文件系统格式化：hdfs namenode -format<br>法二、将其控制安全模式的阀值调小:dfs.safemode.threshold.pct<br> (将其该值调整整)<br>法三、使用命令离强制开安全模式然后再检测损坏block并删除：<br>第一步.<br> hdfs dfsadmin -safemode leave (强制离开安全模式)<br>第二步.<br> hdfs fsck / -delete (删除掉损坏的blocks)<br> 如果想修复，可以使用linux的/sbin/fsck修复工具。</p><p>静态或者动态增加节点：<br>hdfs dfsadmin -refreshNodes<br>start-balancer.sh</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>01-Hadoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-使用IDEA创建和打包Spark工程</title>
    <link href="/07-Bigdata/04-Spark/00-%E4%BD%BF%E7%94%A8IDEA%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%93%E5%8C%85Spark%E5%B7%A5%E7%A8%8B/"/>
    <url>/07-Bigdata/04-Spark/00-%E4%BD%BF%E7%94%A8IDEA%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%93%E5%8C%85Spark%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA的使用"><a href="#IDEA的使用" class="headerlink" title="IDEA的使用"></a>IDEA的使用</h1><h2 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h2><p><a href="http://spark.apache.org/developer-tools.html">官方指导</a></p><h2 id="创建Spark应用"><a href="#创建Spark应用" class="headerlink" title="创建Spark应用"></a>创建Spark应用</h2><h3 id="创建Spark应用-1"><a href="#创建Spark应用-1" class="headerlink" title="创建Spark应用"></a>创建Spark应用</h3><p>1.创建maven应用</p><p><img src="00-01.png"></p><p>2.通过GAV定位maven包<br><img src="00-02.png"></p><p>3.设置maven的配置文件<br><img src="00-03.png"></p><p>4.设置文件夹<br><img src="00-04.png"></p><p>5.设置Scala版本信息</p><p>6.删除两个scala-tools.org</p><p>7.删除junit</p><p>8.删除specs</p><p>9.删除test&amp;main路径下包下面的所有文件</p><p>10.添加spark的依赖包(参考官网)</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.spark<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spark-core_2.11<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>11.如果用到cloudera的包，需要导入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>cloudera<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>cloudera repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre><p>11.添加文件夹<br>File &gt;&gt; Project Structure &gt;&gt; Modules<br><img src=""></p><p>12.打包应用</p><p><img src="00-05.png"></p><h3 id="打包Spark应用"><a href="#打包Spark应用" class="headerlink" title="打包Spark应用"></a>打包Spark应用</h3><ol><li>project structure</li><li>Artifacts</li><li>Add<br><img src="../%E6%89%93%E5%8C%85sparkApp.png"></li><li>选择Main Claas</li><li>删除所有依赖包</li><li>build Artifacts</li></ol><p>胖包：依赖包和代码一起打成一个包<br>瘦包：自由代码包</p><h2 id="使用IDEA和SBT编译Scala项目"><a href="#使用IDEA和SBT编译Scala项目" class="headerlink" title="使用IDEA和SBT编译Scala项目"></a>使用IDEA和SBT编译Scala项目</h2><p><a href="http://www.scala-lang.org/documentation/getting-started-intellij-track/building-a-scala-project-with-intellij-and-sbt.html">官方指导</a><br><a href="http://blog.csdn.net/u012877472/article/details/51000690">参考博客</a></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code class="hljs none">- .idea (IntelliJ files)- project (plugins and additional settings for sbt)- src (source files)    - main (application code)        - java (Java source files)        - scala (Scala source files) &lt;-- This is all we need for now        - scala-2.12 (Scala 2.12 specific files)    - test (unit tests)- target (generated files)- build.sbt (build definition file for sbt)</code></pre><h2 id="解决不能下载源码问题"><a href="#解决不能下载源码问题" class="headerlink" title="解决不能下载源码问题"></a>解决不能下载源码问题</h2><p>方法1：（测试过，好用）</p><p>使用Maven命令。经过测试，好用。下载了所有POM里的依赖包的source，这点不是想要的，原来只想下载想看的依赖的source。参考：IDEA-165800 Can’t download dependency’s source code</p><pre><code>mvn dependency:resolve -Dclassifier=sources</code></pre><p>方法2：（没有测试过）</p><p>1.下载POM文件依赖的包的source</p><pre><code>mvn dependency:sources</code></pre><p>2.下载POM文件依赖的包的javadoce</p><pre><code>mvn dependency:resolve -Dclassifier=javadoc</code></pre><p>3.下载指定依赖包（artifactId）的source。这个很不错，是我想要的。</p><pre><code>mvn dependency:sources -DincludeArtifactIds=guava</code></pre><p>参考：<a href="http://stackoverflow.com/questions/2059431/get-source-jars-from-maven-repository">Get source JARs from Maven repository</a></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Spark是什么</title>
    <link href="/07-Bigdata/04-Spark/01-Spark%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/04-Spark/01-Spark%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="官方直达电梯"><a href="#官方直达电梯" class="headerlink" title="官方直达电梯"></a><a href="http://spark.apache.org/">官方直达电梯</a></h3><p>Spark一种<strong>基于内存</strong>的<strong>通用</strong>的<strong>实时</strong>大数据计算框架(作为MapReduce的另一个更优秀的可选的方案)</p><ul><li>通用：Spark Core 用于离线计算，Spark SQL 用于交互式查询，Spark Streaming 用于实时流式计算，Spark Mlib 用于机器学习，Spark GraphX 用于图计算</li><li>实时：Run programs up to 100x faster than Hadoop MapReduce in memory, or 10x faster on disk.</li></ul><h3 id="一、Spark和Storm的区别"><a href="#一、Spark和Storm的区别" class="headerlink" title="一、Spark和Storm的区别"></a><a href="http://developer.51cto.com/art/201412/460116.htm">一、Spark和Storm的区别</a></h3><h4 id="Storm的计算模型（实时）"><a href="#Storm的计算模型（实时）" class="headerlink" title="Storm的计算模型（实时）"></a>Storm的计算模型（实时）</h4><ul><li>Storm是针对每条数据的流式实时计算框架，由于每条数据过来就直接处理，每条数据都会带来大量的资源消耗（传输，通信，校验等）吞吐量不高</li><li>storm可以动态调整并行度</li><li>Storm保证了更高的实时性，毫秒级延迟</li></ul><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170829140314687-387197817.png" alt="Storm的计算模型"></p><h4 id="Spark-Stream计算模型（准实时）"><a href="#Spark-Stream计算模型（准实时）" class="headerlink" title="Spark Stream计算模型（准实时）"></a>Spark Stream计算模型（准实时）</h4><ul><li>通过设置时间间隔 <strong>batch interval</strong> 一个时间间隔内的数据作为一个<strong>Batch</strong>收集起来给<strong>Spark Streaming Application</strong>处理(少了很多传输，校对开销)，保证了高吞吐量</li><li>秒级延迟</li><li>结合Spark生态圈可以发挥很大的威力</li></ul><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170829140319358-2055201827.png" alt="Spark Stream计算模型"></p><h3 id="二、Spark-Streaming和MapReduce的对比"><a href="#二、Spark-Streaming和MapReduce的对比" class="headerlink" title="二、Spark Streaming和MapReduce的对比"></a>二、Spark Streaming和MapReduce的对比</h3><p>Shuffle以及MapReduce的计算模型决定了MapReduce只适合对速度要求不敏感的离线批处理任务</p><ul><li>Spark的多进程任务可能在同一个物理机器的<strong>内存</strong>上完成（Spark shuffle也会使用磁盘）</li><li>MapReduce死板的模型必须基于磁盘和大量的网络传输</li><li>MapReduce的程度编写复杂，Spark更容易上手，支持（Scale JAVA[8支持函数式编程] Python）</li><li>Spark 在缺少调优时，会出现<strong>OOM</strong>(Out Of Memory)的问题，导致程序无法执行，而MapReduce就算是慢也能执行</li></ul><p><img src="../images/01-02.png" alt="MapReduce流程"></p><h3 id="三、Spark-SQL对比Hive"><a href="#三、Spark-SQL对比Hive" class="headerlink" title="三、Spark SQL对比Hive"></a>三、Spark SQL对比Hive</h3><ul><li>Spark SQL实际上不能完全替代Hive，只是替代了Hive中的查询引擎，<strong>针对Hive数据仓库中的表进行SQL查询</strong></li><li>由于Hive查询底层基于MapReduce决定了Hive的查询慢</li><li>Hive中的一部分高级特性在Spark SQL 中未得到支持</li><li>Spark SQL除了Hive还支持其他数据源（json parquet jdbc等），同时支持<strong>直接针对HDFS执行SQL查询</strong></li></ul><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170712112821400-1917701229.png" alt="Hive架构"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Spark部署模式</title>
    <link href="/07-Bigdata/04-Spark/01-Spark%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/"/>
    <url>/07-Bigdata/04-Spark/01-Spark%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是部署模式"><a href="#什么是部署模式" class="headerlink" title="什么是部署模式"></a>什么是部署模式</h1><pre><code class="hljs sh">bin/spark-submit --<span class="hljs-built_in">help</span> --master MASTER_URL         spark://host:port, mesos://host:port, yarn, or <span class="hljs-built_in">local</span>. --deploy-mode DEPLOY_MODE   Whether to launch the driver program locally (<span class="hljs-string">&quot;client&quot;</span>) or                             on one of the worker machines inside the cluster (<span class="hljs-string">&quot;cluster&quot;</span>)                             (Default: client)</code></pre><p>部署模式有两种，针对<code>driver program</code></p><ul><li>client 单机版，提交应用的机器，运行<code>driver program</code><ul><li>运行日志直接输出到client</li></ul></li><li>cluster 集群，集群中的worker节点中运行<code>driver program</code><ul><li>运行日志输出到文件</li></ul></li></ul><p>client模式：</p><pre><code class="hljs sh">bin/spark-submit \--master spark://cen-ubuntu:7070 \--deploy-mode client \--class com.gci.SimpleApp \jars/SimpleApp.jar</code></pre><p>cluster模式：</p><pre><code class="hljs sh">bin/spark-submit \--master spark://cen-ubuntu:7070 \--deploy-mode cluster \--class com.gci.SimpleApp \jars/SimpleApp.jar</code></pre><h2 id="在YARN上运行集群"><a href="#在YARN上运行集群" class="headerlink" title="在YARN上运行集群"></a><a href="http://spark.apache.org/docs/1.6.0/running-on-yarn.html">在YARN上运行集群</a></h2><ol><li>Client 提交请求-&gt; ResourceManager</li><li>ResourceManager 创建-&gt; SparkApplicationMaster</li><li>SparkApplicationMaster 向　ResourceManager 申请资源</li><li>ResourceManager分配container用于运行Executor</li><li>ApplicationMaster（在cluster模式中也是driver program）<ul><li>创建DAG图 -&gt; DAGScheduler -&gt; StageScheduler -&gt; TaskSet</li></ul></li></ol><p><img src="../images/01-01.png"></p><h3 id="停止Standlone模式的master和Worker"><a href="#停止Standlone模式的master和Worker" class="headerlink" title="停止Standlone模式的master和Worker"></a>停止Standlone模式的master和Worker</h3><pre><code class="hljs sh">sbin/stop-all.sh</code></pre><h3 id="启动YARN"><a href="#启动YARN" class="headerlink" title="启动YARN"></a>启动YARN</h3><pre><code class="hljs sh">sbin/yarn-daemon.sh start resourcemanagersbin/yarn-daemon.sh start nodemanager</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h3 id="在集群模式提交应用的时候，在终端会报异常，然而，应用是已经正确提交了。"><a href="#在集群模式提交应用的时候，在终端会报异常，然而，应用是已经正确提交了。" class="headerlink" title="在集群模式提交应用的时候，在终端会报异常，然而，应用是已经正确提交了。"></a>在集群模式提交应用的时候，在终端会报异常，然而，应用是已经正确提交了。</h3><ul><li>异常：WARN RestSubmissionClient: Unable to connect to server spark://192.168.1.153:7070.</li></ul><h3 id="内存不足异常"><a href="#内存不足异常" class="headerlink" title="内存不足异常"></a>内存不足异常</h3><ul><li>报错：Required executor memory (8192+819 MB) is above the max threshold (8192 MB) of this cluster! Please check the values of ‘yarn.scheduler.maximum-allocation-mb’ and/or ‘yarn.nodemanager.resource.memory-mb’.</li><li>原因：未正确配置<code>spark-executor.memory</code></li><li>解决：编辑<code>conf/spark-env.sh</code>文件中的<code>spark-executor.memory=xG</code></li></ul><h3 id="初始化SparkContext出错，空指针异常"><a href="#初始化SparkContext出错，空指针异常" class="headerlink" title="初始化SparkContext出错，空指针异常"></a><a href="https://issues.apache.org/jira/browse/SPARK-15329">初始化SparkContext出错，空指针异常</a></h3><ul><li>报错：Error initializing SparkContext.java.lang.NullPointerException</li><li>原因：未正确配置classpath</li><li>解决：由于yarn.application.classpath已经指定好了我们需要的依赖包，因此，我们只需要修改好系统变量<code>/etc/profile</code></li></ul><pre><code class="hljs sh"><span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=xxx<span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=xxx<span class="hljs-built_in">export</span> HADOOP_YARN_HOME=xxx</code></pre><h3 id="虚拟内存溢出报错"><a href="#虚拟内存溢出报错" class="headerlink" title="虚拟内存溢出报错"></a><a href="http://www.aboutyun.com/thread-12291-2-1.html">虚拟内存溢出报错</a></h3><ul><li><p>报错：is running beyond virtual memory limits. Current usage: 147.4 MB of 1 GB physical memory used; 2.1 GB of 2.1 GB virtual memory used. Killing container.</p></li><li><p>原因：原因有可能出在YARN上，也可能在Spark上</p><ul><li><p>YARN中的配置为默认配置，刚好我的电脑为8G内存，因此猜测问题在Spark配置上</p></li><li><p>修改Spark配置</p><p>问题尚未解决<br>网友观点：根据官方说明，spark要支持yarn client是需要自行编译的？,本人亲自验证设个说法是错误的。<br>问题可能在YARN的验证上</p></li></ul></li></ul><pre><code class="hljs sh">SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding <span class="hljs-keyword">in</span> [jar:file:/home/cen/software/apache/hadoop-2.8.1/data/tmp/nm-local-dir/usercache/cen/filecache/13/spark-assembly-1.6.0-hadoop2.6.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding <span class="hljs-keyword">in</span> [jar:file:/home/cen/software/apache/hadoop-2.8.1/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html<span class="hljs-comment">#multiple_bindings for an explanation.</span>SLF4J: Actual binding is of <span class="hljs-built_in">type</span> [org.slf4j.impl.Log4jLoggerFactory]17/10/11 13:51:13 INFO ApplicationMaster: Registered signal handlers <span class="hljs-keyword">for</span> [TERM, HUP, INT]17/10/11 13:51:14 INFO ApplicationMaster: ApplicationAttemptId: appattempt_1507700256349_0005_00000217/10/11 13:51:15 INFO SecurityManager: Changing view acls to: cen17/10/11 13:51:15 INFO SecurityManager: Changing modify acls to: cen17/10/11 13:51:15 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: Set(cen); users with modify permissions: Set(cen)17/10/11 13:51:16 INFO ApplicationMaster: Waiting <span class="hljs-keyword">for</span> Spark driver to be reachable.17/10/11 13:51:16 INFO ApplicationMaster: Driver now available: 192.168.1.153:4082217/10/11 13:51:16 INFO ApplicationMaster<span class="hljs-variable">$AMEndpoint</span>: Add WebUI Filter. AddWebUIFilter(org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpFilter,Map(PROXY_HOSTS -&gt; cen-ubuntu, PROXY_URI_BASES -&gt; http://cen-ubuntu:8088/proxy/application_1507700256349_0005),/proxy/application_1507700256349_0005)17/10/11 13:51:17 INFO RMProxy: Connecting to ResourceManager at /0.0.0.0:803017/10/11 13:51:17 INFO YarnRMClient: Registering the ApplicationMaster17/10/11 13:51:17 ERROR ApplicationMaster: RECEIVED SIGNAL 15: SIGTERM17/10/11 13:51:17 INFO ApplicationMaster: Final app status: UNDEFINED, exitCode: 0, (reason: Shutdown hook called before final status was reported.)17/10/11 13:51:17 INFO ApplicationMaster: Unregistering ApplicationMaster with UNDEFINED (diag message: Shutdown hook called before final status was reported.)17/10/11 13:51:17 WARN Client: Exception encountered <span class="hljs-keyword">while</span> connecting to the server : org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.token.SecretManager<span class="hljs-variable">$InvalidToken</span>): appattempt_1507700256349_0005_000002 not found <span class="hljs-keyword">in</span> AMRMTokenSecretManager.17/10/11 13:51:17 INFO ApplicationMaster: Deleting staging directory .sparkStaging/application_1507700256349_000517/10/11 13:51:17 ERROR ApplicationMaster: Uncaught exception: org.apache.hadoop.security.token.SecretManager<span class="hljs-variable">$InvalidToken</span>: appattempt_1507700256349_0005_000002 not found <span class="hljs-keyword">in</span> AMRMTokenSecretManager.at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)at java.lang.reflect.Constructor.newInstance(Constructor.java:423)at org.apache.hadoop.yarn.ipc.RPCUtil.instantiateException(RPCUtil.java:53)at org.apache.hadoop.yarn.ipc.RPCUtil.unwrapAndThrowException(RPCUtil.java:104)at org.apache.hadoop.yarn.api.impl.pb.client.ApplicationMasterProtocolPBClientImpl.registerApplicationMaster(ApplicationMasterProtocolPBClientImpl.java:109)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:498)at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:187)at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:102)at com.sun.proxy.<span class="hljs-variable">$Proxy15</span>.registerApplicationMaster(Unknown Source)at org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl.registerApplicationMaster(AMRMClientImpl.java:222)at org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl.registerApplicationMaster(AMRMClientImpl.java:214)at org.apache.spark.deploy.yarn.YarnRMClient.register(YarnRMClient.scala:71)at org.apache.spark.deploy.yarn.ApplicationMaster.registerAM(ApplicationMaster.scala:284)at org.apache.spark.deploy.yarn.ApplicationMaster.runExecutorLauncher(ApplicationMaster.scala:347)at org.apache.spark.deploy.yarn.ApplicationMaster.run(ApplicationMaster.scala:187)at org.apache.spark.deploy.yarn.ApplicationMaster$<span class="hljs-variable">$anonfun</span><span class="hljs-variable">$main</span><span class="hljs-variable">$1</span>.apply<span class="hljs-variable">$mcV</span><span class="hljs-variable">$sp</span>(ApplicationMaster.scala:653)at org.apache.spark.deploy.SparkHadoopUtil$<span class="hljs-variable">$anon</span><span class="hljs-variable">$1</span>.run(SparkHadoopUtil.scala:69)at org.apache.spark.deploy.SparkHadoopUtil$<span class="hljs-variable">$anon</span><span class="hljs-variable">$1</span>.run(SparkHadoopUtil.scala:68)at java.security.AccessController.doPrivileged(Native Method)at javax.security.auth.Subject.doAs(Subject.java:422)at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1628)at org.apache.spark.deploy.SparkHadoopUtil.runAsSparkUser(SparkHadoopUtil.scala:68)at org.apache.spark.deploy.yarn.ApplicationMaster$.main(ApplicationMaster.scala:651)at org.apache.spark.deploy.yarn.ExecutorLauncher$.main(ApplicationMaster.scala:674)at org.apache.spark.deploy.yarn.ExecutorLauncher.main(ApplicationMaster.scala)Caused by: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.token.SecretManager<span class="hljs-variable">$InvalidToken</span>): appattempt_1507700256349_0005_000002 not found <span class="hljs-keyword">in</span> AMRMTokenSecretManager.at org.apache.hadoop.ipc.Client.call(Client.java:1468)at org.apache.hadoop.ipc.Client.call(Client.java:1399)at org.apache.hadoop.ipc.ProtobufRpcEngine<span class="hljs-variable">$Invoker</span>.invoke(ProtobufRpcEngine.java:232)at com.sun.proxy.<span class="hljs-variable">$Proxy14</span>.registerApplicationMaster(Unknown Source)at org.apache.hadoop.yarn.api.impl.pb.client.ApplicationMasterProtocolPBClientImpl.registerApplicationMaster(ApplicationMasterProtocolPBClientImpl.java:106)... 23 more17/10/11 13:51:17 INFO ShutdownHookManager: Shutdown hook called</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Spark Standalone安装部署</title>
    <link href="/07-Bigdata/04-Spark/02-Spark%20Standalone%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <url>/07-Bigdata/04-Spark/02-Spark%20Standalone%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark-Standdlone是什么"><a href="#Spark-Standdlone是什么" class="headerlink" title="Spark Standdlone是什么"></a>Spark Standdlone是什么</h1><p><a href="http://spark.apache.org/docs/1.6.0/spark-standalone.html">Spark Standlone Mode</a></p><p>Apark Standlone是Spark自身的集群管理，用于自己的集群，不依赖YARN</p><p><img src="http://images2017.cnblogs.com/blog/834652/201709/834652-20170903102718905-1356676917.png" alt="Spark Standlone Mode"></p><ul><li>Master 主节点 分配任务</li><li>Worker 工作节点 管理资源</li><li>Driver Program 执行了mian方法，提供了上下文<ul><li>当运行在集群中时，–deploy-modde作为cluster</li><li>当运行不在集群中时为client模式,shell,默认是client模式</li></ul></li><li>SparkContext 上下文</li><li>Executor 进程</li><li>task 线程：在Spark中任务是以线程执行的(MapReduce中是进程)作为任务提交给进程的单元</li><li>job 一个action就是一个job</li><li>stage 阶段，是一大推任务的集合。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>启动HDFS</p><pre><code class="hljs sh">sbin/hadoop-daemon.sh start namenodesbin/hadoop-daemon.sh start datanode</code></pre><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>1.conf/spark-env.sh</p><p>这个配置文件是Master和Worker的</p><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env bash</span><span class="hljs-comment">#</span><span class="hljs-comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span><span class="hljs-comment"># contributor license agreements.  See the NOTICE file distributed with</span><span class="hljs-comment"># this work for additional information regarding copyright ownership.</span><span class="hljs-comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span><span class="hljs-comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span><span class="hljs-comment"># the License.  You may obtain a copy of the License at</span><span class="hljs-comment">#</span><span class="hljs-comment">#    http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment">#</span><span class="hljs-comment"># Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><span class="hljs-comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="hljs-comment"># See the License for the specific language governing permissions and</span><span class="hljs-comment"># limitations under the License.</span><span class="hljs-comment">#</span><span class="hljs-comment"># 可以设置，特别是当很多版本的时候</span>JAVA_HOME=/usr/<span class="hljs-built_in">local</span>/java/jdk1.8.0_144SCALA_HOME=/usr/<span class="hljs-built_in">local</span>/share/scala<span class="hljs-comment"># This file is sourced when running various Spark programs.</span><span class="hljs-comment"># Copy it as spark-env.sh and edit that to configure Spark for your site.</span><span class="hljs-comment"># Options read when launching programs locally with</span><span class="hljs-comment"># ./bin/run-example or ./bin/spark-submit</span><span class="hljs-comment"># - HADOOP_CONF_DIR, to point Spark towards Hadoop configuration files</span><span class="hljs-comment"># - SPARK_LOCAL_IP, to set the IP address Spark binds to on this node</span><span class="hljs-comment"># - SPARK_PUBLIC_DNS, to set the public dns name of the driver program</span><span class="hljs-comment"># - SPARK_CLASSPATH, default classpath entries to append</span>HADOOP_CONF_DIR=/opt/cdh-5.12.0/hadoop-2.6.0-cdh5.12.0/etc/hadoop<span class="hljs-comment"># Options read by executors and drivers running inside the cluster</span><span class="hljs-comment"># - SPARK_LOCAL_IP, to set the IP address Spark binds to on this node</span><span class="hljs-comment"># - SPARK_PUBLIC_DNS, to set the public DNS name of the driver program</span><span class="hljs-comment"># - SPARK_CLASSPATH, default classpath entries to append</span><span class="hljs-comment"># - SPARK_LOCAL_DIRS, storage directories to use on this node for shuffle and RDD data</span><span class="hljs-comment"># - MESOS_NATIVE_JAVA_LIBRARY, to point to your libmesos.so if you use Mesos</span><span class="hljs-comment"># Options read in YARN client mode</span><span class="hljs-comment"># - HADOOP_CONF_DIR, to point Spark towards Hadoop configuration files</span><span class="hljs-comment"># - SPARK_EXECUTOR_INSTANCES, Number of executors to start (Default: 2)</span><span class="hljs-comment"># - SPARK_EXECUTOR_CORES, Number of cores for the executors (Default: 1).</span><span class="hljs-comment"># - SPARK_EXECUTOR_MEMORY, Memory per Executor (e.g. 1000M, 2G) (Default: 1G)</span><span class="hljs-comment"># - SPARK_DRIVER_MEMORY, Memory for Driver (e.g. 1000M, 2G) (Default: 1G)</span><span class="hljs-comment"># - SPARK_YARN_APP_NAME, The name of your application (Default: Spark)</span><span class="hljs-comment"># - SPARK_YARN_QUEUE, The hadoop queue to use for allocation requests (Default: ‘default’)</span><span class="hljs-comment"># - SPARK_YARN_DIST_FILES, Comma separated list of files to be distributed with the job.</span><span class="hljs-comment"># - SPARK_YARN_DIST_ARCHIVES, Comma separated list of archives to be distributed with the job.</span><span class="hljs-comment"># Options for the daemons used in the standalone deploy mode</span><span class="hljs-comment"># - SPARK_MASTER_IP, to bind the master to a different IP address or hostname</span><span class="hljs-comment"># - SPARK_MASTER_PORT / SPARK_MASTER_WEBUI_PORT, to use non-default ports for the master</span><span class="hljs-comment"># - SPARK_MASTER_OPTS, to set config properties only for the master (e.g. &quot;-Dx=y&quot;)</span><span class="hljs-comment"># - SPARK_WORKER_CORES, to set the number of cores to use on this machine</span><span class="hljs-comment"># - SPARK_WORKER_MEMORY, to set how much total memory workers have to give executors (e.g. 1000m, 2g)</span><span class="hljs-comment"># - SPARK_WORKER_PORT / SPARK_WORKER_WEBUI_PORT, to use non-default ports for the worker</span><span class="hljs-comment"># - SPARK_WORKER_INSTANCES, to set the number of worker processes per node</span><span class="hljs-comment"># - SPARK_WORKER_DIR, to set the working directory of worker processes</span><span class="hljs-comment"># - SPARK_WORKER_OPTS, to set config properties only for the worker (e.g. &quot;-Dx=y&quot;)</span><span class="hljs-comment"># - SPARK_DAEMON_MEMORY, to allocate to the master, worker and history server themselves (default: 1g).</span><span class="hljs-comment"># - SPARK_HISTORY_OPTS, to set config properties only for the history server (e.g. &quot;-Dx=y&quot;)</span><span class="hljs-comment"># - SPARK_SHUFFLE_OPTS, to set config properties only for the external shuffle service (e.g. &quot;-Dx=y&quot;)</span><span class="hljs-comment"># - SPARK_DAEMON_JAVA_OPTS, to set config properties for all daemons (e.g. &quot;-Dx=y&quot;)</span><span class="hljs-comment"># - SPARK_PUBLIC_DNS, to set the public dns name of the master or workers</span>SPARK_MASTER_IP=cen-ubuntuSPARK_MASTER_PORT=7070SPARK_MASTER_WEBUI_PORT=8080<span class="hljs-comment"># 在sbin/start-master.sh中可以看到</span>SPARK_WORKER_CORES=4SPARK_WORKER_MEMORY=8gSPARK_WORKER_PORT=7078SPARK_WORKER_WEBUI_PORT=8081<span class="hljs-comment"># 在sbin/start-slaver.sh中可以看到</span>SPARK_WORKER_INSTANCES=1<span class="hljs-comment"># Worker设置进程数</span><span class="hljs-comment">#SPARK_WORKER_DIR=</span><span class="hljs-comment"># 设置工作目录，默认是tmp</span><span class="hljs-comment"># Generic options for the daemons used in the standalone deploy mode</span><span class="hljs-comment"># - SPARK_CONF_DIR      Alternate conf dir. (Default: $&#123;SPARK_HOME&#125;/conf)</span><span class="hljs-comment"># - SPARK_LOG_DIR       Where log files are stored.  (Default: $&#123;SPARK_HOME&#125;/logs)</span><span class="hljs-comment"># - SPARK_PID_DIR       Where the pid file is stored. (Default: /tmp)</span><span class="hljs-comment"># - SPARK_IDENT_STRING  A string representing this instance of spark. (Default: $USER)</span><span class="hljs-comment"># - SPARK_NICENESS      The scheduling priority for daemons. (Default: 0)</span><span class="hljs-built_in">export</span> SPARK_DIST_CLASSPATH=$(/opt/cdh-5.12.0/hadoop-2.6.0-cdh5.12.0/bin/hadoop classpath)</code></pre><p>2.配置conf/log4j.properties</p><p>3.配置conf/slave</p><pre><code class="hljs sh">cen-ubuntu</code></pre><p>4.配置conf/spark-defaults.conf</p><p>这个配置是配置Client的(driver)，也可以在spark-shell中使用配置替代，请参考<code>spark-shell --help</code></p><pre><code class="hljs sh">spark.master                     spark://cen-ubuntu:7070</code></pre><h4 id="启动主节点"><a href="#启动主节点" class="headerlink" title="启动主节点"></a>启动主节点</h4><pre><code class="hljs sh">sbin/start-master.sh</code></pre><h4 id="启动从节点"><a href="#启动从节点" class="headerlink" title="启动从节点"></a>启动从节点</h4><pre><code class="hljs sh"><span class="hljs-comment"># 启动所有从节点</span>sbin/start-slaves.sh<span class="hljs-comment"># 启动单个次节点</span>sbin/start-slave.sh</code></pre><p>当然也可以使用<code>sbin/start-all.sh</code>实现全部启动，此时可以通过8080,8081查看页面。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="启动shell"><a href="#启动shell" class="headerlink" title="启动shell"></a>启动shell</h3><pre><code class="hljs sh">bin/spark-shell</code></pre><pre><code class="hljs scala"><span class="hljs-keyword">val</span> testFile=sc.textFile(<span class="hljs-string">&quot;/user/cen/mapreduce/input/log4j.properties&quot;</span>)testFile.count()<span class="hljs-comment">//这时候能在web页面看到执行结果job在4040</span></code></pre><h3 id="停止退出"><a href="#停止退出" class="headerlink" title="停止退出"></a>停止退出</h3><p>这是属于SparkContex的生命周期的方法。</p><pre><code class="hljs scala">sc.stopexit</code></pre><h2 id="saprk-shell-参数说明"><a href="#saprk-shell-参数说明" class="headerlink" title="saprk-shell 参数说明"></a>saprk-shell 参数说明</h2><p>请分清自己的使用场景</p><ul><li>–master 指定master和内核 yarn local spark mesos[内核数]默认1核</li><li>–file 文件执行</li><li>–conf 配置文件</li><li>–executor-cores 进程使用的CPU</li><li>–executor-memory 进程使用的内存 默认1G</li><li>–driver-memory 驱动的内存</li></ul><h2 id="一个Application的运行流程"><a href="#一个Application的运行流程" class="headerlink" title="一个Application的运行流程"></a>一个Application的运行流程</h2><p>1.构建Spark Application运行环境</p><p>在Driver Program中新建SparkContext，<strong>集群中的进程由SparkContext协调。</strong></p><p>2.SparkContext负责向资源管理器申请运行Executor资源，并启动StandaloneExecutorBackend，executor向sparkcontext申请task</p><p>3.SparkContext申请到executor后，Application的代码就会发送给executor执行</p><p>4.SparkContext构建RDD DAG图，将RDD DAG图分解成Stage DAG图，将Stage提交给TaskScheduler，最后由TaskScheduler将Task发送给Executor运行</p><p>5.Task在Executor上运行，运行完毕后释放资源。</p><h2 id="启动日志历史服务器"><a href="#启动日志历史服务器" class="headerlink" title="启动日志历史服务器"></a>启动日志历史服务器</h2><p><img src="http://spark.apache.org/docs/latest/monitoring.html" alt="官方参考文档"></p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>编辑<code>conf/spark-env.sh</code></p><pre><code class="hljs sh">SPARK_HISTORY_OPTS=-Dspark.history.fs.logDirectory=hdfs://cen-ubuntu:8020:/user/cen/spark/enentlogs</code></pre><pre><code class="hljs sh">sbin/start-history-server.sh</code></pre><p><a href="http://localhost:18080/">http://localhost:18080</a></p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>编辑<code>conf/spark-default.conf</code></p><pre><code class="hljs sh">spark.master                     spark://cen-ubuntu:7077spark.eventLog.enabled           <span class="hljs-literal">true</span>spark.eventLog.dir               hdfs://localhost:8020/user/cen/spark/enentlogs/spark.eventLog.compress     <span class="hljs-literal">true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Spark编译安装</title>
    <link href="/07-Bigdata/04-Spark/02-Spark%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/04-Spark/02-Spark%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark编译、安装和测试"><a href="#Spark编译、安装和测试" class="headerlink" title="Spark编译、安装和测试"></a>Spark编译、安装和测试</h1><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>不要盲目崇拜CDH，因为CDH做了一些我们不知道的努力，在我们这里就不一定适用了。经过实验发现，cdh版本不适合在测试时候使用，日志等级，上下文对象出不来等一大堆BUG。建议使用<code>Pre-build with user-provided Hadoop</code>版本，经过简单设置即可配合各种版本的hadoop使用。</p><p><a href="http://spark.apache.org/docs/1.6.0/">官方文档</a></p><p>本文使用Spark1.6.0，hadoop版本使用2.6.0-cdh5.12.0请注意查看相应版本的文档。<br>Spark runs on java 7+, Python 2.6+ and R 3.1+. For the Scala API, Spark 1.6.0 uses Scala 2.10. You will need to use a compatible Scala version (2.10.x).</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="http://spark.apache.org/docs/1.6.0/building-spark.html">官方文档</a></p><ul><li>SBT编译，一个Scala的编译方式</li><li>Maven编译，官方基于mvn</li><li>脚本编译，Maven的脚本版</li></ul><h3 id="使用build-mvn编译-不能生成Tar包"><a href="#使用build-mvn编译-不能生成Tar包" class="headerlink" title="使用build/mvn编译(不能生成Tar包)"></a>使用<code>build/mvn</code>编译(不能生成Tar包)</h3><p>这是一个简单粗暴的方法，直接下载对应版本的maven Scala 等组件，不受系统环境影响。</p><pre><code class="hljs sh"><span class="hljs-comment"># -P参数是在pom.xml中</span>build/mvn -Pyarn -Phadoop-2.6 -Dhadoop.version=2.6.0 -Phive -Phive-thriftserver -DskipTests clean package</code></pre><h3 id="使用脚本编译-可以生成Tar包"><a href="#使用脚本编译-可以生成Tar包" class="headerlink" title="使用脚本编译(可以生成Tar包)"></a>使用脚本编译(可以生成Tar包)</h3><p>注意官方文档说明的maven和scala版本要求。</p><p>1.根据版本调整参数使用脚本编译</p><pre><code class="hljs sh"><span class="hljs-comment"># 新版本在dev路径下</span><span class="hljs-comment"># 建议使用Hadoop版本作为name，原因看源码</span>./make-distribution.sh \--name 2.6.0-cdh5.13.0 \--tgz \-Phadoop-2.6 \-Dhadoop.version=2.6.0-cdh5.13.0 \-Phive -Phive-thriftserver \-Pyarn</code></pre><p>2.直接使用，会耗费很长的时间，因为mvn去检测版本信息等等，提速方法：编辑<code>dev/make-distribution.sh</code>文件</p><pre><code class="hljs sh"><span class="hljs-comment"># 注释VERSION相关的信息</span>VERSION=2.2.0SCALA_VERSION=2.11SPARK_HADOOP_VERSION=2.6.0-cdh5.13.0SPARK_HIVE=1</code></pre><pre><code class="hljs sh">+ /home/cen/package/spark-1.6.0/build/mvn clean package -DskipTests -Phadoop-2.6 -Dhadoop.version=2.6.0 -Phive -Phive-thriftserver -Pyarn</code></pre><p>3.若添加Hadoop版本为CDH版本<strong>必然报错</strong>，原因是pom文件中没有cdh的依赖包</p><pre><code class="hljs sh"><span class="hljs-comment"># 一定不能放在第一位</span>&lt;repository&gt;  &lt;id&gt;cloudera&lt;/id&gt;  &lt;name&gt;cloudera Repository&lt;/name&gt;  &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;&lt;/repository&gt;</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="安装scala-不是必要的，spark自带了scala"><a href="#安装scala-不是必要的，spark自带了scala" class="headerlink" title="安装scala(不是必要的，spark自带了scala)"></a>安装scala(不是必要的，spark自带了scala)</h4><p>跟安装JDK如出一辙,下载<a href="http://www.scala-lang.org/download/2.10.6.html">Scala</a><br>修改环境变量<code>vim /etc/profile</code></p><pre><code class="hljs sh"><span class="hljs-comment"># SCALA_HOME</span><span class="hljs-built_in">export</span> SCALA_HOME /usr/<span class="hljs-built_in">local</span>/share/scala<span class="hljs-built_in">export</span> PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$SCALA_HOME</span>/bin</code></pre><p>更新<code>source /etc/profile</code></p><p>验证<code>scala -version</code></p><h4 id="解压tar包"><a href="#解压tar包" class="headerlink" title="解压tar包"></a>解压tar包</h4><h2 id="shell-支持Scala和Python"><a href="#shell-支持Scala和Python" class="headerlink" title="shell(支持Scala和Python)"></a>shell(支持Scala和Python)</h2><ul><li>local 单机运行，没有管理者</li><li>stanlone 使用自己自带的资源管理，单机</li><li>yarn 使用Yarn作为资源管理</li><li>Mesos 使用Mesos作为资源管理</li></ul><p><a href="http://spark.apache.org/docs/1.6.0/quick-start.html">官方文档</a></p><p>1.需要配置一个Hadoop的classpath<a href="https://spark.apache.org/docs/latest/hadoop-provided.html">官方说明</a></p><pre><code class="hljs sh"><span class="hljs-built_in">export</span> SPARK_DIST_CLASSPATH=$(/HADOOP_HOME/bin/hadoop classpath)</code></pre><p>2.需要Hadoop的配置正确但是不要求启动。</p><p>3.使用spark-Shell</p><pre><code class="hljs sh"><span class="hljs-comment"># 使用scala</span>bin/spark-shell<span class="hljs-comment"># 使用Python，尽管是python比较简单，但是不建议使用，因为提示做的比不上scala版本的，不利于学习。</span>bin/pysaprk</code></pre><p>这时候访问<a href="localhost:4040">localhost:4040</a>即可看到WEBUI，每一个apark-shell都会开启一个端口，从4040开始递增。</p><h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> textFile = sc.textFile(<span class="hljs-string">&quot;README.md&quot;</span>) <span class="hljs-comment">//错误的写法</span>scala&gt; <span class="hljs-keyword">val</span> textFile = sc.textFile(<span class="hljs-string">&quot;file:///opt/cdh-5.12.0/spark-1.6.0-bin-without-hadoop/README.md&quot;</span>)textFile: spark.<span class="hljs-type">RDD</span>[<span class="hljs-type">String</span>] = spark.<span class="hljs-type">MappedRDD</span>@<span class="hljs-number">2</span>ee9b6e3</code></pre><p>主要涉及的概念的对比MapReduce</p><ul><li>sc : 上下对象SparkContext，是加载配置文件生成的一个Application必须的配置，就像MapReduce要读取配置一样</li><li>RDD : Resilient Distributed Dataset，弹性分布式数据集，它可被分发到集群各个节点上，进行并行操作，RDD是按行存储的，区别于MapReduce的key-value对</li><li>除了上下文，Spark通过<code>file://</code>是访问到本地路径的，不说明则是HDFS</li><li><a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html">RDDs支持的操作</a>下文将演示两种操作<ul><li>actions: 在数据集上运行计算后返回值</li><li>transformations: 转换, 从现有数据集创建一个新的数据集</li></ul></li></ul><h3 id="actions-真的的计算"><a href="#actions-真的的计算" class="headerlink" title="actions(真的的计算)"></a>actions(真的的计算)</h3><p>操作的结果不是RDD</p><ul><li>RDD.count()</li><li>Rdd.first()</li><li>RDD.take(n)取前n条</li></ul><pre><code class="hljs scala">scala&gt; textFile.count() <span class="hljs-comment">// Number of items in this RDD，根据官方文档，如果HDFS没启动这里将会报错</span><span class="hljs-comment">//Input path does not exist: hdfs://127.0.0.1:8020/user/cen/README.md</span>res0: <span class="hljs-type">Long</span> = <span class="hljs-number">126</span>scala&gt; textFile.first() <span class="hljs-comment">// First item in this RDD</span>res1: <span class="hljs-type">String</span> = # <span class="hljs-type">Apache</span> <span class="hljs-type">Spark</span></code></pre><h3 id="transformation"><a href="#transformation" class="headerlink" title="transformation"></a>transformation</h3><p>操作的结果是RDD</p><ul><li>RDD.filter()</li><li>line是元素的代号而已，不一定要用line</li></ul><p>We will use the filter transformation to return a new RDD with a subset of the items in the file.</p><pre><code class="hljs scala"><span class="hljs-comment">//筛选拥有Spark的行，作为新的RDD</span>scala&gt; <span class="hljs-keyword">val</span> linesWithSpark = textFile.filter(line =&gt; line.contains(<span class="hljs-string">&quot;Spark&quot;</span>))linesWithSpark: spark.<span class="hljs-type">RDD</span>[<span class="hljs-type">String</span>] = spark.<span class="hljs-type">FilteredRDD</span>@<span class="hljs-number">7</span>dd4af09<span class="hljs-comment">//等效于textFile.filter(_.contains(&quot;Spark&quot;))</span></code></pre><p><code>line =&gt; line.contains(&quot;Spark&quot;)</code>这是一个匿名函数A，作为参数传给B，line是这个匿名函数的参数，由于自动判断类型，故类型可以省略，这个函数B叫做<strong>高阶函数</strong>，等效于</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun1</span></span>(line:<span class="hljs-type">String</span>) &#123;  line.contains(<span class="hljs-string">&quot;Spark&quot;</span>)&#125;</code></pre><h3 id="chain-together-transformations-and-actions"><a href="#chain-together-transformations-and-actions" class="headerlink" title="chain together transformations and actions"></a>chain together transformations and actions</h3><pre><code class="hljs scala">scala&gt; textFile.filter(line =&gt; line.contains(<span class="hljs-string">&quot;Spark&quot;</span>)).count() <span class="hljs-comment">// How many lines contain &quot;Spark&quot;?</span>res3: <span class="hljs-type">Long</span> = <span class="hljs-number">15</span></code></pre><h2 id="RDD的更多操作"><a href="#RDD的更多操作" class="headerlink" title="RDD的更多操作"></a>RDD的更多操作</h2><ul><li>RDD.flatMap() 直接切分，压平了的</li><li>RDD.map() 切分，用数组来存的</li><li>RDD.reduce() 合并</li><li>RDD.reduceByKey() 针对Array的值的合并</li><li>RDD.collect() 类似于打印？</li></ul><h3 id="筛选出单词数最多的行"><a href="#筛选出单词数最多的行" class="headerlink" title="筛选出单词数最多的行"></a>筛选出单词数最多的行</h3><pre><code class="hljs scala">textFile.map(line =&gt; line.split(<span class="hljs-string">&quot; &quot;</span>).size).reduce((a, b) =&gt; <span class="hljs-keyword">if</span> (a &gt; b) a <span class="hljs-keyword">else</span> b)</code></pre><p>map函数的结果是各行的单词数作为行的值<br>reduce函数将进行比较，然后大的作为返回值，最后返回的就是最大的了<br>map()、reduce() 中的参数是 Scala 的函数字面量（function literals，也称为闭包 closures），并且可以使用语言特征或 Scala/JAVA 的库。<br>使用JAVA的MATH库</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> java.lang.<span class="hljs-type">Math</span>textFile.map(line =&gt; line.split(<span class="hljs-string">&quot; &quot;</span>).size).reduce((a, b) =&gt; <span class="hljs-type">Math</span>.max(a,b))</code></pre><h3 id="wordCount"><a href="#wordCount" class="headerlink" title="wordCount"></a>wordCount</h3><p>思路：Map是映射<br>flatMap<br>  apple<br>  apple<br>  balana<br>map<br>  (apple,1)<br>  (apple,1)<br>  (banane,1)<br>deduceByKey<br>  (apple,1+1)<br>  (banane,1)</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> wordCount = textFile.flatMap(line =&gt; line.split(<span class="hljs-string">&quot; &quot;</span>)).map(word =&gt; (word,<span class="hljs-number">1</span>)).reduceByKey((a,b) =&gt; a+b)wordCount.collect()</code></pre><p>wordCount就这么搞定了，思路还很清晰，还不用打包，还巨快，我的天。</p><p>切开来</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> textFile=sc.textFile(<span class="hljs-string">&quot;/user/cen/mapreduce/input/log4j.properties&quot;</span>)<span class="hljs-keyword">val</span> wordsRdd = testFile.flatMap(line =&gt; line.split(<span class="hljs-string">&quot; &quot;</span>))<span class="hljs-keyword">val</span> keyValueRdd=wordsRdd.map(word =&gt; (word,<span class="hljs-number">1</span>))<span class="hljs-comment">//这里的(word,1)是元组</span><span class="hljs-keyword">val</span> wordCountRdd = keyValueRdd.reduceByKey((a,b) =&gt; a+b)<span class="hljs-comment">//(a,b)是元组也可以写成(_ + _)</span>wordCount.collect()</code></pre><h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p>Spark支持将数据放入缓存作为热数据，这个函数支持很大的数据集</p><pre><code class="hljs scala">linesWithSpark.cache()</code></pre><h2 id="第一个自己的Application"><a href="#第一个自己的Application" class="headerlink" title="第一个自己的Application"></a>第一个自己的Application</h2><p>Spark支持JAVA Python Scala三种语言的API(其实好像还有Go，但是官方文档没有写出来)</p><ul><li>单从思想上来看，Scala是最合适不过的。</li><li>但是JAVA是我最需要熟悉作为主力语言的(毕竟MapReduce需要用JAVA写)</li><li>但是Python真的简单到，一种境界</li></ul><p>这里我就不写了，看官方文档去吧。。。最终想法：先用Python学思想，然后再研究Scala，以后还有大把机会学习JAVA</p><p><a href="http://dblab.xmu.edu.cn/blog/spark-quick-start-guide/">参考博客１</a></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Spark内核解析</title>
    <link href="/07-Bigdata/04-Spark/03-Spark%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90/"/>
    <url>/07-Bigdata/04-Spark/03-Spark%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark内核解析"><a href="#Spark内核解析" class="headerlink" title="Spark内核解析"></a>Spark内核解析</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="../images/03-01Spark%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90.png"></p><p>1.由RDD开始，构建DGA有向无环图</p><p>2.进行Shuffle等操作，分stage阶段进行DGA调度</p><p>3.由集群进行Task资源的调度(若整个阶段失败，返回上一级)</p><p>4.分配任务给Worker节点执行，若任务执行失败（返回上一级）</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Spark编程指南</title>
    <link href="/07-Bigdata/04-Spark/04-Spark%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <url>/07-Bigdata/04-Spark/04-Spark%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark编程指南"><a href="#Spark编程指南" class="headerlink" title="Spark编程指南"></a>Spark编程指南</h1><p><a href="http://spark.apache.org/docs/1.6.0/programming-guide.html">Spark Programming Guide</a></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>RDD是Spark的基本抽象，提供了并行计算，RDD能够从HDFS Scala 数据集中产生，用户常常将Spark中的RDD缓存在内存中，RDD自身提供了容灾.</p><p>Spark的第二抽象是在并行计算中共享变量，具体表现为搬运计算而不是搬运数据，计算将在数据节点发生，这时候需要共享的变量有两类：广播变量，用于缓存所有节点的内存中的值，累加器，用于计算总和的变量。</p><h2 id="Linking-with-Spark"><a href="#Linking-with-Spark" class="headerlink" title="Linking with Spark"></a>Linking with Spark</h2><p>使用<code>groupID %% artifactID % revision</code>将使用项目的Scala版本作为artifactID的版本</p><pre><code class="hljs sbt">libraryDependencies +&#x3D; groupID % artifactID % revision</code></pre><p>在SBT中使用maven的Spark依赖</p><pre><code class="hljs sbt">groupId &#x3D; org.apache.sparkartifactId &#x3D; spark-core_2.10version &#x3D; 1.6.0</code></pre><p>在用到Hadoop的时候需要Hadoop依赖</p><pre><code class="hljs sbt">groupId &#x3D; org.apache.hadoopartifactId &#x3D; hadoop-clientversion &#x3D; &lt;your-hdfs-version&gt;</code></pre><p>需要在Scalac程序中导包</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.<span class="hljs-type">SparkContext</span><span class="hljs-keyword">import</span> org.apache.spark.<span class="hljs-type">SparkConf</span></code></pre><h2 id="Initializing-Spark"><a href="#Initializing-Spark" class="headerlink" title="Initializing Spark"></a>Initializing Spark</h2><p>初始化Spark必须创建一个<code>SparkContext</code>,而且一个JVM中只能有一个SparkContext，使用完必须调用<code>stop()</code>函数</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> conf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setAppName(appName).setMaster(master)<span class="hljs-keyword">new</span> <span class="hljs-type">SparkContext</span>(conf)</code></pre><ul><li>appname:显示在UI中的界面</li><li><code>master</code> is a <em>Spark, Mesos or YARN cluster URL</em>, or a special “local” string to run in local mode.在集群中运行时，这个参数不需要设置，而是交给<code>spark-submit</code>去配置，以便在各种模式下运行而不需要改动代码，见文档。</li></ul><h3 id="Using-the-Shell"><a href="#Using-the-Shell" class="headerlink" title="Using the Shell"></a>Using the Shell</h3><p>Spark-shell中已经为我们创建了一个<code>SparkContext</code>并命名为<code>sc</code>.<br>允许指定主机名和classpath以及添加依赖，见文档。</p><h2 id="Resilient-Distributed-Datasets-RDDs"><a href="#Resilient-Distributed-Datasets-RDDs" class="headerlink" title="Resilient Distributed Datasets (RDDs)"></a>Resilient Distributed Datasets (RDDs)</h2><p>Spark revolves around the concept of a resilient distributed dataset (RDD), which is a fault-tolerant容错 collection of elements that can be operated on in parallel并行.</p><h3 id="Parallelized-Collections"><a href="#Parallelized-Collections" class="headerlink" title="Parallelized Collections"></a>Parallelized Collections</h3><p>直接使用Scala内部的变量转换成RDD，这种方法仅在测试时候使用，生产中数据从外部来，直接转换成为RDD。</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> data = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">val</span> distData = sc.parallelize(data)</code></pre><h3 id="External-Datasets"><a href="#External-Datasets" class="headerlink" title="External Datasets"></a>External Datasets</h3><p>这是最常用的方式，支持local file system, HDFS, Cassandra, HBase, Amazon S3, etc. Spark supports text files, SequenceFiles, and any other Hadoop InputFormat.</p><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> distFile = sc.textFile(<span class="hljs-string">&quot;data.txt&quot;</span>)distFile: <span class="hljs-type">RDD</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">MappedRDD</span>@<span class="hljs-number">1</span>d4cee08</code></pre><p>读取文件注意事项</p><ul><li>在使用本地路径时，需要保证所有的节点都有相同的路径和文件。</li><li>所有的输入函数都支持<strong>目录/压缩包/通配符</strong> <code>textFile(&quot;/my/directory&quot;), textFile(&quot;/my/directory/*.txt&quot;), textFile(&quot;/my/directory/*.gz&quot;)</code></li><li><code>textFile</code>函数默认以HDFS块大小来分区，你可以指定的partitions数，但不能少于块数。</li></ul><p>其他文件读取函数，详见文档</p><ul><li><code>SparkContext.wholeTextFiles</code></li><li><code>SparkContext.sequenceFile[K, V]</code></li><li><code>SparkContext.hadoopRDD</code></li><li><code>RDD.saveAsObjectFile</code></li></ul><h3 id="RDD-Operations"><a href="#RDD-Operations" class="headerlink" title="RDD Operations"></a>RDD Operations</h3><p>两类操作，transformations 和 actions<br><strong>任何的transformations都是lazy的</strong>,仅仅是记录了转换过程，并没有进行实际的操作。你也可以使用<code>persist (or cache)</code>函数，进行RDD缓存，这个缓存依然是发生在第一次使用之后。</p><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><h4 id="Passing-Functions-to-Spark"><a href="#Passing-Functions-to-Spark" class="headerlink" title="Passing Functions to Spark"></a>Passing Functions to Spark</h4><h4 id="Understanding-closures"><a href="#Understanding-closures" class="headerlink" title="Understanding closures"></a>Understanding closures</h4><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><h5 id="Local-vs-cluster-modes"><a href="#Local-vs-cluster-modes" class="headerlink" title="Local vs. cluster modes"></a>Local vs. cluster modes</h5><h5 id="Printing-elements-of-an-RDD"><a href="#Printing-elements-of-an-RDD" class="headerlink" title="Printing elements of an RDD"></a>Printing elements of an RDD</h5><h4 id="Working-with-Key-Value-Pairs"><a href="#Working-with-Key-Value-Pairs" class="headerlink" title="Working with Key-Value Pairs"></a>Working with Key-Value Pairs</h4><h4 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h4><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><h4 id="Shuffle-operations"><a href="#Shuffle-operations" class="headerlink" title="Shuffle operations"></a>Shuffle operations</h4><h5 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h5><h5 id="Performance-Impact"><a href="#Performance-Impact" class="headerlink" title="Performance Impact"></a>Performance Impact</h5><h3 id="RDD-Persistence"><a href="#RDD-Persistence" class="headerlink" title="RDD Persistence"></a>RDD Persistence</h3><h4 id="Which-Storage-Level-to-Choose"><a href="#Which-Storage-Level-to-Choose" class="headerlink" title="Which Storage Level to Choose?"></a>Which Storage Level to Choose?</h4><h4 id="Removing-Data"><a href="#Removing-Data" class="headerlink" title="Removing Data"></a>Removing Data</h4><h2 id="Shared-Variables"><a href="#Shared-Variables" class="headerlink" title="Shared Variables"></a>Shared Variables</h2><h3 id="Broadcast-Variables"><a href="#Broadcast-Variables" class="headerlink" title="Broadcast Variables"></a>Broadcast Variables</h3><h3 id="Accumulators"><a href="#Accumulators" class="headerlink" title="Accumulators"></a>Accumulators</h3><h2 id="Deploying-to-a-Cluster"><a href="#Deploying-to-a-Cluster" class="headerlink" title="Deploying to a Cluster"></a>Deploying to a Cluster</h2><h2 id="Launching-Spark-jobs-from-Java-Scala"><a href="#Launching-Spark-jobs-from-Java-Scala" class="headerlink" title="Launching Spark jobs from Java / Scala"></a>Launching Spark jobs from Java / Scala</h2><h2 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing"></a>Unit Testing</h2><h2 id="Migrating-from-pre-1-0-Versions-of-Spark"><a href="#Migrating-from-pre-1-0-Versions-of-Spark" class="headerlink" title="Migrating from pre-1.0 Versions of Spark"></a>Migrating from pre-1.0 Versions of Spark</h2>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Spark RDD</title>
    <link href="/07-Bigdata/04-Spark/05-Spark%20RDD/"/>
    <url>/07-Bigdata/04-Spark/05-Spark%20RDD/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark RDD"></a>Spark RDD</h1><p><a href="http://spark.apache.org/docs/1.6.0/programming-guide.html">Spark编程指南</a></p><h2 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h2><p>Spark revolves around the concept of a resilient distributed dataset (RDD), which is a fault-tolerant容错 collection of elements that can be operated on in parallel并行.</p><p>RDD Resilient Distributed Dataset,Spark中的基础抽象，RDD的值是不可变的(只能用val修饰)，分区存储，并行计算<br>底层地说，RDD是一个用于存储数据的类<br>弹性：数据默认在内存中，当内存不足时，存储到磁盘中，用户不用关心数据在哪里，另一个是计算层面的，数据丢失时通过所记录的lineage重新计算恢复</p><h2 id="五大特性-来自源码RDD-scala"><a href="#五大特性-来自源码RDD-scala" class="headerlink" title="五大特性(来自源码RDD.scala)"></a>五大特性(来自源码RDD.scala)</h2><ul><li>A list of partitions RDD是分区的集合，比如64M一个splite</li><li>A function for computing each split 每一个分区运行一个函数进行计算(并行计算)</li><li>A list of dependcies on other RDDs 每个RDD都有自己的lineage保存如何转换得来的</li><li>[Optionally] A partitioner for key-value RDDs 对于Key Value类型的RDD可以指定它的分区，默认是hash分区(也就是说可以像字典一样指定，mapreduce中也有这样的特性)</li><li>[Optionally] A list of preferred locations to comute each split on计算在本地执行，就是说HDFS在哪，Spark计算尽可能就在哪，由于HDFS可能在多台主机，因此一个partition可能返回多个最佳位置</li></ul><h2 id="五大特性在源码中的体现"><a href="#五大特性在源码中的体现" class="headerlink" title="五大特性在源码中的体现"></a>五大特性在源码中的体现</h2><p>这些都是能被子类重写的，可以用于计算，调优。。。</p><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RDD</span>[<span class="hljs-type">T</span>: <span class="hljs-type">ClassTag</span>](<span class="hljs-params"></span></span><span class="hljs-class"><span class="hljs-params">    @transient private var _sc: <span class="hljs-type">SparkContext</span>,</span></span><span class="hljs-class"><span class="hljs-params">    @transient private var deps: <span class="hljs-type">Seq</span>[<span class="hljs-type">Dependency</span>[_]]</span></span><span class="hljs-class"><span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Logging</span></span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">/**</span></span><span class="hljs-class"> <span class="hljs-title">*</span> 1.<span class="hljs-title">RDD是抽象类，不能直接使用</span></span><span class="hljs-class"> <span class="hljs-title">*</span> 2.<span class="hljs-title">T泛型，可以接受任何类型</span></span><span class="hljs-class"> <span class="hljs-title">*</span> 3.<span class="hljs-title">SparkContext</span></span><span class="hljs-class"> <span class="hljs-title">*</span> 4.<span class="hljs-title">Serializable序列化的</span></span><span class="hljs-class"> <span class="hljs-title">*</span> 5.<span class="hljs-title">@transient</span></span><span class="hljs-class"> <span class="hljs-title">*/</span></span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">//</span> <span class="hljs-title">A</span> <span class="hljs-title">list</span> <span class="hljs-title">of</span> <span class="hljs-title">partitions</span></span><span class="hljs-class"><span class="hljs-title">//</span> <span class="hljs-title">getPartitions的返回类型是一个元素为partition的数组</span></span><span class="hljs-class"><span class="hljs-title">protected</span> <span class="hljs-title">def</span> <span class="hljs-title">getPartitions</span></span>: <span class="hljs-type">Array</span>[<span class="hljs-type">Partition</span>]<span class="hljs-comment">// A function for computing each split</span><span class="hljs-comment">// compute函数的定义，需要传入参数Partition </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute</span></span>(split: <span class="hljs-type">Partition</span>, context: <span class="hljs-type">TaskContext</span>): <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>]<span class="hljs-comment">// A list of dependencies on other RDDs</span><span class="hljs-comment">// getDependencies函数，获得依赖关系</span><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDependencies</span></span>: <span class="hljs-type">Seq</span>[<span class="hljs-type">Dependency</span>[_]] = deps<span class="hljs-comment">// Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</span><span class="hljs-comment">// </span><span class="hljs-meta">@transient</span> <span class="hljs-keyword">val</span> partitioner: <span class="hljs-type">Option</span>[<span class="hljs-type">Partitioner</span>] = <span class="hljs-type">None</span><span class="hljs-comment">// Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</span><span class="hljs-comment">// getPreferredLocations函数，获得可选的位置列表s</span><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPreferredLocations</span></span>(split: <span class="hljs-type">Partition</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Nil</span></code></pre><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>There are two ways to create RDDs: parallelizing an existing collection in your driver program, or referencing a dataset in an external storage system, such as a shared filesystem, HDFS, HBase, or any data source offering a Hadoop InputFormat.</p><h3 id="Parallelized-Collections-从代码中的变量转换过来的并行数据集"><a href="#Parallelized-Collections-从代码中的变量转换过来的并行数据集" class="headerlink" title="Parallelized Collections 从代码中的变量转换过来的并行数据集"></a>Parallelized Collections 从代码中的变量转换过来的并行数据集</h3><p>在测试有用而已，在实际环境中没什么作用。<br>然而在官方文档中说了很多关于RDD的重要知识，比如说</p><ul><li><p>默认分片数为2</p></li><li><p>每一个分片就会运行一个task</p></li><li><p>一般的，一个code对应2-4个分片，为了不让CPU休息下来</p><p>  原文如下：</p><p>  One important parameter for parallel collections is the number of partitions to cut the dataset into. Spark will run one task for each partition of the cluster. Typically you want 2-4 partitions for each CPU in your cluster. Normally, Spark tries to set the number of partitions automatically based on your cluster. However, you can also set it manually by passing it as a second parameter to parallelize (e.g. sc.parallelize(data, 10)). Note: some places in the code use the term slices (a synonym for partitions) to maintain backward compatibility.</p></li></ul><pre><code class="hljs scala"><span class="hljs-keyword">val</span> data = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">val</span> distData = sc.parallelize(data)<span class="hljs-comment">//使用说明详见源码</span></code></pre><h3 id="External-Datasets-外部数据源"><a href="#External-Datasets-外部数据源" class="headerlink" title="External Datasets 外部数据源"></a>External Datasets 外部数据源</h3><pre><code class="hljs scala">scala&gt; <span class="hljs-keyword">val</span> distFile = sc.textFile(<span class="hljs-string">&quot;data.txt&quot;</span>)distFile: <span class="hljs-type">RDD</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">MappedRDD</span>@<span class="hljs-number">1</span>d4cee08</code></pre><h2 id="两种操作"><a href="#两种操作" class="headerlink" title="两种操作"></a>两种操作</h2><h3 id="actions-真的的计算"><a href="#actions-真的的计算" class="headerlink" title="actions(真的的计算)"></a>actions(真的的计算)</h3><h3 id="transformation"><a href="#transformation" class="headerlink" title="transformation"></a>transformation</h3><h2 id="RDD-Persistence-缓存"><a href="#RDD-Persistence-缓存" class="headerlink" title="RDD Persistence(缓存)"></a>RDD Persistence(缓存)</h2><p>从源码看，cache和persist()直接使用是一样的，但是persist()可以传入参数，高级选项，详见文档</p><pre><code class="hljs scala"><span class="hljs-comment">/** Persist this RDD with the default storage level (`MEMORY_ONLY`).#/</span><span class="hljs-comment">def persist(): this.type = persist(StorageLevel.MEMORY_ONLY)</span><span class="hljs-comment"></span><span class="hljs-comment">/** Persist this RDD with the default storage level (`MEMORY_ONLY`).#/</span><span class="hljs-comment">def cache(): this.type = persist()</span></code></pre><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>在做transformation的时候是不进行任何计算的，只是记录了运算的过程，等到actions的时候才真正执行。</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-IDEA踩坑日记</title>
    <link href="/07-Bigdata/04-Spark/06-IDEA%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <url>/07-Bigdata/04-Spark/06-IDEA%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="踩坑日志"><a href="#踩坑日志" class="headerlink" title="踩坑日志"></a>踩坑日志</h1><h2 id="找不到依赖包报错"><a href="#找不到依赖包报错" class="headerlink" title="找不到依赖包报错"></a>找不到依赖包报错</h2><ul><li>报错:Error:scalac: No ‘scala-library*.jar’ in Scala compiler classpath in Scala SDK SBT: org.scala-lang:scala-library:2.10.6:jar</li><li>原因：用了系统自己的依赖lib文件，残缺的爱</li><li>解决：下载一个所需版本的scala，配置project structure的libraries的classpath删除自带的，增加自己的lib路径下的全部文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-Spark应用提交</title>
    <link href="/07-Bigdata/04-Spark/07-Spark%E5%BA%94%E7%94%A8%E6%8F%90%E4%BA%A4/"/>
    <url>/07-Bigdata/04-Spark/07-Spark%E5%BA%94%E7%94%A8%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="应用提交"><a href="#应用提交" class="headerlink" title="应用提交"></a>应用提交</h1><p><a href="http://spark.apache.org/docs/1.6.0/submitting-applications.html">官方文档</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code class="hljs sh">bin/spark-submit \  --class &lt;main-class&gt;  --master &lt;master-url&gt; \  --deploy-mode &lt;deploy-mode&gt; \  --conf &lt;key&gt;=&lt;value&gt; \  ... <span class="hljs-comment"># other options</span>  &lt;application-jar&gt; \  [application-arguments]</code></pre><p>bin/spark-submit <br>  –master spark://localhost:7077 <br>  jars/SimpleApp.jar</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-SparkStreaming</title>
    <link href="/07-Bigdata/04-Spark/10-SparkStreaming/"/>
    <url>/07-Bigdata/04-Spark/10-SparkStreaming/</url>
    
    <content type="html"><![CDATA[<p><a href="http://spark.apache.org/docs/1.6.0/streaming-programming-guide.html">官方文档</a></p><h1 id="SparkStreaming是什么"><a href="#SparkStreaming是什么" class="headerlink" title="SparkStreaming是什么"></a>SparkStreaming是什么</h1><p>Spark Streaming is an extension of the core Spark API that enables scalable可拓展, high-throughput高效, fault-tolerant容错 stream processing of live data streams.</p><p>支持的数据流：还有socket等</p><p><img src="../images/10-01.png"></p><h2 id="例子和编程模型"><a href="#例子和编程模型" class="headerlink" title="例子和编程模型"></a>例子和编程模型</h2><p>一个以socket为数据源的测试案例(类似Flume)</p><p>监听数据源：</p><pre><code class="hljs sh">bin/run-example streaming.NetworkWordCount localhost 9999</code></pre><p>创建数据源：</p><pre><code class="hljs sh">nc -lk 9999</code></pre><p>源码分析：</p><pre><code class="hljs Scala"><span class="hljs-keyword">import</span> org.apache.spark._<span class="hljs-keyword">import</span> org.apache.spark.streaming._<span class="hljs-comment">// Create a local StreamingContext with two working thread and batch interval of 1 second.</span><span class="hljs-comment">// The master requires 2 cores to prevent from a starvation scenario.</span><span class="hljs-keyword">val</span> conf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[2]&quot;</span>).setAppName(<span class="hljs-string">&quot;NetworkWordCount&quot;</span>)<span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(conf, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//这里创建时的是StreamingContext</span><span class="hljs-comment">// Create a DStream that will connect to hostname:port, like localhost:9999</span><span class="hljs-keyword">val</span> lines = ssc.socketTextStream(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<span class="hljs-comment">//lines是一个Dstream而不是DDR</span><span class="hljs-comment">// Split each line into words</span><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<span class="hljs-comment">// Count each word in each batch</span><span class="hljs-keyword">val</span> pairs = words.map(word =&gt; (word, <span class="hljs-number">1</span>))<span class="hljs-keyword">val</span> wordCounts = pairs.reduceByKey(_ + _)<span class="hljs-comment">// Print the first ten elements of each RDD generated in this DStream to the console</span>wordCounts.print()ssc.start()             <span class="hljs-comment">// Start the computation</span>ssc.awaitTermination()  <span class="hljs-comment">// Wait for the computation to terminate</span></code></pre><p>编程模板：</p><pre><code class="hljs scala"><span class="hljs-comment">//1.导包</span><span class="hljs-keyword">import</span> org.apache.spark._<span class="hljs-keyword">import</span> org.apache.spark.streaming._<span class="hljs-comment">//2.配置</span><span class="hljs-keyword">val</span> conf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[2]&quot;</span>).setAppName(<span class="hljs-string">&quot;NetworkWordCount&quot;</span>)<span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(conf, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//方式一：直接使用SparkConf创建</span><span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(sc, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//方式二：使用已经存在的SparkContext创建(常用于Spark-Shell测试开发)</span><span class="hljs-comment">//3.设置数据源</span><span class="hljs-keyword">val</span> lines = ssc.socketTextStream(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<span class="hljs-comment">//4.DStream处理</span><span class="hljs-comment">// TODU</span><span class="hljs-comment">//5.启动</span>ssc.start()             <span class="hljs-comment">// Start the computation</span>ssc.awaitTermination()  <span class="hljs-comment">// Wait for the computation to terminate</span></code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Spark Streaming receives live input data streams and divides the data into <strong>batches</strong>, which are then processed by the Spark engine to generate the final stream of results in batches.</p><p><img src="../images/10-02.png"></p><p>batches的切分标准是上文中的<code>val ssc = new StreamingContext(conf, Seconds(1))</code>配置为标准！</p><p>详细的执行步骤:</p><p><img src="../images/10-03.png"></p><h4 id="DStreams"><a href="#DStreams" class="headerlink" title="DStreams"></a>DStreams</h4><p><strong>Discretized Stream</strong> or <strong>DStream</strong> is the basic abstraction provided by Spark Streaming. Internally, a DStream is represented by a continuous series of RDDs.（在内部，Dstream是连续序列的RDD）</p><p>Dstream和RDDs关系图:</p><p><img src="../images/10-04.png"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-Spark读取HDFS数据</title>
    <link href="/07-Bigdata/04-Spark/11-Spark%E8%AF%BB%E5%8F%96HDFS%E6%95%B0%E6%8D%AE/"/>
    <url>/07-Bigdata/04-Spark/11-Spark%E8%AF%BB%E5%8F%96HDFS%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>一种看源码的方式：<a href="https://github.com/apache/spark/blob/v1.6.0/streaming/src/main/scala/org/apache/spark/streaming/StreamingContext.scala">Github</a>)</p><p>源码解析:</p><pre><code class="hljs scala"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Create a input stream that monitors a Hadoop-compatible filesystem</span><span class="hljs-comment"> * for new files and reads them as text files (using key as LongWritable, value</span><span class="hljs-comment"> * as Text and input format as TextInputFormat). Files must be written to the</span><span class="hljs-comment"> * monitored directory by &quot;moving&quot; them from another location within the same</span><span class="hljs-comment"> * file system. File names starting with . are ignored.</span><span class="hljs-comment"> * @param directory HDFS directory to monitor for new file</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">textFileStream</span></span>(directory: <span class="hljs-type">String</span>): <span class="hljs-type">DStream</span>[<span class="hljs-type">String</span>] = withNamedScope(<span class="hljs-string">&quot;text file stream&quot;</span>) &#123;  fileStream[<span class="hljs-type">LongWritable</span>, <span class="hljs-type">Text</span>, <span class="hljs-type">TextInputFormat</span>](directory).map(_._2.toString)&#125;</code></pre><p>MyApplication：</p><pre><code class="hljs scala"><span class="hljs-comment">//1.导包</span><span class="hljs-keyword">import</span> org.apache.spark._<span class="hljs-keyword">import</span> org.apache.spark.streaming._<span class="hljs-comment">//2.配置</span><span class="hljs-keyword">val</span> conf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[2]&quot;</span>).setAppName(<span class="hljs-string">&quot;NetworkWordCount&quot;</span>)<span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(conf, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">/********仅在shell中使用**********/</span><span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(sc, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//3.设置数据源</span><span class="hljs-keyword">val</span> lines = ssc.textFileStream(<span class="hljs-string">&quot;hdfs://localhost:8020/user/cen/spark/input/&quot;</span>)<span class="hljs-comment">//监控整个文件夹</span><span class="hljs-comment">//4.DStream处理</span><span class="hljs-keyword">val</span> words = lines.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<span class="hljs-keyword">val</span> pairs = words.map(word =&gt; (word, <span class="hljs-number">1</span>))<span class="hljs-keyword">val</span> wordCounts = pairs.reduceByKey(_ + _)wordCounts.print()<span class="hljs-comment">//保存数据到文件系统</span><span class="hljs-comment">//wordCounts.saveAsTextFiles(&quot;hdfs://localhost:8020/user/cen/spark/output/&quot;)</span><span class="hljs-comment">//5.启动</span>ssc.start()ssc.awaitTermination()</code></pre><h2 id="使用Spark-shell-贴代码"><a href="#使用Spark-shell-贴代码" class="headerlink" title="使用Spark-shell(贴代码)"></a>使用Spark-shell(贴代码)</h2><h2 id="使用Spark-shell加载file"><a href="#使用Spark-shell加载file" class="headerlink" title="使用Spark-shell加载file"></a>使用Spark-shell加载file</h2><pre><code class="hljs scala">:load /dir/dir/filename.scala</code></pre><h2 id="使用IDEA打包"><a href="#使用IDEA打包" class="headerlink" title="使用IDEA打包"></a>使用IDEA打包</h2>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-Spark与Flume集成</title>
    <link href="/07-Bigdata/04-Spark/12-Spark%E4%B8%8EFlume%E9%9B%86%E6%88%90/"/>
    <url>/07-Bigdata/04-Spark/12-Spark%E4%B8%8EFlume%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p><img src="../images/12-01.png"></p><p><a href="http://spark.apache.org/docs/1.6.0/streaming-flume-integration.html">官方文档</a></p><h2 id="方法一-Flume-style-Push-based-Approach（SparkStreaming是受）"><a href="#方法一-Flume-style-Push-based-Approach（SparkStreaming是受）" class="headerlink" title="方法一:Flume-style Push-based Approach（SparkStreaming是受）"></a>方法一:Flume-style Push-based Approach（SparkStreaming是受）</h2><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项</strong>：</h3><ul><li><p>When your Flume + Spark Streaming application is launched, one of the Spark workers must run on that machine.Spark要先于flume启动，否则推就撞墙了</p></li><li><p>Flume can be configured to push data to a port on that machine.端口必须能够接受数据</p></li></ul><p>Flume架构(本身就是主动push的)：</p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723113827028-57517500.png"></p><p>Spark直接到sink之后去接受数据</p><h3 id="配置Flume的配置文件，请参考Flume配置"><a href="#配置Flume的配置文件，请参考Flume配置" class="headerlink" title="配置Flume的配置文件，请参考Flume配置"></a>配置Flume的配置文件，请参考<a href="https://flume.apache.org/documentation.html">Flume配置</a></h3><pre><code class="hljs sh">agent.sinks = avroSinkagent.sinks.avroSink.type = avroagent.sinks.avroSink.channel = memoryChannelagent.sinks.avroSink.hostname = &lt;chosen machine<span class="hljs-string">&#x27;s hostname&gt;</span><span class="hljs-string">agent.sinks.avroSink.port = &lt;chosen port on the machine&gt;</span></code></pre><h3 id="配置Spark-Streaming-Application"><a href="#配置Spark-Streaming-Application" class="headerlink" title="配置Spark Streaming Application"></a>配置Spark Streaming Application</h3><p>可以参考官方<a href="https://github.com/apache/spark/blob/v1.6.0/examples/src/main/java/org/apache/spark/examples/streaming/JavaFlumeEventCount.java">example</a></p><pre><code class="hljs scala"><span class="hljs-comment">//这个包是默认不在spark的classpath中的，要使用STB/mvn导包，或者手动导包</span><span class="hljs-comment">// 1.编译路径下的extantnal/flume/target/目录下的spark-steam-flume*.jar</span><span class="hljs-comment">// 2.flume/libs目录下的flume-ng-sdk*.jar</span><span class="hljs-comment">// 3.flume.libs目录下的flume-avro-source*.jar</span><span class="hljs-comment">// 加载依赖包bin/spark-shell --jars /dir/1.jar,/dir/2.jar,/dir/3.jar</span><span class="hljs-keyword">import</span> org.apache.spark.streaming.flume._<span class="hljs-keyword">val</span> flumeStream = <span class="hljs-type">FlumeUtils</span>.createStream(streamingContext, [chosen machine<span class="hljs-symbol">&#x27;s</span> hostname], [chosen port])</code></pre><p>启动sparkshell:</p><pre><code class="hljs sh">bin/spark-shell --jars /home/cen/software/apache/spark-1.6.0/externaljars/spark-streaming-flume_2.10-1.6.0.jar,/home/cen/software/apache/spark-1.6.0/externaljars/flume-ng-sdk-1.6.0.jar,/home/cen/software/apache/spark-1.6.0/externaljars/flume-avro-source-1.6.0.jar</code></pre><p>启动flume:</p><pre><code class="hljs sh">bin/flume-ng agent --conf conf --name a1 --conf-file application/flume2spark.conf -Dflume.root.logger=DEBUG,console</code></pre><pre><code class="hljs scala"><span class="hljs-comment">//1.导包</span><span class="hljs-keyword">import</span> org.apache.spark._<span class="hljs-keyword">import</span> org.apache.spark.streaming._<span class="hljs-keyword">import</span> org.apache.spark.streaming.flume._<span class="hljs-comment">//2.配置</span><span class="hljs-keyword">val</span> conf = <span class="hljs-keyword">new</span> <span class="hljs-type">SparkConf</span>().setMaster(<span class="hljs-string">&quot;local[2]&quot;</span>).setAppName(<span class="hljs-string">&quot;NetworkWordCount&quot;</span>)<span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(conf, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//方式一：直接使用SparkConf创建</span><span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(sc, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//方式二：使用已经存在的SparkContext创建(常用于Spark-Shell测试开发)</span><span class="hljs-comment">//3.设置数据源</span><span class="hljs-keyword">val</span> flumeStream = <span class="hljs-type">FlumeUtils</span>.createStream(ssc,<span class="hljs-string">&quot;cen-ubuntu&quot;</span>,<span class="hljs-number">9999</span>)<span class="hljs-comment">//4.DStream处理</span><span class="hljs-keyword">val</span> words = flumeStream.flatMap(_.split(<span class="hljs-string">&quot; &quot;</span>))<span class="hljs-keyword">val</span> pairs = words.map(word =&gt; (word, <span class="hljs-number">1</span>))<span class="hljs-keyword">val</span> wordCounts = pairs.reduceByKey(_ + _)wordCounts.print()<span class="hljs-comment">//5.启动</span>ssc.start()             <span class="hljs-comment">// Start the computation</span>ssc.awaitTermination()  <span class="hljs-comment">// Wait for the computation to terminate</span></code></pre><h2 id="方法二-Pull-based-Approach-using-a-Custom-Sink（SparkStreaming是攻）"><a href="#方法二-Pull-based-Approach-using-a-Custom-Sink（SparkStreaming是攻）" class="headerlink" title="方法二:Pull-based Approach using a Custom Sink（SparkStreaming是攻）"></a>方法二:Pull-based Approach using a Custom Sink（SparkStreaming是攻）</h2>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-spark-shell</title>
    <link href="/07-Bigdata/04-Spark/14-spark-shell/"/>
    <url>/07-Bigdata/04-Spark/14-spark-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark-shell使用教程"><a href="#Spark-shell使用教程" class="headerlink" title="Spark-shell使用教程"></a>Spark-shell使用教程</h1><pre><code class="hljs sh">bin/spark-shell \  --master              运行模式  --name                在web UI中的名字  --jars                使用,分割的依赖包  --driver*             驱动器的各种配置  --executor-memory     执行器的内存  --executor-cores      执行器的内核  --driver-cores        驱动器的内核  --queue               序列  --num-executors       执行器数量</code></pre><pre><code class="hljs sh">bin/spark-shell \  --master <span class="hljs-built_in">local</span>[2] \  --name <span class="hljs-built_in">test</span> \  --jars /dir/dir/asd.jar,/dir/dir/asd.jar \  --driver*  --executor-memory \  --executor-cores  --driver-cores  --queue  --num-executors</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-spark-submit</title>
    <link href="/07-Bigdata/04-Spark/13-spark-submit/"/>
    <url>/07-Bigdata/04-Spark/13-spark-submit/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark应用提交"><a href="#Spark应用提交" class="headerlink" title="Spark应用提交"></a>Spark应用提交</h1><p><a href="http://spark.apache.org/docs/latest/submitting-applications.html">官方文档</a></p><pre><code class="hljs sh"><span class="hljs-comment"># 根据下文来改</span>./bin/spark-submit \  --class &lt;main-class&gt; \  --master &lt;master-url&gt; \  --deploy-mode &lt;deploy-mode&gt; \  --conf &lt;key&gt;=&lt;value&gt; \  &lt;application-jar&gt; \  [application-arguments]</code></pre><pre><code class="hljs sh"><span class="hljs-comment"># 一个本地测试的实例</span>./bin/spark-submit \  --class com.cenzhongman.SparkTest \  --master <span class="hljs-built_in">local</span>[2] \  --jars /home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/zkclient-0.10.jar,/home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/spark-streaming-kafka-0-8_2.11-2.2.0.jar,/home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/metrics-core-2.2.0.jar,/home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/kafka-clients-0.11.0.1.jar,/home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/kafka_2.11-0.11.0.1.jar \  /home/cen/softwares/cdh/spark-2.2.0-bin-2.6.0/data/kafka/first-spark-1.0.jar</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Elasticsearch初体验</title>
    <link href="/07-Bigdata/09-Elasticsearch/01-Elasticsearch%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/07-Bigdata/09-Elasticsearch/01-Elasticsearch%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>如果英文不好，官网可以选择中文，但是中文参考指南中只能提供你需要的思想，它的版本为1.x和2.x，现在已经一下子跳到了5.x</p><h1 id="Elasticsearch是什么"><a href="#Elasticsearch是什么" class="headerlink" title="Elasticsearch是什么"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html">Elasticsearch是什么</a></h1><p>Elasticsearch 是一个实时的分布式搜索分析引擎，使用JSON存储数据，也使用JSON作为查询的请求体。</p><p>在大数据检索领域，它是一个什么地位呢？<br>它部署简单，不需要繁杂的安装和配置，能够很容易就能在单机或者集群上运行起来，给它数据就能工作。门槛较低，也能迎合大体量的需求。实时，而不需要大量的批处理任务。</p><ul><li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><h2 id="CS模型"><a href="#CS模型" class="headerlink" title="CS模型"></a>CS模型</h2><h3 id="Elasticsearch-将所有的功能打包成一个单独的服务"><a href="#Elasticsearch-将所有的功能打包成一个单独的服务" class="headerlink" title="Elasticsearch 将所有的功能打包成一个单独的服务"></a>Elasticsearch 将所有的功能打包成一个单独的服务</h3><p>使用RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>前提是JDK已经正确安装和配置。</p><h2 id="单节点安装Elasticsearch"><a href="#单节点安装Elasticsearch" class="headerlink" title="单节点安装Elasticsearch"></a>单节点安装Elasticsearch</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html">官方文档</a></p><p>其实就是下载解压即可</p><pre><code class="hljs sh">bin/elasticsearch</code></pre><p>可选参数</p><ul><li>-E <KeyValuePair>     Configure a setting       </li><li>-d, –daemonize       Starts Elasticsearch in the background     </li><li>-p, –pidfile <Path>  Creates a pid file in the specified path on start    </li><li>-q, –quiet           Turns off standard ouput/error streams logging in console</li><li>-s, –silent          show minimal output                                 </li><li>-v, –verbose         show verbose output </li></ul><p>这时候，9200端口就是Elasticsearch的RESTful API 的通信端口(JAVA client使用9300)，通过以下指令查看这个服务的相关信息</p><pre><code class="hljs sh"><span class="hljs-comment"># 参数pretty是将返回的json结果格式化输出的选项</span>curl <span class="hljs-string">&#x27;http://localhost:9200/?pretty&#x27;</span>&#123;  <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;fHBOSjF&quot;</span>,  <span class="hljs-string">&quot;cluster_name&quot;</span> : <span class="hljs-string">&quot;elasticsearch&quot;</span>,  <span class="hljs-string">&quot;cluster_uuid&quot;</span> : <span class="hljs-string">&quot;qpPdtXemTtCN8_YkXMnBaw&quot;</span>,  <span class="hljs-string">&quot;version&quot;</span> : &#123;    <span class="hljs-string">&quot;number&quot;</span> : <span class="hljs-string">&quot;5.6.2&quot;</span>,    <span class="hljs-string">&quot;build_hash&quot;</span> : <span class="hljs-string">&quot;57e20f3&quot;</span>,    <span class="hljs-string">&quot;build_date&quot;</span> : <span class="hljs-string">&quot;2017-09-23T13:16:45.703Z&quot;</span>,    <span class="hljs-string">&quot;build_snapshot&quot;</span> : <span class="hljs-literal">false</span>,    <span class="hljs-string">&quot;lucene_version&quot;</span> : <span class="hljs-string">&quot;6.6.1&quot;</span>  &#125;,  <span class="hljs-string">&quot;tagline&quot;</span> : <span class="hljs-string">&quot;You Know, for Search&quot;</span>&#125;</code></pre><h2 id="多节点安装"><a href="#多节点安装" class="headerlink" title="多节点安装"></a>多节点安装</h2><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p><a href="https://www.elastic.co/downloads/kibana">官方文档</a></p><p>kibana是一个配合elasticsearch使用的Web监控组件。作为客户端，通过9200端口与elasticsearch进行交互。</p><ol><li><p>下载kibana</p></li><li><p>编辑<code>config/kibana.yml</code>文件</p></li></ol><pre><code class="hljs sh">lasticsearch.url: <span class="hljs-string">&quot;http://localhost:9200&quot;</span></code></pre><ol start="3"><li>启动kibana</li></ol><pre><code class="hljs sh">bin/kibana</code></pre><ol start="4"><li>Web监控<a href="http://localhost:5601/">http://localhost:5601</a></li></ol><h1 id="交互式使用"><a href="#交互式使用" class="headerlink" title="交互式使用"></a><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_talking_to_elasticsearch.html">交互式使用</a></h1><h2 id="使用JAVA-Client"><a href="#使用JAVA-Client" class="headerlink" title="使用JAVA Client"></a>使用JAVA Client</h2><h2 id="使用RESTful-API"><a href="#使用RESTful-API" class="headerlink" title="使用RESTful API"></a>使用RESTful API</h2><pre><code class="hljs sh">curl -X&lt;VERB&gt; <span class="hljs-string">&#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27;</span> -d <span class="hljs-string">&#x27;&lt;BODY&gt;&#x27;</span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>VERB</td><td>适当的 HTTP 方法 或 谓词 : GET<code>、 </code>POST<code>、 </code>PUT<code>、 </code>HEAD 或者 <code>DELETE</code></td></tr><tr><td>PROTOCOL</td><td>http 或者 https<code>（如果你在 Elasticsearch 前面有一个 </code>https 代理）</td></tr><tr><td>HOST</td><td>Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点</td></tr><tr><td>PORT</td><td>运行 Elasticsearch HTTP 服务的端口号，默认是 9200</td></tr><tr><td>PATH</td><td>API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm</td></tr><tr><td>QUERY_STRING</td><td>任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</td></tr><tr><td>BODY</td><td>一个 JSON 格式的请求体 (如果请求需要的话)</td></tr></tbody></table><p>使用示例</p><pre><code class="hljs sh">curl -XGET <span class="hljs-string">&#x27;http://localhost:9200/_count?pretty&#x27;</span> -d <span class="hljs-string">&#x27;</span><span class="hljs-string">&#123;</span><span class="hljs-string">    &quot;query&quot;: &#123;</span><span class="hljs-string">        &quot;match_all&quot;: &#123;&#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#x27;</span></code></pre><p>返回结果</p><pre><code class="hljs sh"><span class="hljs-comment"># 在curl命令中加入-i参数，将会打印请求头</span>&#123;  <span class="hljs-string">&quot;count&quot;</span>: 2,  <span class="hljs-string">&quot;_shards&quot;</span>: &#123;    <span class="hljs-string">&quot;total&quot;</span>: 6,    <span class="hljs-string">&quot;successful&quot;</span>: 6,    <span class="hljs-string">&quot;skipped&quot;</span>: 0,    <span class="hljs-string">&quot;failed&quot;</span>: 0  &#125;&#125;</code></pre><h3 id="关于缩写"><a href="#关于缩写" class="headerlink" title="关于缩写"></a>关于缩写</h3><p>文档中缩写一般如下，可以直接在Kibana控制台执行</p><pre><code class="hljs sh">GET /_count&#123;    <span class="hljs-string">&quot;query&quot;</span>: &#123;        <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;    &#125;&#125;</code></pre><p>实际上的crul信息</p><pre><code class="hljs sh">curl -XGET <span class="hljs-string">&#x27;localhost:9200/_count?pretty&#x27;</span> -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="hljs-string">&#x27;</span><span class="hljs-string">&#123;</span><span class="hljs-string">    &quot;query&quot;: &#123;</span><span class="hljs-string">        &quot;match_all&quot;: &#123;&#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#x27;</span></code></pre><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><ul><li>Document：一个Document存储一个员工信息</li><li>index(v)：存储数据到 Elasticsearch 的行为叫做<em>index</em></li><li>index(n):储存关系型文档的地方，一个Elasticsearch集群可以有多个index，每一个索引可以包含多种<em>类型</em>(雇主，员工等)，每个类型又多个<em>文档</em>，每个文档有多个<em>属性</em>。</li></ul><p>对一个员工，他的文档创建如下：</p><pre><code class="hljs sh">PUT /megacorp/employee/1&#123;    <span class="hljs-string">&quot;first_name&quot;</span> : <span class="hljs-string">&quot;John&quot;</span>,    <span class="hljs-string">&quot;last_name&quot;</span> :  <span class="hljs-string">&quot;Smith&quot;</span>,    <span class="hljs-string">&quot;age&quot;</span> :        25,    <span class="hljs-string">&quot;about&quot;</span> :      <span class="hljs-string">&quot;I love to go rock climbing&quot;</span>,    <span class="hljs-string">&quot;interests&quot;</span>: [ <span class="hljs-string">&quot;sports&quot;</span>, <span class="hljs-string">&quot;music&quot;</span> ]&#125;</code></pre><p>路径<code>/megacorp/employee/1</code>包含了三部分的信息：</p><p><code>megacorp</code>索引名称</p><p><code>employee</code>类型名称</p><p><code>1</code>雇员的ID</p><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><h3 id="得到文档"><a href="#得到文档" class="headerlink" title="得到文档"></a>得到文档</h3><pre><code class="hljs sh"><span class="hljs-comment"># 根据路径get即可</span>GET /megacorp/employee/1<span class="hljs-comment"># 相当于</span>curl -XGET <span class="hljs-string">&quot;http://localhost:9200/megacorp/employee/1&quot;</span></code></pre><h3 id="简单搜索（传参这种方法只适用简单的命令行查询）"><a href="#简单搜索（传参这种方法只适用简单的命令行查询）" class="headerlink" title="简单搜索（传参这种方法只适用简单的命令行查询）"></a>简单搜索（传参这种方法只适用简单的命令行查询）</h3><p>使用 <code>_search</code> 来取代原来的文档ID</p><pre><code class="hljs sh"><span class="hljs-comment"># 默认返回前10个结果</span>GET /megacorp/employee/_search</code></pre><pre><code class="hljs sh"><span class="hljs-comment"># ？q=表示把要查询的内容传递给参数q</span>GET /megacorp/employee/_search?q=last_name:Smith</code></pre><h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><p>DSL(Domain Specific Language特定领域语言)</p><pre><code class="hljs sh"><span class="hljs-comment"># 使用了match语句，这是查询的类型之一</span>GET /megacorp/employee/_search&#123;    <span class="hljs-string">&quot;query&quot;</span> : &#123;        <span class="hljs-string">&quot;match&quot;</span> : &#123;            <span class="hljs-string">&quot;last_name&quot;</span> : <span class="hljs-string">&quot;Smith&quot;</span>        &#125;    &#125;&#125;</code></pre><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><pre><code class="hljs sh">GET /megacorp/employee/_search&#123;    <span class="hljs-string">&quot;query&quot;</span> : &#123;        <span class="hljs-string">&quot;filtered&quot;</span> : &#123;            <span class="hljs-string">&quot;filter&quot;</span> : &#123;                <span class="hljs-string">&quot;range&quot;</span> : &#123;                    <span class="hljs-string">&quot;age&quot;</span> : &#123; <span class="hljs-string">&quot;gt&quot;</span> : 30 &#125; &lt;1&gt;                &#125;            &#125;,            <span class="hljs-string">&quot;query&quot;</span> : &#123;                <span class="hljs-string">&quot;match&quot;</span> : &#123;                    <span class="hljs-string">&quot;last_name&quot;</span> : <span class="hljs-string">&quot;smith&quot;</span> &lt;2&gt;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>使用区间过滤器(range filter)，<code>gt</code>为”greater than”的缩写，<code>filter</code>过滤结果作为第二部分<code>query</code>的源</p><h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>我们将会搜索所有喜欢“rock climbing”的员工:</p><pre><code class="hljs sh">GET /megacorp/employee/_search&#123;    <span class="hljs-string">&quot;query&quot;</span> : &#123;        <span class="hljs-string">&quot;match&quot;</span> : &#123;            <span class="hljs-string">&quot;about&quot;</span> : <span class="hljs-string">&quot;rock climbing&quot;</span>        &#125;    &#125;&#125;</code></pre><p>在结果中有<code>&quot;_score&quot;: 0.53484553,</code>相关性(relevance)评分。</p><h3 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h3><p>将<code>match</code>替换成<code>match_phrase</code>即可</p><h3 id="高亮匹配结果"><a href="#高亮匹配结果" class="headerlink" title="高亮匹配结果"></a>高亮匹配结果</h3><pre><code class="hljs sh">GET /megacorp/employee/_search&#123;    <span class="hljs-string">&quot;query&quot;</span> : &#123;        <span class="hljs-string">&quot;match_phrase&quot;</span> : &#123;            <span class="hljs-string">&quot;about&quot;</span> : <span class="hljs-string">&quot;rock climbing&quot;</span>        &#125;    &#125;,    <span class="hljs-string">&quot;highlight&quot;</span>: &#123;        <span class="hljs-string">&quot;fields&quot;</span> : &#123;            <span class="hljs-string">&quot;about&quot;</span> : &#123;&#125;        &#125;    &#125;&#125;</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>聚合(aggregations)</p><pre><code class="hljs sh">GET /megacorp/employee/_search&#123;  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;    <span class="hljs-string">&quot;all_interests&quot;</span>: &#123;      <span class="hljs-string">&quot;terms&quot;</span>: &#123; <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;interests&quot;</span> &#125; <span class="hljs-comment"># 使用了terms函数 ， field 字段</span>    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>09-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-分布式集群原理和搭建</title>
    <link href="/07-Bigdata/09-Elasticsearch/02-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%92%8C%E6%90%AD%E5%BB%BA/"/>
    <url>/07-Bigdata/09-Elasticsearch/02-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%92%8C%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式集群原理"><a href="#分布式集群原理" class="headerlink" title="分布式集群原理"></a>分布式集群原理</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>只有一个节点没有索引的空集群：</p><p><img src="../images/02-01.png"></p><ul><li>master :主节点不参与文档级别的变更或搜索,这意味着在流量增长的时候,该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。</li></ul><p>问：只有一个节点的时候，肯定要参与文档的搜索的，那么这个不参与是什么时候开始的呢，是不是只要有从节点开始，就不参与这个过程了呢？</p><ul><li>node :与nodemanager不同的是，每个节点都知道文档存在哪一个节点上(都可以接受来自客户端的请求)，它们可以转发请求到相应的节点上。并收集处理的结果返回给客户端。</li></ul><h2 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h2><pre><code class="hljs sh">GET /_cluster/health</code></pre><table><thead><tr><th>颜色</th><th>意义</th></tr></thead><tbody><tr><td>green</td><td>所有主要分片和复制分片都可用</td></tr><tr><td>yellow</td><td>所有主要分片可用,但不是所有复制分片都可用</td></tr><tr><td>red</td><td>不是所有的主要分片都可用</td></tr></tbody></table><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>索引是用来指向一个或多个分片(shards)的逻辑命名空间(logical namespace)。</p><p>一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了索引中所有数据的一部分，并且<strong>它本身就是一个完整的搜索引擎</strong>，它可以使用单一节点的所有资源，但是应用程序是与索引通信的。就像Spark中的分片一样，大数据是分片存储的。分片在集群中会自动迁移和达到数据平衡。</p><ul><li>主要分片(primary shard):在创建索引时候制定，后期不可修改，默认为５</li><li>复制分片(replica shard):复制分片是为了容灾，后期可以自由改变。</li></ul><pre><code class="hljs sh">PUT /blogs&#123;   <span class="hljs-string">&quot;settings&quot;</span> : &#123;      <span class="hljs-string">&quot;number_of_shards&quot;</span> : 3,      <span class="hljs-string">&quot;number_of_replicas&quot;</span> : 1   &#125;&#125;</code></pre><p>附带索引的单一节点集群: </p><p><img src="../images/02-02.png"></p><p>双节点集群——所有的主分片和复制分片都已分配:</p><p><img src="../images/02-02.png"></p><p>包含3个节点的集群——分片已经被重新分配以平衡负载(自动):(允许单节点故障)</p><p><img src="../images/02-04.png"></p><p>修改复制分片数</p><pre><code class="hljs sh">PUT /blogs/_settings&#123;   <span class="hljs-string">&quot;number_of_replicas&quot;</span> : 2&#125;</code></pre><p>增加 <code>number_of_replicas</code> 到2:(允许双节点故障)</p><p><img src="../images/02-05.png"></p><h1 id="分布式集群搭建"><a href="#分布式集群搭建" class="headerlink" title="分布式集群搭建"></a>分布式集群搭建</h1><p>修改文件<code>./config/elasticsearch.yml</code>中的<code>cluster.name</code>属性即可实现分布式。。。</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>09-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-数据操作</title>
    <link href="/07-Bigdata/09-Elasticsearch/03-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <url>/07-Bigdata/09-Elasticsearch/03-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="数据存储原理"><a href="#数据存储原理" class="headerlink" title="数据存储原理"></a>数据存储原理</h2><p>面向对象编程中的对象　&gt;&gt; JSON文档</p><p>Elasticsearch是一个分布式的文档(document)<strong>存储引擎</strong></p><h2 id="数据查询原理"><a href="#数据查询原理" class="headerlink" title="数据查询原理"></a>数据查询原理</h2><p>NOSQL也实现了文档存储数据，与elasticsearch相比，重点在于如何快速检索</p><ul><li>反向索引 使用反向索引，所有的字段默认都是被索引的。</li></ul><h1 id="什么是文档"><a href="#什么是文档" class="headerlink" title="什么是文档"></a>什么是文档</h1><p>对象中可以含有其他对象</p><p>文档，特指最顶层结构或者根对象(root object)序列化成的JSON数据(以唯一ID标识并存储于Elasticsearch中）</p><h2 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h2><table><thead><tr><th>节点</th><th>说明</th><th>对比</th></tr></thead><tbody><tr><td>_index</td><td>文档存储的地方</td><td>数据库中的数据库</td></tr><tr><td>_type</td><td>文档代表的对象的类</td><td>对象的类名</td></tr><tr><td>_id</td><td>文档的唯一标识，可以自己创建，也可以自增长</td><td>对象ID</td></tr></tbody></table><h2 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h2><h4 id="PUT-指定ID"><a href="#PUT-指定ID" class="headerlink" title="PUT 指定ID"></a>PUT 指定ID</h4><pre><code class="hljs sh">PUT /website/blog/123&#123;  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;My first blog entry&quot;</span>,  <span class="hljs-string">&quot;text&quot;</span>:  <span class="hljs-string">&quot;Just trying this out...&quot;</span>,  <span class="hljs-string">&quot;date&quot;</span>:  <span class="hljs-string">&quot;2014/01/01&quot;</span>&#125;</code></pre><h4 id="POST-自增ID"><a href="#POST-自增ID" class="headerlink" title="POST 自增ID"></a>POST 自增ID</h4><p>自动生成的ID有22个字符长，Base64-encoded string universally unique identifiers, 或者叫 <code>UUIDs</code></p><pre><code class="hljs sh">POST /website/blog/&#123;  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;My second blog entry&quot;</span>,  <span class="hljs-string">&quot;text&quot;</span>:  <span class="hljs-string">&quot;Still trying this out...&quot;</span>,  <span class="hljs-string">&quot;date&quot;</span>:  <span class="hljs-string">&quot;2014/01/01&quot;</span>&#125;</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h4 id="返回整个文档"><a href="#返回整个文档" class="headerlink" title="返回整个文档"></a>返回整个文档</h4><pre><code class="hljs sh">GET /website/blog/123?pretty</code></pre><h4 id="需要请求头"><a href="#需要请求头" class="headerlink" title="需要请求头"></a>需要请求头</h4><pre><code class="hljs sh">curl -i xxx</code></pre><h4 id="只需要部分字段"><a href="#只需要部分字段" class="headerlink" title="只需要部分字段"></a>只需要部分字段</h4><pre><code class="hljs sh">GET /website/blog/123?_source=title,text</code></pre><h4 id="只要内容不要元数据"><a href="#只要内容不要元数据" class="headerlink" title="只要内容不要元数据"></a>只要内容不要元数据</h4><pre><code class="hljs sh">GET /website/blog/123/_source</code></pre><h4 id="只要头信息"><a href="#只要头信息" class="headerlink" title="只要头信息"></a>只要头信息</h4><pre><code class="hljs sh">curl -i -XHEAD http://localhost:9200/website/blog/123</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>当文档中的ID已经存在时，再次存入信息，就自动更新了文档，<code>_version</code>号+１,这时旧的版本不会立即删除</p><p>在局部更新中，<code>update</code>API允许修改文档的局部，其实并不然，过程任然是整个文档拉入回收站，只是使用的API不一样罢了</p><ol><li>从旧文档中检索JSON</li><li>修改它</li><li>删除旧文档</li><li>索引新文档</li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>在文档不存在的情况下，就是增了。</p><p>怎么保证文档不存在呢</p><h4 id="方法一：使用POST自增"><a href="#方法一：使用POST自增" class="headerlink" title="方法一：使用POST自增"></a>方法一：使用POST自增</h4><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><pre><code class="hljs sh">PUT /website/blog/123?op_type=create&#123; ... &#125;</code></pre><h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><pre><code class="hljs sh">PUT /website/blog/123/_create&#123; ... &#125;</code></pre><p>方法二和方法三对于不存在文档则创建，若文档存在返回<code>409 Conflict</code>状态码</p><h3 id="删-只是标志删除"><a href="#删-只是标志删除" class="headerlink" title="删(只是标志删除)"></a>删(只是标志删除)</h3><pre><code class="hljs sh">DELETE /website/blog/123</code></pre><h4 id="文档存在"><a href="#文档存在" class="headerlink" title="文档存在"></a>文档存在</h4><p><code>200 OK</code>状态码<br>版本号+1</p><h4 id="文档不存在"><a href="#文档不存在" class="headerlink" title="文档不存在"></a>文档不存在</h4><p><code>404 Not Found</code>状态码<br>版本号+1，为了记录在不用节点操作的顺序</p><h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><p>就像多线程任务一样，修改是分三个步骤实现的</p><ol><li>从旧文档中检索JSON</li><li>修改它</li><li>删除旧文档</li><li>索引新文档(就是改了地址)</li></ol><p><img src="../images/03-01.png"></p><p>这时候就会有资源冲突问题</p><h4 id="悲观并发控制-Pessimistic-concurrency-control"><a href="#悲观并发控制-Pessimistic-concurrency-control" class="headerlink" title="悲观并发控制(Pessimistic concurrency control)"></a>悲观并发控制(Pessimistic concurrency control)</h4><p>这在关系型数据库中被广泛的使用,假设冲突的更改经常发生,为了解决冲突我们把访问区块化。典型的例子是在读一行数据前锁定这行,然后确保只有加锁的那个线程可以修改这行数据。</p><h4 id="乐观并发控制-Optimistic-concurrency-control"><a href="#乐观并发控制-Optimistic-concurrency-control" class="headerlink" title="乐观并发控制(Optimistic concurrency control)"></a>乐观并发控制(Optimistic concurrency control)</h4><p>被Elasticsearch使用,假设冲突不经常发生,也不区块化访问,然而,如果在读写过程中数据发生了变化,更新操作将失败。这时候由程序决定在失败后如何解决冲突。实际情况中,可以重新尝试更新,刷新数据(重新读取)或者直接反馈给用户。</p><h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>在elasticsearch中使用乐观并发控制，这个乐观将锁权限给了用户。</p><p>使用版本号作为一个标识，当我们读取文档时的版本号跟存储时候的版本号不一致时，数据保存将失败。</p><p>所有更新和删除文档的请求都接受<code>version</code>参数,它可以允许在你的代码中增加乐观锁控制。</p><pre><code class="hljs sh"><span class="hljs-comment"># 指定版本号，版本号相同才允许更新</span>PUT /website/blog/1?version=1&#123;  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;My first blog entry&quot;</span>,  <span class="hljs-string">&quot;text&quot;</span>:  <span class="hljs-string">&quot;Starting to get the hang of this...&quot;</span>&#125;</code></pre><h3 id="使用外部版本控制系统"><a href="#使用外部版本控制系统" class="headerlink" title="使用外部版本控制系统"></a>使用外部版本控制系统</h3><p>一种常见的结构是使用一些其他的数据库做为主数据库,然后使用Elasticsearch搜索数据，如果有多个进程处理同步操作，就有可能出现并发问题。</p><p>如果主数据库有版本字段如：timestamp等，你就可以在Elasticsearch的查询字符串后面添加<code>version_type=external</code>来使用这些版本号。</p><p>这时只要新版本比旧版本号大就能更新成功(相同版本将报错)。</p><pre><code class="hljs sh">PUT /website/blog/2?version=5&amp;version_type=external&#123;  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;My first external blog entry&quot;</span>,  <span class="hljs-string">&quot;text&quot;</span>:  <span class="hljs-string">&quot;Starting to get the hang of this...&quot;</span>&#125;</code></pre><h2 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h2><p>暂时更新到这里</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>09-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-中文分词插件安装</title>
    <link href="/07-Bigdata/09-Elasticsearch/04-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/09-Elasticsearch/04-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="中文分词插件安装"><a href="#中文分词插件安装" class="headerlink" title="中文分词插件安装"></a>中文分词插件安装</h1><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">Github地址</a></p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>使用解压到安装路径安装失败</p><p>使用方式二安装</p><pre><code class="hljs sh">bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.3/elasticsearch-analysis-ik-5.6.3.zip</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>09-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-使用Docker安装ES</title>
    <link href="/07-Bigdata/09-Elasticsearch/05-%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85ES/"/>
    <url>/07-Bigdata/09-Elasticsearch/05-%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85ES/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Docker安装ES"><a href="#使用Docker安装ES" class="headerlink" title="使用Docker安装ES"></a>使用Docker安装ES</h1><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">官方指导</a></li><li><a href="https://store.docker.com/images/elasticsearch">DockerHub指导</a></li></ul><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>您可以elasticsearch简单地运行默认命令：</p><pre><code class="hljs sh">docker run -d elasticsearch</code></pre><p>您还可以将其他标志传递给elasticsearch：</p><pre><code class="hljs sh">docker run -d elasticsearch -Des.node.name=<span class="hljs-string">&quot;TestNode&quot;</span></code></pre><h2 id="挂载配置文件"><a href="#挂载配置文件" class="headerlink" title="挂载配置文件"></a>挂载配置文件</h2><p>该映像带有一组默认的配置文件elasticsearch，但如果您想提供自己的一组配置文件，则可以通过安装在/usr/share/elasticsearch/config以下位置的卷执行此操作：</p><pre><code class="hljs sh">docker run -d -v <span class="hljs-string">&quot;<span class="hljs-variable">$PWD</span>/config&quot;</span>:/usr/share/elasticsearch/config elasticsearch</code></pre><h2 id="挂载数据"><a href="#挂载数据" class="headerlink" title="挂载数据"></a>挂载数据</h2><p>此图像配置有一个卷/usr/share/elasticsearch/data以保存持久索引数据。如果您希望将数据保存在装入的卷中，请使用该路径：</p><pre><code class="hljs sh">docker run -d -v <span class="hljs-string">&quot;<span class="hljs-variable">$PWD</span>/esdata&quot;</span>:/usr/share/elasticsearch/data elasticsearch</code></pre><h2 id="映射端口"><a href="#映射端口" class="headerlink" title="映射端口"></a>映射端口</h2><p>此image使用 9200 9300（默认http.port），因此标准容器链接将使链接容器自动可用。</p><pre><code class="hljs sh">docker run -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:6.2.3</code></pre><p>需要区分生产模式和开发模式，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>09-Elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01scala函数式编程</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/01scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/01scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Scala函数式编程"><a href="#Scala函数式编程" class="headerlink" title="Scala函数式编程"></a>Scala函数式编程</h1><p>Scala函数式编程也是面向过程的佐证</p><h2 id="将函数赋值给变量"><a href="#将函数赋值给变量" class="headerlink" title="将函数赋值给变量"></a>将函数赋值给变量</h2><pre><code class="hljs scala"><span class="hljs-comment">// 定义函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>(name:<span class="hljs-type">String</span>) = println(<span class="hljs-string">&quot;hello&quot;</span>+name)<span class="hljs-comment">// 函数赋值给变量</span><span class="hljs-keyword">val</span> sayHello = sayHellow _</code></pre><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><pre><code class="hljs scala"><span class="hljs-comment">// scala 语法规定 (参数:类型) =&gt; 函数体</span><span class="hljs-comment">// =&gt; 有点映射的意思，就像转变，在数学中，映射就是函数</span><span class="hljs-keyword">val</span> sayHello = (name:<span class="hljs-type">String</span>) =&gt; println(<span class="hljs-string">&quot;hello&quot;</span>+name)sayHello: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">Unit</span> = &lt;function1&gt;</code></pre><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>将函数作为变量传入函数，或者作为返回值</p><pre><code class="hljs scala"><span class="hljs-comment">// 函数作为参数</span><span class="hljs-keyword">val</span> sayHello = (name:<span class="hljs-type">String</span>) =&gt; println(<span class="hljs-string">&quot;hello&quot;</span>+name)<span class="hljs-comment">// def 函数名(形参:())</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span></span>(func:(<span class="hljs-type">String</span>) =&gt; <span class="hljs-type">Unit</span>,name:<span class="hljs-type">String</span>) &#123;func(name)&#125;greeting(sayHello,<span class="hljs-string">&quot;czm&quot;</span>)<span class="hljs-comment">// 函数作为返回值</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGreetingFunc</span></span>(msg:<span class="hljs-type">String</span>) = (name:<span class="hljs-type">String</span>) =&gt; println(msg+<span class="hljs-string">&quot;,&quot;</span>+name)<span class="hljs-comment">// 这里将一个匿名函数作为返回值</span></code></pre><h2 id="高级函数的类型推断"><a href="#高级函数的类型推断" class="headerlink" title="高级函数的类型推断"></a>高级函数的类型推断</h2><pre><code class="hljs sacla">&#x2F;&#x2F; 定义高阶函数def greeting(func:(String) &#x3D;&gt; Unit,name:String) &#x3D; &#123;func(name)&#125;&#x2F;&#x2F; 本来应该是这样的greeting((name:String) &#x3D;&gt; println(&quot;hello &quot; + name) , &quot;czm&quot;)&#x2F;&#x2F; 自动推断类型greeting((name) &#x3D;&gt; println(&quot;hello &quot; + name) , &quot;czm&quot;)&#x2F;&#x2F; 去掉括号greeting(name &#x3D;&gt; println(&quot;hello &quot; + name) , &quot;czm&quot;)&#x2F;&#x2F; 只有一个参数且只在右侧调用一次(也就是说在用户调用时无需改变)，可以用 _ 代替def triple(func:(Int) &#x3D;&gt; Int) &#x3D; &#123;func(3)&#125;triple(3 + _)</code></pre><h2 id="Scala的常用高阶函数函数式"><a href="#Scala的常用高阶函数函数式" class="headerlink" title="Scala的常用高阶函数函数式"></a>Scala的常用高阶函数函数式</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>对每个传入元素都进行映射，返回一个处理后的元素</p><pre><code class="hljs scala"><span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).map(<span class="hljs-number">2</span>*_)</code></pre><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>对传入的每个元素都进行处理，但是没有返回值</p><pre><code class="hljs scala"><span class="hljs-comment">// 字符串*数字 &gt;&gt; 变成n个字符，数字*字符串 &gt;&gt; 不合法</span>(<span class="hljs-number">1</span> to <span class="hljs-number">9</span>).map(<span class="hljs-string">&quot;#&quot;</span> * _).foreach(println _)</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>对传入的每个元素进行判断，返回ture则保留</p><pre><code class="hljs scala">(<span class="hljs-number">1</span> to <span class="hljs-number">20</span>).filter(_ % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)</code></pre><h3 id="reduceLeft"><a href="#reduceLeft" class="headerlink" title="reduceLeft"></a>reduceLeft</h3><p>从左侧开始Reduce操作，相当于1<em>2</em>3<em>4</em>5<em>6</em>7<em>8</em>9</p><pre><code class="hljs scala">(<span class="hljs-number">1</span> to <span class="hljs-number">9</span>).reduceLeft(_ * _)</code></pre><h3 id="sortWith"><a href="#sortWith" class="headerlink" title="sortWith"></a>sortWith</h3><p>对元素进行比较并排列</p><pre><code class="hljs scala"><span class="hljs-type">Array</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">512</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">56</span>,<span class="hljs-number">65</span>).sortWith(_ &gt; _)</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，函数在变量不处于其有效作用域时，还能够对变量进行访问，即为闭包</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getGreetingFunc</span></span>(msg:<span class="hljs-type">String</span>) = (name:<span class="hljs-type">String</span>) =&gt; println(msg+<span class="hljs-string">&quot;,&quot;</span>+name)<span class="hljs-keyword">val</span> getGreetingFuncHello = getGreetingFunc(<span class="hljs-string">&quot;Hello&quot;</span>)getGreetingFuncHello(<span class="hljs-string">&quot;czm&quot;</span>) <span class="hljs-comment">// 这个getGreetingFuncHello函数中访问了不属于自己作用域(只属于getGreetingFunc函数)的msg参数，在scala中，msg是作为函数的对象存在，因此，函数可以拥有不同的msg</span><span class="hljs-type">Hello</span>,czm</code></pre><h2 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h2><p>JAVA中不支持将函数作为变量，只能通过实现一个只有一个抽象方法的接口，single abstract method 简称SAM（安卓SDK中的onClickLienster就是一个SAM）</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> javax.swing._<span class="hljs-keyword">import</span> java.awt.event._<span class="hljs-keyword">val</span> button = <span class="hljs-keyword">new</span> <span class="hljs-type">JButton</span>(<span class="hljs-string">&quot;Clivt&quot;</span>)button.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-type">ActionListener</span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">actionPerformed</span></span>(event:<span class="hljs-type">ActionEvent</span>)&#123;        println(<span class="hljs-string">&quot;Click ME!&quot;</span>)    &#125;&#125;)<span class="hljs-comment">// 不支持的操作</span><span class="hljs-comment">// button.addActionListener((event:ActionEvent) =&gt; println(&quot;Click ME!&quot;))</span><span class="hljs-comment">// 隐式SAM转换</span><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getActionListener</span></span>(actionProcessFunc:(<span class="hljs-type">ActionEvent</span>) =&gt; <span class="hljs-type">Unit</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">ActionListener</span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">actionPerformed</span></span>(event:<span class="hljs-type">ActionEvent</span>)&#123;        actionProcessFunc(event)    &#125;&#125;button.addActionListener((event:<span class="hljs-type">ActionEvent</span>) =&gt; println(<span class="hljs-string">&quot;Click ME!&quot;</span>))</code></pre><h2 id="Curring函数"><a href="#Curring函数" class="headerlink" title="Curring函数"></a>Curring函数</h2><p>将本来接受两个参数的一个参数转化成两个函数</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>) = a + bsum(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum2</span></span>(a:<span class="hljs-type">Int</span>) = (b:<span class="hljs-type">Int</span>) =&gt; a + bsum2(<span class="hljs-number">2</span>)(<span class="hljs-number">2</span>)<span class="hljs-comment">// 更加简洁的语法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum3</span></span>(a:<span class="hljs-type">Int</span>)(b:<span class="hljs-type">Int</span>) = a + bsum3(<span class="hljs-number">2</span>)(<span class="hljs-number">2</span>)</code></pre><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>在一般的函数中，最后一行的返回值默认作为函数的返回值<br>return用于在匿名函数中返回给父函数，并作为父函数的返回值。</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span></span>(name:<span class="hljs-type">String</span>)=&#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>(name:<span class="hljs-type">String</span>):<span class="hljs-type">String</span> = &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name    &#125;    sayHello(name)&#125;<span class="hljs-comment">// 好像也没问题 ?</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span></span>(name:<span class="hljs-type">String</span>)=&#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>(name:<span class="hljs-type">String</span>):<span class="hljs-type">String</span> = &#123;        <span class="hljs-string">&quot;Hello,&quot;</span> + name    &#125;    sayHello(name)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02scala集合操作</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/02scala%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/02scala%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="scala中的集合操作"><a href="#scala中的集合操作" class="headerlink" title="scala中的集合操作"></a>scala中的集合操作</h1><h2 id="Scala的集合体系结构"><a href="#Scala的集合体系结构" class="headerlink" title="Scala的集合体系结构"></a>Scala的集合体系结构</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="集合的函数式编程"><a href="#集合的函数式编程" class="headerlink" title="集合的函数式编程"></a>集合的函数式编程</h2><h2 id="上阵杀敌"><a href="#上阵杀敌" class="headerlink" title="上阵杀敌"></a>上阵杀敌</h2>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala Map</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%20Map/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%20Map/</url>
    
    <content type="html"><![CDATA[<h2 id="Python中的Dict"><a href="#Python中的Dict" class="headerlink" title="Python中的Dict"></a><a href="http://www.cnblogs.com/cenzhongman/p/7323981.html">Python中的Dict</a></h2><p>字典是一组键(key)和值(value)的组合,通过键(key)进行查找, <strong>没有顺序</strong> , 使用大括号”**{}<strong>” !key不允许重复 !key不可变,**value可变</strong></p><h2 id="Scala中的Map"><a href="#Scala中的Map" class="headerlink" title="Scala中的Map"></a>Scala中的Map</h2><p>无序(有序看第7点)，有可变和不可变两种，</p><h4 id="1-值不可变的Map-不常用"><a href="#1-值不可变的Map-不常用" class="headerlink" title="1.值不可变的Map(不常用)"></a>1.值不可变的Map(不常用)</h4><pre><code class="hljs awk">val info = Map(<span class="hljs-string">&quot;czm&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;CZM&quot;</span> -&gt; <span class="hljs-number">21</span>)<span class="hljs-regexp">//</span>格式<span class="hljs-number">1</span>val info = Map((<span class="hljs-string">&quot;czm&quot;</span> , <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;CZM&quot;</span> , <span class="hljs-number">21</span>))<span class="hljs-regexp">//</span>格式<span class="hljs-number">2</span>(更体现tuple作为存储单元)res0: scala.collection.immutable.Map[String,Int] = Map(czm -&gt; <span class="hljs-number">10</span>, CZM -&gt; <span class="hljs-number">21</span>)<span class="hljs-regexp">//</span>修改值** + - **，并不是改info(<span class="hljs-string">&quot;czm&quot;</span>) = <span class="hljs-number">29</span><span class="hljs-regexp">//</span>错误info + (<span class="hljs-string">&quot;czm&quot;</span> -&gt; <span class="hljs-number">100</span>)<span class="hljs-regexp">//</span>这种方式只是生成了一个新的不可变的Map原值并未改变info - <span class="hljs-string">&quot;czm&quot;</span><span class="hljs-regexp">//</span>这种方式只是生成了一个新的不可变的Map原值并未改变</code></pre><h4 id="2-值可变的Map"><a href="#2-值可变的Map" class="headerlink" title="2.值可变的Map"></a>2.值可变的Map</h4><pre><code class="hljs stylus">val info = scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span>.Map(<span class="hljs-string">&quot;czm&quot;</span> -&gt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;CZM&quot;</span> -&gt; <span class="hljs-number">21</span>)<span class="hljs-comment">//格式1</span>val info = scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span>.Map((<span class="hljs-string">&quot;czm&quot;</span> , <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;CZM&quot;</span> , <span class="hljs-number">21</span>))<span class="hljs-comment">//格式2(更体现tuple作为存储单元)</span>res0: scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span><span class="hljs-selector-class">.Map</span>[String,Int] = Map(czm -&gt; <span class="hljs-number">10</span>, CZM -&gt; <span class="hljs-number">21</span>)<span class="hljs-comment">//修改值** += -= **</span><span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-string">&quot;czm&quot;</span>)</span></span> = <span class="hljs-number">29</span><span class="hljs-comment">//正确，若Key不存在，则增加</span><span class="hljs-comment">//一次增加多个</span>info += (<span class="hljs-string">&quot;asd&quot;</span> -&gt; <span class="hljs-number">123</span>,<span class="hljs-string">&quot;aer&quot;</span> -&gt; <span class="hljs-number">122</span>)<span class="hljs-comment">//移除</span>info -= <span class="hljs-string">&quot;czm&quot;</span>info -= (<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-string">&quot;asd&quot;</span>)<span class="hljs-comment">//即使移除不存在的元素，不会报错</span></code></pre><h4 id="3-创建空Map"><a href="#3-创建空Map" class="headerlink" title="3.创建空Map"></a>3.创建空Map</h4><pre><code class="hljs markdown">//HashMap是Map的实现类，不能直接实例化Map(抽象类)<span class="hljs-strong">**跟JAVA一样**</span>val info = scala.collection.mutable.HashMap[<span class="hljs-string">String,Int</span>](<span class="hljs-link"></span>)</code></pre><h4 id="4-取值-使用"><a href="#4-取值-使用" class="headerlink" title="4.取值,使用()"></a>4.<strong>取值,使用()</strong></h4><p>在取值的时候，访问一个不存在的Key会报错，<strong>JAVA 返回Null</strong>,<strong>Python dict也会报错</strong></p><pre><code class="hljs armasm"><span class="hljs-comment">//方法1</span><span class="hljs-symbol">if</span> (<span class="hljs-meta">info</span>.contains(<span class="hljs-string">&quot;nukl&quot;</span>)) <span class="hljs-meta">info</span>(<span class="hljs-string">&quot;nukl&quot;</span>) <span class="hljs-meta">else</span> <span class="hljs-number">0</span><span class="hljs-comment">//方法2</span><span class="hljs-symbol">info.getOrElse</span>(<span class="hljs-string">&quot;nukl&quot;</span>,<span class="hljs-number">0</span>)</code></pre><h4 id="5-增，改"><a href="#5-增，改" class="headerlink" title="5.增，改"></a>5.增，改</h4><pre><code class="hljs awk"><span class="hljs-regexp">//</span>对于存在的Key，赋值即修改<span class="hljs-regexp">//</span>对于不存在的Key，赋值即增加</code></pre><h4 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h4><pre><code class="hljs q"><span class="hljs-comment">//增强for循环</span>for ((<span class="hljs-built_in">key</span>, <span class="hljs-built_in">value</span>) &lt;- info) &#123;  println(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">value</span>)&#125;<span class="hljs-comment">//只要Key,也可以用keySet</span>for (<span class="hljs-built_in">key</span> &lt;- info.<span class="hljs-built_in">keys</span>) &#123;  println(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot;:&quot;</span> + info(<span class="hljs-built_in">key</span>))&#125;<span class="hljs-comment">//只要value</span>for (<span class="hljs-built_in">value</span> &lt;- info.values) &#123;  println(<span class="hljs-built_in">value</span>)&#125;</code></pre><h4 id="7-有序的Map"><a href="#7-有序的Map" class="headerlink" title="7.有序的Map"></a>7.有序的Map</h4><pre><code class="hljs stylus"><span class="hljs-comment">//Map的另一个实现类SortedMap，根据Key排序</span><span class="hljs-selector-tag">var</span> info = scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span>.SortedMap(<span class="hljs-string">&quot;as&quot;</span> -&gt; <span class="hljs-number">12</span>, <span class="hljs-string">&quot;nSD&quot;</span> -&gt; <span class="hljs-number">23</span>, <span class="hljs-string">&quot;casd&quot;</span> -&gt; <span class="hljs-number">123</span>)info: scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span><span class="hljs-selector-class">.SortedMap</span>[String,Int] = Map(as -&gt; <span class="hljs-number">12</span>, casd -&gt; <span class="hljs-number">123</span>, nSD -&gt; <span class="hljs-number">23</span>)<span class="hljs-comment">//Map的另一个实现类LinkedHashMap，记住插入的顺序</span><span class="hljs-selector-tag">var</span> info = scala<span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.mutable</span><span class="hljs-selector-class">.LinkedHashMap</span>[String,Int]()</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala Trait</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%20Trait/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%20Trait/</url>
    
    <content type="html"><![CDATA[<h1 id="Scala-Trait"><a href="#Scala-Trait" class="headerlink" title="Scala Trait"></a>Scala Trait</h1><p>只允许单继承class允许多继承trait（就像接口一样）<br>Trait是一个为了突破JAVA的单继承限制出来的（JAVA8支持多继承）一个新玩意</p><ul><li>可以定义具体的字段</li><li>可以定义抽象的字段</li><li>可以定义具体的方法</li><li>可以定义抽象的方法</li></ul><h3 id="Trait作为接口来使用"><a href="#Trait作为接口来使用" class="headerlink" title="Trait作为接口来使用"></a>Trait作为接口来使用</h3><p>牛逼！对象可以动态继承Trait</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala Tuple</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%20Tuple/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%20Tuple/</url>
    
    <content type="html"><![CDATA[<h2 id="Python中的Tuple"><a href="#Python中的Tuple" class="headerlink" title="Python中的Tuple"></a><a href="http://www.cnblogs.com/cenzhongman/p/7323791.html">Python中的Tuple</a></h2><p>元组将多样的对象集合到一起,<strong>元素不能修改</strong>,通过索引进行查找, 使用括号”**()**” 允许重复</p><h2 id="Scala中的Tuple"><a href="#Scala中的Tuple" class="headerlink" title="Scala中的Tuple"></a>Scala中的Tuple</h2><p>概念跟Python是完全相同的</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>tuple其实Map的元素类型，就是一个存储单元</p><pre><code class="hljs lisp">val <span class="hljs-literal">t</span> = (<span class="hljs-string">&quot;cam&quot;</span>,<span class="hljs-number">1</span>)</code></pre><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><pre><code class="hljs apache"><span class="hljs-attribute">t</span>._<span class="hljs-number">1</span></code></pre><h4 id="zip操作（拉链操作）"><a href="#zip操作（拉链操作）" class="headerlink" title="zip操作（拉链操作）"></a>zip操作（拉链操作）</h4><pre><code class="hljs pgsql">val names = <span class="hljs-keyword">Array</span>(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)val ages = <span class="hljs-keyword">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)val nameAges = names.zip(ages)//nameAges: <span class="hljs-keyword">Array</span>[(String, <span class="hljs-type">Int</span>)] = <span class="hljs-keyword">Array</span>((A,<span class="hljs-number">1</span>), (B,<span class="hljs-number">2</span>), (C,<span class="hljs-number">3</span>))这个时候的存储单元是**(一个tuple)**<span class="hljs-keyword">for</span> ((<span class="hljs-type">name</span>,age) &lt;- nameAges)&#123;println(<span class="hljs-type">name</span> + &quot;:&quot; + age)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala入门</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%E5%85%A5%E9%97%A8/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Scala"><a href="#关于Scala" class="headerlink" title="关于Scala"></a>关于Scala</h1><p>Scala是基于JVM的一门编程语言，使用字节码文件在JVM上运行，可以与JAVA代码无缝调用。<br>Scala是Spark的编程语言，看源码和编写Spark处理程序会用到。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><a href="https://www.jetbrains.com/idea">使用IntelliJ</a></li><li><a href="http://www.scala-sbt.org/download.html">使用SBT(Simple Build Tool)</a></li><li><a href="https://downloads.lightbend.com/scala/2.12.3/scala-2.12.3.msi">使用命令行安装</a></li><li><a href="http://blog.csdn.net/u013041398/article/details/50532334">使用sublime</a></li></ul><pre><code class="hljs sh">Ctrl+Shift+P输入：package，选择package control：package Install。输入:repl，选择sublimeREPLTools -&gt; SublimeREPL -&gt; Scala</code></pre><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="分行符"><a href="#分行符" class="headerlink" title="分行符"></a>分行符</h3><p>可以使用;作为行结束，也可以不使用，但是在一行需要多条语句时候需要使用</p><h3 id="块表达式-，作为一个表达式是有值的-其实就是省略了return"><a href="#块表达式-，作为一个表达式是有值的-其实就是省略了return" class="headerlink" title="块表达式{}，作为一个表达式是有值的(其实就是省略了return)"></a>块表达式{}，作为一个表达式是有值的(其实就是省略了return)</h3><p>可以像JAVA一样使用{}包含代码块，包含的部分作为块执行,<strong>最后一个语句的值作为块表达式的返回值</strong></p><pre><code class="hljs scala"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">10</span>)&#123;b = b + <span class="hljs-number">1</span>;c+<span class="hljs-number">1</span>&#125;<span class="hljs-comment">//相当于,最后一行作为返回值</span><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">10</span>)&#123;    b = b + <span class="hljs-number">1</span>    c = c + <span class="hljs-number">1</span>&#125;</code></pre><h3 id="注释与JAVA相同"><a href="#注释与JAVA相同" class="headerlink" title="注释与JAVA相同"></a>注释与JAVA相同</h3><h3 id="缩进问题：与Python不同，不是靠缩进实现代码块的"><a href="#缩进问题：与Python不同，不是靠缩进实现代码块的" class="headerlink" title="缩进问题：与Python不同，不是靠缩进实现代码块的"></a>缩进问题：与Python不同，不是靠缩进实现代码块的</h3><pre><code class="hljs scala"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">10</span>)  b = b + <span class="hljs-number">1</span>  c = c + <span class="hljs-number">1</span><span class="hljs-comment">//这一行被当做新的一条语句来执行</span></code></pre><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><h3 id="REPL：-Read-Evaluation-Print-Loop-Scala解释器会快速编译成字节码文件，提交给JVM执行然后返回结果"><a href="#REPL：-Read-Evaluation-Print-Loop-Scala解释器会快速编译成字节码文件，提交给JVM执行然后返回结果" class="headerlink" title="REPL：(Read Evaluation Print Loop)Scala解释器会快速编译成字节码文件，提交给JVM执行然后返回结果"></a><strong>REPL</strong>：(Read Evaluation Print Loop)Scala解释器会快速编译成字节码文件，提交给JVM执行然后返回结果</h3><h3 id="计算表达式：直接输入计算表达式，Scala会像Python一样直接返回计算结果，如果你没有定义一个变量来接收，将使用内置变量-res1-Int-来打印变量和类型"><a href="#计算表达式：直接输入计算表达式，Scala会像Python一样直接返回计算结果，如果你没有定义一个变量来接收，将使用内置变量-res1-Int-来打印变量和类型" class="headerlink" title="计算表达式：直接输入计算表达式，Scala会像Python一样直接返回计算结果，如果你没有定义一个变量来接收，将使用内置变量**res1:Int = **来打印变量和类型"></a><strong>计算表达式</strong>：直接输入计算表达式，Scala会像Python一样直接返回计算结果，如果你没有定义一个变量来接收，将使用内置变量**res1:Int = **来打印变量和类型</h3><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span>+<span class="hljs-number">1</span>res1: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span></code></pre><h3 id="内置变量：上文的变量是可以直接调用的"><a href="#内置变量：上文的变量是可以直接调用的" class="headerlink" title="内置变量：上文的变量是可以直接调用的"></a><strong>内置变量</strong>：上文的变量是可以直接调用的</h3><pre><code class="hljs scala">scala&gt; <span class="hljs-number">1</span>+res2res3: <span class="hljs-type">Int</span> = <span class="hljs-number">3</span></code></pre><h3 id="使用tab自动补全"><a href="#使用tab自动补全" class="headerlink" title="使用tab自动补全"></a><strong>使用tab自动补全</strong></h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="val变量-常量，不可改变-推荐使用"><a href="#val变量-常量，不可改变-推荐使用" class="headerlink" title="**val变量(常量，不可改变)**推荐使用"></a>**val变量(常量，不可改变)**推荐使用</h3><pre><code class="hljs scala"><span class="hljs-keyword">val</span> result = <span class="hljs-number">1</span> + <span class="hljs-number">1</span></code></pre><h3 id="var变量-正常的变量"><a href="#var变量-正常的变量" class="headerlink" title="var变量(正常的变量)"></a><strong>var变量(正常的变量)</strong></h3><p>在Spark编程中，通常建议使用val来声明，防止在复杂的大数据系统中值被错误的更改<br>在JAVA中这种大型复杂系统开发中，同样用了类似的特性，如不可变类（Immuable class），里面的变量使用final定义，从而提升系统的健壮性（robust鲁棒性）</p><pre><code class="hljs scala"><span class="hljs-keyword">var</span> res = <span class="hljs-number">2</span></code></pre><h3 id="指定类型-用于使用父类的类型来包容更小的类型"><a href="#指定类型-用于使用父类的类型来包容更小的类型" class="headerlink" title="指定类型(用于使用父类的类型来包容更小的类型)"></a><strong>指定类型</strong>(用于使用父类的类型来包容更小的类型)</h3><p>Scala在声明变量时候可以指定类型，如不声明，scala会根据值自动判断类型</p><pre><code class="hljs scala"><span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> = <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-keyword">var</span> name:<span class="hljs-type">Any</span> = <span class="hljs-number">123</span></code></pre><h3 id="多个变量声明"><a href="#多个变量声明" class="headerlink" title="多个变量声明"></a><strong>多个变量声明</strong></h3><pre><code class="hljs scala"><span class="hljs-comment">//错误</span><span class="hljs-keyword">var</span> i1,i2 = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><span class="hljs-keyword">var</span> i1 = <span class="hljs-number">1</span>,i2 = <span class="hljs-number">2</span><span class="hljs-comment">//正确</span><span class="hljs-keyword">var</span> i1,i2 = <span class="hljs-number">100</span></code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型：Byte-Char-Short-Int-Long-Float-Double-Boolean"><a href="#基本数据类型：Byte-Char-Short-Int-Long-Float-Double-Boolean" class="headerlink" title="基本数据类型：Byte Char Short Int Long Float Double Boolean"></a><strong>基本数据类型</strong>：Byte Char Short Int Long Float Double Boolean</h3><p>scala中，没有基本数据类型和包装数据类型的区别，都是类。全都拥有方法。对于底层的数据类型和引用类型的转换<strong>自动完成</strong>。</p><pre><code class="hljs scala"><span class="hljs-number">1.</span>toString<span class="hljs-number">1.</span>toString()</code></pre><h3 id="加强版数据类型-StingOps-RichInt-RichDouble-RichChar使用这些增强类来增加基本数据类型的功能或函数。然而这一切都是自动完成的"><a href="#加强版数据类型-StingOps-RichInt-RichDouble-RichChar使用这些增强类来增加基本数据类型的功能或函数。然而这一切都是自动完成的" class="headerlink" title="加强版数据类型:StingOps RichInt RichDouble RichChar使用这些增强类来增加基本数据类型的功能或函数。然而这一切都是自动完成的"></a><strong>加强版数据类型</strong>:StingOps RichInt RichDouble RichChar使用这些增强类来增加基本数据类型的功能或函数。然而这一切都是<strong>自动完成</strong>的</h3><pre><code class="hljs scala"><span class="hljs-number">1.</span>to(<span class="hljs-number">10</span>)res0: scala.collection.immutable.<span class="hljs-type">Range</span>.<span class="hljs-type">Inclusive</span> = <span class="hljs-type">Range</span> <span class="hljs-number">1</span> to <span class="hljs-number">10</span></code></pre><h3 id="操作符：在scala中的操作符其实也是函数，函数也能做操作符"><a href="#操作符：在scala中的操作符其实也是函数，函数也能做操作符" class="headerlink" title="操作符：在scala中的操作符其实也是函数，函数也能做操作符"></a><strong>操作符</strong>：在scala中的操作符其实也是函数，函数也能做操作符</h3><p><strong>支持 +=  -= 但不支持 –  ++</strong>.</p><pre><code class="hljs scala"><span class="hljs-number">1</span> + <span class="hljs-number">1</span>     等于<span class="hljs-number">1.</span>+(<span class="hljs-number">1</span>)<span class="hljs-number">1.</span>to(<span class="hljs-number">10</span>)  等于<span class="hljs-number">1</span> to <span class="hljs-number">10</span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数调用-需要传参数才需要括号，不需要参数可以省略括号"><a href="#函数调用-需要传参数才需要括号，不需要参数可以省略括号" class="headerlink" title="函数调用:需要传参数才需要括号，不需要参数可以省略括号"></a><strong>函数调用</strong>:需要传参数才需要括号，不需要参数可以省略括号</h3><pre><code class="hljs scala">max(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-string">&quot;Hello&quot;</span>.toUpperCase</code></pre><h3 id="apply函数：使用-类名-即可实例化对象，实际上相当于调用了类名-apply-，我们需要在类中def-apply"><a href="#apply函数：使用-类名-即可实例化对象，实际上相当于调用了类名-apply-，我们需要在类中def-apply" class="headerlink" title="apply函数：使用 类名()**即可实例化对象，实际上相当于调用了类名.apply()，我们需要在类中def apply():**"></a><strong>apply函数</strong>：使用 <strong>类名()**即可实例化对象，实际上相当于调用了</strong>类名.apply()<strong>，我们需要在类中</strong>def apply():**</h3><pre><code class="hljs scala"><span class="hljs-comment">//实例化对象：</span><span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">//相当于调用了，StingOps类中的apply方法</span><span class="hljs-type">Array</span>.apply(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)res0: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</code></pre><h2 id="条件控制及循环"><a href="#条件控制及循环" class="headerlink" title="条件控制及循环"></a>条件控制及循环</h2><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><h4 id="有值的if表达式"><a href="#有值的if表达式" class="headerlink" title="有值的if表达式"></a>有值的if表达式</h4><pre><code class="hljs scala"><span class="hljs-comment">//将会返回if/else最后的值作为表达式的值(感觉就是省略了return语句)</span><span class="hljs-keyword">val</span> age = <span class="hljs-number">30</span>;<span class="hljs-keyword">var</span> isAdult = <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><span class="hljs-comment">//另一种写法(不常用)</span><span class="hljs-keyword">var</span> isAdult = <span class="hljs-number">-1</span>;<span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) isAdult = <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> isAdult = <span class="hljs-number">0</span></code></pre><h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><pre><code class="hljs scala"><span class="hljs-comment">//if和else中返回值类型不同时，返回值类型取两种类型的**父类型**</span>age = <span class="hljs-number">30</span>;<span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) <span class="hljs-string">&quot;adult&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>res0: <span class="hljs-type">Any</span> = adult<span class="hljs-comment">//当else语句不存在时，默认else的类型为**Unit**也用**()**表示，相当于Java中的null</span>age = <span class="hljs-number">30</span>;<span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) <span class="hljs-string">&quot;adult&quot;</span>res0: <span class="hljs-type">AnyVal</span> = ()</code></pre><h4 id="多行可以使用-paste进入粘贴模式-无需"><a href="#多行可以使用-paste进入粘贴模式-无需" class="headerlink" title="多行可以使用{}/:paste进入粘贴模式(无需{})"></a>多行可以使用{}/:paste进入粘贴模式(无需{})</h4><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while-do-循环"><a href="#while-do-循环" class="headerlink" title="while do 循环"></a>while do 循环</h4><pre><code class="hljs scala"><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span> <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;  print(n + <span class="hljs-string">&quot; &quot;</span>)  n -= <span class="hljs-number">1</span>&#125;</code></pre><h4 id="Scala没有正儿八经的for循环"><a href="#Scala没有正儿八经的for循环" class="headerlink" title="Scala没有正儿八经的for循环"></a>Scala没有正儿八经的for循环</h4><pre><code class="hljs scala"><span class="hljs-comment">// 1.简易for循环</span><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>)&#123;  println(i)&#125;<span class="hljs-comment">//1 to 10：Range(1,2,3,4,5,6,7,8,9,10)</span><span class="hljs-comment">// 2.使用until忽略上界限</span><span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">1</span> until <span class="hljs-number">10</span>)&#123;  println(i)&#125;<span class="hljs-comment">//1 until 10：Range(1,2,3,4,5,6,7,8,9)</span><span class="hljs-comment">// 3.增强for循环(更体现面向对象)</span><span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-string">&quot;Hello world&quot;</span>)&#123;  print(i+<span class="hljs-string">&quot; &quot;</span>)&#125;</code></pre><h4 id="高级for循环"><a href="#高级for循环" class="headerlink" title="高级for循环"></a>高级for循环</h4><p><strong>循环嵌套</strong>.</p><pre><code class="hljs scala"><span class="hljs-keyword">for</span> (i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">9</span>; j &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">9</span>) &#123;  printf(<span class="hljs-string">&quot;i=%d j=%d\n&quot;</span>,i,j)  <span class="hljs-comment">//这样就实现了循环嵌套，总共执行4*4次</span>&#125;<span class="hljs-comment">//结果如下</span>i=<span class="hljs-number">1</span> j=<span class="hljs-number">1</span>i=<span class="hljs-number">1</span> j=<span class="hljs-number">2</span>i=<span class="hljs-number">1</span> j=<span class="hljs-number">3</span>i=<span class="hljs-number">1</span> j=<span class="hljs-number">4</span>i=<span class="hljs-number">2</span> j=<span class="hljs-number">1</span>i=<span class="hljs-number">2</span> j=<span class="hljs-number">2</span>i=<span class="hljs-number">2</span> j=<span class="hljs-number">3</span>i=<span class="hljs-number">2</span> j=<span class="hljs-number">4</span>...<span class="hljs-comment">//完全等效的JAVA代码</span><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;j=&quot;</span> + j + <span class="hljs-string">&quot;\n&quot;</span>);  &#125;&#125;</code></pre><p><strong>if守卫</strong>.</p><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(i &lt;- <span class="hljs-number">1</span> to <span class="hljs-number">100</span> <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;  println(i)&#125;</code></pre><p><strong>for推导式</strong>.</p><pre><code class="hljs scala"><span class="hljs-keyword">for</span>(i&lt;- <span class="hljs-number">1</span> to <span class="hljs-number">10</span>) <span class="hljs-keyword">yield</span> ires0: scala.collection.immutable.<span class="hljs-type">IndexedSeq</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)</code></pre><h4 id="跳出for循环-！！丧心病狂！！"><a href="#跳出for循环-！！丧心病狂！！" class="headerlink" title="跳出for循环(！！丧心病狂！！)"></a>跳出for循环(！！丧心病狂！！)</h4><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">Breaks</span><span class="hljs-keyword">val</span> mybreaks = <span class="hljs-keyword">new</span> <span class="hljs-type">Breaks</span><span class="hljs-keyword">import</span> mybreaks.&#123;<span class="hljs-keyword">break</span>, breakable&#125;breakable &#123;  <span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span>  <span class="hljs-keyword">for</span> (c &lt;- <span class="hljs-string">&quot;Helloworld&quot;</span>) &#123;    print(c + <span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">5</span> ) <span class="hljs-keyword">break</span>()    n -= <span class="hljs-number">1</span>  &#125;&#125;</code></pre><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><pre><code class="hljs scala"><span class="hljs-comment">// use java API</span><span class="hljs-type">System</span>.out.print(<span class="hljs-string">&quot;ABC&quot;</span>)<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;ABC&quot;</span>)<span class="hljs-comment">// Use scala API</span>print(<span class="hljs-string">&quot;ABC&quot;</span>)print(<span class="hljs-string">&quot;ABC&quot;</span>)<span class="hljs-comment">// printf %s %d 必须使用print</span>printf(<span class="hljs-string">&quot;My name is %s,I&#x27;m %d yesrs old&quot;</span>,<span class="hljs-string">&quot;James&quot;</span>,<span class="hljs-number">20</span>)<span class="hljs-comment">// input from Terminal</span>readLine(<span class="hljs-string">&quot;This will show in Terminal and wait for you input&quot;</span>)      <span class="hljs-comment">//弃用</span>readInt()                                                          <span class="hljs-comment">//将会强转为Int</span><span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">StdIn</span>                                              <span class="hljs-comment">//新标准</span>readf(<span class="hljs-string">&quot;This is a new read in method&quot;</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala函数</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%E5%87%BD%E6%95%B0/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="定义普通函数-后面有不需要等号的"><a href="#定义普通函数-后面有不需要等号的" class="headerlink" title="定义普通函数(=)(后面有不需要等号的)"></a>定义普通函数(<strong>=</strong>)(后面有不需要等号的)</h2><p>参数类型必须声明，函数返回类型无需声明(只要不存在递归语句，scala会自动推导出返回值类型)<br>允许定义默认参数，有默认值的可不传，跟Python一个德行，包括参数调用</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloWorld</span></span>(name:<span class="hljs-type">String</span>,age:<span class="hljs-type">Int</span>=<span class="hljs-number">18</span>) = &#123;print(name,age)&#125;helloWorld: (name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>)<span class="hljs-type">Unit</span><span class="hljs-comment">//调用</span>helloWorld(age = <span class="hljs-number">15</span>)</code></pre><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>必须声明返回类型，因为不知道你递归到什么时候</p><pre><code class="hljs scala"><span class="hljs-comment">//斐波那契数列1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144</span><span class="hljs-comment">//递归中的In = In-1 + In-2</span><span class="hljs-number">9</span>+<span class="hljs-number">8</span>;<span class="hljs-number">8</span>+<span class="hljs-number">7</span>+<span class="hljs-number">7</span>+<span class="hljs-number">6</span>;<span class="hljs-number">7</span>+<span class="hljs-number">6</span>+<span class="hljs-number">6</span>+<span class="hljs-number">5</span>+<span class="hljs-number">6</span>+<span class="hljs-number">5</span>+<span class="hljs-number">5</span>+<span class="hljs-number">4</span>;<span class="hljs-number">6</span>+<span class="hljs-number">5</span>+<span class="hljs-number">5</span>+<span class="hljs-number">4</span>+<span class="hljs-number">5</span>+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>+<span class="hljs-number">3</span>++<span class="hljs-number">4</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>;<span class="hljs-number">5</span>+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fab</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = &#123;  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-number">1</span>  &#125;<span class="hljs-keyword">else</span>&#123;    fab(n<span class="hljs-number">-1</span>)+fab(n<span class="hljs-number">-2</span>)  &#125;&#125;print(fab(<span class="hljs-number">10</span>))</code></pre><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><pre><code class="hljs scala"><span class="hljs-comment">//接收到的参数为**Seq[Int] = WrappedArray(1, 23, 4, 4, 1)**</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(nums:<span class="hljs-type">Int</span>*) = &#123;<span class="hljs-keyword">var</span> rst = <span class="hljs-number">0</span><span class="hljs-keyword">for</span>(num &lt;- nums)&#123;<span class="hljs-comment">//增强for循环</span>rst += rst&#125;rst&#125;</code></pre><h4 id="传入一个已有序列"><a href="#传入一个已有序列" class="headerlink" title="传入一个已有序列"></a>传入一个已有序列</h4><pre><code class="hljs scala">sum(<span class="hljs-number">1</span> to <span class="hljs-number">5</span>)<span class="hljs-comment">//错误，将一个Range赋值给Int</span>sum(<span class="hljs-number">1</span> to <span class="hljs-number">5</span>: _*)<span class="hljs-comment">//将1 to 5 这个Range解开为单个传入</span></code></pre><p>与Python对比</p><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(*nums):rst = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> num in nums:rst += numretuen rst</code></pre><p>与java对比</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>...  args)</span></span>&#123;<span class="hljs-comment">//todo...</span>&#125;</code></pre><h2 id="神奇的执行逻辑-也许这就是函数式编程的冰山一角吧"><a href="#神奇的执行逻辑-也许这就是函数式编程的冰山一角吧" class="headerlink" title="神奇的执行逻辑(也许这就是函数式编程的冰山一角吧)"></a>神奇的执行逻辑(也许这就是函数式编程的冰山一角吧)</h2><pre><code class="hljs scala"><span class="hljs-comment">//当if...else...下方无语句时，从宏观上看，if...else...作为一个整体是** = **右边**&#123;块表达式&#125;**的最后一条语句，所以if...else...的返回值将作为函数的返回值</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloWorld</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>) = &#123;  <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;    printf(<span class="hljs-string">&quot;Hello %s you are an adult!!\n&quot;</span>, name)    name  &#125; <span class="hljs-keyword">else</span> &#123;    printf(<span class="hljs-string">&quot;Hello %s you are a little boy!!&quot;</span>, name)    name  &#125;&#125;<span class="hljs-comment">// 如下</span>helloWorld: (name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>)<span class="hljs-type">String</span><span class="hljs-comment">//反之，就不是最后一条语句了，如果没有一个变量去接收if...else...表达式的值，if...else...的返回值就没有一点意义了</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloWorld</span></span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>) = &#123;  <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;    printf(<span class="hljs-string">&quot;Hello %s you are an adult!!\n&quot;</span>, name)    name<span class="hljs-comment">//多余的表达式返回值</span>  &#125; <span class="hljs-keyword">else</span> &#123;    printf(<span class="hljs-string">&quot;Hello %s you are a little boy!!&quot;</span>, name)    name  &#125;  <span class="hljs-keyword">val</span> i = <span class="hljs-number">1</span>  i&#125;<span class="hljs-comment">//如下</span>helloWorld: (name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>)<span class="hljs-type">Int</span></code></pre><h2 id="过程-不需要返回值的函数"><a href="#过程-不需要返回值的函数" class="headerlink" title="过程(不需要返回值的函数)"></a>过程(不需要返回值的函数)</h2><p>没有使用等号连接{}的函数称为过程，其返回值类型为Unit，也就是没有返回值</p><pre><code class="hljs scala"><span class="hljs-comment">//写法1：不写等号</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printName</span></span>(name:<span class="hljs-type">String</span>)&#123;print(name)&#125;<span class="hljs-comment">//写法2：声明无返回</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printName</span></span>(name:<span class="hljs-type">String</span>):<span class="hljs-type">Unit</span> = &#123;print(name)&#125;</code></pre><h2 id="lazy懒变量-用于耗时操作如网络，文件IO"><a href="#lazy懒变量-用于耗时操作如网络，文件IO" class="headerlink" title="lazy懒变量(用于耗时操作如网络，文件IO)"></a>lazy懒变量(用于耗时操作如网络，文件IO)</h2><p>变量后面的表达式在定义时候不会执行任何计算，直到第一次使用，在很多时候都需要，毕竟不是所有都需要一上来就加载的，或许你可能不会有机会使用呢</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">Source</span>._<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> myfile = fromFile(<span class="hljs-string">&quot;D:\\123.txt&quot;</span>).mkString<span class="hljs-comment">//myfile: String = &lt;lazy&gt;</span>print(myfile)<span class="hljs-comment">//这时候才会执行计算</span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>使用了模式匹配的思想，catch字句里的内容跟match里的case是完全一样的。</p><pre><code class="hljs scala"><span class="hljs-comment">//由于异常捕捉是按次序，如果最普遍的异常，Throwable，写在最前面，则在它后面的case都捕捉不到，因此需要将它写在最后面。</span><span class="hljs-keyword">try</span>&#123;  fromFile(<span class="hljs-string">&quot;D:\\asdasdasdasd&quot;</span>).mkString&#125;<span class="hljs-keyword">catch</span>&#123;  <span class="hljs-keyword">case</span> e1:<span class="hljs-type">IOException</span> =&gt; println(<span class="hljs-string">&quot;IO Exception&quot;</span>)<span class="hljs-comment">//e1是异常的名字，可以使用 _ 代替</span>&#125;<span class="hljs-keyword">finally</span> &#123;  println(<span class="hljs-string">&quot;close resource&quot;</span>)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala数组</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%E6%95%B0%E7%BB%84/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>在scala中的数组和JAVA中的数组都是定长的，一旦初始化就不可改变（Scala数据底层是直接变成JAVA的数组）</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>定义即初始化，并分配空间</p><pre><code class="hljs angelscript"><span class="hljs-comment">//声明类型和长度 </span>val arr = new Array[Int](<span class="hljs-number">10</span>)arr: Array[Int] = Array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">//直接使用构造函数构建(调用apply函数) </span>val arr1 = Array(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">1</span>)arr1: Array[Any] = Array(<span class="hljs-number">123</span>, <span class="hljs-number">1</span>)</code></pre><h1 id="ArrayBuffer-JAVA无-由ArrayList实现？"><a href="#ArrayBuffer-JAVA无-由ArrayList实现？" class="headerlink" title="ArrayBuffer(JAVA无):由ArrayList实现？"></a>ArrayBuffer(JAVA无):由ArrayList实现？</h1><p>类似于JAVA中的ArrayList(ArrayList数组实现，每次中间插入删除慢，而LinkedList[火车]由对象实现，查找慢)，变长数组</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><pre><code class="hljs markdown">import scala.collection.mutable.ArrayBuffervar arrBuf = ArrayBuffer[<span class="hljs-string">Int</span>](<span class="hljs-link"></span>)arrB: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</code></pre><h3 id="2-写入"><a href="#2-写入" class="headerlink" title="2.写入"></a>2.写入</h3><pre><code class="hljs angelscript"><span class="hljs-comment">// 尾部追加 += **奇葩语法又来了**,其实就是定义了+=函数</span>arrBuf += <span class="hljs-number">1</span>arrBuf += (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//追加整个数组</span>arrBuf ++= Array(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//源码</span>def +=:(elem: A): <span class="hljs-keyword">this</span>.type = &#123;def ++=:(xs: TraversableOnce[A]): <span class="hljs-keyword">this</span>.type = &#123;<span class="hljs-comment">//指定位置追加(index,args: _*)</span>arrBuf.insert(<span class="hljs-number">3</span>,args)</code></pre><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><pre><code class="hljs angelscript"><span class="hljs-comment">//尾部删除,删除指定长的元素</span>arrBuf.trimEnd(<span class="hljs-number">3</span>)<span class="hljs-comment">//指定位置删除(index,lenth)</span>arrBuf.remove(<span class="hljs-number">2</span>)arrBuf.remove(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</code></pre><h2 id="Array和ArrayBuffer转换"><a href="#Array和ArrayBuffer转换" class="headerlink" title="Array和ArrayBuffer转换"></a>Array和ArrayBuffer转换</h2><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Array()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Buffer()</span></code></pre><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><ul><li>arr[]</li><li>arrBuf()</li></ul><h4 id="1-增强for循环"><a href="#1-增强for循环" class="headerlink" title="1.增强for循环"></a>1.增强for循环</h4><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(e &lt;- arrBuf)</span>&#123;</span><span class="hljs-function"><span class="hljs-title">println</span><span class="hljs-params">(e)</span></span><span class="hljs-function">&#125;</span></code></pre><h4 id="2-for-until（无上界限）"><a href="#2-for-until（无上界限）" class="headerlink" title="2.for until（无上界限）"></a>2.for until（无上界限）</h4><pre><code class="hljs less"><span class="hljs-comment">//for (i &lt;- arrBuf.indices)&#123;   //新API</span><span class="hljs-comment">//全遍历（从0开始）</span><span class="hljs-selector-tag">for</span> (i &lt;- <span class="hljs-number">0</span> until arrBuf.length)&#123;  <span class="hljs-selector-tag">println</span>(arrBuf(i))&#125;<span class="hljs-comment">//基数遍历（从0开始）</span><span class="hljs-selector-tag">for</span> (i &lt;- <span class="hljs-number">0</span> until (arrBuf.length,<span class="hljs-number">2</span>))&#123;  <span class="hljs-selector-tag">println</span>(arrBuf(i))&#125;<span class="hljs-comment">//偶数遍历（从1开始）</span><span class="hljs-selector-tag">for</span> (i &lt;- <span class="hljs-number">1</span> until (arrBuf.length,<span class="hljs-number">2</span>))&#123;  <span class="hljs-selector-tag">println</span>(arrBuf(i))&#125;<span class="hljs-comment">//逆序(新API)</span><span class="hljs-selector-tag">for</span> (i &lt;- arrBuf.indices.reverse)&#123;  <span class="hljs-selector-tag">println</span>(arrBuf(i))&#125;</code></pre><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><pre><code class="hljs awk"><span class="hljs-regexp">//</span>求和arr.sum<span class="hljs-regexp">//</span>最大，最小arr.maxarr.min<span class="hljs-regexp">//</span>克隆arr.clone()<span class="hljs-regexp">//</span>排序util.Sorting.quickSort(arr)<span class="hljs-regexp">//m</span>kstring(组装字符串)arr.mkString<span class="hljs-regexp">//</span>res0: String = <span class="hljs-number">56783456</span>arr.mkString(<span class="hljs-string">&quot;,&quot;</span>)<span class="hljs-regexp">//</span>res1: String = <span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">83</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>arr.mkString(<span class="hljs-string">&quot;&lt;&quot;</span>,<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;&gt;&quot;</span>)<span class="hljs-regexp">//</span>res2: String = &lt;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">83</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&gt;<span class="hljs-regexp">//</span>toStringarr.toString<span class="hljs-regexp">//</span>res0: String = [I@<span class="hljs-number">6</span>f8cf218<span class="hljs-regexp">//</span>hashCodearr.hashCode()<span class="hljs-regexp">//</span>res0: Int = <span class="hljs-number">1556830203</span></code></pre><h2 id="使用yield和函数式编程实现数组转换"><a href="#使用yield和函数式编程实现数组转换" class="headerlink" title="使用yield和函数式编程实现数组转换"></a>使用yield和函数式编程实现数组转换</h2><h4 id="yield转换"><a href="#yield转换" class="headerlink" title="yield转换"></a>yield转换</h4><pre><code class="hljs livecodeserver">//转换后类型与原类型相同，原值不变<span class="hljs-keyword">for</span> (<span class="hljs-keyword">a</span> &lt;- arr) yield <span class="hljs-keyword">a</span>*<span class="hljs-keyword">a</span>//增减<span class="hljs-keyword">if</span>守护过滤<span class="hljs-keyword">for</span> (<span class="hljs-keyword">a</span> &lt;- arr <span class="hljs-keyword">if</span> <span class="hljs-keyword">a</span>%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) yield <span class="hljs-keyword">a</span>*<span class="hljs-keyword">a</span></code></pre><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><pre><code class="hljs angelscript"><span class="hljs-comment">//使用filter作为过滤器</span>arr.filter(_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(_ * <span class="hljs-number">2</span>)<span class="hljs-comment">// _表示占位符，第一个表示Array里的每一个元素，第二个表示过滤后的一个元素</span><span class="hljs-comment">//可以将()变成&#123;&#125;，不常用</span>arr.filter&#123;_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;.map&#123;_ * <span class="hljs-number">2</span>&#125;</code></pre><h2 id="算法实战"><a href="#算法实战" class="headerlink" title="算法实战"></a>算法实战</h2><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> scala.collection.mutable.ArrayBuffer<span class="hljs-comment">/*</span><span class="hljs-comment">删除第一个负数之后的负数</span><span class="hljs-comment"> */</span>var arr = ArrayBuffer[Int](<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">5</span>)var foundFirstNegative = <span class="hljs-literal">false</span>var index = <span class="hljs-number">0</span>var arr_length = arr.length<span class="hljs-comment">////不可以用for因为删了就少了，就会出现以后的几遍就不能比较了</span><span class="hljs-comment">//for (i &lt;- arr.indices) &#123;</span><span class="hljs-comment">//  if (arr(i) &gt; 0) &#123;</span><span class="hljs-comment">/*</span><span class="hljs-comment">//低效率版,remove频繁移动数组，当数组全是负数时，复杂度为O((n+n^2)/2)</span><span class="hljs-comment">while (index &lt; arr_length) &#123;</span><span class="hljs-comment">  if (arr(index) &gt; 0) &#123;</span><span class="hljs-comment">    index += 1</span><span class="hljs-comment">  &#125; else &#123;</span><span class="hljs-comment">    if (foundFirstNegative) &#123;</span><span class="hljs-comment">      arr.remove(index)</span><span class="hljs-comment">      arr_length -= 1</span><span class="hljs-comment">    &#125; else &#123;</span><span class="hljs-comment">      foundFirstNegative = true</span><span class="hljs-comment">      index += 1</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">  &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">arr.mkString</span><span class="hljs-comment">*/</span><span class="hljs-comment">//高效率版，把留下的index做标志，一次性删除其他的，最坏的情况，复杂度为O(n)</span><span class="hljs-comment">//这里的if守卫，刚开始的时候都能放行，当找到第一个负数之后就把别的负数拦在门外了</span>val keepIndexArr = <span class="hljs-keyword">for</span> (i &lt;- arr.indices <span class="hljs-keyword">if</span> !foundFirstNegative || arr(i) &gt;= <span class="hljs-number">0</span>) yield &#123;  <span class="hljs-keyword">if</span> (arr(i) &lt; <span class="hljs-number">0</span>) &#123;    foundFirstNegative = <span class="hljs-literal">true</span>  &#125;  i&#125;<span class="hljs-comment">//先装</span><span class="hljs-keyword">for</span> (i &lt;- keepIndexArr.indices) &#123;  arr(i) = arr(keepIndexArr(i))&#125;<span class="hljs-comment">//后删</span>arr.trimEnd(arr_length - keepIndexArr.length)print(arr.mkString)</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala继承</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%E7%BB%A7%E6%89%BF/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="override重写"><a href="#override重写" class="headerlink" title="override重写"></a>override重写</h1><ul><li>为什么要用override关键字？因为这样更清楚，不容易出错，比如打错字了，就没覆盖成功，但是不会报错</li><li>override可以覆盖feild和method</li></ul><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;CZM&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span> </span>= name&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> score = <span class="hljs-string">&quot;A&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getScore</span> </span>= score<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span> </span>= <span class="hljs-string">&quot;My name is &quot;</span>+<span class="hljs-keyword">super</span>.getName<span class="hljs-comment">//重写需要使用关键字override声明。如果父类定义为final则不可重写</span>&#125;<span class="hljs-keyword">val</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>s1.getScores1.getName</code></pre><h1 id="isInstanceOf和asInstanceOf-多态判断"><a href="#isInstanceOf和asInstanceOf-多态判断" class="headerlink" title="isInstanceOf和asInstanceOf:多态判断"></a>isInstanceOf和asInstanceOf:多态判断</h1><ul><li>在多态的转换中，会把子类对象赋值给父类变量，如果遇到需要把本来是子类的对象变回子类怎么实现？</li><li>isInstanceOf用于判断是否是指定类的对象</li><li>asInstanceOf用于将对象转换成指定类型</li></ul><pre><code class="hljs armasm"><span class="hljs-comment">//接上文代码</span><span class="hljs-comment">//旧API,这个并不能精准判断</span><span class="hljs-symbol">val</span> <span class="hljs-built_in">p1</span>:Person = new Student<span class="hljs-symbol">if</span> (<span class="hljs-built_in">p1</span>.isInstanceOf[Student])&#123;  val <span class="hljs-built_in">s1</span>:Student = <span class="hljs-built_in">p1</span>.asInstanceOf[Student]<span class="hljs-comment">//p1的本质是没有改变的，返回一个clone的对象</span>  <span class="hljs-built_in">s1</span>.getScore <span class="hljs-comment">//如果不转换，这个学生就失去了这个方法</span>&#125;<span class="hljs-comment">//新API，非精准判断</span><span class="hljs-symbol">p1</span> match &#123;  case _: Student =&gt;    <span class="hljs-built_in">p1</span>.asInstanceOf[Student]    <span class="hljs-built_in">p1</span>  case _ =&gt;&#125;</code></pre><h1 id="getClass和classOf-精准判断"><a href="#getClass和classOf-精准判断" class="headerlink" title="getClass和classOf:精准判断"></a>getClass和classOf:精准判断</h1><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span> p1: Person = <span class="hljs-keyword">new</span> Student<span class="hljs-keyword">val</span> s1 = <span class="hljs-keyword">new</span> Studentp1.getClass == classOf[Student]<span class="hljs-comment">//false</span>p1.getClass == classOf[Person]<span class="hljs-comment">//true</span></code></pre><h1 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h1><p>除了private之外，scala还提供和了protect关键字，子类访问权限</p><ul><li>**private[this]**：出了自己的{ }就不承认了，就比如说一个人有病，只有自己知道，在外人看来是不存在的，儿子也不知道</li><li>**protected[this]**：出了自己和儿子的{ }就不承认了，就比如说一个人有病，只有自己和儿子知道，在外人看来是不存在的，儿子不会告诉别人的儿子</li></ul><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">protected</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;CZM&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span> </span>= name &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> score = <span class="hljs-string">&quot;A&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getScore</span> </span>= score    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makeFriend</span></span>(s: <span class="hljs-type">Student</span>): <span class="hljs-type">Unit</span> = &#123;    println(<span class="hljs-string">&quot;My name is &quot;</span> + name + <span class="hljs-string">&quot; , I&#x27;m &quot;</span> + s.name + <span class="hljs-string">&quot; is friend!&quot;</span>)<span class="hljs-comment">//在自己家可以调用name，无法调用s.name相当于自己儿子去了别人家</span>  &#125;&#125;<span class="hljs-keyword">val</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span><span class="hljs-keyword">val</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>s1.makeFriend(s2)</code></pre><h1 id="调用父类constructor"><a href="#调用父类constructor" class="headerlink" title="调用父类constructor"></a>调用父类constructor</h1><ul><li>为什么调用父类构造函数这么奇葩？ 因为子类constructor第一行必须调用主constructor或者其他辅助constructor</li><li>为什么不用super(…)? 因为没有 </li></ul><pre><code class="hljs angelscript"><span class="hljs-comment">//父类，定义了两个constructor</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">val</span> <span class="hljs-symbol">name: <span class="hljs-symbol">String</span></span>) &#123;  var age = <span class="hljs-number">10</span>    def getName = name  def <span class="hljs-keyword">this</span>(name: String, age: Int) &#123;    <span class="hljs-keyword">this</span>(name)    <span class="hljs-keyword">this</span>.age = age  &#125;&#125;<span class="hljs-comment">//子类定义自己的constructor(name:传值，age：重写父类中的age字段，score：定义自己的变量score) Person()这里就决定了调用哪一个constructor</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span>(<span class="hljs-symbol">name: <span class="hljs-symbol">String</span>, <span class="hljs-symbol">override</span></span> <span class="hljs-symbol">val</span> <span class="hljs-symbol">age: <span class="hljs-symbol">Int</span>, <span class="hljs-symbol">val</span></span> <span class="hljs-symbol">score: <span class="hljs-symbol">Double</span></span>) <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Person</span>(<span class="hljs-symbol">name</span>) &#123;</code></pre><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li>匿名内部类：定义一个没有名称的某个类（接口）的子类，并马上实例化new</li><li>匿名内部类本身没有构造器，但是会调用父类构造器</li><li>匿名内部类必须继承或实现一个接口，但最多只能一个父类或实现一个接口(JAVA == scala)</li></ul><h3 id="JAVA中的匿名内部类"><a href="#JAVA中的匿名内部类" class="headerlink" title="JAVA中的匿名内部类"></a>JAVA中的匿名内部类</h3><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type"></span>父类构造器( ) 或  接口( )&#123;<span class="hljs-comment">//todo</span>&#125;</code></pre><h3 id="scala中的匿名内部类，跟JAVA没有一点区别"><a href="#scala中的匿名内部类，跟JAVA没有一点区别" class="headerlink" title="scala中的匿名内部类，跟JAVA没有一点区别"></a>scala中的匿名内部类，跟JAVA没有一点区别</h3><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">val name: <span class="hljs-type">String</span></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span> </span>= println(<span class="hljs-string">&quot;Person class &quot;</span> + name)&#125;<span class="hljs-keyword">val</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;CZM&quot;</span>)    <span class="hljs-comment">//p1是一个Person类的对象 </span><span class="hljs-keyword">val</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;leo&quot;</span>) &#123;  <span class="hljs-comment">//p2是一个Person类的匿名子类的对象</span>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span> </span>= println(<span class="hljs-string">&quot;new sun class &quot;</span> + name)&#125;p1.sayHellop2.sayHello</code></pre><h1 id="abstract抽象"><a href="#abstract抽象" class="headerlink" title="abstract抽象"></a>abstract抽象</h1><ul><li>子类覆盖抽象类的抽象方法可以不需要override，<strong>IDEA推荐还是使用override</strong></li><li>抽象类中允许有非抽象方法</li><li>没有implement关键字，依然使用<strong>extends</strong></li><li>可以抽象field(需要在抽象类中)，编译在编译抽象类时，生成了getter和setter方法，但是父类中没有这个field</li></ul><pre><code class="hljs scala"><span class="hljs-comment">//抽象类和抽象方法</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>():<span class="hljs-type">Any</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span></span>() = ??? &#125;<span class="hljs-comment">//抽象类和抽象field</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> name:<span class="hljs-type">String</span> &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Scala面向对象</title>
    <link href="/07-Bigdata/04-Spark/01-Sacla/Scala%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/07-Bigdata/04-Spark/01-Sacla/Scala%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre><code class="hljs kotlin"><span class="hljs-comment">//不用修饰符</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;<span class="hljs-comment">//定义一个私有的field </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;CZM&quot;</span>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//这是一个带参数的方法</span>&#125;def getName = name<span class="hljs-comment">//定义一个不带参数的方法</span></code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span> helloWorld = <span class="hljs-keyword">new</span> HelloWorld<span class="hljs-comment">//括号可有可无 </span></code></pre><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><pre><code class="hljs awk"><span class="hljs-regexp">//</span>可以不写*()*helloWorld.fun()<span class="hljs-regexp">//</span>不能写*()*helloWorld.getName</code></pre><h1 id="getter和setter方法"><a href="#getter和setter方法" class="headerlink" title="getter和setter方法"></a><strong>getter和setter方法</strong></h1><ul><li>定义<strong>不带private的var field</strong> Scala生成面向JVM的类时，会定义成private的字段，并提供Public的getter和setter （也就是说，你在用对象调用这个值的时候，底层转换为使用pubic的getter/setter方法访问）</li><li>定义<strong>带private的field</strong>，则生成的getter和setter方法也是private的，外部不能调用，只能通过暴露的方法得到</li><li>定义成<strong>val field</strong>时，只会生成getter方法</li><li>如果不希望生成getter和setter方法，则将field声明成privete[this]</li></ul><pre><code class="hljs haxe"><span class="hljs-comment">//自动生成的getter和setter方法，通过 val var private private[this]</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;CZM&quot;</span><span class="hljs-comment">/*自动生成如下代码</span><span class="hljs-comment">//getter</span><span class="hljs-comment">def name = name</span><span class="hljs-comment"></span><span class="hljs-comment">//setter</span><span class="hljs-comment">def name_ = (new_name:String)</span><span class="hljs-comment">*/</span><span class="hljs-comment">//手动getter和setter</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name= <span class="hljs-string">&quot;CZM&quot;</span>def name = <span class="hljs-string">&quot;Your name is &quot;</span>+name<span class="hljs-comment">//错误，因为这样相当于两次定义了name</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> old_name= <span class="hljs-string">&quot;CZM&quot;</span>    def name = <span class="hljs-string">&quot;Your name is &quot;</span>+old_name<span class="hljs-comment">//正确：old_name 作为类中的私有feild，仅仅提供私有的getter和setter方法，而name作为一个提供了public的getter和setter方法的feild ==&gt; var name并重写了public的getter和setter</span>    def name_=(<span class="hljs-keyword">new</span><span class="hljs-type">_name</span>: <span class="hljs-keyword">String</span>) &#123;<span class="hljs-comment">//需要注意的是这里的语法规则，**=号前后不允许有空格**</span>old_name = <span class="hljs-keyword">new</span><span class="hljs-type">_name</span><span class="hljs-type"></span>    print(<span class="hljs-string">&quot;Your new name is &quot;</span> + old_name)  &#125;&#125;<span class="hljs-comment">//调用getter和setter</span><span class="hljs-keyword">var</span> helloWorld = <span class="hljs-keyword">new</span> <span class="hljs-type">HelloWorld</span>()helloWorld.name <span class="hljs-comment">//geter </span>helloWorld.name_= <span class="hljs-string">&quot;asd&quot;</span> <span class="hljs-comment">//正儿八经setter</span>helloWorld.name = <span class="hljs-string">&quot;asd&quot;</span><span class="hljs-comment">//新型setter，将name作为返回，买一送一</span></code></pre><h3 id="privete-this-的使用"><a href="#privete-this-的使用" class="headerlink" title="privete[this]的使用"></a>privete[this]的使用</h3><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> myAge = <span class="hljs-number">0</span><span class="hljs-comment">//private[this] var myAge = 0 //调用getter方法会报错，即使定义了getter和setter方法</span>def age = myAgedef age_=(<span class="hljs-keyword">new</span><span class="hljs-type">Value</span>:<span class="hljs-keyword">Int</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Value</span>&lt;<span class="hljs-number">0</span>)&#123;println(<span class="hljs-string">&quot;illegal gar!!&quot;</span>)&#125;<span class="hljs-keyword">else</span>&#123;myAge = <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>&#125;&#125;def older(s:<span class="hljs-type">Student</span>)&#123;myAge &gt; s.myAge &#125;&#125;</code></pre><h3 id="怀旧党专用，使用类JAVA的getter和setter方法"><a href="#怀旧党专用，使用类JAVA的getter和setter方法" class="headerlink" title="怀旧党专用，使用类JAVA的getter和setter方法"></a>怀旧党专用，使用类JAVA的getter和setter方法</h3><pre><code class="hljs less"><span class="hljs-variable">@BeanProperty</span> var age = <span class="hljs-number">0</span><span class="hljs-variable">@BeanProperty</span> var age：Int = _<span class="hljs-comment">//使用占位符需要声明类型</span><span class="hljs-comment">//同时拥有两种调用方式</span>s1.getAges1.age</code></pre><h1 id="构造函数constructor"><a href="#构造函数constructor" class="headerlink" title="构造函数constructor"></a>构造函数constructor</h1><h3 id="主constructor"><a href="#主constructor" class="headerlink" title="主constructor"></a>主constructor</h3><ul><li>主构造函数就是与类名在一起的构造函数，关键问题是，当主构造函数定义了之后，就不能调用无参构造函数了，也就是说，<strong>主构造函数定义了最少参数的构造函数</strong>，以后就只有更多参数的了</li><li>主constructor中定义的参数，如果被使用到，则会被声明成<strong>privat[this] var name</strong></li><li>如果类中没有使用到这个参数，则不会被声明，并不会有这个feild</li></ul><pre><code class="hljs angelscript"><span class="hljs-comment">//当然，可以设置默认参数 </span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span>(<span class="hljs-symbol">name:<span class="hljs-symbol">String</span>,<span class="hljs-symbol">age</span>:<span class="hljs-symbol">Int</span></span>)&#123;&#125;</code></pre><h3 id="辅助constructor"><a href="#辅助constructor" class="headerlink" title="辅助constructor"></a>辅助constructor</h3><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>()&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span>def <span class="hljs-keyword">this</span>(name:String)&#123;<span class="hljs-keyword">this</span>()<span class="hljs-comment">//如果不相互调用，必须调用**主构造函数**，且要在**首行 == JAVA**</span><span class="hljs-keyword">this</span>.name = name&#125;def <span class="hljs-keyword">this</span>(name:String,age:<span class="hljs-built_in">Int</span>)&#123;<span class="hljs-keyword">this</span>(name)<span class="hljs-keyword">this</span>.age = age&#125;&#125;</code></pre><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>与JAVA不同的是，Scala中的外部类的<strong>对象的内部类</strong>都是不同的类</p><pre><code class="hljs scala"><span class="hljs-keyword">import</span> scala.collection.mutable.<span class="hljs-type">ArrayBuffer</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name: <span class="hljs-type">String</span></span>) </span>&#123;&#125;  <span class="hljs-keyword">val</span> students = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBuffer</span>[<span class="hljs-type">Student</span>]()  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getStudent</span></span>(name: <span class="hljs-type">String</span>) = &#123;    <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span>(name)  &#125;&#125;<span class="hljs-keyword">val</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span><span class="hljs-keyword">val</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span><span class="hljs-keyword">val</span> s1 = c1.getStudent(<span class="hljs-string">&quot;CZM&quot;</span>)<span class="hljs-comment">//s1: c1.Student = Class$Student@1d3f8af1</span><span class="hljs-keyword">val</span> s2 = c2.getStudent(<span class="hljs-string">&quot;czm&quot;</span>)<span class="hljs-comment">//s2: c2.Student = Class$Student@73589106</span>c1.students += s1<span class="hljs-comment">//正确</span>c1.students += s2<span class="hljs-comment">//错误，每一个内部类都是属于对象的，而不是独立存在的</span><span class="hljs-comment">/*错误信息</span><span class="hljs-comment">Error:(21, 24) type mismatch;</span><span class="hljs-comment">found   : c2.Student</span><span class="hljs-comment">required: c1.Student</span><span class="hljs-comment">c1.students += s2</span><span class="hljs-comment">*/</span></code></pre><h1 id="object对象"><a href="#object对象" class="headerlink" title="object对象"></a>object对象</h1><p>由于类中定义的feild都是属于对象的，并没有属于类的字段，在JAVA中使用Static定义的字段作为所有对象共用的类的字段，在scala中提供了object来存放。</p><ul><li>object 也有constructor(不属于方法的代码都是静态加载)，<strong>只在第一次被调用时执行一次</strong>，不能定义带参数的constructor</li><li>object通常用作<strong>单例模式</strong>(只有自己一个对象)，或者作为<strong>伴生对象</strong>存放静态成员，静态工具方法</li><li>与class相比，object仅仅是不能定义带参数的constructor，其他都是一样的，能继承其他方法</li></ul><pre><code class="hljs scala"><span class="hljs-comment">//定义object对象</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-comment">//不能有括号，不能定义带参数的constructor</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span>  println(<span class="hljs-string">&quot;This is constructor!&quot;</span>)  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span> </span>= name  println(<span class="hljs-string">&quot;This is constructor too!&quot;</span>)&#125;<span class="hljs-type">Person</span>.getName<span class="hljs-comment">//让object继承抽象类</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">syaHello</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span>&#125;<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">syaHello</span></span>(name: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;    println(<span class="hljs-string">&quot;Implement from Hello, your name is &quot;</span> + name)  &#125;&#125;<span class="hljs-type">HelloObject</span>.syaHello(<span class="hljs-string">&quot;CZM&quot;</span>)</code></pre><h1 id="伴生对象和伴生类"><a href="#伴生对象和伴生类" class="headerlink" title="伴生对象和伴生类"></a>伴生对象和伴生类</h1><ul><li>在同一个.scala文件中。同名的class和object，称object为class的伴生对象，class称为object的伴生类</li><li>伴生对象和伴生类之间可以<strong>相互访问</strong>private的feild</li><li>class中的一切属于对象</li><li>object中的一切属于类</li></ul><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span> </span>= &#123;    println(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot; you are &quot;</span> + age + <span class="hljs-string">&quot; years old, and you must have &quot;</span> + <span class="hljs-type">Person</span>.legNum + <span class="hljs-string">&quot;legs&quot;</span>)<span class="hljs-comment">//需要加上Object名访问object对象变量（即使不是私有的）</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> legNum = <span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLegNum</span> </span>= legNum &#125;<span class="hljs-keyword">val</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;czm&quot;</span>, <span class="hljs-number">18</span>)p1.sayHello</code></pre><h1 id="Apply方法-允许重载？"><a href="#Apply方法-允许重载？" class="headerlink" title="Apply方法(允许重载？)"></a>Apply方法(允许重载？)</h1><ul><li>apply方法中一般做什么？创建一个对象，并返回对象</li><li>为什么要Apply方法？让创建类对象来的更简单，直接使用 **类名()**即可</li><li>为什么要在伴生对象中创建apply方法？因为这是一个工具方法，不应该属于对象，应该用类名调用</li></ul><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-variable">name</span>: <span class="hljs-variable">String</span>)</span><span class="hljs-variable"><span class="hljs-class">object</span></span> <span class="hljs-variable">Person</span> &#123;  <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-variable">name</span>: <span class="hljs-variable">String</span>): <span class="hljs-variable">Person</span> = <span class="hljs-variable">new</span> <span class="hljs-title">Person</span>(<span class="hljs-variable">name</span>)</span>&#125;<span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-string">&quot;你好&quot;</span>)</span></code></pre><h1 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h1><ul><li>为什么要main方法？作为函数的入口</li><li>为什么要定义在object中？因为main是public static的，需要被JVM使用类名调用</li></ul><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><pre><code class="hljs arduino"><span class="hljs-comment">//注意文件名与类名相同</span>object HelloWorld &#123;  <span class="hljs-function">def <span class="hljs-title">main</span><span class="hljs-params">(args: Array[<span class="hljs-keyword">String</span>])</span> </span>&#123;    <span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello &quot;</span> + args(<span class="hljs-number">0</span>))    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)    &#125;  &#125;&#125;</code></pre><h3 id="方法2-继承APP-Trait"><a href="#方法2-继承APP-Trait" class="headerlink" title="方法2:继承APP Trait"></a>方法2:继承APP Trait</h3><p>继承APP Trait，然后将需要在main中运行的代码，直接在constructor中编写。直接使用args接收传入的参数<strong>黑人问号脸？？</strong>：这里的参数是来自父类APP Trait的父类DelayedInit Trait的Main方法中的args</p><ul><li>工作原理：APP Trait 继承自DelayedInit Trait 编译时会将object中的constructor中的代码放到DelayedInit Trait的delayedInit方法中执行。DelayedInit的main方法将会调用delayedInit方法（为了懒加载？）</li></ul><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span></span>&#123;<span class="hljs-keyword">if</span> (args.length != <span class="hljs-number">0</span>) &#123;      println(<span class="hljs-string">&quot;Hello &quot;</span> + args(<span class="hljs-number">0</span>))    &#125; <span class="hljs-keyword">else</span> &#123;      println(<span class="hljs-string">&quot;Hello World!&quot;</span>)    &#125;&#125;</code></pre><h1 id="使用object实现枚举"><a href="#使用object实现枚举" class="headerlink" title="使用object实现枚举"></a>使用object实现枚举</h1><ul><li>枚举是什么：枚举是一个特殊的类，就是固定的多个常量对象的集合</li><li>Scala没有提供类似JAVA中的Enum这样的枚举特性，可以使用object继承Enumeration类，并且调用<strong>Value</strong>方法来初始化枚举值</li><li>调用时，直接使用Season(0)，为什么，不会跟apply冲突吗？继承了Enumeration，Enumeration中的apply方法是final的，子类不允许再定义apply只能继承Enumeration的apply（详情亲看源码）</li></ul><h3 id="scala实现枚举"><a href="#scala实现枚举" class="headerlink" title="scala实现枚举"></a>scala实现枚举</h3><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Season</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enumeration</span></span>&#123;  <span class="hljs-keyword">val</span> <span class="hljs-type">SPRING</span>,<span class="hljs-type">SUMMER</span>,<span class="hljs-type">AUTUMN</span>,<span class="hljs-type">WINTER</span> = <span class="hljs-type">Value</span><span class="hljs-comment">//Value方法继承于Enumeration</span>  <span class="hljs-comment">//可以自定义Value的元素</span>  <span class="hljs-keyword">val</span> <span class="hljs-type">SPRING</span> = <span class="hljs-type">Value</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;spring&quot;</span>)  ...&#125;<span class="hljs-comment">//调用</span><span class="hljs-comment">//Enumeration的apply方法返回一个Value对象</span><span class="hljs-type">Season</span>(<span class="hljs-number">0</span>)res0: <span class="hljs-type">Season</span>.<span class="hljs-type">Value</span> = <span class="hljs-type">SPRING</span><span class="hljs-type">Season</span>(<span class="hljs-string">&quot;spring&quot;</span>)</code></pre><h3 id="java中的枚举"><a href="#java中的枚举" class="headerlink" title="java中的枚举"></a>java中的枚举</h3><pre><code class="hljs awk">enum Weeday&#123;SUNDAY,MONDAY.TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY;&#125;<span class="hljs-regexp">//</span>在底层<span class="hljs-regexp">//</span>创建了一个final的Weeday类继承Enum<span class="hljs-regexp">//</span>实例化各个字段为 public final static 的 Weekday 对象，存在数组<span class="hljs-variable">$VALUES</span>中<span class="hljs-regexp">//</span>定义了一个values方法，用于返回数组<span class="hljs-regexp">//</span>Weekday.values()<span class="hljs-regexp">//</span>定义了一个valueOf方法，用于返回<span class="hljs-regexp">//</span>Weekday.valueof(<span class="hljs-string">&quot;SUNDAY&quot;</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>04-Spark</category>
      
      <category>01-Sacla</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie Coordinator job 之定时任务</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20Coordinator%20job%20%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20Coordinator%20job%20%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>使用 Coordinator job 可以执行定时任务和时间触发执行<br>需要注意的是 Oozie 默认使用的时区与中国时区不是一致的，需要进行一点修改 </p><p>###<a href="http://www.cnblogs.com/cenzhongman/p/7259013.html?yyue=a21bo.50862.201879">1.关于时区</a><br>####a.修改 core-site.xml 文件(运行需要)需要清除编译文件，重启 tomcat 服务(不能是UTC+0800)<br><a href="http://www.cnblogs.com/cenzhongman/p/7231663.html?yyue=a21bo.50862.201879">Oozie 安装及 examples app 的使用</a></p><pre><code>&lt;property&gt;    &lt;name&gt;oozie.processing.timezone&lt;/name&gt;    &lt;value&gt;GMT+0800&lt;/value&gt;&lt;/property&gt;</code></pre><p>####b.修改 $OOZIE_HOME/oozie-server/webapps/oozie/oozie-console.js 文件(Web显示需要)，无需重启</p><pre><code>function getTimeZone() &#123;Ext.state.Manager.setProvider(new Ext.state.CookieProvider());return Ext.state.Manager.get(&quot;TimezoneId&quot;,&quot;GMT+0800&quot;);&#125;</code></pre><p>###2.拷贝 example 文件 cron-schedule<br>###3.编辑 job.properties 文件(注意时间格式)</p><pre><code>nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020jobTracker=localhost:8032queueName=defaultoozieAppsRoot=oozie-appsoozie.coord.application.path=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/cron-schedulestart=2017-07-30T14:40+0800end=2017-07-30T14:59+0800workflowAppUri=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/cron-schedule</code></pre><p>###4.编辑 workflow.xml 文件(内容酌情添加，这里什么也不做)(修改了版本号)</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;no-op-wf&quot;&gt;    &lt;start to=&quot;end&quot;/&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>###5.编辑 coordinator.xml 文件(支持两种定时任务方式，下文详细说明)</p><pre><code>&lt;coordinator-app name=&quot;cron-coord&quot; frequency=&quot;0/1 * * * *&quot; start=&quot;$&#123;start&#125;&quot; end=&quot;$&#123;end&#125;&quot; timezone=&quot;GMT+0800&quot;                 xmlns=&quot;uri:oozie:coordinator:0.4&quot;&gt;        &lt;action&gt;        &lt;workflow&gt;            &lt;app-path&gt;$&#123;workflowAppUri&#125;&lt;/app-path&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;jobTracker&lt;/name&gt;                    &lt;value&gt;$&#123;jobTracker&#125;&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;nameNode&lt;/name&gt;                    &lt;value&gt;$&#123;nameNode&#125;&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;queueName&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;        &lt;/workflow&gt;    &lt;/action&gt;&lt;/coordinator-app&gt;</code></pre><p>##注意事项</p><ul><li>修改时区写法</li><li>修改版本号</li><li>coordinator.xml 文件在本地文件系统中读取，HDFS 中无需修改不影响</li></ul><p>###6.上传文件至 HDFS 文件系统<br>###7.执行任务</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job --config oozie-apps/cron-schedule/job.properties -run</code></pre><p>#关于定时方式<br>###方式一：官方定义方式</p><table><thead><tr><th>EL Constant</th><th>Value</th><th>Example</th></tr></thead><tbody><tr><td>${coord:minutes(int n)}</td><td>n</td><td>${coord:minutes(45)} –&gt; 45</td></tr><tr><td>${coord:hours(int n)}</td><td>n * 60</td><td>${coord:hours(3)} –&gt; 180</td></tr><tr><td>${coord:days(int n)}</td><td>variable</td><td>${coord:days(2)} –&gt; minutes in 2 full days from the current date</td></tr><tr><td>${coord:months(int n)}</td><td>variable</td><td>${coord:months(1)} –&gt; minutes in a 1 full month from the current date</td></tr><tr><td>${cron syntax}</td><td>variable</td><td>${0,10 15 * * 2-6} –&gt; a job that runs every weekday at 3:00pm and 3:10pm UTC time</td></tr></tbody></table><p>###方式二：corntab方式<br><a href="http://www.cnblogs.com/cenzhongman/p/7229387.html?yyue=a21bo.50862.201879">Crontab使用参考</a></p><table><thead><tr><th>Field name</th><th>Allowed Values</th><th>Allowed Special Characters</th></tr></thead><tbody><tr><td>Minutes</td><td>0-59</td><td>, - * /</td></tr><tr><td>Hours</td><td>0-23</td><td>, - * /</td></tr><tr><td>Day-of-month</td><td>1-31</td><td>, - * ? / L W</td></tr><tr><td>Month</td><td>1-12 or JAN-DEC</td><td>, - * /</td></tr><tr><td>Day-of-Week</td><td>1-7 or SUN-SAT</td><td>, - * ? / L #</td></tr></tbody></table><p>Example</p><table><thead><tr><th>Cron Expression</th><th>Meaning</th></tr></thead><tbody><tr><td>10 9 * * *</td><td>Runs everyday at 9:10am</td></tr><tr><td>10,30,45 9 * * *</td><td>Runs everyday at 9:10am, 9:30am, and 9:45am</td></tr><tr><td>0 * 30 JAN 2-6</td><td>Runs at 0 minute of every hour on weekdays and 30th of January</td></tr><tr><td>0/20 9-17 * * 2-5</td><td>Runs every Mon, Tue, Wed, and Thurs at minutes 0, 20, 40 from 9am to 5pm</td></tr><tr><td>1 2 L-3 * *</td><td>Runs every third-to-last day of month at 2:01am</td></tr><tr><td>1 2 6W 3 ?</td><td>Runs on the nearest weekday to March, 6th every year at 2:01am</td></tr><tr><td>1 2 * 3 3#2</td><td>Runs every second Tuesday of March at 2:01am every year</td></tr><tr><td>0 10,13 * * MON-FRI</td><td>Runs every weekday at 10am and 1pm</td></tr></tbody></table><p>##注1：开启了检查频率，导致5分钟以内的频率运行失败</p><ul><li><p>错误提示:Error: E1003 : E1003: Invalid coordinator application attributes, Coordinator job with frequency [2] minutes is faster than allowed maximum of 5 minutes (oozie.service.coord.check.maximum.frequency is set to true)</p></li><li><p>错误原因:开启了检查频率，导致5分钟以内的频率运行失败</p></li><li><p>解决：关闭频率检查功能 配置oozie-site.xml文件</p><pre><code>  &lt;property&gt;      &lt;name&gt;oozie.service.coord.check.maximum.frequency&lt;/name&gt;      &lt;value&gt;false&lt;/value&gt;  &lt;/property&gt;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie wordcount实战</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20wordcount%E5%AE%9E%E6%88%98/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20wordcount%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>#一、定义<br>##基本概念<br>Action: An execution/computation task (Map-Reduce job, Pig job, a shell command). It can also be referred as task or ‘action node’.<br>》》》》Action 也叫 Action Node 用于执行或者运算的任务(如MapRudecr,shell 命令等)</p><p>Workflow: A collection of actions arranged in a control dependency DAG (Direct Acyclic Graph)有向无环图. “control dependency” from one action to another means that the second action can’t run until the first action has completed.<br>》》》》WorkFlow 依赖有向无环图控制 actions ，在这个任务结束之前，另一个任务不能运行</p><p>Workflow Definition: A programmatic description of a workflow that can be executed.<br>》》》》用于定义一个Wokrflow</p><p>Workflow Definition Language: The language used to define a Workflow Definition.</p><p>Workflow Job: An executable instance of a workflow definition.</p><p>Workflow Engine: A system that executes workflows jobs. It can also be referred as a DAG engine.</p><p>###Workflow Definition<br>A workflow definition is a DAG with control flow nodes (start, end, decision, fork, join, kill) or action nodes (map-reduce, pig, etc.), nodes are connected by transitions arrows.<br>》》》》一个 Workflow 包括有flow控制节点[control flow nodes (start, end, decision, fork, join, kill)] 和 action nodes (map-reduce, pig, etc.)</p><p>The workflow definition language is XML based and it is called <strong>hPDL</strong> (Hadoop Process Definition Language).</p><p>#二、如何编写一个 workflow.xml 之 Map-Reduce<br>####1.The map-reduce action starts a Hadoop map/reduce job from a workflow. Hadoop jobs can be Java Map/Reduce jobs or streaming jobs. 》》》可以是一个 JAVA 的Map-ruduce程序，也可以是一个流式计算任务。</p><p>####2.A map-reduce action can be configured to perform file system cleanup and directory creation before starting the map reduce job. This capability enables Oozie to retry a Hadoop job in the situation of a transient failure (Hadoop checks the non-existence of the job output directory and then creates it when the Hadoop job is starting, thus a retry without cleanup of the job output directory would fail).》》》Mapreduce 程序需要确保输出目录不存在</p><p>####3.The workflow job will wait until the Hadoop map/reduce job completes before continuing to the next action in the workflow execution path.》》》在继续下一个任务之前确保这个任务已经结束了</p><p>####4.The counters of the Hadoop job and job exit status (=FAILED=, KILLED or SUCCEEDED ) must be available to the workflow job after the Hadoop jobs ends. This information can be used from within decision nodes and other actions configurations.》》》必须提供一个自己的状态给别人参考，以进行别的任务安排</p><p>####5.The map-reduce action has to be configured with all the necessary Hadoop JobConf properties to run the Hadoop map/reduce job.》》》这句户的意思是说，我们在编写mapreduce程序的时候只需要 Map 和 Reduce 其他配置信息在 xml 中说明</p><p>workfolw.xml(旧版本API，且缺少很多必要的配置参数，毕竟是demo)</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.2&quot; name=&quot;map-reduce-wf&quot;&gt;    &lt;start to=&quot;mr-node&quot;/&gt;    &lt;action name=&quot;mr-node&quot;&gt;        &lt;map-reduce&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;prepare&gt;                &lt;delete path=&quot;$&#123;nameNode&#125;/user/$&#123;wf:user()&#125;/$&#123;examplesRoot&#125;/output-data/$&#123;outputDir&#125;&quot;/&gt;            &lt;/prepare&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;mapred.mapper.class&lt;/name&gt;                    &lt;value&gt;org.apache.oozie.example.SampleMapper&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;mapred.reducer.class&lt;/name&gt;                    &lt;value&gt;org.apache.oozie.example.SampleReducer&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;mapred.map.tasks&lt;/name&gt;                    &lt;value&gt;1&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;mapred.input.dir&lt;/name&gt;                    &lt;value&gt;/user/$&#123;wf:user()&#125;/$&#123;examplesRoot&#125;/input-data/text&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                    &lt;name&gt;mapred.output.dir&lt;/name&gt;                    &lt;value&gt;/user/$&#123;wf:user()&#125;/$&#123;examplesRoot&#125;/output-data/$&#123;outputDir&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;        &lt;/map-reduce&gt;        &lt;ok to=&quot;end&quot;/&gt;        &lt;error to=&quot;fail&quot;/&gt;    &lt;/action&gt;    &lt;kill name=&quot;fail&quot;&gt;        &lt;message&gt;Map/Reduce failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>修改 job.properties 文件</p><pre><code>nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020jobTracker=0.0.0.0:8032queueName=defaultoozieAppRoot=oozie-appsoozieDataRoot=oozie/datasoozie.wf.application.path=$&#123;nameNode&#125;/user/$&#123;user.name&#125;/$&#123;oozieAppRoot&#125;/mr-wordcount-wf/workflow.xmlinputDir=mr-wordcount-wf/inputoutputDir=mr-wordcount-wf/output</code></pre><p>标准的 workflow.xml 文件<br>参考<a href="http://www.cnblogs.com/cenzhongman/p/7128140.html">MapReduce 程序设计中的 driver</a></p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;mr-wordcount-wf&quot;&gt;  &lt;start to=&quot;mr-node-wordcount&quot;/&gt;  &lt;action name=&quot;mr-node-wordcount&quot;&gt;    &lt;map-reduce&gt;      &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;      &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;      &lt;prepare&gt;        &lt;delete path=&quot;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&quot;/&gt;      &lt;/prepare&gt;      &lt;configuration&gt;        &lt;property&gt;          &lt;name&gt;mapred.mapper.new-api&lt;/name&gt;          &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapred.reducer.new-api&lt;/name&gt;          &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.job.queuename&lt;/name&gt;          &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.job.map.class&lt;/name&gt;          &lt;value&gt;com.cenzhongman.hdfs.WordCount$WordcountMapper&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.job.reduce.class&lt;/name&gt;          &lt;value&gt;com.cenzhongman.hdfs.WordCount$WordcountReducer&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.map.output.key.class&lt;/name&gt;          &lt;value&gt;org.apache.hadoop.io.Text&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.map.output.value.class&lt;/name&gt;          &lt;value&gt;org.apache.hadoop.io.IntWritable&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.job.output.key.class&lt;/name&gt;          &lt;value&gt;org.apache.hadoop.io.Text&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.job.output.value.class&lt;/name&gt;          &lt;value&gt;org.apache.hadoop.io.IntWritable&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.input.fileinputformat.inputdir&lt;/name&gt;          &lt;value&gt;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;inputDir&#125;&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;          &lt;name&gt;mapreduce.output.fileoutputformat.outputdir&lt;/name&gt;          &lt;value&gt;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&lt;/value&gt;        &lt;/property&gt;      &lt;/configuration&gt;    &lt;/map-reduce&gt;    &lt;ok to=&quot;end&quot;/&gt;    &lt;error to=&quot;fail&quot;/&gt;  &lt;/action&gt;  &lt;kill name=&quot;fail&quot;&gt;    &lt;message&gt;Map/Reduce failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;  &lt;/kill&gt;  &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>注意事项：</p><ul><li>修改版本为0.5</li><li>修改程序名</li><li>修改 action 名(两处)</li><li>修改删除路径</li><li>修改 map reduce 新api</li><li>修改Mapclass(注意内部类的写法)</li><li>修改reduceclass(注意内部类的写法)</li><li>修改 map-output-key class value</li><li>修改 job-output-key class value</li><li>修改 input dir</li><li>修改 output dir</li></ul><p>###其他步骤<br>####1.拷贝jar包到lib目录下<br>####2.上传包文件夹到指定目录<br>####3.上传数据文件<br>####4.执行程序</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job -config /opt/cdh5.3.6/oozie-4.0.0-cdh5.3.6/oozie-apps/mr-wordcount-wf/job.properties -run</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie 之 sqoop 实战</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20%E4%B9%8B%20sqoop%20%E5%AE%9E%E6%88%98/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20%E4%B9%8B%20sqoop%20%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>###1.创建 lib 目录并拷贝 mysql 支持包<br>###2.修改 job.properties 文件</p><pre><code>nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020jobTracker=localhost:8032queueName=defaultoozieAppsRoot=oozie-appsoozie.use.system.libpath=trueoozie.wf.application.path=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop-import/outputDir=sqoop-import/output</code></pre><p>###3.修改 workflow.xml 文件</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;sqoop-import-wf&quot;&gt;    &lt;start to=&quot;sqoop-node&quot;/&gt;    &lt;action name=&quot;sqoop-node&quot;&gt;        &lt;sqoop xmlns=&quot;uri:oozie:sqoop-action:0.3&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;prepare&gt;                &lt;delete path=&quot;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&quot;/&gt;            &lt;/prepare&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;command&gt;import --options-file sqoop-import.sql&lt;/command&gt;        &lt;/sqoop&gt;        &lt;ok to=&quot;end&quot;/&gt;        &lt;error to=&quot;fail&quot;/&gt;    &lt;/action&gt;    &lt;kill name=&quot;fail&quot;&gt;        &lt;message&gt;Sqoop failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>##注意事项</p><ul><li>workflow 版本0,5 sqoop action 版本0.3</li><li>使用的是新版本的API，但旧版本依旧支持使用(可以不用改)</li><li>上文command&gt;支持三种使用 sqoop 方式，下文会说明</li><li>特别重要的 command&gt; 只支持 “ ”</li></ul><p>###4.上传文件到HDFS文件系统<br>###5.执行程序</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job --config /opt/cdh5.3.6/oozie-4.1.0-cdh5.12.0/oozie-apps/sqoop-import/job.properties -run</code></pre><p>##注：三种命令方式<br>###1.直接执行 sqoop 命令</p><pre><code>&lt;command&gt;import --connect jdbc:mysql://cen-ubuntu:3306/mysql --username root --password ubuntu --table user --target-dir /user/cen/oozie-apps/sqoop-import/output --fields-terminated-by &quot;\t&quot; --num-mappers 1 --direct&lt;/command&gt;</code></pre><p>###2.从相对路径导入文件(文件在ＨＤＦＳ上的应用目录下)<a href="http://www.cnblogs.com/cenzhongman/p/7253157.html">涉及文件需要使用file，可参考 shell </a></p><pre><code>&lt;command&gt;import --options-file sqoop-import.sql&lt;/command&gt; # job.properties文件名EXEC=xxx.sql＃ workflow.xml&lt;!--Copy the executable to compute node&#39;s current working directory --&gt;&lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop-import/$&#123;EXEC&#125;#$&#123;EXEC&#125;&lt;/file&gt; </code></pre><p>###3.从绝对路径导入</p><pre><code># job.propertiessqoop-import=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop-import/sqoop-import＃ workflow.xml&lt;command&gt;import --options-file $&#123;sqoop-import&#125;&lt;/command&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie 安装及 examples app 的使用</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20%E5%AE%89%E8%A3%85%E5%8F%8A%20examples%20app%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20%E5%AE%89%E8%A3%85%E5%8F%8A%20examples%20app%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>##<a href="http://oozie.apache.org/docs/4.0.0/DG_QuickStart.html#Building_Oozie_">参考文档</a></p><h1 id="一、Building-OOzie"><a href="#一、Building-OOzie" class="headerlink" title="一、Building OOzie"></a>一、Building OOzie</h1><p>特别注意的是修改Pom.xml文件中的版本与本机中安装的版本相同</p><p>#二、 install Oozie<br>####1.为 hadoop 添加 Oozie 的代理用户，添加如下配置到 hadoop 的 core-site.xml 中(需Hadoop读取之后才会生效)</p><pre><code>&lt;!-- OOZIE 添加代理用户 --&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.cen.hosts&lt;/name&gt;    &lt;value&gt;cen-ubuntu&lt;/value&gt;&lt;/property&gt;&lt;!-- *表示所有用户组 --&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.cen.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;</code></pre><p>####2.解压hadooplibs(包含支持 Oozie 版本的 Hadoop 分布式支持–也就是支持 MapReduce job 的依赖包)</p><pre><code>$ tar -xzvf oozie-hadooplibs-4.0.0-cdh5.3.6.tar.gz </code></pre><p>####3.创建文件夹 libext</p><pre><code>$ mkdir libext</code></pre><p>####4.拷贝运行使用的 Hadoop jars 包(不带mr1的那一个，yarn 版本的)到 libext 目录下</p><pre><code>$ cp oozie-4.0.0-cdh5.3.6/hadooplibs/hadooplib-2.5.0-cdh5.3.6.oozie-4.0.0-cdh5.3.6/* libext/</code></pre><p>####5.拷贝 ExtJs2.2.zip 文件到 libext 目录</p><pre><code>$ cp ~/package/ExtJs2.2.SDK.zip libext/</code></pre><p>####6.创建 war 包包含的 jars (在解压目录的oozie-server下)</p><pre><code>$ bin/oozie-setup.sh prepare-war [-d directory] [-secure]                     sharelib create -fs &lt;FS_URI&gt; [-locallib &lt;PATH&gt;]                     sharelib upgrade -fs &lt;FS_URI&gt; [-locallib &lt;PATH&gt;]                     db create|upgrade|postupgrade -run [-sqlfile &lt;FILE&gt;]# 创建 war 包指定包含的 jars $ bin/oozie-setup.sh prepare-war# 上传 jar 包到 HDFS 文件系统(HDFS 要在运行)、指定本地要上传的支持包(选择YARN版本的)，创建数据库$ bin/oozie-setup.sh sharelib create -fs hdfs://cen-ubuntu:8020 -locallib oozie-sharelib-4.0.0-cdh5.3.6-yarn.tar.gz# 创建数据库$ bin/ooziedb.sh create -sqlfile oozie.sql -run DB Connection.</code></pre><p>####7.配置Oozie-site.xml文件中的HDFS信息</p><pre><code>&lt;property&gt;    &lt;name&gt;oozie.service.HadoopAccessorService.hadoop.configurations&lt;/name&gt;    &lt;value&gt;*=/opt/cdh5.3.6/hadoop-2.5.0-cdh5.3.6/etc/hadoop&lt;/value&gt;&lt;/property&gt;</code></pre><p>####8.启动 Oozie<br>    # 守护进程<br>    $ bin/oozied.sh start<br>    # 前台<br>    $ bin/oozied.sh run<br>    # 停止<br>    $ bin/oozied.sh stop</p><p>##注1：使用 MySQL 数据库步骤<br>####1.拷贝依赖包到 libext 目录<br>####2.编辑 Oozie-site.xml 文件(注意数据库名)</p><h1 id="三、运行-example-程序"><a href="#三、运行-example-程序" class="headerlink" title="三、运行 example 程序"></a>三、运行 example 程序</h1><p>####1.解压oozie-examples.tar.gz<br>####2.复制 example 到 HDFS 问价主目录下<br>####3.修改 URL 地址 apps/job.properties(入口配置文件：指向workflow.xml文件和输出目录)</p><p>###注意：( job.properties 必须在本地，workflow.xml 必须在 HDFS 上)</p><pre><code>nameNode=hdfs://cen-ubuntu:8020# 端口根据ResourceManage配置文件可知(默认8032)jobTracker=cen-ubuntu:8032examplesRoot=examplesoozie.wf.application.path=$&#123;nameNode&#125;/user/$&#123;user.name&#125;/$&#123;examplesRoot&#125;/apps/map-reduce/workflow.xmloutputDir=map-reduce</code></pre><p>####4.运行 example 的 map-reduce APP(其他使用请参考oozie help)</p><pre><code>$ bin/oozie job -oozie http://cen-ubuntu.cenzhongman.com:11000/oozie -config examples/apps/map-reduce/job.properties -run</code></pre><p>####5.查看状态信息</p><pre><code># 命令行$ oozie job -oozie  http://cen-ubuntu.cenzhongman.com:11000/oozie -info 14-20090525161321-oozie-tucu# Web 界面http://cen-ubuntu:11000/oozie/</code></pre><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724225022840-448771764.png"></p><p>##注：编辑Oozie 配置文件后重启 Tomcat 服务需要清除相关的编译文件</p><pre><code>    $ rm -r $OOZIE_HOME/oozie-server/work/Catalina    $ rm -r $OOZIE_HOME/oozie-server/conf/Catalina</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie 实战之 shell</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20%E5%AE%9E%E6%88%98%E4%B9%8B%20shell/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20%E5%AE%9E%E6%88%98%E4%B9%8B%20shell/</url>
    
    <content type="html"><![CDATA[<p>说明：使用 shell action 执行 shell 脚本 hive-select-test.sh 来通过已经配置好的 Hive -f 来执行 HQL 查询脚本文件 select.sql<br>###1.创建脚本文件 hive-select-test.sh</p><pre><code>#!/bin/sh/opt/cdh5.3.6/hive-1.1.0-cdh5.12.0/bin/hive -f select.sql</code></pre><p>###2.创建 HQL 文件 select.sql</p><pre><code>insert overwrite directory &#39;/user/cen/oozie-apps/shell-hive-select/output/&#39; select count(1)  cnt from default.test; </code></pre><p>###3.修改 job.properties 文件</p><pre><code>nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020jobTracker=localhost:8032queueName=defaultoozieAppsRoot=oozie-appsoozie.wf.application.path=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/shell-hive-select/EXEC=hive-select-test.shscript=select.sql</code></pre><p>###4.修改 workflow.xml 文件</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;shell-wf&quot;&gt;    &lt;start to=&quot;shell-node&quot;/&gt;    &lt;action name=&quot;shell-node&quot;&gt;        &lt;shell xmlns=&quot;uri:oozie:shell-action:0.2&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;exec&gt;$&#123;EXEC&#125;&lt;/exec&gt;            &lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/shell-hive-select/$&#123;EXEC&#125;#$&#123;EXEC&#125;&lt;/file&gt;            &lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/shell-hive-select/$&#123;script&#125;#$&#123;script&#125;&lt;/file&gt;        &lt;/shell&gt;        &lt;ok to=&quot;end&quot;/&gt;        &lt;error to=&quot;fail&quot;/&gt;    &lt;/action&gt;    &lt;kill name=&quot;fail&quot;&gt;        &lt;message&gt;Shell action failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>##注意事项</p><ul><li>workflow 版本0,5 sqoop action 版本0.2</li><li>使用的是新版本的API，但旧版本依旧支持使用(可以不用改)</li><li>关于file作用和配置，下文会说明</li></ul><p>###5.上传文件到HDFS文件系统<br>###6.执行程序</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job --config oozie-apps/shell-hive-select/job.properties -run</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie 实战之 Hive</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20%E5%AE%9E%E6%88%98%E4%B9%8B%20Hive/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20%E5%AE%9E%E6%88%98%E4%B9%8B%20Hive/</url>
    
    <content type="html"><![CDATA[<p>###1.编辑job.propertiers</p><p>  nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020<br>  jobTracker=localhost:8032<br>  queueName=default<br>  oozieAppsRoot=oozie-apps</p><p>  oozie.use.system.libpath=true</p><p>  oozie.wf.application.path=${nameNode}/user/cen/${oozieAppsRoot}/hive-select/<br>  outputDir=hive-select/output</p><p>###2.添加lib文件夹<br>###3.复制MySQL的API到lib下<br>###4.复制hive-site.xml文件到目录下<br>###5.编辑workflow</p>  <workflow-app xmlns="uri:oozie:workflow:0.5" name="hive-select-wf">      <start to="hive-node"/><pre><code>  &lt;action name=&quot;hive-node&quot;&gt;      &lt;hive xmlns=&quot;uri:oozie:hive-action:0.5&quot;&gt;          &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;          &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;          &lt;prepare&gt;              &lt;delete path=&quot;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&quot;/&gt;          &lt;/prepare&gt;          &lt;job-xml&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/hive-select/hive-site&lt;/job-xml&gt;          &lt;configuration&gt;              &lt;property&gt;                  &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                  &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;              &lt;/property&gt;          &lt;/configuration&gt;          &lt;script&gt;select.sql&lt;/script&gt;          &lt;param&gt;OUTPUT=/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&lt;/param&gt;      &lt;/hive&gt;      &lt;ok to=&quot;end&quot;/&gt;      &lt;error to=&quot;fail&quot;/&gt;  &lt;/action&gt;  &lt;kill name=&quot;fail&quot;&gt;      &lt;message&gt;Hive failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;  &lt;/kill&gt;  &lt;end name=&quot;end&quot;/&gt;</code></pre>  </workflow-app><p>##注意事项(对比example文件)</p><ul><li>更新版本两个</li><li>无需使用新api</li><li>添加<job-xml>${nameNode}/user/cen/${oozieAppsRoot}/hive-select/hive-site</job-xml>用以说明配置文件位置</li><li>添加<script>select.sql</script>指明SQL文件</li><li>添加<param>OUTPUT=/user/cen/${oozieAppsRoot}/${outputDir}</param>说明输出目录[可选]</li></ul><p>###6.上传文件<br>###7.执行文件</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job -config oozie-apps/hive-select/job.properties -run</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie 配合 sqoop hive 实现数据分析输出到 mysql</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%20%E9%85%8D%E5%90%88%20sqoop%20hive%20%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%BE%93%E5%87%BA%E5%88%B0%20mysql/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%20%E9%85%8D%E5%90%88%20sqoop%20hive%20%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%BE%93%E5%87%BA%E5%88%B0%20mysql/</url>
    
    <content type="html"><![CDATA[<p>####文件/RDBMS -&gt; flume/sqoop -&gt; HDFS -&gt; Hive -&gt; HDFS -&gt; Sqoop -&gt; RDBMS<br>其中，本文实现了</p><ul><li>使用 sqoop 从 RDBMS 中读取数据(非Oozie实现，具体错误将在本文最后说明)</li><li>从 Hive 处理数据存储到 HDFS</li><li>使用 sqoop 将 HDFS 存储到 RDBMS 中\</li></ul><p>###1.复制一个 sqoop example，拷贝 hive-site.xml 文件，拷贝 mysql 依赖包到 lib 目录下<br>###2.增加 sqoop-import.sql 文件用以从 RDBMS 读取数据到 Hive 中</p><pre><code>--connectjdbc:mysql://cen-ubuntu:3306/test--usernameroot--passwordubuntu--tableuser--hive-databasedefault--hive-tableimport_from_mysql--hive-import--hive-overwrite--delete-target-dir</code></pre><p>###3.增加 select.sql 用于使用 Hive 处理数据导出到 HDFS 中(注意说明输出分隔符)</p><pre><code>insert overwrite directory &#39;/user/cen/oozie-apps/sqoop2hive2sqoop/output/&#39; ROW format delimited fields terminated by &#39;,&#39; select id,name from default.import_from_mysql;</code></pre><p>###4.增加 sqoop-export.sql 用于使用 sqoop 将 HDFS 文件导入到 RDBMS 中</p><pre><code>--connectjdbc:mysql://cen-ubuntu:3306/test--usernameroot--passwordubuntu--tableexport_from_hdfs--export-dir/user/cen/oozie-apps/sqoop2hive2sqoop/output/--fields-terminated-by&#39;,&#39;</code></pre><p>###5.修改 job.properties 文件</p><pre><code>nameNode=hdfs://cen-ubuntu.cenzhongman.com:8020jobTracker=localhost:8032queueName=defaultoozieAppsRoot=oozie-appsoozie.use.system.libpath=trueoozie.wf.application.path=$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/outputDir=sqoop2hive2sqoop/output</code></pre><p>###6.修改 workflow.xml 文件</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;sqoop2hive2sqoop-wf&quot;&gt;    &lt;start to=&quot;hive-node&quot;/&gt;    &lt;action name=&quot;hive-node&quot;&gt;        &lt;hive xmlns=&quot;uri:oozie:hive-action:0.5&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;prepare&gt;                &lt;delete path=&quot;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&quot;/&gt;            &lt;/prepare&gt;            &lt;job-xml&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/hive-site.xml&lt;/job-xml&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;script&gt;select.sql&lt;/script&gt;        &lt;/hive&gt;        &lt;ok to=&quot;sqoop-export-node&quot;/&gt;        &lt;error to=&quot;hive-fail&quot;/&gt;    &lt;/action&gt;    &lt;action name=&quot;sqoop-export-node&quot;&gt;        &lt;sqoop xmlns=&quot;uri:oozie:sqoop-action:0.3&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;command&gt;export --options-file sqoop-export.sql&lt;/command&gt;            &lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/sqoop-export.sql#sqoop-export.sql&lt;/file&gt;        &lt;/sqoop&gt;        &lt;ok to=&quot;end&quot;/&gt;        &lt;error to=&quot;sqoop-export-fail&quot;/&gt;    &lt;/action&gt;    &lt;kill name=&quot;hive-fail&quot;&gt;        &lt;message&gt;hive failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;kill name=&quot;sqoop-export-fail&quot;&gt;        &lt;message&gt;Sqoop export failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>##注意事项</p><ul><li>各个 action 节点的版本号</li><li>用到文件拷贝，请使用 file 属性</li><li>Hive 的配置文件不能忘记</li></ul><p>###7.上传文件到 HDFS 上<br>###8.执行 sqoop 从 MySQL 中读取数据到 Hive 中(此处出现错误 could not load org.apache.hadoop.hive.conf.HiveConf.Make sure HIVE_CONF_DIR is set corretly.原因及解决请看 注2 )</p><pre><code>bin/sqoop import --options-file /opt/cdh5.3.6/oozie-4.1.0-cdh5.12.0/oozie-apps/sqoop2hive2sqoop/sqoop-import.sql</code></pre><p>###9.检查 Hive 中是否已经存在数据，并执行 Oozie</p><pre><code>export OOZIE_URL=http://cen-ubuntu:11000/oozie/bin/oozie job --config /opt/cdh5.3.6/oozie-4.1.0-cdh5.12.0/oozie-apps/sqoop2hive2sqoop/job.properties -run</code></pre><p>###10.检查程序执行 Wordflow 和 MySQL 中的输出结果</p><p><img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170730095501334-2141405890.png"></p><p>##注1：使用 Oozie 通过 sqoop import to hive 执行失败(同样的程序，本地执行成功)，但日志无输出，此处贴出完整 wordflow.xml 文件仅供参考</p><pre><code>&lt;workflow-app xmlns=&quot;uri:oozie:workflow:0.5&quot; name=&quot;sqoop2hive2sqoop-wf&quot;&gt;    &lt;start to=&quot;sqoop-import-node&quot;/&gt;    &lt;action name=&quot;sqoop-import-node&quot;&gt;        &lt;sqoop xmlns=&quot;uri:oozie:sqoop-action:0.3&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;command&gt;import --options-file sqoop-import.sql&lt;/command&gt;            &lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/sqoop-import.sql#sqoop-import.sql&lt;/file&gt;        &lt;/sqoop&gt;        &lt;ok to=&quot;hive-node&quot;/&gt;        &lt;error to=&quot;sqoop-import-fail&quot;/&gt;    &lt;/action&gt;    &lt;action name=&quot;hive-node&quot;&gt;        &lt;hive xmlns=&quot;uri:oozie:hive-action:0.5&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;prepare&gt;                &lt;delete path=&quot;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/$&#123;outputDir&#125;&quot;/&gt;            &lt;/prepare&gt;            &lt;job-xml&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/hive-site.xml&lt;/job-xml&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;script&gt;select.sql&lt;/script&gt;        &lt;/hive&gt;        &lt;ok to=&quot;sqoop-export-node&quot;/&gt;        &lt;error to=&quot;hive-fail&quot;/&gt;    &lt;/action&gt;    &lt;action name=&quot;sqoop-export-node&quot;&gt;        &lt;sqoop xmlns=&quot;uri:oozie:sqoop-action:0.3&quot;&gt;            &lt;job-tracker&gt;$&#123;jobTracker&#125;&lt;/job-tracker&gt;            &lt;name-node&gt;$&#123;nameNode&#125;&lt;/name-node&gt;            &lt;configuration&gt;                &lt;property&gt;                    &lt;name&gt;mapred.job.queue.name&lt;/name&gt;                    &lt;value&gt;$&#123;queueName&#125;&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            &lt;command&gt;export --options-file sqoop-export.sql&lt;/command&gt;            &lt;file&gt;$&#123;nameNode&#125;/user/cen/$&#123;oozieAppsRoot&#125;/sqoop2hive2sqoop/sqoop-export.sql#sqoop-export.sql&lt;/file&gt;        &lt;/sqoop&gt;        &lt;ok to=&quot;end&quot;/&gt;        &lt;error to=&quot;sqoop-export-fail&quot;/&gt;    &lt;/action&gt;    &lt;kill name=&quot;sqoop-import-fail&quot;&gt;        &lt;message&gt;Sqoop import failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;kill name=&quot;hive-fail&quot;&gt;        &lt;message&gt;hive failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;kill name=&quot;sqoop-export-fail&quot;&gt;        &lt;message&gt;Sqoop export failed, error message[$&#123;wf:errorMessage(wf:lastErrorNode())&#125;]&lt;/message&gt;    &lt;/kill&gt;    &lt;end name=&quot;end&quot;/&gt;&lt;/workflow-app&gt;</code></pre><p>原因剖析：错误出现在 sqoop-import-node</p><ul><li>找不到 hive 配置文件，尝试 (1):如 hive-node 一样增加说明 –&gt; 无效  尝试(2):在 sqoop-import.sql 中增加 –hive-home /opt/xxx/xxx/xxx   –&gt;  无效   尝试(3):修改conf/cation-conf/hive.xml   –&gt;   并未配置</li><li>无法从本地的 sqoop 执行 Hive ？ ? 有机会再探索</li></ul><p>##注2：执行 sqoop 过程出现错误could not load org.apache.hadoop.hive.conf.HiveConf.Make sure HIVE_CONF_DIR is set corretly.</p><ul><li><p>原因：系统使用了变量$HADOOP_CLASSPATH 但本机未定义</p></li><li><p>解决：增加用户环境变量~/.bash_profile</p><p>  export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:/opt/cdh5.3.6/hive-1.1.0-cdh5.12.0/lib/*</p></li></ul><p><a href="http://m.blog.csdn.net/lichangzai/article/details/51604848?yyue=a21bo.50862.201879">详情请参考</a></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie是什么</title>
    <link href="/07-Bigdata/02-Oozie/Oozie%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/02-Oozie/Oozie%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>#Apache Oozie Workflow Scheduler for Hadoop<br>Oozie is a workflow scheduler system to manage Apache Hadoop jobs.<br>Oozie 是一个工作流调度系统用来管理 Hadoop 任务<br>工作流调度：工作流程的编排，调度：安排事件的触发执行(时间触发,事件触发)</p><p>Oozie is integrated with the rest of the Hadoop stack supporting several types of Hadoop jobs out of the box (such as Java map-reduce, Streaming map-reduce, Pig, Hive, Sqoop and Distcp) as well as system specific jobs (such as Java programs and shell scripts).<br>Oozip 集成了 Hadoop 其他的几种协议(如 MapReduce Pig Hive Sqoop Distcp)和系统专有的任务(如 java程序 shell脚本)</p><p>底层是一个仅有 Map Task 的 MapReduce 程序</p><p>##一、横向比较<br>###1.Linux Crontab Linux自带的定时任务指令(写绝对路径)<br>特点：简单，结合 shell 脚本能实现大部分的功能<br>缺点：太简单了，没有监控界面<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724165618231-1311108151.png"></p><pre><code>crontab: usage error: unrecognized optionusage:  crontab [-u user] file                                 指向文件        crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;                (default operation is replace, per 1003.2)        -e      (edit user&#39;s crontab)                        指定编辑器        -l      (list user&#39;s crontab)                        列表        -r      (delete user&#39;s crontab)                        删除        -i      (prompt before deleting user&#39;s crontab)        删除前提示minute    hour    day        month    week    command0-60    0-24    0-31    1-12    0-7( 0=7=周日 )        ( * ):所有可能的值( , ):并列( - ):范围( / ):频率eg:# 每周六晚上8点-12点每30分钟加早上10点执行一次0-60/30 20-7,8 * * 6 /bin/ls</code></pre><p>###2.AzKaban Linkedin 公司一个开源的工作流管理程序<br>特点：简单得一塌糊涂，又漂亮的不像实力派<br>缺点：…<br><img src="https://azkaban.github.io/img/logo.png"><br><a href="https://azkaban.github.io/">Azkaban</a></p><p>###3.Oozie Apache 顶级项目<br>特点：Apache 出品，强大<br>缺点：存在 jar 包冲突，长得不是一般的丑(程序员就不该有审美)<br><img src="http://oozie.apache.org/images/oozie_200x.png"><br><a href="http://oozie.apache.org/">Oozie</a></p><p>###4.Zeus 宙斯 阿里开源的框架(找不到了，阿里遗弃了？)<br>特点：比较简单，阿里出品，有中文文档，中文界面<br>缺点：小众，毕竟国内</p><p>#关于Oozie(拷贝模板改之)<br>1.Oozie是 <strong>Cloudeara</strong> 公司共享给 Apache 的一个开源顶级项目，提供对 Hadoop MapReduce Hive Pig 的任务的调度；Oozie需要部署到一个 <strong>Java Servlet</strong> 容器中(如：Tomcat)运行，需要使用关系型数据库存储调度信息<br>2.Oozie 工作流的定义，同 Jboss jBPM 提供的 jPDL 一样，提供了类似流程定义语言 hPDL ,通过 <strong>XML</strong>  格式实现流程定义。对于工作流系统，一般都会有很多不同的功能节点，如分支、并发、汇合等<br>3.Ooize 定义了<strong>控制流节点 Control Flow Nodes **和</strong>动作节点 Action Nodes **。其中控制流节点定义了流程的开始和结束，以及控制流程的执行路径( Execution Path ) ,如 decision / fork / join 等；而动作节点包括 Hadoop MapReduce / HDFS / Pig / SSH / HTTP / eMail / Oozie 子流程等。</p><p>#关于各个版本的架构(重点)<br>Oozie v1 is a server based <strong>Workflow</strong> Engine <strong>工作流引擎</strong> specialized专门 in running workflow jobs with actions that execute Hadoop Map/Reduce and Pig jobs.<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724165628090-1042702146.png"></p><p>Oozie v2 is a server based <strong>Coordinator</strong> Engine <strong>协调引擎</strong> specialized in running workflows based on time and data triggers(时间触发 数据触发). It can continuously不断地 run workflows based on time (e.g. run it every hour), and data availability (e.g. wait for my input data to exist before running my workflow).<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724165633356-479401892.png"></p><p>Oozie v3 is a server based <strong>Bundle</strong> Engine <strong>绑定引擎</strong> that provides a higher-level oozie abstraction抽象 that will batch批量 a set of coordinator applications. The user will be able to start/stop/suspend暂停/resume继续/rerun a set coordinator jobs in the <strong>bundle level</strong>(捆绑包层次) resulting a better and easy operational control.<br>v3提供了一个更高级别的抽象Oozie,将批处理一组协调应用程序。<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724165641856-806068542.png"></p><p>###整体服务框架<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170724171008809-1261995813.png"></p><ul><li>左侧：Oozie 通过 Tomcat Http Server 对外提供了 JAVA API 、REST API 、CLI(终端) 、Web 接口（hue） ；产生的数据存储在 Oozie object dstabase 上</li><li>中间：Oozie 的三层结构</li><li>右侧：Oozie 的 <strong>Coordinator</strong> Engine <strong>协调引擎</strong> 能够监控基于 Time-based triggers 和 HDFS 上的 Data-based triggers；每一个 Oozie Job 都是一个只有 Map Task 的 MapReduce 程序</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>02-Oozie</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01RestAPI</title>
    <link href="/07-Bigdata/03-Hbase/01RestAPI/"/>
    <url>/07-Bigdata/03-Hbase/01RestAPI/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/supperman_009/article/details/64440290">中文</a><br>centos5.insight.com:20550&gt;114.67.37.235:8025</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase java API 的使用范例(增,删,查,扫描)</title>
    <link href="/07-Bigdata/03-Hbase/HBase%20java%20API%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B(%E5%A2%9E,%E5%88%A0,%E6%9F%A5,%E6%89%AB%E6%8F%8F)/"/>
    <url>/07-Bigdata/03-Hbase/HBase%20java%20API%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B(%E5%A2%9E,%E5%88%A0,%E6%9F%A5,%E6%89%AB%E6%8F%8F)/</url>
    
    <content type="html"><![CDATA[<p>编辑pom.xml</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;  &lt;artifactId&gt;hbase-server&lt;/artifactId&gt;  &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;  &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;  &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>java文件</p><pre><code>package com.cenzhongman.hbase;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.Cell;import org.apache.hadoop.hbase.CellUtil;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.client.Delete;import org.apache.hadoop.hbase.client.Get;import org.apache.hadoop.hbase.client.HTable;import org.apache.hadoop.hbase.client.Put;import org.apache.hadoop.hbase.client.Result;import org.apache.hadoop.hbase.client.ResultScanner;import org.apache.hadoop.hbase.client.Scan;import org.apache.hadoop.hbase.util.Bytes;import org.apache.hadoop.io.IOUtils;/** *  * 演示 HBase 的 JDBC 连接及 CRUD 操作 *  * @author cen * */public class HBaseOperation &#123;    static HTable table = null;    static String TABLE_NAME = &quot;user&quot;;    /**     * getHTablebyTbaleName     *      * @param tableName     * @return     */    @SuppressWarnings(&quot;deprecation&quot;)    public static HTable getHTable() &#123;        // 1.get instance of Default Configuration 读取 core-site.xml hdfs-site.xml 信息        // Configuration conf = new Configuration();//HDFS中获取core-site.xml hdfs-site.xml        // 的方法        // conf.addResource(&quot;hbase-default.xml&quot;);        // conf.addResource(&quot;hbase-site.xml&quot;);        // Hbase封装的获取方法(详见源码),增加了读取HBase 的配置文件        Configuration conf = HBaseConfiguration.create();        // 2.get Table instance        try &#123;            table = new HTable(conf, TABLE_NAME);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return table;    &#125;    /**     * getData by table,rowKey,columns[&#123;cfs&#125;][columns]     *      * @param table     * @param rowKey     * @param columns     */    public static void getData(String rowKey, String[][] columns) &#123;        try &#123;            table = getHTable();            // create get with RowKey 选定Get的RowKey            Get get = new Get(Bytes.toBytes(rowKey));            if (columns != null) &#123;                // add column 增加列查询条件                for (int i = 0; i &lt; columns[0].length; i++) &#123;                    for (int j = 0; j &lt; columns[1].length; j++) &#123;                        get.addColumn(Bytes.toBytes(columns[0][i]), Bytes.toBytes(columns[1][j]));                    &#125;                &#125;            &#125;            // get Result            Result result = null;            result = table.get(get);            // Key:rowKwy + cf + c + version + type +            // value:value            for (Cell cell : result.rawCells()) &#123;                System.out.println(                        Bytes.toString(CellUtil.cloneFamily(cell)) + &quot;:&quot; + Bytes.toString(CellUtil.cloneQualifier(cell))                                + &quot;-&gt;&quot; + Bytes.toString(CellUtil.cloneValue(cell)));            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            IOUtils.closeStream(table);        &#125;    &#125;    public static void getData(String rowKey) &#123;        getData(rowKey, null);    &#125;    /**     * putData to HBase by table,rowKey,column,value 通常一张表的表名和列簇都设置常量 使用Map比数组更简单     *      * @param table     * @param rowKey     * @param column     * @param value     */    @SuppressWarnings(&quot;deprecation&quot;)    public static void putData(String rowKey, String cf, String column, String value) &#123;        try &#123;            table = getHTable();            // create put with rowKey            Put put = new Put(Bytes.toBytes(rowKey));            // 增加列数据            put.add(Bytes.toBytes(cf), Bytes.toBytes(column), Bytes.toBytes(value));            // put The data to put.            // 实际使用list&lt;Puts&gt;            table.put(put);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            IOUtils.closeStream(table);        &#125;    &#125;    /**     * 删除一张表中的数据     *      * @param table     * @param rowKey     * @param cf     * @param column     */    public static void deleteData(String rowKey, String cf, String column) &#123;        // create Delete        try &#123;            table = getHTable();            Delete delete = new Delete(Bytes.toBytes(rowKey));            // 需要 delete 的 data            // delete.addColumn(Bytes.toBytes(cf), Bytes.toBytes(column));//删除最新的版本            delete.addColumns(Bytes.toBytes(cf), Bytes.toBytes(column));// 删除所有的版本            table.delete(delete);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            IOUtils.closeStream(table);        &#125;    &#125;    /**     * scan data from HBase 包头不包尾     */    public static void scanData() &#123;        scanData(null, null, null, null);    &#125;    public static void scanData(String startRow) &#123;        scanData(startRow, null, null, null);    &#125;    public static void scanData(String startRow, String stopRow) &#123;        scanData(startRow, stopRow, null, null);    &#125;    public static void scanData(String startRow, String stopRow, String family, String qualifier) &#123;        ResultScanner resultScanner = null;        try &#123;            Scan scan = new Scan();            //三种方式            //1.范围扫描可用构造函数来设置//            Scan scan2 = new Scan(startRow, stopRow)            //2.设置起始范围            if (startRow != null) &#123;                scan.setStartRow(Bytes.toBytes(startRow));            &#125;            if (stopRow != null) &#123;                scan.setStopRow(Bytes.toBytes(stopRow));            &#125;            // 列过滤条件            if (family != null) &#123;                if (qualifier != null) &#123;                    scan.addFamily(Bytes.toBytes(family));                &#125;                scan.addColumn(Bytes.toBytes(family), Bytes.toBytes(qualifier));            &#125;            //3.使用过滤器            /*             * 使用Filter查询速度会下降             * PrefixFilter : 前缀过滤             * PageFilter : 分页过滤             *///            scan.setFilter(filter);            //设置缓存//            scan.setCacheBlocks(cacheBlocks);//把常用的数据缓存到 RegionServer 的 BlocksCache 中//            scan.setCaching(caching);//每一次扫描时获取列的数目            table = getHTable();            resultScanner = table.getScanner(scan);            for (Result result : resultScanner) &#123;                System.out.println(&quot;Row:&quot; + Bytes.toString(result.getRow()));                for (Cell cell : result.rawCells()) &#123;                    System.out.println(Bytes.toString(CellUtil.cloneFamily(cell)) + &quot;:&quot;                            + Bytes.toString(CellUtil.cloneQualifier(cell)) + &quot;-&gt;&quot;                            + Bytes.toString(CellUtil.cloneValue(cell)));                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            IOUtils.closeStream(resultScanner);            IOUtils.closeStream(table);        &#125;    &#125;    public static void main(String[] args) &#123;        String rowKey = &quot;00002&quot;;        String cf = &quot;info&quot;;        String column = &quot;name&quot;;        String value = &quot;gugjhg&quot;;        putData(rowKey, cf, column, value);        // deleteData(rowKey, cf, column);        // String[][] columns = &#123; &#123; &quot;info&quot; &#125;, &#123; &quot;name&quot; ,&quot;tel&quot;&#125; &#125;;        // getData(rowKey);        scanData();        System.out.println(&quot;finish&quot;);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase 是什么</title>
    <link href="/07-Bigdata/03-Hbase/HBase%20%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/03-Hbase/HBase%20%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p><img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170731161514130-704455035.png"></p><p>####Apache HBase™ is the Hadoop database, a distributed, scalable, big data store.<br>####HBase 是 Hadoop database 一个分布式(文件在HDFS上)的可拓展(分区域存储的)的大数据仓库。用于存储和检索海量数据<br>Use Apache HBase™ when you need random随机, realtime实时 read/write access存取 to your Big Data. This project’s goal is the hosting of very large tables – billions数十亿 of rows X millions百万 of columns – atop clusters of commodity hardware商用机器. Apache HBase is an open-source, distributed, versioned多版本(数据可以有多个版本的值), non-relational database modeled after Google’s Bigtable: A Distributed Storage System for Structured Data by Chang et al. Just as Bigtable leverages the distributed data storage provided by the Google File System, Apache HBase provides Bigtable-like capabilities on top of Hadoop and HDFS.<br>####与传统 RDBMS 数据库，HBase 対与海量数据查询检索速度有明显速度上的优势</p><p>#Table in HBase</p><ul><li>Schema：TableName &amp; Column Family Name<br>意味着 HBase 每一行的列不一定相同，不占据空间(RDBMS为NULL也占据空间)</li><li>Value 和 Name 都是使用 byte[] 数组存储在 HDFS 中 </li></ul><p>##HBase 是一个面向列的数据库，数据按列存储<br>####一个数据单元 Cell 包括了：rowkey + columnfamily + [column] + timestamp : value</p><ul><li>columnfamily(列簇)：字段的类别 eg: basic 包括了(name,age,birthday…)</li><li>rowkey(行关键字)：类似RDBMS中的主键，作为行的唯一标识符，每个 cell 都，快速查询的关键有 eg:ID</li></ul><p>##Example<br><img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170731172407583-2094789264.png"><br><img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170731172419911-340741011.png"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase 高级架构解析</title>
    <link href="/07-Bigdata/03-Hbase/HBase%20%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <url>/07-Bigdata/03-Hbase/HBase%20%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>##整体框架<br> <img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170731171913411-564113471.png"><br>使用 ZooKeeper 框架协助 RegionServer（类似于HDFS的nodemanager）用户请求从 Client 到 Zookeeper 进行判断数据属于哪一个 Region 辅助 HBase 进行数据存储/检索<br>主节点 Master (类似HDFS的ResourceManager) 管理 RegionServer ，数据不经过 Master</p><p>#物理模型<br><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170801174724661-937485112.png"></p><ul><li>Table中多有行按照RowKey字典顺序排列</li><li>Table在行的方向上分割为多个Region</li></ul><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170801174727302-480533853.png"></p><ul><li>随着Region大小的增大，达到一定阈值的时候，会分裂成两个新的Region</li><li>Table在行的方向上分割为多个Region</li></ul><p>##数据写入流程：put</p><ul><li>Wal(Write Ahead Log) 预写日志(HLog)文件(HDFS/Hbase/目录下):这个是修改日志，不是整个文件？就像git一样？</li><li>memStore</li><li>storeFile </li></ul><p>#完整架构图HBase Architecture<br><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170802012833458-172919843.jpg"></p><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p><strong>客户端  -&gt;  Zookeeper -&gt;  得到　hbase:meta 表的 RegionServer -&gt;  客户端从 meta 表中查得用户所需表的 RegionServer  -&gt; put/get/scan …</strong><br>###1.nameSpace：类似于 RDBMS 中 Database 概念，用户创建的表在 default namespace 下 ，系统自带表在 hbase namespace 下</p><p>#####hbase:meta 表存储了 HBase 中所有(自己除外)表的元数据信息<br>#####hbase:namespace 表存储了 namespace　信息</p><pre><code># 显示所有 namespace&gt; list_namespace# 显示 namespace 下的表&gt; list_namespace_tables &#39;hbase&#39;# 使用 hbase namespace 下的表 hbase:meta&gt; scan &#39;hbase:meta&#39;</code></pre><p>###2.表数据存储位置：hdfs://HBase/data/</p><p>#####HFile:HBase中KeyValue数据的存储格式，是 Hadoop 的二进制文件格式，是 StoreFile 的轻量级包装<br>#####HLog File:(Write Ahead Log) 预写日志(HLog)文件，在物理上是 Hadoop 的 Sequence File</p><p>###3.预写日志文件目录：hdfs://HBase/wals/<br>###4.Zookeeper 作用：用户申请数据首先经过 Zookeeper,Zokkeeper 中存储了 mate 所在的 Region 被哪一个 RegionServer 管理的信息。Hmaster 管理 RegionServer 的信息存储在 Zookeeper 中</p><pre><code># 查看mate-server(bin/zkCli.sh)$ get /hbase/meta-region-server# 查看 RegionServer 信息(分文件夹存储)$ ls /hbase/rs</code></pre><p>#人工干预数据的读写</p><pre><code># 从 memStore 到 Hfile$ flush &#39;tablename&#39;# 合并小文件$ compact &#39;tablename&#39;</code></pre><p>#各个组件的功能和作用(参考JAVA API 导包)<br>##Client</p><ul><li>整个集群的访问入口</li><li>使用 HBase RPC（Remote Procedure Call Protocol）——远程过程调用协议 与 HMAster 和 HRegionServer 进行通信</li><li>与 HMAster 进行通信,进行管理类操作(创建表,删除表…)</li><li>与 HRegionServer 进行数据读写类操作(put get …)</li><li>包含访问 HBase 的接口,并维护 cache(缓存) 来加快对 HBase 的访问</li></ul><p>##Zookeeper</p><ul><li>通过 Zookeeper 协作,允许开启/存在多个 HMaster 但 Zookeeper 通过 Master Election 保证了任何时候,集群中只有一个 HMaster </li><li>保存了所有的 HRegion 的寻址入口(Client 访问 Zookeeper 找到 Region 的信息)</li><li>实时监控 HRegionServer 的上线和下线信息,并通知给 HMaster </li><li>存储了 HBase 的所有表信息的元数据信息 namespace 的信息</li><li>存储了 meta 表和 HMaster 的地址</li></ul><p>##HMaster</p><ul><li>HMaster 不存在单点问题,HBase 中可以启动多个 HMaster (详情请看bin/master-backup.sh)通过 Zookeeper 通过 Master Election 保证了任何时候,集群中只有一个 HMaster 在运行,负责 Table 和 Region 的管理工作</li><li>管理用户对 Table 的增删改查操作</li><li>管理 HRegionServer 的负载平衡,调整 Region 分布</li><li>Region Split 后,负责新 Region 的分布</li><li>在 HRegionServer 停机后,负责失效 HRegionServer 的 Region 转移工作 </li></ul><p>##HRegionServer</p><ul><li>维护 HRegion 处理 HRegion 的 IO 请求,向 HDFS 文件系统中读写数据</li><li>负责 Region Split ,之后再交给 HMaster 调整 Region 分布</li><li>负责数据的访问过程,数据不经过 HMater ,HMaster 仅仅维护 Table 和 Region 的元数据信息,负载很低&lt;&lt;寻址访问 Zookeeper 和 HRegionServer ,数据访问 HRegionServer &gt;&gt;(重点)</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase与MapReduce集成</title>
    <link href="/07-Bigdata/03-Hbase/HBase%E4%B8%8EMapReduce%E9%9B%86%E6%88%90/"/>
    <url>/07-Bigdata/03-Hbase/HBase%E4%B8%8EMapReduce%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>即HBase作为MapReduce的数据来源，MapReduce 分析，输出数据存储在HBase表中</p><h1 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h1><p><a href="http://archive.cloudera.com/cdh5/cdh/5/hbase-1.2.0-cdh5.12.0/book.html#hbase.mapreduce.classpath">HBase, MapReduce, and the CLASSPATH</a><br>By default, MapReduce jobs deployed to a MapReduce cluster do not have access to either the HBase configuration under $HBASE_CONF_DIR or the HBase classes.<br>官网bb了很多，意思是说，mapReduce 默认是没有添加HBase的依赖包的，你可以通过添加HBase-site这个配置文件到hadoop配置目录下，但是这样要复制到整个集群；或者你可以编辑Hadoop的CLASSPATH，但这样又会使得你的Hadoop环境受到污染。而且需要重启Hadoop集群才能生效。<br>因此，最好的方法是让HBase自己添加自己的依赖包到Hadoop的CLASSPATH，然后再使用程序。</p><p>####1.输出MapReduce与HBase集成时候需要的HBase依赖包</p><pre><code>bin/hbase mapredcp</code></pre><p>####2.于是我们可以，通过以下方法执行程序</p><pre><code>#先将HBase的依赖包告诉世界 (空格) 然后执行mapreduce程序$ HADOOP_CLASSPATH=`$HBASE_HOME/bin/hbase mapredcp` $HADOOP_HOME/bin/hadoop jar $HBASE_HOME/lib/hbase-server-1.2.0-cdh5.12.0.jar</code></pre><p>#工具包hbase-server-VERSION.jar含了以下几个功能（超级有用）</p><pre><code># 统计Cell数目CellCounter: Count cells in HBase table.# WALPlayer: Replay WAL files.# ******大量的数据加载******重中之重，把TSV、CSV格式的文件通过 MapReduce 直接存储成 hfile(以块存储的HBase文件) 然后加载（移动）到表中去，不走正常的路径一条条插入completebulkload: Complete a bulk data load.# 从一个集群拷贝到另一个集群copytable: Export a table from local cluster to peer cluster.# 导入导出数据从HBase &gt;    HDFS export: Write table data to HDFS.exportsnapshot: Export the specific snapshot to a given FileSystem.import: Import data written by Export.# TSV table分隔 CSV 使用逗号分隔importtsv: Import data in TSV format.# 统计行数rowcounter: Count rows in HBase table.verifyrep: Compare the data from tables in two different clusters.</code></pre><h1 id="MapReduce读写HBase范例程序编写-参考官网"><a href="#MapReduce读写HBase范例程序编写-参考官网" class="headerlink" title="MapReduce读写HBase范例程序编写(参考官网)"></a>MapReduce读写HBase范例程序编写(参考官网)</h1><pre><code>package com.gci.hadoop.hbase;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.conf.Configured;import org.apache.hadoop.hbase.Cell;import org.apache.hadoop.hbase.CellUtil;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.client.Mutation;import org.apache.hadoop.hbase.client.Put;import org.apache.hadoop.hbase.client.Result;import org.apache.hadoop.hbase.client.Scan;import org.apache.hadoop.hbase.io.ImmutableBytesWritable;import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;import org.apache.hadoop.hbase.mapreduce.TableMapper;import org.apache.hadoop.hbase.mapreduce.TableReducer;import org.apache.hadoop.hbase.util.Bytes;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.util.Tool;import org.apache.hadoop.util.ToolRunner;/** * 需求分析，从数据表user读取info:name到新表basic:info:name */// extends Configured implements Tool 实现Tool接口的run方法，真正的入口的方法public class Table_user2basic extends Configured implements Tool &#123;    public static final String sourceTable = &quot;user&quot;;    public static final String targetTable = &quot;basic&quot;;    // 一.Mapper class extends TableMapper&lt;KEYOUT输出的Key的类型, VALUEOUT输出的Value的类型&gt;    // 原版的Mapper程序是有输入的KV类型，和输出的KV类型四个参数，源码：extends Mapper&lt;ImmutableBytesWritable,    // Result, KEYOUT, VALUEOUT&gt;    // Put类型为hbase中定义的类型，便于作为Reducer的输入类型,根据reducer输入类型可知    public static class ReadUserMapper extends TableMapper&lt;Text, Put&gt; &#123;        private Text mapOutputKey = new Text();        @Override        public void map(ImmutableBytesWritable key, Result value,                Mapper&lt;ImmutableBytesWritable, Result, Text, Put&gt;.Context context)                throws IOException, InterruptedException &#123;            // get rowKey            String rowKey = Bytes.toString(key.get());            // set outputRowKey            mapOutputKey.set(rowKey);            // 通过rowKey创建put对象            Put put = new Put(key.get());            // 迭代以获取cell数据            for (Cell cell : value.rawCells()) &#123;                // add family 详情请看HBase API 使用(让info在前，避免了空指针异常)                if (&quot;info&quot;.equals(Bytes.toString(CellUtil.cloneFamily(cell)))) &#123;                    // add column:name                    if (&quot;name&quot;.equals(Bytes.toString(CellUtil.cloneQualifier(cell)))) &#123;                        put.add(cell);                    &#125;                &#125;            &#125;        &#125;    &#125;    // 二.Reducer calss extends TableReducer&lt;KEYIN, VALUEIN, KEYOUT&gt;    // 输出key 类型为ImmutableBytesWritable 实现writeableComparable的字节数组    // 输出 value 类型为 Mutation 是 delete put increment append 的父类    public static class WriteBasicReducer extends TableReducer&lt;Text, Put, ImmutableBytesWritable&gt; &#123;        @Override        public void reduce(Text key, Iterable&lt;Put&gt; values,                Reducer&lt;Text, Put, ImmutableBytesWritable, Mutation&gt;.Context context)                throws IOException, InterruptedException &#123;            // 从得到的put中得到数据            for (Put put : values) &#123;                // 往外写数据                context.write(null, put);            &#125;        &#125;    &#125;    // 三.Driver    public int run(String[] arg0) throws Exception &#123;        // create job        Job job = Job.getInstance(this.getConf(), this.getClass().getSimpleName());        // set run job class        job.setJarByClass(this.getClass());        // set job        Scan scan = new Scan();        scan.setCaching(500); // 每次获取条目数 1 is the default in Scan, which will be bad for MapReduce jobs        scan.setCacheBlocks(false); // don&#39;t set to true for MR jobs        // set other scan attrs        // set input and set mapper        TableMapReduceUtil.initTableMapperJob(sourceTable, // input table                scan, // Scan instance to control CF and attribute selection                ReadUserMapper.class, // mapper class                Text.class, // mapper output key                Put.class, // mapper output value                job);        // set reducer and output        TableMapReduceUtil.initTableReducerJob(targetTable, // output table                WriteBasicReducer.class, // reducer class                job);        job.setNumReduceTasks(1); // 设置Reduce个数 at least one, adjust as required        // 提交 submit job        Boolean isSuccess = job.waitForCompletion(true);        return isSuccess ? 0 : 1;    &#125;    public static void main(String[] args) throws Exception &#123;        // get configuration        Configuration configuration = HBaseConfiguration.create();        // submit job 提交job        int status = ToolRunner.run(configuration, new Table_user2basic(), args);        // exit program 结束程序        System.exit(status);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase配置和使用</title>
    <link href="/07-Bigdata/03-Hbase/HBase%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/07-Bigdata/03-Hbase/HBase%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="http://hbase.apache.org/book.html?yyue=a21bo.50862.201879#quickstart">参考官方文档</a></p><h1 id="整体实现框架"><a href="#整体实现框架" class="headerlink" title="整体实现框架"></a>整体实现框架</h1><p>图1<br>以下几个为组成部件</p><pre><code>21892 HMaster22028 HRegionServer21553 QuorumPeerMain2366  NameNode2539  DataNode</code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="1-配置-hbase-env-sh"><a href="#1-配置-hbase-env-sh" class="headerlink" title="1.配置 hbase-env.sh"></a>1.配置 hbase-env.sh</h3><pre><code># JAVA_HOMEexport JAVA_HOME=/opt/softwares/jdk1.8.0_141# 使用自己的 Zookeeperexport HBASE_MANAGES_ZK=false</code></pre><h3 id="2-配置-hbase-site-xml-Example-Distributed-HBase-Cluster"><a href="#2-配置-hbase-site-xml-Example-Distributed-HBase-Cluster" class="headerlink" title="2.配置 hbase-site.xml(Example Distributed HBase Cluster)"></a>2.配置 hbase-site.xml(Example Distributed HBase Cluster)</h3><pre><code>&lt;configuration&gt;  &lt;!--根目录，在HDFS的路径--&gt;  &lt;property&gt;    &lt;name&gt;hbase.rootdir&lt;/name&gt;    &lt;value&gt;hdfs://cen-ubuntu.cenzhongman.com:8020/hbase&lt;/value&gt;  &lt;/property&gt;  &lt;!--是否分布式--&gt;  &lt;property&gt;    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;  &lt;/property&gt;  &lt;!--所有节点,逗号隔开--&gt;  &lt;property&gt;    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;    &lt;value&gt;cen-ubuntu.cenzhongman.com&lt;/value&gt;  &lt;/property&gt;&lt;/configuration&gt;</code></pre><h3 id="3-配置-regionservers-类似-Slaves"><a href="#3-配置-regionservers-类似-Slaves" class="headerlink" title="3.配置 regionservers 类似(Slaves)"></a>3.配置 regionservers 类似(Slaves)</h3><pre><code>cen-ubuntu</code></pre><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h3 id="1-启动-Zookeper-server"><a href="#1-启动-Zookeper-server" class="headerlink" title="1.启动 Zookeper server"></a>1.启动 Zookeper server</h3><pre><code>$ bin/zkServer.sh start</code></pre><h3 id="2-启动-HBase"><a href="#2-启动-HBase" class="headerlink" title="2.启动 HBase"></a>2.启动 HBase</h3><pre><code>$ bin/start-hbase.sh</code></pre><h3 id="3-Web-查看"><a href="#3-Web-查看" class="headerlink" title="3.Web 查看"></a>3.Web 查看</h3><pre><code>$ hostname:60010</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-Connect-to-HBase"><a href="#1-Connect-to-HBase" class="headerlink" title="1.Connect to HBase."></a>1.Connect to HBase.</h3><p>Connect to your running instance of HBase using the hbase shell command, located in the bin/ directory of your HBase install. In this example, some usage and version information that is printed when you start HBase Shell has been omitted. The HBase Shell prompt ends with a &gt; character.</p><pre><code>$ ./bin/hbase shellhbase(main):001:0&gt;</code></pre><h3 id="2-Display-HBase-Shell-Help-Text"><a href="#2-Display-HBase-Shell-Help-Text" class="headerlink" title="2.Display HBase Shell Help Text."></a>2.Display HBase Shell Help Text.</h3><p>Type help and press Enter, to display some basic usage information for HBase Shell, as well as several example commands. Notice that table names, rows, columns all must be enclosed in quote characters.</p><pre><code>hbase(main):001:0&gt; helphbase(main):001:0&gt; help &#39;create&#39;</code></pre><h3 id="3-List-Information-About-your-Table"><a href="#3-List-Information-About-your-Table" class="headerlink" title="3.List Information About your Table"></a>3.List Information About your Table</h3><pre><code>Use the list command tohbase(main):002:0&gt; list &#39;test&#39;TABLEtest1 row(s) in 0.0180 seconds=&gt; [&quot;test&quot;]</code></pre><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="1-Create-a-table"><a href="#1-Create-a-table" class="headerlink" title="1.Create a table."></a>1.Create a table.</h3><p>Use the create command to create a new table. You must specify the table name and the ColumnFamily name.</p><pre><code>hbase(main):001:0&gt; create &#39;test&#39;, &#39;cf&#39;0 row(s) in 0.4170 seconds=&gt; Hbase::Table - test</code></pre><h3 id="2-Put-data-into-your-table"><a href="#2-Put-data-into-your-table" class="headerlink" title="2.Put data into your table."></a>2.Put data into your table.</h3><p>To put data into your table, use the put command.</p><pre><code># 表名   RowKey   列簇名[:列名]  值   [timeStamp]可指定，默认为时间戳hbase(main):003:0&gt; put &#39;test&#39;, &#39;row1&#39;, &#39;cf:a&#39;, &#39;value1&#39;0 row(s) in 0.0850 secondshbase(main):004:0&gt; put &#39;test&#39;, &#39;row2&#39;, &#39;cf:b&#39;, &#39;value2&#39;0 row(s) in 0.0110 secondshbase(main):005:0&gt; put &#39;test&#39;, &#39;row3&#39;, &#39;cf:c&#39;, &#39;value3&#39;0 row(s) in 0.0100 seconds</code></pre><h2 id="查询-三种方式"><a href="#查询-三种方式" class="headerlink" title="查询(三种方式)"></a>查询(三种方式)</h2><h3 id="1-Scan-the-table-for-all-data-at-once-全表扫描"><a href="#1-Scan-the-table-for-all-data-at-once-全表扫描" class="headerlink" title="1.Scan the table for all data at once.全表扫描"></a>1.Scan the table for all data at once.全表扫描</h3><p>One of the ways to get data from HBase is to scan. Use the scan command to scan the table for data. You can limit your scan, but for now, all data is fetched.</p><pre><code>hbase(main):006:0&gt; scan &#39;test&#39;ROW                                      COLUMN+CELL row1                                    column=cf:a, timestamp=1421762485768, value=value1 row2                                    column=cf:b, timestamp=1421762491785, value=value2 row3                                    column=cf:c, timestamp=1421762496210, value=value33 row(s) in 0.0230 seconds</code></pre><h3 id="2-Get-a-single-row-of-data-单行查询-最快速"><a href="#2-Get-a-single-row-of-data-单行查询-最快速" class="headerlink" title="2.Get a single row of data.单行查询(最快速)"></a>2.Get a single row of data.单行查询(最快速)</h3><p>To get a single row of data at a time, use the get command.</p><pre><code># 表名  RowKey  [列簇名[:列名]]  [timeStamp]hbase(main):007:0&gt; get &#39;test&#39;, &#39;row1&#39;COLUMN                                   CELL cf:a                                    timestamp=1421762485768, value=value11 row(s) in 0.0350 seconds</code></pre><h3 id="3-范围查询"><a href="#3-范围查询" class="headerlink" title="3.范围查询"></a>3.范围查询</h3><p>给定条件按范围进行列查询</p><pre><code>hbase(main):007:0&gt; scan &#39;test&#39; ,&#123;STARTROW =&gt; &#39;xyz&#39;&#125;</code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="1-Disable-a-table"><a href="#1-Disable-a-table" class="headerlink" title="1.Disable a table."></a>1.Disable a table.</h3><p>If you want to delete a table or change its settings, as well as in some other situations, you need to disable the table first, using the disable command. You can re-enable it using the enable command.</p><pre><code>hbase(main):008:0&gt; disable &#39;test&#39;0 row(s) in 1.1820 secondshbase(main):009:0&gt; enable &#39;test&#39;0 row(s) in 0.1770 seconds</code></pre><p>Disable the table again if you tested the enable command above:</p><pre><code>hbase(main):010:0&gt; disable &#39;test&#39;0 row(s) in 1.1820 seconds</code></pre><h3 id="2-Drop-the-table"><a href="#2-Drop-the-table" class="headerlink" title="2.Drop the table."></a>2.Drop the table.</h3><p>To drop (delete) a table, use the drop command.</p><pre><code>hbase(main):011:0&gt; drop &#39;test&#39;0 row(s) in 0.1370 seconds</code></pre><h3 id="3-Delete-Data"><a href="#3-Delete-Data" class="headerlink" title="3.Delete Data"></a>3.Delete Data</h3><p>To Delect data from table.</p><pre><code># 删除一行中一列数据(不能根据列簇所属的列的数据，但是能删除列簇的自己数据)hbase(main):011:0&gt; delete &#39;t1&#39;,&#39;r1&#39;,&#39;c1&#39;,[&#39;ts1&#39;]# 删除整行数据hbase(main):011:0&gt; deleteall &#39;t1&#39;,&#39;r1&#39;</code></pre><h2 id="Exit-the-HBase-Shell"><a href="#Exit-the-HBase-Shell" class="headerlink" title="Exit the HBase Shell."></a>Exit the HBase Shell.</h2><p>To exit the HBase Shell and disconnect from your cluster, use the quit command. HBase is still running in the background.</p><pre><code>hbase(main):007:0&gt; quit/exit</code></pre><h1 id="Stop-HBase"><a href="#Stop-HBase" class="headerlink" title="Stop HBase"></a>Stop HBase</h1><p>In the same way that the bin/start-hbase.sh script is provided to conveniently start all HBase daemons, the bin/stop-hbase.sh script stops them.</p><pre><code>$ ./bin/stop-hbase.shstopping hbase....................</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hbase数据IO</title>
    <link href="/07-Bigdata/03-Hbase/Hbase%E6%95%B0%E6%8D%AEIO/"/>
    <url>/07-Bigdata/03-Hbase/Hbase%E6%95%B0%E6%8D%AEIO/</url>
    
    <content type="html"><![CDATA[<h1 id="场景及方案分析"><a href="#场景及方案分析" class="headerlink" title="场景及方案分析"></a>场景及方案分析</h1><h3 id="场景1：logs-–-gt-HBase"><a href="#场景1：logs-–-gt-HBase" class="headerlink" title="场景1：logs    –&gt;        HBase"></a>场景1：logs    –&gt;        HBase</h3><ul><li>logs -&gt; flume -&gt; hfile -&gt; import -&gt; HBase     (实时)</li><li>csv导入HBase 使用hive 作为临时表<a href="https://yq.aliyun.com/articles/59457">csv导入HBase</a></li><li>tsv导入HBase 直接import     方式1</li></ul><h3 id="场景2：RDBMS-–-gt-HBase"><a href="#场景2：RDBMS-–-gt-HBase" class="headerlink" title="场景2：RDBMS    –&gt;        HBase"></a>场景2：RDBMS    –&gt;        HBase</h3><ul><li>RDBMS -&gt; sqoop -&gt; Hfile -&gt; import -&gt; HBase     (非实时)    方式1    </li><li>RDBMS -&gt; JDBC -&gt; Put API -&gt; HBase             (实时较高，纯手写，较常用，因为需要过滤处理)    方式3</li><li>RDBMS -&gt; Stome -&gt; HBase                         (实时)</li><li>RDBMS -&gt; Spark -&gt; HBase                         (实时)</li></ul><h3 id="场景3：集群性能测试"><a href="#场景3：集群性能测试" class="headerlink" title="场景3：集群性能测试"></a>场景3：集群性能测试</h3><ul><li>自己写多线程并发程序()，测试读写速度</li></ul><h3 id="场景4：HBase-gt-RDBMS"><a href="#场景4：HBase-gt-RDBMS" class="headerlink" title="场景4：HBase -&gt; RDBMS"></a>场景4：HBase -&gt; RDBMS</h3><h1 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h1><h3 id="1-Using-the-HBase-Put-API"><a href="#1-Using-the-HBase-Put-API" class="headerlink" title="1.Using the HBase Put API"></a>1.Using the HBase Put API</h3><p>使用Put API import，缺点：数据保存在内存中，大数据量处理速度慢，数据缺少过滤</p><pre><code>HADOOP_CLASSPATH=`$HBASE_HOME/bin/hbase mapredcp` \$HADOOP_HOME/bin/yarn jar \$HBASE_HOME/lib/hbase-server-1.2.0-cdh5.12.0.jar \importtsv \-Dimporttsv.columns=HBASE_ROW_KEY,info:name,info:sex,info:age \user_from_tsv \/user/cen/data/hbase_import_user.tsv</code></pre><h3 id="2-Using-the-HBase-bulk-load-tool"><a href="#2-Using-the-HBase-bulk-load-tool" class="headerlink" title="2.Using the HBase bulk load tool"></a>2.Using the HBase bulk load tool</h3><p>使用MapReduce存储成HBase底层文件，优点，减少HBase集群插入压力(不经过插入)，降低Job集群时间提高运行速度</p><pre><code># 跟上述命令不用的是，这个导入并不会将数据导入到HBase而是到一个指定的文件夹# 使用import生成Hfile文件到HDFS，底层通过MapReduce(只有Map)实现HADOOP_CLASSPATH=`$HBASE_HOME/bin/hbase mapredcp`:$&#123;HBASE_HOME&#125;/conf \$HADOOP_HOME/bin/yarn jar \$HBASE_HOME/lib/hbase-server-1.2.0-cdh5.12.0.jar \importtsv \-Dimporttsv.columns=HBASE_ROW_KEY,info:name,info:sex,info:age \-Dimporttsv.bulk.output=/user/cen/hbase/hfileoutput \user_from_tsv_bulk \ /user/cen/data/hbase_import_user.tsv# 加载数据(非MapReduce)，相当于移动数据HADOOP_CLASSPATH=`$HBASE_HOME/bin/hbase mapredcp`:$&#123;HBASE_HOME&#125;/conf \$HADOOP_HOME/bin/yarn jar \$HBASE_HOME/lib/hbase-server-1.2.0-cdh5.12.0.jar \completebulkload \/user/cen/hbase/hfileoutput \user_from_tsv_bulk</code></pre><h3 id="3-Using-a-customized-MapReduce-job"><a href="#3-Using-a-customized-MapReduce-job" class="headerlink" title="3.Using a customized MapReduce job"></a>3.Using a customized MapReduce job</h3><p>自定义 MapReduce Job     优点：前所未有的自由度，缺点：我有一句mmp不知当讲不当讲</p><h4 id="a-mapreduce"><a href="#a-mapreduce" class="headerlink" title="a.mapreduce"></a>a.mapreduce</h4><pre><code>csv -&gt; hfile</code></pre><h4 id="b-bulk-load"><a href="#b-bulk-load" class="headerlink" title="b.bulk load"></a>b.bulk load</h4><pre><code>hfile -&gt; table</code></pre><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170821102154464-1824144459.png" alt="bulk_load_API"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Cloudra Manager</title>
    <link href="/07-Bigdata/07-CloudraManager/01-Cloudra%20Manager/"/>
    <url>/07-Bigdata/07-CloudraManager/01-Cloudra%20Manager/</url>
    
    <content type="html"><![CDATA[<h1 id="Cloudra-Manager"><a href="#Cloudra-Manager" class="headerlink" title="Cloudra Manager"></a>Cloudra Manager</h1><h2 id="ubutnu使用B计划安装"><a href="#ubutnu使用B计划安装" class="headerlink" title="ubutnu使用B计划安装"></a>ubutnu使用B计划安装</h2><ul><li><a href="https://www.cloudera.com/documentation/enterprise/latest/topics/installation_installation.html">官方教程</a></li><li><a href="http://blog.csdn.net/earbao/article/details/38019935">参考博客</a></li><li><a href="http://blog.csdn.net/u014791046/article/details/50547126?locationNum=8">参考博客</a></li></ul><h3 id="1-MySQL配置"><a href="#1-MySQL配置" class="headerlink" title="1.MySQL配置"></a>1.MySQL配置</h3><ul><li><a href="https://www.cloudera.com/documentation/enterprise/latest/topics/cm_ig_mysql.html">官方指导</a></li></ul><h4 id="a-安装MySQL"><a href="#a-安装MySQL" class="headerlink" title="a.安装MySQL"></a>a.安装MySQL</h4><pre><code class="hljs shell">sudo apt-get install mysql-server</code></pre><h4 id="b-配置MySQL"><a href="#b-配置MySQL" class="headerlink" title="b.配置MySQL"></a>b.配置MySQL</h4><p>在/etc/mysql/conf.d下创建mysql_cloudera_manager.cnf文件，加入以下内容：</p><pre><code class="hljs sh">[mysqld]transaction-isolation = READ-COMMITTED<span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks;</span><span class="hljs-comment"># to do so, uncomment this line:</span><span class="hljs-comment"># symbolic-links = 0</span>key_buffer_size = 32Mmax_allowed_packet = 32Mthread_stack = 256Kthread_cache_size = 64query_cache_limit = 8Mquery_cache_size = 64Mquery_cache_type = 1max_connections = 550<span class="hljs-comment">#expire_logs_days = 10</span><span class="hljs-comment">#max_binlog_size = 100M</span><span class="hljs-comment">#log_bin should be on a disk with enough free space. Replace &#x27;/var/lib/mysql/mysql_binary_log&#x27; with an appropriate path for your system</span><span class="hljs-comment">#and chown the specified folder to the mysql user.</span>log_bin=/var/lib/mysql/mysql_binary_log<span class="hljs-comment"># For MySQL version 5.1.8 or later. For older versions, reference MySQL documentation for configuration help.</span>binlog_format = mixedread_buffer_size = 2Mread_rnd_buffer_size = 16Msort_buffer_size = 8Mjoin_buffer_size = 8M<span class="hljs-comment"># InnoDB settings</span>innodb_file_per_table = 1innodb_flush_log_at_trx_commit  = 2innodb_log_buffer_size = 64Minnodb_buffer_pool_size = 4Ginnodb_thread_concurrency = 8innodb_flush_method = O_DIRECTinnodb_log_file_size = 512M[mysqld_safe]<span class="hljs-built_in">log</span>-error=/var/<span class="hljs-built_in">log</span>/mysqld.logpid-file=/var/run/mysqld/mysqld.pidsql_mode=STRICT_ALL_TABLES</code></pre><h4 id="c-增加数据库"><a href="#c-增加数据库" class="headerlink" title="c.增加数据库"></a>c.增加数据库</h4><pre><code class="hljs sh">create database amon DEFAULT CHARACTER SET utf8;grant all on amon.* TO <span class="hljs-string">&#x27;amon&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;amon_password&#x27;</span>;create database smon DEFAULT CHARACTER SET utf8;grant all on smon.* TO <span class="hljs-string">&#x27;smon&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;smon_password&#x27;</span>;create database rman DEFAULT CHARACTER SET utf8;grant all on rman.* TO <span class="hljs-string">&#x27;rman&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;rman_password&#x27;</span>;grant all on hmon.* TO <span class="hljs-string">&#x27;hmon&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;hmon_password&#x27;</span>;grant all on hmon.* TO <span class="hljs-string">&#x27;hmon&#x27;</span>@<span class="hljs-string">&#x27;CDH&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;hmon_password&#x27;</span>;create database hive DEFAULT CHARACTER SET utf8;grant all on hive.* TO <span class="hljs-string">&#x27;hive&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;hive_password&#x27;</span>;</code></pre><h4 id="d-去除本地登录限制"><a href="#d-去除本地登录限制" class="headerlink" title="d.去除本地登录限制"></a>d.去除本地登录限制</h4><pre><code class="hljs sh">$ vim /etc/mysql/mysql.conf.d/mysqld.cnf<span class="hljs-comment">#bind-address           = 127.0.0.1</span></code></pre><h3 id="2-Installing-the-MySQL-JDBC-Driver"><a href="#2-Installing-the-MySQL-JDBC-Driver" class="headerlink" title="2.Installing the MySQL JDBC Driver"></a>2.Installing the MySQL JDBC Driver</h3><pre><code class="hljs sh">sudo apt-get install libmysql-java</code></pre><p>文件路径：/usr/lib/jvm/</p><h3 id="3-下载apt源并更新"><a href="#3-下载apt源并更新" class="headerlink" title="3.下载apt源并更新"></a>3.下载apt源并更新</h3><p>1.Save the appropriate Cloudera Manager list file (cloudera.list) for your system.<br>See the Repo File column in the <a href="https://www.cloudera.com/documentation/enterprise/latest/topics/cm_vd.html#concept_skz_ljx_kv__table_dwv_wgh_sy">Repositories</a> table for the URL.<br>2.Copy the content of that file to the cloudera-manager.list file in the <strong>/etc/apt/sources.list.d/</strong> directory.<br>3.Update your system package index by running:</p><pre><code>`$ sudo apt-get update`</code></pre><h3 id="4-在CM主节点安装JDK"><a href="#4-在CM主节点安装JDK" class="headerlink" title="4.在CM主节点安装JDK"></a>4.在CM主节点安装JDK</h3><pre><code class="hljs sh">sudo apt-get install oracle-j2sdk1.7</code></pre><p>文件路径：/usr/share/java/</p><h3 id="5-Cloudera-Manager-Server-和-守护进程"><a href="#5-Cloudera-Manager-Server-和-守护进程" class="headerlink" title="5.Cloudera Manager Server 和 守护进程"></a>5.Cloudera Manager Server 和 守护进程</h3><pre><code class="hljs sh">sudo apt-get install cloudera-manager-daemons cloudera-manager-server</code></pre><h3 id="6-集群免密钥sudo"><a href="#6-集群免密钥sudo" class="headerlink" title="6.集群免密钥sudo"></a>6.集群免密钥sudo</h3><p>对于ubuntu server 还是有点特殊的</p><pre><code class="hljs sh"><span class="hljs-comment"># 增加可写权限</span>$ chmod u+w /etc/sudoers<span class="hljs-comment"># 编辑</span>$ vim /etc/sudoers<span class="hljs-comment"># 第一处：增加一行</span>root ALL=(ALL:ALL) ALLcen ALL=(ALL:ALL) NOPASSWD: ALL<span class="hljs-comment"># 第二处：增加免密钥</span>%sudo ALL=(ALL:ALL) NOPASSWD: ALL<span class="hljs-comment"># 把权限改回来</span>$ sudo chmod u-w /etc/sudoers</code></pre><h2 id="错误大集合"><a href="#错误大集合" class="headerlink" title="错误大集合"></a>错误大集合</h2><h3 id="1-MySQL重启错误"><a href="#1-MySQL重启错误" class="headerlink" title="1.MySQL重启错误"></a>1.MySQL重启错误</h3><ul><li>错误信息：[ERROR] You have enabled the binary log, but you haven’t provided the mandatory server-id. Please refer t</li><li>原因：在设置bin log日志的时候，没有设置server_id参数。server-id参数用于在复制中，为主库和备库提供一个独立的ID，以区分主库和备库；开启二进制文件的时候，需要设置这个参数。</li><li>解决：</li></ul><pre><code class="hljs sh">[root@mysql bin]<span class="hljs-comment"># vi /etc/my.cnf</span><span class="hljs-comment">#add</span>[mysqld]<span class="hljs-built_in">log</span>-bin=mysql-binserver-id=1</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>07-CloudraManager</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-impala是什么</title>
    <link href="/07-Bigdata/08-Impala/01-impala%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/08-Impala/01-impala%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="impala是什么"><a href="#impala是什么" class="headerlink" title="impala是什么"></a>impala是什么</h1><p>impala是什么</p><h3 id="Apache-impala"><a href="#Apache-impala" class="headerlink" title="Apache impala"></a><a href="http://impala.apache.org/">Apache impala</a></h3><p>Apache Impala (incubating) is the open source, native analytic database for Apache Hadoop. Impala is shipped by Cloudera, MapR, Oracle, and Amazon. </p><p>Impala 是一个开源的用于分析本地数据的工具。</p><ul><li><p>低延迟，高并发，可拓展，不基于MapReduce批处理框架</p></li><li><p>不进行文件复制，直接对文件进行扫描分析</p></li><li><p>提供与Hive相同的SQL查询语句</p></li><li><p>通过哨兵机制等，保证了企业级数据安全性</p></li></ul><p>#概念</p><ul><li>Impala Daemon 守护进程(impalad)</li></ul><p>用于往HDFS文件系统读写数据，接收来自各个终端的查询指令，回传查询结果，在生产环境中使用JDBC、ODBC 通过循环，可以将查询提交给不同的守护进程节点以实现负载平衡。在1.2版本后，守护进程还接收了来自 catalogd daemon 的数据，当一些节点在集群中进行了加载，删除等操作时，不需要再进行节点间元数据的同步等操作</p><ul><li>Impala Statestore 状态存储(statestored)</li></ul><p>仅需要一个节点，用于监控集群的健康状态，可以单节点运行，即使失去连接，也不会导致集群不正常工作，知识缺少个监控者而已。</p><p>Statestore demon 和 Catalog Server 对高可用并不作要求。</p><ul><li>Impala Catalog Service 编辑日志监控(catalogd)</li></ul><p>当你通过Hive执行了创建，删除等操作时，需要impala发出 REFRESH更新 or INVALIDATE METADATA 数据无效 指令</p><p>#安装</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>08-Impala</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flume使用（案例分析）</title>
    <link href="/07-Bigdata/10-Flume/Flume%E4%BD%BF%E7%94%A8%EF%BC%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/07-Bigdata/10-Flume/Flume%E4%BD%BF%E7%94%A8%EF%BC%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##<a href="http://flume.apache.org/FlumeUserGuide.html#exec-source">Flume官方文档</a></p><pre><code>Usage: bin/flume-ng &lt;command&gt; [options]...commands:  help                      display this help text  agent                     run a Flume agentglobal options:  --conf,-c &lt;conf&gt;          use configs in &lt;conf&gt; directory  -Dproperty=value          sets a Java system property valueagent options:  --name,-n &lt;name&gt;          the name of this agent (required)  --conf-file,-f &lt;file&gt;     specify a config file (required if -z missing)eg:bin/flume-ng agent --conf conf --name agent-test --conf-file test.conf -Dflume.root.logger=DEBUG,consolebin/flume-ng agent -c conf -n agent-test -f test.conf -Dflume.root.logger=DEBUG,console</code></pre><p>#一个不能再简单的例子<br>###1.编辑 Conf 范例 (官网和 conf 目录下都有)</p><pre><code># example.conf: A single-node Flume configuration# 1.定义三个组件的名称# Name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# 2.配置Source(从哪里连接Sources)# Describe/configure the sourcea1.sources.r1.type = netcata1.sources.r1.bind = cen-ubuntua1.sources.r1.port = 44444# 3.配置Sink(主要用于输出日志信息)# Describe the sinka1.sinks.k1.type = loggera1.sinks.k1.maxBytesToLog = 1024# 4.配置Channel(使用存储当做管道)# Use a channel which buffers events in memorya1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100# 5.绑定三个组件# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1</code></pre><p>###2.安装 netcat <a href="http://www.oschina.net/translate/linux-netcat-command">(一个可以传输文件，信息的网络工具)</a>来发送接收信息</p><pre><code>$ sudo apt-get install netcat</code></pre><p>###3.运行实时 flume 实时抓取数据(监控 端口 )</p><pre><code>bin/flume-ng agent --conf conf --name a1 --conf-file conf/a1.conf -Dflume.root.logger=DEBUG,console</code></pre><p>###4.通过 shell 查看端口是否开启成功</p><pre><code>netstat -tnlp</code></pre><p>###5.通过 telnet 向该端口发送数据</p><pre><code>telnet cen-ubuntu 44444</code></pre><p>###6.若Flume接收到数据则表示成功</p><pre><code>Event: &#123; headers:&#123;&#125; body: 6E 69 68 61 6F 20 08 0D                         nihao .. &#125;</code></pre><p>##各种各样的 Sources</p><h4 id="Exec-Source-通过执行命令行"><a href="#Exec-Source-通过执行命令行" class="headerlink" title="Exec Source 通过执行命令行"></a>Exec Source 通过执行命令行</h4><pre><code>a1.sources = r1a1.channels = c1a1.sources.r1.type = execa1.sources.r1.command = tail -F /var/log/secure</code></pre><h4 id="Spooling-Directory-Source-监控一个目录的文件变化"><a href="#Spooling-Directory-Source-监控一个目录的文件变化" class="headerlink" title="Spooling Directory Source 监控一个目录的文件变化"></a>Spooling Directory Source 监控一个目录的文件变化</h4><h4 id="Kafka-Source"><a href="#Kafka-Source" class="headerlink" title="Kafka Source"></a>Kafka Source</h4><h4 id="Syslog-Sources-收集系统日志"><a href="#Syslog-Sources-收集系统日志" class="headerlink" title="Syslog Sources 收集系统日志"></a>Syslog Sources 收集系统日志</h4><h4 id="HTTP-Source-通过HTTP协议供互联网下载服务器的数据"><a href="#HTTP-Source-通过HTTP协议供互联网下载服务器的数据" class="headerlink" title="HTTP Source 通过HTTP协议供互联网下载服务器的数据"></a>HTTP Source 通过HTTP协议供互联网下载服务器的数据</h4><h4 id="NetCat-Source"><a href="#NetCat-Source" class="headerlink" title="NetCat Source"></a>NetCat Source</h4><p>##各种各样的Channels</p><h4 id="Memory-Channel"><a href="#Memory-Channel" class="headerlink" title="Memory Channel"></a>Memory Channel</h4><h4 id="Kafka-Channel"><a href="#Kafka-Channel" class="headerlink" title="Kafka Channel"></a>Kafka Channel</h4><h4 id="File-Channel-存在文件中"><a href="#File-Channel-存在文件中" class="headerlink" title="File Channel 存在文件中"></a>File Channel 存在文件中</h4><p>##各种各样的Sinks</p><h4 id="HDFS-Sink"><a href="#HDFS-Sink" class="headerlink" title="HDFS Sink"></a>HDFS Sink</h4><h4 id="Hive-Sink"><a href="#Hive-Sink" class="headerlink" title="Hive Sink"></a>Hive Sink</h4><h4 id="HBase-Siinks-HBase-Sink-AsyncHBaseSink"><a href="#HBase-Siinks-HBase-Sink-AsyncHBaseSink" class="headerlink" title="HBase Siinks(HBase Sink ; AsyncHBaseSink)"></a>HBase Siinks(HBase Sink ; AsyncHBaseSink)</h4><h4 id="MorphlineSolrSink-一个ELT工具-Extract-transform-load"><a href="#MorphlineSolrSink-一个ELT工具-Extract-transform-load" class="headerlink" title="MorphlineSolrSink 一个ELT工具(Extract, transform, load)"></a>MorphlineSolrSink 一个ELT工具(Extract, transform, load)</h4><h4 id="ElasticSearchSink-一个基于Lucene的搜索服务器"><a href="#ElasticSearchSink-一个基于Lucene的搜索服务器" class="headerlink" title="ElasticSearchSink 一个基于Lucene的搜索服务器"></a>ElasticSearchSink 一个基于Lucene的搜索服务器</h4><hr><hr><p>#案例1：<br>###收集Hive运行的目录到hdfs文件系统<br>分析：使用 Exec 来监控文件实时性较高，但可靠性较差，当系统命令中断后，数据丢失，或重新读取，数据安全性无法得到保障，生产环境中不能使用；使用文件缓存比内存来得更安全</p><ul><li>Source: Exec Source<br>  tail -f /opt/cdh5.3.6/hive-0.13.1-cdh5.3.6/logs/hive.log</li><li>Channel: Memory Channel</li><li>Sink: HDFS Sink<br>  /user/cen/flume/hive-log</li></ul><p>####1.编写 agent 程序</p><pre><code># example.conf: A single-node Flume configuration# 1.定义三个组件的名称# Name the components on this agenta2.sources = r2a2.sinks = k2a2.channels = c2# 2.配置Source(从哪里连接Sources)# Describe/configure the sourcea2.sources.r2.type = execa2.sources.r2.command = tail -F /opt/cdh5.3.6/hive-0.13.1-cdh5.3.6/logs/hive.log# 3.配置Sink(主要用于输出日志信息)# Describe the sinka2.sinks.k2.type = hdfs# 非高可用的 namenode 指定 host (注1，注2)a2.sinks.k2.hdfs.path = hdfs://cen-ubuntu:8020/user/cen/flume/hive-log# 设置前缀a2.sinks.k2.hdfs.filePrefix = events-# 数据格式(不压缩的文本数据)a2.sinks.k2.hdfs.fileType = DataStream # 存储格式a2.sinks.k2.hdfs.writeFormat = Text# 每次写的event数a2.sinks.k2.hdfs.batchSize = 100# 设置文件滚动的参数(配合下面一项使用)a2.sinks.k2.hdfs.rollInterval = 0a2.sinks.k2.hdfs.rollSize = 1024a2.sinks.k2.hdfs.rollCount = 0# 参考http://doc.okbase.net/chiweitree/archive/126197.htmla2.sinks.k2.hdfs.minBlockReplicas=1# 4.配置Channel(使用存储当做管道)# Use a channel which buffers events in memorya2.channels.c2.type = memorya2.channels.c2.capacity = 1000a2.channels.c2.transactionCapacity = 100# 5.绑定三个组件# Bind the source and sink to the channela2.sources.r2.channels = c2a2.sinks.k2.channel = c2</code></pre><p>####2.添加相应的jar依赖包(使用 find /dir/dir -name ‘filename’ 即可轻松找到) </p><pre><code>commons-configuration-1.6.jarhadoop-common-2.5.0-cdh5.3.6.jarhadoop-auth-2.5.0-cdh5.3.6.jarhadoop-hdfs-2.5.0-cdh5.3.6.jar</code></pre><p>####3.执行</p><pre><code>bin/flume-ng agent --conf conf --name a2 --conf-file conf/flume-tail.conf -Dflume.root.logger=DEBUG,console</code></pre><hr><hr><p>#案例二：</p><ul><li>###收集Hive运行的目录到hdfs文件系统</li><li>Source: Spooling Directory Source<br>  /opt/cdh5.3.6/hive-0.13.1-cdh5.3.6/logs/</li><li>Channel: File Channel</li><li>Sink: HDFS Sink<br>  /user/cen/flume/hive-log<br>分析：Spooling Directory Source 通过监控文件夹的新增文件来实现日志信息收集。实际生产环境结合 log4j 来使用，日志文件传输完成后会修改其后缀名，添加.COMPLETED 后缀</li></ul><p>####1.编写 agent 程序</p><pre><code># example.conf: A single-node Flume configuration# Name the components on this agenta3.sources = r3a3.sinks = k3a3.channels = c3# Describe/configure the sourcea3.sources.r3.type = spooldira3.sources.r3.spoolDir = /opt/datas/flume/a3.sources.r3.ignorePattern = (.)*.log$# 监控后的文件后缀a3.sources.r3.fileSuffix = .deleteable# Describe the sinka3.sinks.k3.type = hdfsa3.sinks.k3.hdfs.path = hdfs://cen-ubuntu:8020/user/cen/flume/spool-file-hdfs/%Y%m%da3.sinks.k3.hdfs.useLocalTimeStamp = truea3.sinks.k3.hdfs.filePrefix = events-a3.sinks.k3.hdfs.fileType = DataStream a3.sinks.k3.hdfs.writeFormat = Texta3.sinks.k3.hdfs.batchSize = 10# Use a channel which buffers events in filea3.channels.c3.type = file# 临时文件存储目录(可选)a3.channels.c3.checkpointDir = /opt/cdh5.3.6/flume-1.5.0-cdh5.3.6/data/filechanel/cheakpointa3.channels.c3.dataDirs = /opt/cdh5.3.6/flume-1.5.0-cdh5.3.6/data/filechanel/data# Bind the source and sink to the channela3.sources.r3.channels = c3a3.sinks.k3.channel = c3</code></pre><p>####2.执行</p><pre><code>bin/flume-ng agent --conf conf --name a3 --conf-file conf/spooling-file-hdfs.conf -Dflume.root.logger=DEBUG,console</code></pre><p>####3.运行结果</p><ul><li>被读取过的文件从背上了.delectable 的罪名</li><li>.log 结尾的文件不会被读取</li><li>HDFS文件系统如实出现了被读取的文件，且按日期分文件夹存储</li></ul><h2 id="注1：HDFS-的-HA-配置"><a href="#注1：HDFS-的-HA-配置" class="headerlink" title="注1：HDFS 的 HA 配置"></a>注1：HDFS 的 HA 配置</h2><p>####1.添加配置文件 hdfs-site.xml core-site.xml 到目录 conf 下<br>####2.修改 hdfs 的路径<br>    # 若 namenode 为HA<br>    # a2.sinks.k2.hdfs.path = hdfs://ns1/user/cen/flume/hive-log</p><h2 id="注2：特别的，可以设置一定规则-如按时间-Y-m-d-来创建文件目录，详情见官方文档"><a href="#注2：特别的，可以设置一定规则-如按时间-Y-m-d-来创建文件目录，详情见官方文档" class="headerlink" title="注2：特别的，可以设置一定规则(如按时间%Y%m%d)来创建文件目录，详情见官方文档"></a>注2：特别的，可以设置一定规则(如按时间%Y%m%d)来创建文件目录，详情见官方文档</h2><pre><code># 如官方文档所说明，关于时间有关的参数需要在 events 的头中加入服务器的时间这个字段，添加参数如下hdfs.useLocalTimeStamp = true</code></pre><p>##注3：使用文件</p><pre><code>/bin/sqoop --options-file /opt/datas/filename</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>10-Flume</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flume是什么</title>
    <link href="/07-Bigdata/10-Flume/Flume%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/10-Flume/Flume%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723113815387-468354707.png"></p><h2 id="分布式流式实时收集日志文件系统，便于实时在线的流式计算，常配合-Storm-和-spark-streming-使用。"><a href="#分布式流式实时收集日志文件系统，便于实时在线的流式计算，常配合-Storm-和-spark-streming-使用。" class="headerlink" title="分布式流式实时收集日志文件系统，便于实时在线的流式计算，常配合 Storm 和 spark streming 使用。"></a>分布式流式实时收集日志文件系统，便于实时在线的流式计算，常配合 Storm 和 spark streming 使用。</h2><p>Flume is a <strong>distributed</strong>分布式的, <strong>reliable</strong>可靠的, and <strong>available</strong>可用的 service for efficiently高效 <strong>collecting</strong>收集, <strong>aggregating</strong>聚合, and <strong>moving</strong>移动 large amounts of log data.<br>It has a simple简单 and flexible灵活 architecture结构 based on streaming流式 data flows. It is <strong>robust</strong>健壮 and <strong>fault tolerant</strong>容错 with tunable可调 reliability mechanisms机制 and many failover and recovery mechanisms. It uses a simple extensible可拓展 data model that allows for online analytic application.</p><h4 id="架构图如下"><a href="#架构图如下" class="headerlink" title="架构图如下"></a>架构图如下</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723113820809-527350861.png"></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170723113827028-57517500.png"></p><table><thead><tr><th>角色</th><th>作用</th></tr></thead><tbody><tr><td>Agent</td><td>Flume的客户端</td></tr><tr><td>Event</td><td>Flume 数据传输的基本单元，由 [Header] 和 数据的 byte Array 构成，载有数据对Flume不透明；Header 是容纳了KEY_VALUE对的无序集合(Key是唯一的)；Header 可以在上下文路由中使用拓展</td></tr><tr><td>Source</td><td>用于收集数据，产生数据源的地方，并主动推送数据到 Channel 中</td></tr><tr><td>Channel</td><td>数据管道，用于连接 sources 和 sinks ，可以连接多个Source(所谓的分布式)，在管道前后增加过滤器可以清洗数据</td></tr><tr><td>Sink</td><td>主动到 Channel 拉取数据，向目标源写数据，目标源可以使HDFS、HBase 也可以是下一个Source</td></tr></tbody></table><h1 id="Flume-配置"><a href="#Flume-配置" class="headerlink" title="Flume 配置"></a>Flume 配置</h1><p>编辑配置文件的 $JAVA_PATH 就可以使用了</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>10-Flume</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive LanguageManual DDL</title>
    <link href="/07-Bigdata/11-Hive/Hive%20LanguageManual%20DDL/"/>
    <url>/07-Bigdata/11-Hive/Hive%20LanguageManual%20DDL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL">hive语法规则LanguageManual DDL</a><br>##SQL DML 和 DDL 数据操作语言 (DML) 和 数据定义语言 (DDL)<br>##一、数据库   增删改都在文档里说得也很明白，不重复造车轮<br>##二、表<br>###1.创建table重点解析如下<br>###Create Table<br>    eg1:基础创建方式<br>    create table if not exists default.cenzhongman<br>    (<br>    ip string COMMENT ‘this is ip’,<br>    name string<br>    )<br>    COMMENT ‘this is log of cenzhongman.com’<br>    ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘ ‘<br>    ——————————————–<br>    eg2:常用于分表<br>    create table if not exists default.cenzhongman_2<br>    AS select ip,date from default.cenzhongman;<br>    ——————————————–<br>    eg3:常用于表复制<br>    create table if not exists default.cenzhongman_3<br>    like default.cenzhongman;</p><pre><code>CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)  #字段定义  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]  #表注释  [COMMENT table_comment]      #分区表，按指定字段进行分区，既按每一个字段按文件夹存储  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)     [STORED AS DIRECTORIES]  #数据格式化  [   #行分割   [ROW FORMAT row_format]   #处理的文件格式   [STORED AS file_format]     | STORED BY &#39;storage.handler.class.name&#39; [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)  ]  #数据存储在hdfs文件系统位置  [LOCATION hdfs_path]  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)  #根据另一张表查询结果创建  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)#根据另一张表创建，字段一致CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name  LIKE existing_table_or_view_name  [LOCATION hdfs_path];data_type  : primitive_type  | array_type  | map_type  | struct_type  | union_type  -- (Note: Available in Hive 0.7.0 and later)primitive_type  : TINYINT  | SMALLINT  | INT  | BIGINT  | BOOLEAN  | FLOAT  | DOUBLE  | DOUBLE PRECISION -- (Note: Available in Hive 2.2.0 and later)  | STRING  | BINARY      -- (Note: Available in Hive 0.8.0 and later)  | TIMESTAMP   -- (Note: Available in Hive 0.8.0 and later)  | DECIMAL     -- (Note: Available in Hive 0.11.0 and later)  | DECIMAL(precision, scale)  -- (Note: Available in Hive 0.13.0 and later)  | DATE        -- (Note: Available in Hive 0.12.0 and later)  | VARCHAR     -- (Note: Available in Hive 0.12.0 and later)  | CHAR        -- (Note: Available in Hive 0.13.0 and later)array_type  : ARRAY &lt; data_type &gt;map_type  : MAP &lt; primitive_type, data_type &gt;struct_type  : STRUCT &lt; col_name : data_type [COMMENT col_comment], ...&gt;union_type   : UNIONTYPE &lt; data_type, data_type, ... &gt;  -- (Note: Available in Hive 0.7.0 and later)row_format  : DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]         #行分隔符和列分隔符        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]        [NULL DEFINED AS char]   -- (Note: Available in Hive 0.13 and later)  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]file_format:  : SEQUENCEFILE  | TEXTFILE    -- (Default, depending on hive.default.fileformat configuration)  | RCFILE      -- (Note: Available in Hive 0.6.0 and later)  | ORC         -- (Note: Available in Hive 0.11.0 and later)  | PARQUET     -- (Note: Available in Hive 0.13.0 and later)  | AVRO        -- (Note: Available in Hive 0.14.0 and later)  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classnameconstraint_specification:  : [, PRIMARY KEY (col_name, ...) DISABLE NOVALIDATE ]    [, CONSTRAINT constraint_name FOREIGN KEY (col_name, ...) REFERENCES table_name(col_name, ...) DISABLE NOVALIDATE</code></pre><p>###2.清除表的所有数据<br>    TRUNCATE TABLE table_name [PARTITION partition_spec];</p><pre><code>partition_spec:  : (partition_column = partition_col_value, partition_column = partition_col_value, ...)</code></pre><p>##三、Hive表的类型<br>###管理表MANAGED_TABLE<br>    表删除之后，表的数据同时删除<br>###托管表(外部表)EXTERNAL_TABLE<br>    一般通过LOCATION指定数据存储目录，以便共用<br>    表删除之后，表的数据不会删除(hdfs中的数据)，只删除元数据（matestore）<br>    直接把需要加载的文件放到表所在文件夹中，自动加载<br>###分区表（此类型与上述类型非并列关系）</p><pre><code>#创建分区表create table emp_partition(ID int, name string, job string, mrg int, hiredate string, sal double, comm double, deptno int) partitioned by (mouth string);#加载数据load data local inpath &#39;/opt/datas/xxx.txt&#39; into table default.tableName partition (mouth = &#39;201707&#39; ,day = &#39;14&#39;);#查询数据select * from emp_partition where mouth = &#39;201707&#39; and day = &#39;14&#39;;#在实现上，分区表在（load）加载数据时候，会往 matestore 的数据库中的 partition 表中添加一行用于说明分区情况#在查询数据时，会读取 matestore 中的 partition 表中的信息#若用户自行 put 数据到hdfs文件系统，matestore 中的数据不会添加分区信息，则查询数据为空，此时可以使用 msck 修复表，详情见DDL官方文档msck repair table table_name;        #自动修复alter table tableName add partition(day = &#39;20170714&#39;);     #手动修复（更常用）#显示分区show partitions tablename;</code></pre><p>###4.查询语法<br>###<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select">LanguageManualSelect</a></p><pre><code>eg:全部查询select * from tablename ;eg2: t 是表的别名(为了方便书写，同时在存储和查看时显示)select t.id,t.name,t.xxx from tablename t;eg3:普通条件查询select * from tablename t where id = &#39;1234&#39;;=  &gt;=  &lt;=  is null  /  is not null  /  in   /  not in eg4:区间条件查询select * from tablename t where t.money between 800 and 1500;eg5:使用函数查询select count(*) from tablename;select max(*) from tablename;select min(*) from tablename;select sum(money) from tablename;select avg(*) from tablename;....eg6:分组查询（**！不在函数中的字段必须在 group by 里面**）select t.deptId,avg(money) avg_money(注：别名，可选) from tablename t group by t.deptId;     #通过 deptId 分组,从表中查询每个部门平均工资select t.job,t.deptId,avg(money) avg_money from tablename t group by t.deptId,t.job;     #每个部门每个岗位的平均工资eg7:having     where 针对单挑记录进行筛选    having 针对分组结果进行筛选 &gt; 先分组，对组进行条件判断select deptid, avg(sal) avg_sal from tablename group by deptid having &gt; 8000;     #平均薪资大于 8000 的部门SELECT [ALL(默认值) | DISTINCT(不重复的)] select_expr, select_expr, ...  FROM table_reference  [WHERE where_condition]  [GROUP BY col_list]#分组  [ORDER BY col_list]#显示顺序  [CLUSTER BY col_list    | [DISTRIBUTE BY col_list] [SORT BY col_list]  ] [LIMIT [offset,] rows]#限制显示行数</code></pre><p>###join 链接查询：将 m n 两个数据库链接起来，组成一条记录<br>####等值 join<br>    select e.id, e.name, d.deptid, d.name from emp e join dept d on e.deptid = d.deptid;     #显示e,d两个表 deptid 字段相同的信息在一个结果中<br>####左链接 left join 以 join 左边的表为准（允许有的员工没有部门，左表存在该字段则打印）<br>    select e.id, e.name, d.deptid, d.name from emp e left join dept d on e.deptid = d.deptid;<br>####右链接 right join 以 join 右边的表为准（允许有的部门没有员工，右表存在该字段则打印）<br>    select e.id, e.name, d.deptid, d.name from emp e right join dept d on e.deptid = d.deptid;<br>####全连接 full join 左 + 右 = 全<br>        select e.id, e.name, d.deptid, d.name from emp e fuill join dept d on e.deptid = d.deptid;</p><p>###Order, Sort, Cluster, and Distribute By</p><pre><code>#order by ( ASC | DESC )全局数据 升序 | 降序 ，仅仅只有一个reduceselect * from tablename order by id desc;#sort by 每一个reduce内部数据进行排序set mapreduce.job.reduces = 3;select * from tablename sort by id desc;    #直接显示结果，效果不明显insert overwrite local directory &#39;/opt/datas/sortby-res&#39; select * from tablename sort by id decs;    #结果保存到本地文件系统中，分成三个结果文件存储#Cluster by 当 distribute by 和 sort by 字段相同时相当于 cluster by 根据字段（按照一定规则）根据 reduce 数分组并排序insert overwrite local directory &#39;/opt/datas/sortby-res&#39; select * from tablename cluster by id；#distribute by 分布式，指定分区方式，按某个字段进行分区insert overwrite local directory &#39;/opt/datas/sortby-res&#39; select * from tablename distribute by job sort by id decs;    #按岗位分区，内部按 ID 排序，结果保存到#！！注：若reduce分区数 &gt; 字段数     存在空数据   若 reduce 数 &lt; 字段数，部分结果会合并</code></pre><p>###!!总结（重点）：<br>####order by<br>    全局排序，一个Reduce<br>####sort by<br>    每个Reduce中进行排序，全局不排序<br>####distribute by<br>    类似MapReduce 中的 partition 进行分区，结合 sort by 使用<br>####cluster by<br>    当distribute by 和 sort by 字段相同时使用，按照根据该字段进行分区，并排序</p><p>##注：Hive 的虚拟属性<br>可以使用<strong>虚拟列</strong>属性协助 Hive 工作</p><pre><code>    select id,name,INPUT__FILE__NAME from tablename;</code></pre><p>即可显现 hive 文件所在文件</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive 中的 UDF</title>
    <link href="/07-Bigdata/11-Hive/Hive%20%E4%B8%AD%E7%9A%84%20UDF/"/>
    <url>/07-Bigdata/11-Hive/Hive%20%E4%B8%AD%E7%9A%84%20UDF/</url>
    
    <content type="html"><![CDATA[<p>###<a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins">LanguageManual UDF</a><br>###一、分类<br>    UDF:User defined function 用户定义函数<br>        一进一出<br>    UDAF:User defined aggregation function<br>        聚类函数：多进一出<br>        如：max min count<br>    UDTF:User definesd table-Generating Function<br>        一进多出<br>        如：lateral view explore</p><p>###二、实战<br>####1.创建Maven工程，修改pom.xml<br><a href="http://www.cnblogs.com/cenzhongman/p/7182621.html">hive-pom.xml</a><br>####2.First, you need to create a new class that extends UDF, with one or more methods named evaluate.<br>####创建一个类继承UDF类，实现 evaluate 方法</p><pre><code>package com.cenzhongman.hive.udf;import org.apache.hadoop.hive.ql.exec.UDF;import org.apache.hadoop.io.Text;public class LowerUDF extends UDF&#123;    //•Implement one or more methods named evaluate which will be called by Hive (the exact way in which Hive resolves the method to call can be configured by setting a custom UDFMethodResolver). The following are some examples: ◦public int evaluate();    //    ◦public int evaluate(int a);    //    ◦public double evaluate(int a, double b);    //    ◦public String evaluate(String a, int b, Text c);    //    ◦public Text evaluate(String a);    //    ◦public String evaluate(List&lt;Integer&gt; a); (Note that Hive Arrays are represented as Lists in Hive. So an ARRAY&lt;int&gt; column would be passed in as a List&lt;Integer&gt;.)    //    •evaluate should never be a void method. However it can return null if needed. 不允许返回类型为 void 可以返回 null    //    •Return types as well as method arguments can be either Java primitives or the corresponding Writable class.    //  ！！推荐参数使用mapReduce 的类型    public Text evaluate(Text str) &#123;        //void data         if(str.toString() == null) &#123;            return null;        &#125;        //lower        return new Text(str.toString().toLowerCase());    &#125;    //用于测试，Hive 的入口函数是 evaluate 所以没有影响    public static void main(String[] args) &#123;        System.out.println(new LowerUDF().evaluate(new Text(&quot;Hive&quot;)));    &#125;&#125;</code></pre><p>####3.在 Hive 中使用自定义函数</p><pre><code># 添加 jar 到资源库中add jar /opt/datas/filename.jar# 创建临时函数create temporary function my_lower as &quot;com.cenzhongman.hive.udf.LowerUDF&quot;;# 查看函数，确认添加成功show functions;# 使用函数select my_lower(job) Upper_job from emp;</code></pre><p>####As of Hive 0.13, UDFs also have the option of being able to specify required jars in the CREATE FUNCTION statement:<br>####对于新版本，有一种新的打开方式(文件需在HDFS文件系统上)</p><pre><code>CREATE FUNCTION myfunc AS &#39;myclass&#39; USING JAR &#39;hdfs:///path/to/jar&#39;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive 压缩技术Data Compression</title>
    <link href="/07-Bigdata/11-Hive/Hive%20%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AFData%20Compression/"/>
    <url>/07-Bigdata/11-Hive/Hive%20%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AFData%20Compression/</url>
    
    <content type="html"><![CDATA[<p>####Mapreducwe 执行流程 ：input &gt; map &gt; shuffle &gt; reduce &gt; output<br>####压缩执行时间，map 之后，压缩，数据存储在本地磁盘，减少磁盘IO，减少网络带宽。</p><p>###1.常见压缩技术<br>####压缩格式    bzip2    gzip    lzo     snappy<br>####压缩比        bzip2 &gt;    gzip  &gt;    lzo  |     snappy         bzip2     最节省空间<br>####解压速度   sanppy | lzo   &gt;    gzip &gt;    bzip2        lzo|sanppy 最解压快<br>    综合考虑，其实是为了节省CPU，lzo 和 snappy 更符合需求，但是，由于 snappy 出生名门(Google开源产品)<br>####数据后的数据要具有可分割性，就是可以切开来，每一个块单独解压使用 splittability</p><p>###2.压缩位置说明<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170715234439759-1271088265.png"><br>###3.支持包<br>snappy     : org.apache.hadoop.io.compress.SnappyCodec<br>lzo     : org.hadoop.compression.loz.LozCodec    </p><p>###4.mapreduce 中的压缩配置<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170715234535353-1955045968.png"></p><p>###5.Hive 中的压缩配置<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170715234540775-2012395020.png"></p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive 数据实战</title>
    <link href="/07-Bigdata/11-Hive/Hive%20%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98/"/>
    <url>/07-Bigdata/11-Hive/Hive%20%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>##需求</p><ul><li>remote_addr 用户IP<br>  1.用于根据地址确认区域<br>  2.用于统计来自同一个（外网）用户的访问数量</li><li>time_local 用户访问时间<br>  1.分析用户访问时间段<br>  2.合理安排客服上班时间</li><li>request 用户请求的URL<br>  1.统计用户最感兴趣的内容<br>  2.用户最容易发现的区域/内容</li><li>http_referer 用户跳转过来的网站<br>  1.了解客户的来源<br>  2.统计广告投放</li></ul><p>##一、创建原表</p><ul><li>数据存储格式 默认：TEXTFILE</li><li>数据压缩 默认：ZLIB</li><li>map output 数据压缩 none</li><li>默认：管理表</li></ul><p>####创建原表 bf_log_src</p><pre><code>drop table if exists default.bf_log_src;create table if not exists default.bf_log_src(remote_addr string,remote_user string,time_local string,request string,status string,body_bytes_send string,request_body string,http_referer string,http_user_agent string,http_x_forworded_for string,host string)ROW FORMAT SERDE &#39;org.apache.hadoop.hive.contrib.serde2.RegexSerDe&#39;WITH SERDEPROPERTIES (&quot;input.regex&quot; = &quot;(\&quot;[^ ]*\&quot;) (\&quot;[^ ]*\&quot;) (\&quot;[^\&quot;]*\&quot;) (\&quot;[^\&quot;]*\&quot;) (\&quot;[0-9]*\&quot;) (\&quot;[0-9]*\&quot;) ([^ ]*) (\&quot;[^ ]*\&quot;) (\&quot;[^\&quot;]*\&quot;) (\&quot;[^ ]*\&quot;) (\&quot;[^ ]*\&quot;)&quot;);</code></pre><p>####加载数据</p><pre><code>load data local inpath &#39;/opt/datas/bf.log&#39; into table bf_log_src;</code></pre><p>##二、根据业务需求创建子表</p><ul><li>数据存储格式 ORCfile | parquet</li><li>数据压缩 snappy</li><li>map output 数据压缩 snappy</li><li>外部表</li><li>分区表</li></ul><p>####创建子表 bf_log_comm</p><pre><code>drop table if exists default.bf_log_comm;create EXTERNAL table if not exists default.bf_log_comm(remote_addr string,time_local string,request string,http_referer string)ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39; stored as orc location &#39;/user/hive/warehouse/bf_log_comm/&#39; tblproperties (&quot;orc.compression&quot;=&quot;snappy&quot;) ;</code></pre><p>####加载数据</p><pre><code>insert into table default.bf_log_comm select remote_addr,time_local,request,http_referer from default.bf_log_src;</code></pre><p>##三.数据清洗<br>###3.1 删除引号<br>###3.2 更改日期<br>定义方法参考：<a href="http://www.cnblogs.com/cenzhongman/p/7182725.html">Hive 中的 UDF</a></p><pre><code>注意：输入数据类型定义为Text会导致编码错误，改为String即可解决问题# 添加正则表达式支持包add jar /opt/softwares/hive-1.2.2/lib/hive-contrib-1.2.2.jar;# 添加 UDF jar 包add jar /opt/datas/RemoveDoubleQuotationMarks.jar;# 创建临时方法create temporary function my_rm_marks as &quot;com.cenzhongman.hive.udf.RemoveDoubleQuotationMarks&quot;;create temporary function ChangeDate as &quot;com.cenzhongman.hive.udf.ChangeDate&quot;;</code></pre><p>####替换数据</p><pre><code>insert overwrite table default.bf_log_comm select my_rm_marks(remote_addr),ChangeDate(my_rm_marks(time_local)),my_rm_marks(request),my_rm_marks(http_referer) from default.bf_log_src;</code></pre><p>##四、使用自带函数分析数据</p><pre><code>desc function extended substring ;#分析时间段select t.hour,count(*) cnt from (select substring(time_local,9,2) hour from bf_log_comm) t group by t.hour order by cnt desc;#分析IP地址select t.pre_ip,count(*) cnt from (select substring(remote_addr,1,7) pre_ip from bf_log_comm) t group by t.pre_ip order by cnt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive 表数据的存储和压缩格式</title>
    <link href="/07-Bigdata/11-Hive/Hive%20%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F/"/>
    <url>/07-Bigdata/11-Hive/Hive%20%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>###<a href="https://cwiki.apache.org/confluence/display/Hive/SerDe">SerDe</a><br>    * 按行存储<br>    * 按列存储</p><pre><code>file_format:  :   | SEQUENCEFILE    序列化(行存储)  | TEXTFILE          文本格式(行存储)- (Default, depending on hive.default.fileformat configuration)  | RCFILE            列式存储文件(列存储)- (Note: Available in Hive 0.6.0 and later)  | ORC       常用     优化列式存储文件(列存储)- (Note: Available in Hive 0.11.0 and later)  | PARQUET   常用    (列存储)- (Note: Available in Hive 0.13.0 and later)  | AVRO             - (Note: Available in Hive 0.14.0 and later)  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</code></pre><p><img src="https://cwiki.apache.org/confluence/download/attachments/31818911/OrcFileLayout.png?version=1&modificationDate=1366430304000&api=v2"><br>ORC列存储结构如图所示，个人理解：每一个字段存为一列，index data 保存了最大值和最小值，只有当索引范围合适时，才去扫描对应的列数据查找匹配项<br>As shown in the diagram, each stripe in an ORC file holds index data, row data, and a stripe footer.</p><p>The <strong>stripe footer</strong> contains a directory of stream locations. <strong>Row data</strong> is used in table scans.</p><p><strong>Index data</strong> includes min and max values for each column and the row positions within each column.<strong>索引数据</strong>包含了对应的 列(column)数据 的最大值和最小值，以及列中数据的相应行的位置。 Row index entries provide offsets that enable seeking to the right compression block and byte within a decompressed block.  Note that ORC indexes are used only for the selection of stripes and row groups and not for answering queries.</p><p>###<a href="https://zh.hortonworks.com/blog/orcfile-in-hdp-2-better-compression-better-performance/">来自 hortonworks 的性能评估</a></p><p>###二、各种数据存储格式比较<br>For example, creating an ORC stored table without compression:</p><p>####官网例子</p><pre><code>create table Addresses (  name string,  street string,  city string,  state string,  zip int) stored as orc tblproperties (&quot;orc.compress&quot;=&quot;NONE&quot;);</code></pre><p>###个人测试用例：TEXTFILE</p><pre><code>create table bf_log(user_ip string,a string,time string,get2host string,status1 string,status2 string,b string,from_url string,equipment_info string,c string,url_now string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39; stored as TEXTFILE;</code></pre><p>####导入数据</p><pre><code>load data local inpath &#39;/opt/datas/xxx.log&#39; into table bf_log;</code></pre><p>####数据大小</p><pre><code>2.0 M  /user/hive/warehouse/bf_log_orc/moodle.ibeifeng.access.log</code></pre><p>###使用 ORC 存储</p><pre><code>create table bf_log_orc(user_ip string,a string,time string,get2host string,status1 string,status2 string,b string,from_url string,equipment_info string,c string,url_now string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39; stored as orc;</code></pre><p>####导入数据</p><pre><code>insert into table bf_log_orc select * from bf_log;</code></pre><p>####数据大小</p><pre><code>62.5 K  /user/hive/warehouse/bf_log_orc/000000_0</code></pre><p>###使用 PARQUET</p><pre><code>create table bf_log_parquet(user_ip string,a string,time string,    get2host string,status1 string,status2 string,b string,from_url string,    equipment_info string,c string,url_now string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39; stored as PARQUET;</code></pre><p>####导入数据</p><pre><code>insert into table bf_log_parquet select * from bf_log;</code></pre><p>####数据大小</p><pre><code>360.1 K  /user/hive/warehouse/bf_log_parquet/000000_0</code></pre><p>###三、进行数据文件的压缩(主要只支持三种，详情见底部图片)<br>####1.查看支持的数据压缩格式</p><pre><code>cen@hostname-ubuntu:/opt/softwares/hadoop-2.8.0$ bin/hadoop checknative17/07/17 05:34:32 INFO bzip2.Bzip2Factory: Successfully loaded &amp; initialized native-bzip2 library system-native17/07/17 05:34:32 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib libraryNative library checking:hadoop:  true /opt/softwares/hadoop-2.8.0/lib/native/libhadoop.so.1.0.0zlib:    true /lib/x86_64-linux-gnu/libz.so.1snappy:  true /usr/lib/x86_64-linux-gnu/libsnappy.so.1lz4:     true revision:10301bzip2:   true /lib/x86_64-linux-gnu/libbz2.so.1openssl: true /usr/lib/x86_64-linux-gnu/libcrypto.so</code></pre><p>####2.使用 snappy 压缩</p><pre><code>create table bf_log_orc_snappy(user_ip string,a string,time string,    get2host string,status1 string,status2 string,b string,from_url string,    equipment_info string,c string,url_now string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39; stored as PARQUET tblproperties (&quot;orc.compress&quot;=&quot;snappy&quot;);</code></pre><p>####导入数据</p><pre><code>insert into table bf_log_orc_snappy select * from bf_log;</code></pre><p>####数据大小</p><pre><code>360.1 K  /user/hive/warehouse/bf_log_orc_snappy/000000_0#！！！什么？居然搞大了，为什么？#因为原本默认使用的是 ZLIB (接近bzip2)压缩</code></pre><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170717210643441-2021656590.png"><br><a href="https://zh.hortonworks.com/blog/orcfile-in-hdp-2-better-compression-better-performance/">图片来源</a></p><p>###四、总结</p><p><strong>最常用的解决方案：</strong></p><ul><li>数据格式：orc | parquet</li><li>压缩格式：sanppy</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HiveServer2</title>
    <link href="/07-Bigdata/11-Hive/HiveServer2/"/>
    <url>/07-Bigdata/11-Hive/HiveServer2/</url>
    
    <content type="html"><![CDATA[<p>###<a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients">HiveServer2</a><br>###一、启动 Hiveserver2  一个Server</p><p>###二、连接HiveServer2<br>####1.通过启动 Beeline    一个Client<br>#####1.1从 Beeline 通过 JDBC 连接 Hiveserver2</p><pre><code>!connect jdbc:hive2://hostname-ubuntu:10000 cen ubuntu</code></pre><p>#####1.2或者，通过参数链接</p><pre><code>bin/beeline -u !connect jdbc:hive2://hostname-ubuntu:10000 cen ubuntu</code></pre><p>####2.通过JDBC链接<br>参考官方文档。。。</p><pre><code>Connection con = DriverManager.getConnection(&quot;jdbc:hive2://hostname-ubuntu.cenzhongman.com:10000/emplo&quot;, &quot;cen&quot;, &quot;ubuntu&quot;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive是什么</title>
    <link href="/07-Bigdata/11-Hive/Hive%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/11-Hive/Hive%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>Hive用于对数据进行ETL(extract/tranform/load) </p><pre><code>1.load file data to database          E2.使用select / python 进行转换     T3.数据转换后在sub表中                 L</code></pre><p><a href="https://hive.apache.org/">Hive官方网站</a><br><a href="https://cwiki.apache.org/confluence/display/Hive/Gettingstarted">Gettingstarted</a><br><img src="https://hive.apache.org/images/hive_logo_medium.jpg"><br>The Apache Hive ™ data warehouse software facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. Structure can be projected onto data already in storage. A command line tool and JDBC driver are provided to connect users to Hive.<br>Apache Hiva 数据仓库软件便于使用SQL语句读,写,和管理分布式存储大型数据集。该结构可以投射到已经存在的仓库中。提供了一个命令行工具和JDBC驱动程序将用户连接到Hive。<br>##（重点）通俗地说：<strong>Hive是Hadoop三大原始框架的上层封装，将结构化的数据文件映射成一张表，并通过HiveQL(HQL)查询功能</strong><br><strong>处理的数据存储在HDFS中</strong><br><strong>分析数据的底层实现MapReduce</strong><br><strong>执行程序运行在YARN上</strong></p><p>##Hive架构（重点）<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170712112821400-1917701229.png"></p><pre><code>Client:用户接口    1.CLI:Hive shell    2.JDBC/ODBC    3.WebUI:浏览器访问Meta store:存储元数据信息，默认存储在自带的DerBy数据库中， 推荐使用MySQL存储Metastore    1.表名    2.所属数据库，默认是Default    3.拥有者    4.字段    5.表的类型    6.数据所在目录Dirver:驱动，包含以下三个部分，将SQL语句转换成MapReduce程序    1.SQL Parser:SQL语句解析    2.Query Optimizer:查询优化    3.Physical Plan:物理计划    4.Execution:执行物理计划</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive数据导入导出的n种方式</title>
    <link href="/07-Bigdata/11-Hive/Hive%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9A%84n%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/07-Bigdata/11-Hive/Hive%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%9A%84n%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>###<a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial#Tutorial-LoadingData">Tutorial-LoadingData</a><br>###Hive加载数据的6种方式</p><pre><code>#格式load data [local] inpath &#39;/op/datas/xxx.txt&#39; [overwrite] into table tablename [partition (partcol1 = val1,partcol2 = val2)];1.从本地文件系统加载load data local inpath &#39;/opt/datas/xxx.txt&#39; into table tablename;2.从 hdfs 加载（相当于移动，原来的位置文件会被删除）load data inpath &#39;/user/cen/datas/xxx.txt&#39; into table tablename;3.覆盖加载load data inpath &#39;/user/cen/datas/xxx.txt&#39; overwrite into table tablename;4.创建表时候 select 加载create table tablename as select * form tablename2;        4.insert加载(两种方式等价)create table tablename like tablename2;insert into table tablename select * from tablename2;5.创建表时候指定location加载CREATE EXTERNAL TABLE page_view_stg(viewTime INT, userid BIGINT,                page_url STRING, referrer_url STRING,                ip STRING COMMENT &#39;IP Address of the User&#39;,                country STRING COMMENT &#39;country of origination&#39;)COMMENT &#39;This is the staging page view table&#39;ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;44&#39; LINES TERMINATED BY &#39;12&#39;STORED AS TEXTFILELOCATION &#39;/user/data/staging/page_view&#39;;hadoop dfs -put /tmp/pv_2008-06-08.txt /user/data/staging/page_view</code></pre><p>###Hive数据导出</p><pre><code>1.指定本地系统文件导出insert  overwrite local directory &#39;/opt/datas/hive_exp_emp&#39;ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39;select * from tablename;2.指定 hdfs 文件系统目录insert  overwrite directory &#39;/user/cen/output&#39;ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39; &#39;select * from tablename;3.通过 hive -e/-f 执行SQL语句，并将结果指向文件(默认分隔符为&#39;/t&#39;)bin/hive -e &quot;select * from databasename.tablename;&quot; &gt; /opt/datas/hive_exp_emp/exp.txt4.sqoophdfs/hive &gt; rdbmsrdbms &gt; hdfs/hive/hbase</code></pre><p>###import和export(数据备份)<br><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ImportExport">import export</a><br>注意是hdfs文件系统目录，其他的文档说明的很详细，属于DML</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive环境搭建及基本操作</title>
    <link href="/07-Bigdata/11-Hive/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/07-Bigdata/11-Hive/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>##伪分布式<br>###一、安装及配置Hive<br>####1.配置HADOOP_HOME和Hive conf 目录hive-env.sh</p><pre><code># Set HADOOP_HOME to point to a specific hadoop install directoryHADOOP_HOME=/opt/softwares/hadoop-2.8.0# Hive Configuration Directory can be controlled by:export HIVE_CONF_DIR=/opt/softwares/hive-1.2.2/conf</code></pre><p>####2.在HDFS文件系统中创建两个目录并为同组用户添加执行权限<br>####In addition, you must use below HDFS commands to create /tmp and /user/hive/warehouse (aka hive.metastore.warehouse.dir) and set them chmod g+w before you can create a table in Hive</p><pre><code>$ $HADOOP_HOME/bin/hadoop fs -mkdir       /tmp $ $HADOOP_HOME/bin/hadoop fs -mkdir       /user/hive/warehouse $ $HADOOP_HOME/bin/hadoop fs -chmod g+w   /tmp $ $HADOOP_HOME/bin/hadoop fs -chmod g+w   /user/hive/warehouse</code></pre><p>####3.运行Hive shell(CLI)<br>###！！！必须在HDFS启动之后启动Hive</p><pre><code>$ $HIVE_HOME/bin/hive</code></pre><p>####4.HQL操作</p><pre><code>show databases ;use/create default;show tables;#显示表信息desc student;#显示表详细信息desc extended student;#显示表格式化后的详细信息desc formatted student;create table student(id int, name string)ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;\t&#39;;     # 行格式分隔的字段以“t”结尾load data local inpath &#39;/opt/datas/test&#39; into table databaseName.student;                    # 从本地文件导入数据到表中，数据库名可以加可以不加，跟手动 put 是一样的select * from student;select id form student;show functions;desc function xxx;                    #注意没有sdesc function extended xxx;            #详细#显示帮助#/bin/hive -help#启动时设置配置信息bin/hive --hiveconf &lt;property=value&gt;#!!!在Hive中操作文件dfs系统dfs -cp xxx xxx;#!!!在Hivez中操作本地文件系统!ls /opt/datas</code></pre><p>###二、安装MySQL<br>    1. sudo apt-get install mysql-server</p><pre><code>2. sudo apt-get isntall mysql-client3. sudo apt-get install libmysqlclient-dev4. service mysql start5. mysql -uroot -p6. 在数据库中将root的Hostname改成%,允许所有人登录，所有IP</code></pre><p>###三、在Hive中配置MySQL作为元数据存储数据库，Metastore<br>    1.拷贝MySQL的驱动Java包(mysql-connector下的jar包)到HIVE-HOME/lib下</p><pre><code>2.添加配置文件hive-site.xml(hive-default.xml.template的复刻版)3.添加并修改连接数据库需要的四个配置&lt;property&gt;  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;  &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;  &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;  &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;  &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;  &lt;value&gt;root&lt;/value&gt;  &lt;description&gt;Username to use against metastore database&lt;/description&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;  &lt;value&gt;ubuntu&lt;/value&gt;  &lt;description&gt;password to use against metastore database&lt;/description&gt;&lt;/property&gt;&lt;!--显示头信息和当前数据库名--&gt;&lt;property&gt;  &lt;name&gt;hive.cli.print.header&lt;/name&gt;  &lt;value&gt;true&lt;/value&gt;  &lt;description&gt;Whether to print the names of the columns in query output.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.cli.print.current.db&lt;/name&gt;  &lt;value&gt;true&lt;/value&gt;  &lt;description&gt;Whether to include the current database in the Hive prompt.&lt;/description&gt;&lt;/property&gt;</code></pre>  </configuration><p>###四、各种信息的设置位置说明<br>    1.数据仓库存储位置<br>        *由1.2.2可知，默认为/user/hive/warehouse<br>        *配置在hive.default中<br>              <property><br>                <name>hive.metastore.warehouse.dir</name><br>                <value>/user/hive/warehouse</value><br>                <description>location of default database for the warehouse</description><br>              </property><br>        *在仓库目录下每一个数据库一个文件夹(default除外)        DirName = databaseName.db<br>        *default下的表也作为一个文件夹在默认路径下存储起来        DirName = tableName<br>    2.配置log目录(非必要)<br>        *默认路径/tmp/username/hive.log<br>        *修改conf/hive-log4j.properties文件<br>    3.日志显示级别<br>        *修改conf/hive-log4j.properties文件<br>        *hive.root.logger = INFO/DEBUG,DRFA/console<br>    4.在命令行显示当前数据库以及表头信息<br>        *三中有涉及<br>    5.启动时设置配置信息<br>        *bin/hive –hiveconf &lt;property=value&gt;<br>    6.查看当前所有配置信息<br>        *hive &gt; set ;<br>        *hive &gt; set key = value ;    #临时设置一个值<br>    7.执行历史记录<br>        ~/.hivehistory</p><p>###五、hive的参数</p><pre><code>cen@hostname-ubuntu:/opt/softwares/hive-1.2.2$ bin/hive -helpusage: hive -d,--define &lt;key=value&gt;          Variable subsitution to apply to hive         -d 定义一个值                                  commands. e.g. -d A=B or --define A=B    --database &lt;databasename&gt;     Specify the database to use -e &lt;quoted-query-string&gt;         SQL from command line                         -e 单行查询语句 -f &lt;filename&gt;                    SQL from files                                 -f SQL文件 -H,--help                        Print help information                        -help 显示帮助    --hiveconf &lt;property=value&gt;   Use value for given property                     -hiveconf 临时配置hive    --hivevar &lt;key=value&gt;         Variable subsitution to apply to hive         -hivevar                                   commands. e.g. --hivevar A=B -i &lt;filename&gt;                    Initialization SQL file                         -i 初始化的SQL文件，udf相关 -S,--silent                      Silent mode in interactive shell -v,--verbose                     Verbose mode (echo executed SQL to the                                  console)#查询结果保存到文件中bin/hiva -e &quot;select * from student;&quot; &gt; /opt/datas/hive-res.txt</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hive-pom.xml.html</title>
    <link href="/07-Bigdata/11-Hive/hive-pom.xml/"/>
    <url>/07-Bigdata/11-Hive/hive-pom.xml/</url>
    
    <content type="html"><![CDATA[<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><modelVersion>4.0.0</modelVersion><groupId>com.cenzhongman</groupId><artifactId>hive</artifactId><version>0.0.1-SNAPSHOT</version><packaging>jar</packaging><name>hive</name><url>http://maven.apache.org</url><properties><project.build.sourceEncoding>UTF-8</project.build.sourceEncoding></properties><dependencies><dependency><groupId>junit</groupId><artifactId>junit</artifactId><version>3.8.1</version><scope>test</scope></dependency><dependency><groupId>org.apache.hadoop</groupId><artifactId>hadoop-hdfs</artifactId><version>2.8.0</version></dependency><dependency><groupId>org.apache.hadoop</groupId><artifactId>hadoop-client</artifactId><version>2.8.1</version></dependency><dependency><groupId>org.apache.hadoop</groupId><artifactId>hadoop-common</artifactId><version>2.8.0</version></dependency><dependency><groupId>org.apache.hive</groupId><artifactId>hive-jdbc</artifactId><version>1.2.2</version></dependency><dependency><groupId>org.apache.hive</groupId><artifactId>hive-exec</artifactId><version>1.2.2</version></dependency></dependencies></project>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01Kafka是什么</title>
    <link href="/07-Bigdata/13-Kafka/01Kafka%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/07-Bigdata/13-Kafka/01Kafka%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka是什么"><a href="#Kafka是什么" class="headerlink" title="Kafka是什么"></a>Kafka是什么</h1><p><img src="http://kafka.apache.org/images/logo.png"></p><p>Kafka是领英开源的分布式流式消息队列系统，快速，可拓展，容错。</p><p>Kafka® is used for building real-time data pipelines and streaming apps. It is horizontally scalable, fault-tolerant, wicked fast, and runs in production in thousands of companies.</p><p><img src="01-01.png"><br><img src="http://kafka.apache.org/0110/images/kafka-apis.png"></p><p>通过<a href="http://kafka.apache.org/intro.html">四个API</a>与程序交互</p><p>依赖Zookeeper存贮配置数据等。包括kafka的信息和消费之的信息，都存在Zookeeper中。</p><p>kafka是scala语言编写的。</p><ul><li>broker 每一个节点就是一个broker</li></ul><h2 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h2><h3 id="首先要安装好Zookeeper"><a href="#首先要安装好Zookeeper" class="headerlink" title="首先要安装好Zookeeper"></a>首先要安装好Zookeeper</h3><h3 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h3><p>1.复制Zookeeper的依赖包到kafka的libs路径下</p><pre><code class="hljs sh">rm <span class="hljs-variable">$KAFKA_HOME</span>/libs/zookeeper*.jarcp <span class="hljs-variable">$ZOOKEEPER_HOME</span>/*.jar</code></pre><p>2.编辑<code>server.properties</code></p><pre><code class="hljs sh"><span class="hljs-comment"># 在分布式部署中，唯一要变的值，每一个编号要唯一</span>broker.id=?listeners=PLAINTEXT://ubuntu:9092log.dirs=zookeeper.connect=ubuntu:2181</code></pre><p>3.启动zookeeper</p><pre><code class="hljs sh"><span class="hljs-comment"># 这个暂时没有配置，咱们后面会配置，目前使用的是已经启动的Zookeeper</span>bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>4.启动kafka</p><pre><code class="hljs sh">bin/kafka-server-start.sh config/server.properties</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="创建一个Topic"><a href="#创建一个Topic" class="headerlink" title="创建一个Topic"></a>创建一个Topic</h3><p>1.创建topic</p><pre><code class="hljs sh">bin/kafka-topics.sh --create --zookeeper ubuntu:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in">test</span></code></pre><p>2.列举topic</p><pre><code class="hljs sh">bin/kafka-topics.sh --list --zookeeper ubuntu:2181</code></pre><h3 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h3><pre><code class="hljs sh">bin/kafka-console-producer.sh --broker-list ubuntu:9092 --topic <span class="hljs-built_in">test</span></code></pre><h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><pre><code class="hljs sh">bin/kafka-console-consumer.sh --bootstrap-server ubuntu:9092 --topic <span class="hljs-built_in">test</span> --from-beginning</code></pre><hr><p>更多数据源，请参阅下一个文档。</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>13-Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02更多输入和输出源</title>
    <link href="/07-Bigdata/13-Kafka/02%E6%9B%B4%E5%A4%9A%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%BA%90/"/>
    <url>/07-Bigdata/13-Kafka/02%E6%9B%B4%E5%A4%9A%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka中更多的数据源"><a href="#Kafka中更多的数据源" class="headerlink" title="Kafka中更多的数据源"></a>Kafka中更多的数据源</h1><p><a href="http://kafka.apache.org/0102/documentation.html#quickstart_kafkaconnect">Use Kafka Connect to import/export data</a></p><h2 id="file-to-file"><a href="#file-to-file" class="headerlink" title="file to file"></a>file to file</h2><p>!!一定要先把kafka服务启动起来</p><p>1.创建源文件</p><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;foo\nbar&quot;</span> &gt; test.txt</code></pre><p>kakfa是通过三个配置文件来确定所运行的输入输出的connector的配置的，我们可以通过<code>ll config/</code>看一下关于<code>connector</code>的信息</p><pre><code class="hljs sh">connect-console-sink.propertiesconnect-console-source.propertiesconnect-distributed.propertiesconnect-file-sink.propertiesconnect-file-source.propertiesconnect-log4j.propertiesconnect-standalone.properties</code></pre><p>2.创建standalone的文件订阅系统</p><pre><code class="hljs sh">bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</code></pre><p>3.查看输出</p><pre><code class="hljs sh">cat test.sink.txt</code></pre><p>4.查看存在kafka中的数据</p><pre><code class="hljs sh">bin/kafka-console-consumer.sh --bootstrap-server ubuntu:9092 --topic connect-test --from-beginning</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>13-Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03与spark集成</title>
    <link href="/07-Bigdata/13-Kafka/03%E4%B8%8Espark%E9%9B%86%E6%88%90/"/>
    <url>/07-Bigdata/13-Kafka/03%E4%B8%8Espark%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="解决依赖问题"><a href="#解决依赖问题" class="headerlink" title="解决依赖问题"></a>解决依赖问题</h1><h3 id="复制依赖包四个"><a href="#复制依赖包四个" class="headerlink" title="复制依赖包四个"></a>复制依赖包四个</h3><pre><code class="hljs sh"><span class="hljs-comment"># 编译路径下的/external/kafka/target/路径下</span>spark-streaming-kafka_2.10-1.6.0.jar<span class="hljs-comment"># kafka/libs/路径下</span>kafka_2.10-0.10.2.1.jarkafka-clients-0.10.2.1.jarzkclient-0.10.jarmetrics-core-2.2.0.jar</code></pre><h3 id="启动spark-shell"><a href="#启动spark-shell" class="headerlink" title="启动spark-shell"></a>启动spark-shell</h3><pre><code class="hljs sh">bin/spark-shell --jars \/home/cen/softwares/apache/spark-1.6.0-bin-without-hadoop/externallib/kafka_2.10-0.10.2.1.jar,/home/cen/softwares/apache/spark-1.6.0-bin-without-hadoop/externallib/kafka-clients-0.10.2.1.jar,/home/cen/softwares/apache/spark-1.6.0-bin-without-hadoop/externallib/spark-streaming-kafka_2.10-1.6.0.jar,/home/cen/softwares/apache/spark-1.6.0-bin-without-hadoop/externallib/zkclient-0.10.jar</code></pre><h3 id="spark程序"><a href="#spark程序" class="headerlink" title="spark程序"></a><a href="https://github.com/apache/spark/blob/v1.6.0/external/kafka/src/main/scala/org/apache/spark/streaming/kafka/KafkaUtils.scala">spark程序</a></h3><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.streaming._<span class="hljs-keyword">import</span> org.apache.spark.streaming.kafka._<span class="hljs-comment">//val conf = new SparkConf().setMaster(&quot;local[2]&quot;).setAppName(&quot;KafkaWordCount&quot;)</span><span class="hljs-comment">//val ssc = new StreamingContext(conf, Seconds(5))//方式一：直接使用SparkConf创建</span><span class="hljs-keyword">val</span> ssc = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingContext</span>(sc, <span class="hljs-type">Seconds</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//方式二：使用已经存在的SparkContext创建(常用于Spark-Shell测试开发)</span>ssc.checkpoint(<span class="hljs-string">&quot;checkpoint&quot;</span>)<span class="hljs-comment">//3.设置数据源</span><span class="hljs-keyword">val</span> topicMap = <span class="hljs-type">Map</span>(<span class="hljs-string">&quot;share&quot;</span> -&gt; <span class="hljs-number">1</span>)<span class="hljs-keyword">val</span> lines = <span class="hljs-type">KafkaUtils</span>.createStream(ssc, <span class="hljs-string">&quot;ubuntu:2181&quot;</span>, <span class="hljs-string">&quot;spark-program&quot;</span>, topicMap).map(_._2)lines.print()<span class="hljs-comment">//5.启动</span>ssc.start()             <span class="hljs-comment">// Start the computation</span>ssc.awaitTermination()  <span class="hljs-comment">// Wait for the computation to terminate</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>13-Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04kafka调优</title>
    <link href="/07-Bigdata/13-Kafka/04kafka%E8%B0%83%E4%BC%98/"/>
    <url>/07-Bigdata/13-Kafka/04kafka%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="可以调优的地方"><a href="#可以调优的地方" class="headerlink" title="可以调优的地方"></a>可以调优的地方</h1><p><img src="04-01.png"></p><ul><li>producer<ul><li>acks</li><li>buffer mamery</li><li>compression.type      snappy</li><li>retries</li><li>batch.size            重要，数据的条数</li></ul></li><li>broker<ul><li>message.max.bytes     调节单次消息最大数默认为1M，可以调2M</li><li>num.io.threads        IO线程数</li><li>num.network.threads   网络线程数</li></ul></li><li>consumer<br>  * </li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>13-Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-什么是Zookeeper</title>
    <link href="/07-Bigdata/14-Zookeeper/01-%E4%BB%80%E4%B9%88%E6%98%AFZookeeper/"/>
    <url>/07-Bigdata/14-Zookeeper/01-%E4%BB%80%E4%B9%88%E6%98%AFZookeeper/</url>
    
    <content type="html"><![CDATA[<p><a href="http://zookeeper.apache.org/doc/r3.4.10/zookeeperOver.html">官方文档</a><br>###ZooKeeper: A Distributed Coordination Service for Distributed Applications<br>###ZooKeeper:一个开源的分布式的，为分布式应用提供协调服务的应用</p><p>ZooKeeper is a distributed, open-source coordination service for distributed applications. It exposes a simple set of primitives that distributed applications can build upon to implement higher level services for synchronization同步, configuration配置 maintenance维护, and groups分组 and naming命名. It is designed to be easy to program to, and uses a data model styled after the familiar directory tree structure of file systems. It runs in Java and has bindings for both Java and C.</p><p>###Design Goals<br>###设计目标</p><p><strong>ZooKeeper is simple.简单</strong> ZooKeeper allows distributed processes to coordinate整合 with each other through a shared hierarchal分级的 namespace which is organized similarly to a standard file system. The name space consists构成 of data registers寄存器 - called <strong>znodes</strong>, in ZooKeeper parlance - and these are similar to files and directories. Unlike a typical file system, which is designed for storage, ZooKeeper data is kept in-memory, which means ZooKeeper can acheive high throughput and low latency numbers.</p><p><strong>ZooKeeper is replicated.可重复</strong> Like the distributed processes it coordinates, ZooKeeper itself is intended to be replicated over a sets of hosts called an ensemble.<br><img src="http://zookeeper.apache.org/doc/r3.4.10/images/zkservice.jpg"><br>The servers that make up the ZooKeeper service must all know about each other. They maintain an in-memory image of state, along with a transaction logs and snapshots in a persistent store. As long as a majority of the servers are available, the ZooKeeper service will be available.</p><p>Clients connect to a single ZooKeeper server. The client maintains a TCP connection through which it sends requests, gets responses, gets watch events, and sends heart beats. If the TCP connection to the server breaks, the client will connect to a different server.</p><p><strong>ZooKeeper is ordered.有序的</strong> ZooKeeper stamps each update with a number that reflects the order of all ZooKeeper transactions. Subsequent operations can use the order to implement higher-level abstractions, such as synchronization primitives.</p><p><strong>ZooKeeper is fast.快速</strong>It is especially fast in “read-dominant” workloads. ZooKeeper applications run on thousands of machines, and it performs best where reads are more common than writes, at ratios of around 10:1.</p><p>###Data model and the hierarchical namespace<br>###数据结构和分等级的命名空间</p><p>The name space provided by ZooKeeper is much like that of a standard file system. A name is a sequence of path elements separated by a slash (/). Every node in ZooKeeper’s name space is identified by a path.<br><img src="http://zookeeper.apache.org/doc/r3.4.10/images/zknamespace.jpg"></p><p>###Zookeper的应用场景<br>终于可以说人话了，好轻松！！<br>Zookeeper从设计模式角度来看，是一个基于<strong>观察者模式设计</strong>的分布式服务管理框架，它负责<strong>存储和管理</strong>大家都关心的数据，然后接收观察者的注册，一旦这些数据发生变化，Zookeeper就负责<strong>通知</strong>已经注册的那些<strong>观察者</strong>做出相应的反应。从而实现类似<strong>Master/Slave管理模式</strong><br>####应用场景(第一句话中就提到了)<br>*统一命名空间<br>*配置管理<br>*集群管理<br>*共享锁(Locks)/同步锁</p>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>14-Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Zookeeper的安装</title>
    <link href="/07-Bigdata/14-Zookeeper/02-Zookeeper%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/07-Bigdata/14-Zookeeper/02-Zookeeper%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>##伪分布式安装</p><h3 id="1-下载ZooKeeper"><a href="#1-下载ZooKeeper" class="headerlink" title="1.下载ZooKeeper"></a>1.下载ZooKeeper</h3><h3 id="2-创建数据文件目录"><a href="#2-创建数据文件目录" class="headerlink" title="2.创建数据文件目录"></a>2.创建数据文件目录</h3><pre><code>$ mkdir -p data/zkData</code></pre><h3 id="3-编辑配置文件"><a href="#3-编辑配置文件" class="headerlink" title="3.编辑配置文件"></a>3.编辑配置文件</h3><pre><code>$ vim conf/zoo.cfgdataDir=/opt/softwares/zookeeper-3.4.9/data/zkData</code></pre><h3 id="4-启动ZookeeperServer"><a href="#4-启动ZookeeperServer" class="headerlink" title="4.启动ZookeeperServer"></a>4.启动ZookeeperServer</h3><pre><code>$ bin/zkServer.sh start</code></pre><h3 id="5-查看状态"><a href="#5-查看状态" class="headerlink" title="5.查看状态"></a>5.查看状态</h3><pre><code>$ bin/zkServer.sh status</code></pre><h3 id="6-启动Zookeeper客户端"><a href="#6-启动Zookeeper客户端" class="headerlink" title="6.启动Zookeeper客户端"></a>6.启动Zookeeper客户端</h3><pre><code>$ bin/zkCli.sh # 常用命令ls create get rmr...</code></pre><h3 id="7-停止Zookeeper"><a href="#7-停止Zookeeper" class="headerlink" title="7.停止Zookeeper"></a>7.停止Zookeeper</h3><pre><code>$ bin/zkServer.sh stop</code></pre><h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><pre><code># 发送心跳包时间间隔tickTime=2000# follower服务器链接leader最长忍受的心跳时间数量initLimit=10# Flower和Leader通信应答忍受时间长度的心跳时间数量syncLimit=5# 保存数据的目录，日志文件默认在此目录dataDir=/opt/softwares/zookeeper-3.4.9/data/zkData# 客户端连接端口号clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60</code></pre><p>##分布式安装</p><h3 id="1-下载ZooKeeper-1"><a href="#1-下载ZooKeeper-1" class="headerlink" title="1.下载ZooKeeper"></a>1.下载ZooKeeper</h3><h3 id="2-创建数据文件目录-1"><a href="#2-创建数据文件目录-1" class="headerlink" title="2.创建数据文件目录"></a>2.创建数据文件目录</h3><pre><code>$ mkdir -p data/zkData</code></pre><h3 id="3-编辑配置文件-1"><a href="#3-编辑配置文件-1" class="headerlink" title="3.编辑配置文件"></a>3.编辑配置文件</h3><pre><code>$ vim conf/zoo.cfgdataDir=/opt/softwares/zookeeper-3.4.9/data/zkData### ### ### ### ### ### ##cluster### ### ### ### ### ### ### ### ##添加服务器ID,主机名和端口    #server.1:IP   hostname:ip地址（已经映射了）   2888: 服务器与集群信息交换端口  3888：万一Leader死了，用新的端口进行选举（仅在选举通知时候进行通信）server.1=hostname-ubuntu.cenzhongman.com:2888:3888server.2=hostname-ubuntu2.cenzhongman.com:2888:3888server.3=hostname-ubuntu3.cenzhongman.com:2888:3888</code></pre><h3 id="4-在数据文件夹下增加id声明文件"><a href="#4-在数据文件夹下增加id声明文件" class="headerlink" title="4.在数据文件夹下增加id声明文件"></a>4.在数据文件夹下增加id声明文件</h3><pre><code>$ touch /opt/softwares/zookeeper-3.4.9/data/zkData/myid$ vim /opt/softwares/zookeeper-3.4.9/data/zkData/myid1</code></pre><h3 id="5-同步文件并修改各自的id"><a href="#5-同步文件并修改各自的id" class="headerlink" title="5.同步文件并修改各自的id"></a>5.同步文件并修改各自的id</h3><h3 id="6-没有统一启动，必须分别启动"><a href="#6-没有统一启动，必须分别启动" class="headerlink" title="6.没有统一启动，必须分别启动"></a>6.没有统一启动，必须分别启动</h3>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>14-Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HBase-site.xml 常见重要配置参数</title>
    <link href="/07-Bigdata/03-Hbase/HBase-site.xml%20%E5%B8%B8%E8%A7%81%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <url>/07-Bigdata/03-Hbase/HBase-site.xml%20%E5%B8%B8%E8%A7%81%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="HBase-常见重要配置参数"><a href="#HBase-常见重要配置参数" class="headerlink" title="HBase 常见重要配置参数"></a>HBase 常见重要配置参数</h2><p><strong>(1) <a href="http://lib.csdn.net/base/hbase" title="Hbase知识库">Hbase</a>.rpc.timeout</strong><br>rpc 的超时时间，默认 60s，不建议修改，避免影响正常的业务，在线上环境刚开始配置的是 3 秒，运行半天后发现了大量的 timeout error，原因是有一个 region 出现了如下问题阻塞了写操作：“Blocking updates … memstore size 434.3m is &gt;= than blocking 256.0m size”可见不能太低</p><p><strong>(2) ipc.socket.timeout</strong>：socket 建立链接的超时时间，应该小于或者等于 rpc 的超时时间，默认为 20s</p><p><strong>(3) <a href="http://lib.csdn.net/base/hbase" title="Hbase知识库">hbase</a>.client.retries.number</strong>：重试次数，默认为 10，可配置为 3</p><p><strong>(4) hbase.client.pause</strong>：重试的休眠时间，默认为 1s，可减少，比如 100ms</p><p><strong>(5) hbase.regionserver.lease.period</strong>：scan 查询时每次与 server 交互的超时时间，默认为 60s，可不调整</p><hr><h2 id="HBase-默认配置参数"><a href="#HBase-默认配置参数" class="headerlink" title="HBase 默认配置参数"></a>HBase 默认配置参数</h2><p><strong>1. hbase.rootdir</strong></p><ul><li>这个目录是 RegionServer 的共享目录，用来持久化 HBase。URL 需要是 “完全正确” 的，还要包含文件系统的 scheme。 例如 “/hbase” 表示 HBase 在 HDFS 中占用的实际存储位置，HDFS 的 NameNode 运行在主机名为 master5 的 8020 端口，则 hbase.rootdir 的设置应为 “hdfs://master5:8020/hbase”。在默认情况下 HBase 是写在 <strong>/tmp</strong> 中的。不修改这个配置的话，数据会在重启的时候丢失。<strong>特别注意的是 hbase.rootdir 里面的 HDFS 地址是要跟 Hadoop 的 core-site.xml 里面的 fs.defaultFS 的 HDFS 的 IP 地址或者域名、端口必须一致。</strong></li><li>默认为 <strong>file:///tmp/hbase-${user.name}/hbase</strong></li></ul><hr><p><strong>2. hbase.cluster.distributed</strong></p><ul><li>HBase 的运行模式。为 false 表示单机模式，为 true 表示分布式模式。若为 false，HBase 和 ZooKeeper 会运行在同一个 JVM 中</li><li>默认值为 <strong>false</strong></li></ul><p><strong>3. hbase.master （hbase.master.port）</strong></p><ul><li>如果只设置单个 Hmaster，那么 hbase.master 属性参数需要设置为 <strong>master5:60000</strong> (主机名:60000)</li><li>如果要设置多个 Hmaster，那么我们<strong>只需要提供端口 60000</strong>，因为选择真正的 master 的事情会有 zookeeper 去处理</li><li>默认端口号：<strong>60000</strong></li></ul><hr><p><strong>4. hbase.tmp.dir</strong></p><ul><li>本地文件系统的临时文件夹。可以修改到一个更为持久的目录上。(/tmp会在重启时清除)</li><li>默认: /<strong>tmp/hbase-${user.name}</strong></li></ul><hr><p><strong>5. hbase.master.info.port</strong></p><ul><li>HBase Master web 界面端口. 设置为 -1 意味着你不想让它运行</li><li>默认: <strong>60010</strong></li></ul><hr><p><strong>6. hbase.master.info.bindAddress</strong></p><ul><li>HBase Master web 界面绑定的端口</li><li>默认: <strong>0.0.0.0</strong></li></ul><hr><p><strong>7. hbase.client.write.buffer</strong></p><ul><li>HTable 客户端的写缓冲的默认大小。这个值越大，需要消耗的内存越大。因为缓冲在客户端和服务端都有实例，所以需要消耗客户端和服务端两个地方的内存。得到的好处是，可以减少 RPC 的次数。可以这样估算服务器端被占用的内存： hbase.client.write.buffer * hbase.regionserver.handler.count</li><li>默认: <strong>2097152 (2G)</strong></li></ul><hr><p><strong>8. hbase.regionserver.port</strong></p><ul><li>HBase RegionServer 绑定的端口</li><li>默认: <strong>60020</strong></li></ul><p><strong>9. hbase.regionserver.info.port</strong></p><ul><li>HBase RegionServer web 界面绑定的端口 设置为 -1 意味这你不想与运行 RegionServer 界面</li><li>默认: <strong>60030</strong></li></ul><hr><p><strong>10. hbase.regionserver.info.port.auto</strong></p><ul><li>Master 或 RegionServer 是否要动态搜一个可以用的端口来绑定界面。当 hbase.regionserver.info.port已经被占用的时候，可以搜一个空闲的端口绑定。这个功能在测试的时候很有用。默认关闭</li><li>默认: <strong>false</strong></li></ul><hr><p><strong>11. hbase.regionserver.info.bindAddress</strong></p><ul><li>HBase RegionServer web 界面的IP地址</li><li>默认: <strong>0.0.0.0</strong></li></ul><hr><p><strong>12. hbase.regionserver.class</strong></p><ul><li>RegionServer 使用的接口。客户端打开代理来连接region server的时候会使用到</li><li>默认: <strong>org.apache.hadoop.hbase.ipc.HRegionInterface</strong></li></ul><hr><p><strong>13. hbase.client.pause</strong></p><ul><li>通常的客户端暂停时间。最多的用法是客户端在重试前的等待时间。比如失败的 get 操作和 region 查询操作等都很可能用到</li><li>默认: <strong>1000</strong> ms</li></ul><hr><p><strong>14. hbase.client.retries.number</strong></p><ul><li>最大重试次数。例如 region 查询，Get 操作，Update 操作等等都可能发生错误，需要重试。这是最大重试错误的值</li><li>默认: <strong>10</strong></li></ul><hr><p><strong>15. hbase.client.scanner.caching</strong></p><ul><li>当调用 Scanner 的 next 方法，而值又不在缓存里的时候，从服务端一次获取的行数。越大的值意味着 Scanner 会快一些，但是会占用更多的内存。当缓冲被占满的时候，next 方法调用会越来越慢。慢到一定程度，可能会导致超时。例如超过了 hbase.regionserver.lease.period</li><li>默认: <strong>1</strong></li></ul><hr><p><strong>16.hbase.client.keyvalue.maxsize</strong></p><ul><li>一个 KeyValue 实例的最大 size。这个是用来设置存储文件中的单个 entry 的大小上界。因为一个 KeyValue 是不能分割的，所以可以避免因为数据过大导致 region 不可分割。明智的做法是把它设为可以被最大 region size 整除的数。如果设置为 0 或者更小，就会禁用这个检查。默认 10MB</li><li>默认: <strong>10485760 (10MB)</strong></li></ul><hr><p><strong>17. hbase.regionserver.lease.period</strong></p><ul><li>客户端租用 HRegion server 期限，即超时阀值。单位是毫秒。默认情况下，客户端必须在这个时间内发一条信息，否则视为死掉。</li><li>默认: <strong>60000</strong></li></ul><hr><p><strong>18. hbase.regionserver.handler.count</strong></p><ul><li>RegionServers 受理的 RPC Server 实例数量。对于 Master 来说，这个属性是 Master 受理的 handler 数量</li><li>默认: <strong>10</strong></li></ul><hr><p><strong>19. hbase.regionserver.msginterval</strong></p><ul><li>RegionServer 发消息给 Master 时间间隔，单位是毫秒</li><li>默认: <strong>3000</strong></li></ul><hr><p><strong>20. hbase.regionserver.optionallogflushinterval</strong></p><ul><li>将 Hlog 同步到 HDFS 的间隔。如果 Hlog 没有积累到一定的数量，到了时间，也会触发同步。默认是 1秒，单位毫秒。</li><li>默认: <strong>1000</strong></li></ul><hr><p><strong>21. hbase.regionserver.regionSplitLimit</strong></p><ul><li>region 的数量到了这个值后就不会在分裂了。这不是一个 region 数量的硬性限制。但是起到了一定指导性的作用，到了这个值就该停止分裂了。默认是 MAX_INT。就是说不阻止分裂。</li><li>默认: <strong>2147483647 (1G)</strong></li></ul><hr><p><strong>22. hbase.regionserver.logroll.period</strong></p><ul><li>提交 commit log 的间隔，不管有没有写足够的值</li><li>默认: <strong>3600000</strong></li></ul><hr><p><strong>23. hbase.regionserver.hlog.reader.impl</strong></p><ul><li>HLog file reader 的实现</li><li>默认: <strong>org.apache.hadoop.hbase.regionserver.wal.SequenceFileLogReader</strong></li></ul><hr><p><strong>24. hbase.regionserver.hlog.writer.impl</strong></p><ul><li>HLog file writer 的实现</li><li>默认: <strong>org.apache.hadoop.hbase.regionserver.wal.SequenceFileLogWriter</strong></li></ul><hr><p><strong>25. hbase.regionserver.thread.splitcompactcheckfrequency</strong></p><ul><li>region server 多久执行一次 split/compaction 检查</li><li>默认: <strong>20000</strong></li></ul><hr><p><strong>26. hbase.regionserver.nbreservationblocks</strong></p><ul><li>储备的内存 block 的数量(译者注:就像石油储备一样)。当发生 out of memory 异常的时候，我们可以用这些内存在 RegionServer 停止之前做清理操作</li><li>默认: <strong>4</strong></li></ul><hr><p><strong>27. hbase.zookeeper.dns.interface</strong></p><ul><li>当使用 DNS 的时候，Zookeeper 用来上报的 IP 地址的网络接口名字</li><li>默认: <strong>default</strong></li></ul><hr><p><strong>28. hbase.zookeeper.dns.nameserver</strong></p><ul><li>当使用 DNS 的时候，Zookeepr 使用的 DNS 的域名或者 IP 地址，Zookeeper 用它来确定和 master 用来进行通讯的域名</li><li>默认: <strong>default</strong></li></ul><hr><p><strong>29. hbase.regionserver.dns.interface</strong></p><ul><li>当使用 DNS 的时候，RegionServer 用来上报的 IP 地址的网络接口名字</li><li>默认: <strong>default</strong></li></ul><hr><p><strong>30. hbase.regionserver.dns.nameserver</strong></p><ul><li>当使用 DNS 的时候，RegionServer 使用的 DNS 的域名或者 IP 地址，RegionServer 用它来确定和 master 用来进行通讯的域名</li><li>默认: <strong>default</strong></li></ul><hr><p><strong>31. hbase.master.dns.interface</strong></p><ul><li>当使用 DNS 的时候，Master 用来上报的 IP 地址的网络接口名字</li><li>默认: <strong>default</strong></li></ul><hr><p><strong>32. hbase.master.dns.nameserver</strong></p><ul><li>当使用 DNS 的时候，RegionServer 使用的 DNS 的域名或者 IP 地址，Master 用它来确定用来进行通讯的域名</li><li>默认: <strong>default</strong></li></ul><p><strong>33. hbase.balancer.period</strong></p><ul><li>Master 执行 region balancer 的间隔</li><li>默认: <strong>300000</strong></li></ul><p><strong>34. hbase.regions.slop</strong></p><ul><li>当任一 regionserver 有 average + (average * slop) 个 region 是会执行 Rebalance</li><li>默认: <strong>0</strong></li></ul><p><strong>35. hbase.master.logcleaner.ttl</strong></p><ul><li>Hlog 存在于.oldlogdir 文件夹的最长时间, 超过了就会被 Master 的线程清理掉</li><li>默认: <strong>600000</strong></li></ul><hr><p><strong>36. hbase.master.logcleaner.plugins</strong></p><ul><li>LogsCleaner 服务会执行的一组 LogCleanerDelegat。值用逗号间隔的文本表示。这些 WAL/HLog cleaners 会按顺序调用。可以把先调用的放在前面。你可以实现自己的 LogCleanerDelegat，加到 Classpath下，然后在这里写 下类的全称。一般都是加在默认值的前面</li><li>默认: <strong>org.apache.hadoop.hbase.master.TimeToLiveLogCleaner</strong></li></ul><hr><p><strong>37. hbase.regionserver.global.memstore.upperLimit</strong></p><ul><li>单个 region server 的全部 memtores 的最大值。超过这个值，一个新的 update 操作会被挂起，强制执行flush操作</li><li>默认: <strong>0.4</strong></li></ul><hr><p><strong>38. hbase.regionserver.global.memstore.lowerLimit</strong></p><ul><li>当强制执行 flush 操作的时候，当低于这个值的时候，flush 会停止。默认是堆大小的 35% . 如果这个值和 hbase.regionserver.global.memstore.upperLimit 相同就意味着当 update 操作因为内存限制被挂起时，会尽量少的执行 flush(译者注:一旦执行 flush，值就会比下限要低，不再执行)</li><li>默认: <strong>0.35</strong></li></ul><hr><p><strong>39. hbase.server.thread.wakefrequency</strong></p><ul><li>service 工作的 sleep 间隔，单位毫秒。 可以作为 service 线程的 sleep 间隔，比如 log roller</li><li>默认: <strong>10000</strong></li></ul><hr><p><strong>40. hbase.hregion.memstore.flush.size</strong></p><ul><li>当 memstore 的大小超过这个值的时候，会 flush 到磁盘。这个值被一个线程每隔 hbase.server.thread.wakefrequency 检查一下</li><li>默认: <strong>67108864 (64MB)</strong></li></ul><hr><p><strong>41. hbase.hregion.preclose.flush.size</strong></p><ul><li>当一个 region 中的 memstore 的大小大于这个值的时候，我们又触发了 close. 会先运行“pre-flush”操作，清理这个需要关闭的 memstore，然后将这个 region 下线。当一个 region 下线了，我们无法再进行任何写操作。如果一个 memstore 很大的时候，flush 操作会消耗很多时间。”pre-flush” 操作意味着在 region 下线之前，会先把 memstore 清空。这样在最终执行 close 操作的时候，flush 操作会很快</li><li>默认: <strong>5242880 (5MB)</strong></li></ul><hr><p><strong>42. hbase.hregion.memstore.block.multiplier</strong></p><ul><li>如果 memstore 有 hbase.hregion.memstore.block.multiplier 倍数的 hbase.hregion.flush.size 的大小，就会阻塞 update 操作。这是为了预防在 update 高峰期会导致的失控。如果不设上 界，flush 的时候会花很长的时间来合并或者分割，最坏的情况就是引发 out of memory 异常。(译者注:内存操作的速度和磁盘不匹配，需要等一等。原文似乎有误)</li><li>默认: <strong>2</strong></li></ul><hr><p><strong>43. hbase.hregion.memstore.mslab.enabled</strong></p><ul><li>体验特性：启用 memStore 分配本地缓冲区。这个特性是为了防止在大量写负载的时候堆的碎片过多。这可以减少 GC 操作的频率。( GC 有可能会 Stop the world )(译者注：实现的原理相当于预分配内存，而不是每一个值都要从堆里分配)</li><li>默认: <strong>false</strong></li></ul><hr><p><strong>44. hbase.hregion.max.filesize</strong></p><ul><li>最大 HStoreFile 大小。若某个 Column families 的 HStoreFile 增长达到这个值，这个 Hegion 会被切割成两个</li><li>默认: <strong>268435456 (256M)</strong></li></ul><hr><p><strong>45. hbase.hstore.compactionThreshold</strong></p><ul><li>当一个 HStore 含有多于这个值的 HStoreFiles (每一个 memstore flush 产生一个 HStoreFile )的时候，会执行一个合并操作，把这 HStoreFiles 写成一个。这个值越大，需要合并的时间就越长</li><li>默认: <strong>3</strong></li></ul><hr><p><strong>46. hbase.hstore.blockingStoreFiles</strong></p><ul><li>当一个 HStore 含有多于这个值的 HStoreFiles (每一个 memstore flush 产生一个 HStoreFile )的时候，会执行一个合并操作，update 会阻塞直到合并完成，直到超过了 hbase.hstore.blockingWaitTime 的值</li><li>默认: <strong>7</strong></li></ul><hr><p><strong>47. hbase.hstore.blockingWaitTime</strong></p><ul><li>hbase.hstore.blockingStoreFiles 所限制的 StoreFile 数量会导致 update 阻塞，这个时间是来限制阻塞时间的。当超过了这个时间，HRegion 会停止阻塞update操作，不过合并还有没有完成。默认为 90s</li><li>默认: <strong>90000</strong></li></ul><hr><p><strong>48. hbase.hstore.compaction.max</strong></p><ul><li>每个“小”合并的 HStoreFiles 最大数量</li><li>默认: <strong>10</strong></li></ul><hr><p><strong>49. hbase.hregion.majorcompaction</strong></p><ul><li>一个 Region 中的所有 HStoreFile 的 major compactions 的时间间隔。默认是 1 天。 设置为 0 就是禁用这个功能</li><li>默认: <strong>86400000</strong></li></ul><hr><p><strong>50. hbase.mapreduce.hfileoutputformat.blocksize</strong></p><ul><li>MapReduce 中 HFileOutputFormat 可以写 storefiles/hfiles。这个值是 hfile 的 blocksize 的最小值。通常在 Hbase写Hfile 的时候，bloocksize 是由 table schema(HColumnDescriptor) 决定的，但是在 mapreduce 写的时候，我们无法获取 schema 中 blocksize。这个值 越小，你的索引就越大，你随机访问需要获取的数据就越小。如果你的 cell 都很小，而且你需要更快的随机访问，可以把这个值调低</li><li>默认: <strong>65536</strong></li></ul><hr><p><strong>51. hfile.block.cache.size</strong></p><ul><li>分配给 HFile/StoreFile 的 block cache 占最大堆(-Xmx setting)的比例。默认是20%，设置为0就是不分配</li><li>默认: <strong>0.2</strong></li></ul><hr><p><strong>52. hbase.hash.type</strong></p><ul><li>哈希函数使用的哈希算法。可以选择两个值:: murmur (MurmurHash) 和 jenkins (JenkinsHash). 这个哈希是给 bloom filters 用的</li><li>默认: <strong>murmur</strong></li></ul><hr><p><strong>53. hbase.master.keytab.file</strong></p><ul><li>HMaster server 验证登录使用的 kerberos keytab 文件路径。(译者注：Hbase 使用 Kerberos实现安全)</li><li>默认: <strong>none</strong></li></ul><hr><p><strong>54. hbase.master.kerberos.principal</strong></p><ul><li>例如. “hbase/<a href="mailto:&#x5f;&#x48;&#79;&#83;&#x54;&#x40;&#x45;&#x58;&#65;&#x4d;&#x50;&#x4c;&#x45;&#x2e;&#x43;&#79;&#x4d;">&#x5f;&#x48;&#79;&#83;&#x54;&#x40;&#x45;&#x58;&#65;&#x4d;&#x50;&#x4c;&#x45;&#x2e;&#x43;&#79;&#x4d;</a>”。 HMaster 运行需要使用 kerberos principal name. principal name 可以在: user/hostname@DOMAIN 中获取. 如果 “_HOST” 被用做 hostname portion，需要使用实际运行的 hostname 来替代它</li><li>默认: <strong>none</strong></li></ul><hr><p><strong>55. hbase.regionserver.keytab.file</strong></p><ul><li>HRegionServer 验证登录使用的 kerberos keytab 文件路径</li><li>默认: <strong>none</strong></li></ul><hr><p><strong>56. hbase.regionserver.kerberos.principal</strong></p><ul><li>例如. “hbase/<a href="mailto:&#95;&#x48;&#79;&#x53;&#84;&#x40;&#x45;&#88;&#x41;&#x4d;&#80;&#76;&#69;&#x2e;&#67;&#79;&#x4d;">&#95;&#x48;&#79;&#x53;&#84;&#x40;&#x45;&#88;&#x41;&#x4d;&#80;&#76;&#69;&#x2e;&#67;&#79;&#x4d;</a>”。HRegionServer 运行需要使用 kerberos principal name. principal name 可以在: user/hostname@DOMAIN 中获取。如果 “_HOST” 被用做 hostname portion，需要使用实际运行的 hostname 来替代它。在这个文件中必须要有一个entry来描述 hbase.regionserver.keytab.file</li><li>默认: <strong>none</strong></li></ul><hr><p><strong>57. zookeeper.session.timeout</strong></p><ul><li>ZooKeeper 会话超时。Hbase 把这个值传递改 zk 集群，向它推荐一个会话的最大超时时间。单位是毫秒</li><li>默认: <strong>180000</strong></li></ul><hr><p><strong>58. zookeeper.znode.parent</strong></p><ul><li>ZooKeeper 中的 Hbase 的根 ZNode。所有的 Hbase 的 ZooKeeper 会用这个目录配置相对路径。默认情况下，所有的 Hbase 的 ZooKeeper 文件路径是用相对路径，所以它们会都去这个目录下面\</li><li>默认: <strong>/hbase</strong></li></ul><hr><p><strong>59. zookeeper.znode.rootserver</strong></p><ul><li>ZNode 保存的根 region 的路径. 这个值是由 Master 来写，client 和 regionserver 来读的。如果设为一个相对地址，父目录就是 <code>$&#123;zookeeper.znode.parent&#125;</code>。默认情形下，意味着根 region的路径存储在/hbase/root-region- server</li><li>默认: <strong>root-region-server</strong></li></ul><hr><p><strong>60. hbase.zookeeper.quorum</strong></p><ul><li>Zookeeper 集群的地址列表，用逗号分割。例如：”host1.mydomain.com,host2.mydomain.com,host3.mydomain.com”.默认是 localhost,是给伪分布式用的。要修改才能在完全分布式的情况下使用。如果在hbase-env.sh设置了HBASE_MANAGES_ZK， 这些ZooKeeper节点就会和Hbase一起启动</li><li>默认: <strong>localhost</strong></li></ul><hr><p><strong>61. hbase.zookeeper.peerport</strong></p><ul><li>ZooKeeper节点使用的端口</li><li>默认: 2888</li></ul><hr><p><strong>62. hbase.zookeeper.leaderport</strong></p><ul><li>ZooKeeper用来选择Leader的端口</li><li>默认: <strong>3888</strong></li></ul><hr><p><strong>63. hbase.zookeeper.property.initLimit</strong></p><ul><li>ZooKeeper的zoo.conf中的配置。 初始化synchronization阶段的ticks数量限制</li><li>默认: <strong>10</strong></li></ul><hr><p><strong>64. hbase.zookeeper.property.syncLimit</strong></p><ul><li>ZooKeeper的zoo.conf中的配置。 发送一个请求到获得承认之间的ticks的数量限制</li><li>默认: <strong>5</strong></li></ul><hr><p><strong>65. hbase.zookeeper.property.dataDir</strong></p><ul><li>ZooKeeper的zoo.conf中的配置。 快照的存储位置</li><li>默认: <strong>${hbase.tmp.dir}/zookeeper</strong></li></ul><hr><p><strong>66. hbase.zookeeper.property.clientPort</strong></p><ul><li>ZooKeeper的zoo.conf中的配置。 客户端连接的端口</li><li>默认: <strong>2181</strong></li></ul><hr><p><strong>67. hbase.zookeeper.property.maxClientCnxns</strong></p><ul><li>ZooKeeper的zoo.conf中的配置。 ZooKeeper集群中的单个节点接受的单个Client(以IP区分)的请求的并发数。这个值可以调高一点，防止在单机和伪分布式模式中出问题。</li><li>默认: <strong>2000</strong></li></ul><hr><p><strong>68. hbase.rest.port</strong></p><ul><li>HBase REST server的端口<br>-默认: <strong>8080</strong></li></ul><hr><p><strong>69. hbase.rest.readonly</strong></p><ul><li>定义REST server的运行模式。可以设置成如下的值： false: 所有的HTTP请求都是被允许的 - GET/PUT/POST/DELETE. true:只有GET请求是被允许的</li><li>默认: <strong>false</strong></li></ul><hr><p><strong>70. hbase.regionserver.restart.on.zk.expire</strong></p><ul><li>当 regionserver 遇到 ZooKeeper session expired ， regionserver 是否选择 restart</li><li>默认: <strong>false</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>03-Hbase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Python安装</title>
    <link href="/02-Python/01-Python%E5%AE%89%E8%A3%85/"/>
    <url>/02-Python/01-Python%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="各种系统安装Python"><a href="#各种系统安装Python" class="headerlink" title="各种系统安装Python"></a>各种系统安装Python</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="1-复制已经装好的，改环境变量"><a href="#1-复制已经装好的，改环境变量" class="headerlink" title="1. 复制已经装好的，改环境变量"></a>1. 复制已经装好的，改环境变量</h3><h3 id="2-直接去官网下载exe安装"><a href="#2-直接去官网下载exe安装" class="headerlink" title="2. 直接去官网下载exe安装"></a>2. 直接去官网下载exe安装</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>默认情况下，Linux自带Python</p><pre><code class="hljs sh">python --versionpython3 --version</code></pre><h2 id="无冲突安装Python3"><a href="#无冲突安装Python3" class="headerlink" title="无冲突安装Python3"></a>无冲突安装Python3</h2><pre><code class="hljs sh"><span class="hljs-comment"># 下载python3的包，解压</span>wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgztar -zxvf Python-3.6.3.tgz<span class="hljs-built_in">cd</span> Python-3.6.3/<span class="hljs-comment"># 设置安装路径</span>./configure --prefix=/usr/pythonmakemake installln -s /usr/python/bin/python3 /usr/bin/python3<span class="hljs-built_in">cd</span> ..rm -rf Python-3.6.3-1.tgzrm -rf Python-3.6.3</code></pre><p><a href="http://www.cnblogs.com/Mr-wangxd/p/7028285.html">参考博客</a></p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-使用Python读取docx</title>
    <link href="/02-Python/03-%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96docx/"/>
    <url>/02-Python/03-%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96docx/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Python读docx实战"><a href="#使用Python读docx实战" class="headerlink" title="使用Python读docx实战"></a>使用Python读docx实战</h1><h2 id="神奇的docx格式"><a href="#神奇的docx格式" class="headerlink" title="神奇的docx格式"></a>神奇的docx格式</h2><p><a href="http://www.cnblogs.com/awpatp/archive/2009/12/04/1616822.html"></a></p><p>doc是微软自己开心的一种编码，自娱自乐，不提也罢。</p><p><code>docx</code>是一种强大的文档格式<code>Office Open XML</code>，基于zip技术，也就是说，每一个docx都是一个Zip文件，我们可以使用压缩工具一看究竟。</p><p><img src="../images/03-01.png"></p><p>文件夹功能说明</p><pre><code class="hljs sh">/docProps/app.xml/docProps/core.xml/word/document.xml      <span class="hljs-comment"># 最重要的文档，包含文档中大部分的信息</span>/word/fontTable.xml/word/settings.xml/word/styles.xml/word/theme/theme1.xml</code></pre><p>使用一段简单的python代码实现读取<code>document.xml</code></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> zipfile <span class="hljs-keyword">import</span> ZipFile<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<span class="hljs-comment"># read file and compress it</span>wordFile = urlopen(<span class="hljs-string">&quot;http://pythonscraping.com/pages/AWordDocument.docx&quot;</span>).read()wordFile = BytesIO(wordFile)document = ZipFile(wordFile)<span class="hljs-comment"># read xml</span>xml_content = document.read(<span class="hljs-string">&#x27;word/document.xml&#x27;</span>)print(xml_content.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<span class="hljs-comment"># 简单读一点文字</span>wordObj = BeautifulSoup(xml_content.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))textStrings = wordObj.findAll(<span class="hljs-string">&quot;w:t&quot;</span>)<span class="hljs-keyword">for</span> textElem <span class="hljs-keyword">in</span> textStrings:print(textElem.text)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-文件存储</title>
    <link href="/02-Python/05-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    <url>/02-Python/05-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="永久文件存储技术"><a href="#永久文件存储技术" class="headerlink" title="永久文件存储技术"></a>永久文件存储技术</h3><pre><code>#1.通过打印流输出到文件out = open(&#39;file_name&#39;,&#39;w&#39;)print(&#39;输出的字符串序列&#39;,file = out)#2.通过输出流保存out = open(&#39;file_name&#39;,&#39;w&#39;)out.</code></pre><h4 id="使用try-expect-finally来打开文件"><a href="#使用try-expect-finally来打开文件" class="headerlink" title="使用try/expect/finally来打开文件"></a>使用try/expect/finally来打开文件</h4><pre><code>try:    data = open(&#39;data.txt&#39;,&#39;w&#39;)    print(&#39;这是存储内容&#39;,file = data)expect IOError as err:    print(&#39;错误提示：&#39; + str(err))finally:    if &#39;data&#39; in locals()         #使用locals()可以检查对象‘data’是否存在当前作用域里面                                #如果没有这句，文件不存在，则data也不存在        data.colse()</code></pre><h4 id="由于用try-except-finally-模式来打开和关闭代码非常常见，py提供了用whih语句-无需考虑文件的关闭"><a href="#由于用try-except-finally-模式来打开和关闭代码非常常见，py提供了用whih语句-无需考虑文件的关闭" class="headerlink" title="由于用try/except/finally/模式来打开和关闭代码非常常见，py提供了用whih语句,无需考虑文件的关闭"></a>由于用try/except/finally/模式来打开和关闭代码非常常见，py提供了用whih语句,无需考虑文件的关闭</h4><pre><code>try:    with open (&#39;data.txt&#39;,&#39;w&#39;) as data:        print(&#39;这是存储内容&#39;,file = data)expect IOError as err:     print(&#39;错误提示：&#39; + str(err))</code></pre><h3 id="使用pickle保存"><a href="#使用pickle保存" class="headerlink" title="使用pickle保存"></a>使用pickle保存</h3><pre><code># 腌制数据,就是原格式保存数据import picklewith open(&#39;mydata.pickle&#39;, &#39;wb&#39;) as myPickleSave:  # 使用二进制保存文件    pickle.dump([1, 23, 4, 5, &#39;aa&#39;], myPickleSave)  # 使用dump方法进行保存数据with open(&#39;mydata.pickle&#39;, &#39;rb&#39;) as myPickleRead:    testList = pickle.load(myPickleRead)  # 使用load方法恢复数据print(testList)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-文件操作</title>
    <link href="/02-Python/05-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/02-Python/05-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html">https://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html</a></p><p>python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。</p><p>得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()</p><p>返回指定目录下的所有文件和目录名:os.listdir()</p><p>函数用来删除一个文件:os.remove()</p><p>删除多个目录：os.removedirs（r“c：\python”）</p><p>检验给出的路径是否是一个文件：os.path.isfile()</p><p>检验给出的路径是否是一个目录：os.path.isdir()</p><p>判断是否是绝对路径：os.path.isabs()</p><p>检验给出的路径是否真地存:os.path.exists()</p><p>返回一个路径的目录名和文件名:os.path.split()     eg os.path.split(‘/home/swaroop/byte/code/poem.txt’) 结果：(‘/home/swaroop/byte/code’, ‘poem.txt’) </p><p>分离扩展名：os.path.splitext()</p><p>获取路径名：os.path.dirname()</p><p>获取文件名：os.path.basename()</p><p>运行shell命令: os.system()</p><p>读取和设置环境变量:os.getenv() 与os.putenv()</p><p>给出当前平台使用的行终止符:os.linesep    Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’</p><p>指示你正在使用的平台：os.name       对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’</p><p>重命名：os.rename（old， new）</p><p>创建多级目录：os.makedirs（r“c：\python\test”）</p><p>创建单个目录：os.mkdir（“test”）</p><p>获取文件属性：os.stat（file）</p><p>修改文件权限与时间戳：os.chmod（file）</p><p>终止当前进程：os.exit（）</p><p>获取文件大小：os.path.getsize（filename）</p><p>文件操作：<br>os.mknod(“test.txt”)        创建空文件<br>fp = open(“test.txt”,w)     直接打开一个文件，如果文件不存在则创建文件</p><p>关于open 模式：</p><p>w     以写方式打开，<br>a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)<br>r+     以读写模式打开<br>w+     以读写模式打开 (参见 w )<br>a+     以读写模式打开 (参见 a )<br>rb     以二进制读模式打开<br>wb     以二进制写模式打开 (参见 w )<br>ab     以二进制追加模式打开 (参见 a )<br>rb+    以二进制读写模式打开 (参见 r+ )<br>wb+    以二进制读写模式打开 (参见 w+ )<br>ab+    以二进制读写模式打开 (参见 a+ )</p><p>fp.read([size])                     #size为读取的长度，以byte为单位</p><p>fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分</p><p>fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</p><p>fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符</p><p>fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</p><p>fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError</p><p>fp.flush()                                      #把缓冲区的内容写入硬盘</p><p>fp.fileno()                                      #返回一个长整型的”文件标签“</p><p>fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）</p><p>fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点</p><p>fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</p><p>fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</p><p>fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</p><p>目录操作：<br>os.mkdir(“file”)                   创建目录<br>复制文件：<br>shutil.copyfile(“oldfile”,”newfile”)       oldfile和newfile都只能是文件<br>shutil.copy(“oldfile”,”newfile”)            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录<br>复制文件夹：<br>shutil.copytree(“olddir”,”newdir”)        olddir和newdir都只能是目录，且newdir必须不存在<br>重命名文件（目录）<br>os.rename(“oldname”,”newname”)       文件或目录都是使用这条命令<br>移动文件（目录）<br>shutil.move(“oldpos”,”newpos”)<br>删除文件<br>os.remove(“file”)<br>删除目录<br>os.rmdir(“dir”)只能删除空目录<br>shutil.rmtree(“dir”)    空目录、有内容的目录都可以删<br>转换目录<br>os.chdir(“path”)   换路径</p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-Python JSon 解析</title>
    <link href="/02-Python/06-Python%20JSon%20%E8%A7%A3%E6%9E%90/"/>
    <url>/02-Python/06-Python%20JSon%20%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.runoob.com/python/python-json.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-Python 解析XML</title>
    <link href="/02-Python/07-Python%20%E8%A7%A3%E6%9E%90XML/"/>
    <url>/02-Python/07-Python%20%E8%A7%A3%E6%9E%90XML/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/fnng/p/3581433.html?yyue=a21bo.50862.201879">Python 解析XML</a></p><pre><code>&lt;configuration&gt;    &lt;conf&gt;        &lt;name&gt;URL_to_start&lt;/name&gt;        &lt;value&gt;http://baike.baidu.com/item/python&lt;/value&gt;    &lt;/conf&gt;    &lt;!-- 总爬取数量 默认:-1 无限制 --&gt;    &lt;conf&gt;        &lt;name&gt;count&lt;/name&gt;        &lt;value&gt;10&lt;/value&gt;    &lt;/conf&gt;    &lt;!-- 总爬取时间(分钟) 默认:-1 无限制--&gt;    &lt;conf&gt;        &lt;name&gt;run_time&lt;/name&gt;        &lt;value&gt;-1&lt;/value&gt;    &lt;/conf&gt;    &lt;!-- 线程数 默认:1 --&gt;    &lt;conf&gt;        &lt;name&gt;Thread_count&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/conf&gt;    &lt;!-- URL匹配规则 请使用正则表达式 --&gt;    &lt;conf&gt;        &lt;name&gt;URL_re&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/conf&gt;&lt;/configuration&gt;</code></pre><p>解析</p><pre><code>import xml.dom.minidomclass ReadConf:    def read(self):        # 打开xml文档        dom = xml.dom.minidom.parse(&#39;conf.xml&#39;)        # 得到文档元素对象        root = dom.documentElement        conf_nodes = root.getElementsByTagName(&#39;conf&#39;)        conf_dict = &#123;&#125;        for conf_node in conf_nodes:            conf_dict[conf_node.getElementsByTagName(&#39;name&#39;)[0].firstChild.data] = \                conf_node.getElementsByTagName(&#39;value&#39;)[                    0].firstChild.data        return conf_dict</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-Python多线程</title>
    <link href="/02-Python/09-Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/02-Python/09-Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>###<a href="http://www.cnblogs.com/fnng/p/3670789.html?yyue=a21bo.50862.201879">Python多线程</a></p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-日志管理Logger</title>
    <link href="/02-Python/04-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86Logger/"/>
    <url>/02-Python/04-%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86Logger/</url>
    
    <content type="html"><![CDATA[<h1 id="日志管理模块的使用"><a href="#日志管理模块的使用" class="headerlink" title="日志管理模块的使用"></a>日志管理模块的使用</h1><h2 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h2><pre><code class="hljs py">program = os.path.basename(sys.argv[<span class="hljs-number">0</span>])logger = logging.getLogger(program)logging.basicConfig(format=<span class="hljs-string">&#x27;%(asctime)s: %(levelname)s: %(message)s&#x27;</span>)logging.root.setLevel(level=logging.INFO)logger.info(<span class="hljs-string">&quot;running %s&quot;</span> % <span class="hljs-string">&#x27; &#x27;</span>.join(sys.argv))</code></pre><h2 id="封装，全局使用"><a href="#封装，全局使用" class="headerlink" title="封装，全局使用"></a>封装，全局使用</h2><pre><code class="hljs py"><span class="hljs-keyword">import</span> logging.handlers<span class="hljs-keyword">import</span> logging<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span>:</span>    logger = <span class="hljs-literal">None</span>    levels = &#123;<span class="hljs-string">&quot;n&quot;</span>: logging.NOTSET,              <span class="hljs-string">&quot;d&quot;</span>: logging.DEBUG,              <span class="hljs-string">&quot;i&quot;</span>: logging.INFO,              <span class="hljs-string">&quot;w&quot;</span>: logging.WARN,              <span class="hljs-string">&quot;e&quot;</span>: logging.ERROR,              <span class="hljs-string">&quot;c&quot;</span>: logging.CRITICAL&#125;    log_level = <span class="hljs-string">&quot;d&quot;</span>    log_file = <span class="hljs-string">&quot;logger.log&quot;</span>    log_max_byte = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>    log_backup_count = <span class="hljs-number">5</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLogger</span>():</span>        <span class="hljs-keyword">if</span> Logger.logger <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> Logger.logger        log_fmt = logging.Formatter(<span class="hljs-string">&quot;[%(levelname)s][%(funcName)s][%(asctime)s]%(message)s&quot;</span>)        Logger.logger = logging.Logger(<span class="hljs-string">&quot;LogModule.Logger&quot;</span>)        log_handler = logging.handlers.RotatingFileHandler(filename=Logger.log_file,                                                           maxBytes=Logger.log_max_byte,                                                           backupCount=Logger.log_backup_count)        <span class="hljs-comment"># 增加Handler用于文件输出</span>        log_handler.setFormatter(log_fmt)        Logger.logger.addHandler(log_handler)        <span class="hljs-comment"># 增加Handler用于控制台输出</span>        console = logging.StreamHandler()        console.setFormatter(log_fmt)        Logger.logger.addHandler(console)        Logger.logger.setLevel(Logger.levels.get(Logger.log_level))        <span class="hljs-keyword">return</span> Logger.logger<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    logger = Logger.getLogger()    logger.debug(<span class="hljs-string">&quot;this is a debug msg!&quot;</span>)    logger.info(<span class="hljs-string">&quot;this is a info msg!&quot;</span>)    logger.warn(<span class="hljs-string">&quot;this is a warn msg!&quot;</span>)    logger.error(<span class="hljs-string">&quot;this is a error msg!&quot;</span>)    logger.critical(<span class="hljs-string">&quot;this is a critical msg!&quot;</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-python数据排序</title>
    <link href="/02-Python/12-python%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/"/>
    <url>/02-Python/12-python%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>####1.原地排序</p><pre><code>data.sort()     #对原列表进行排序</code></pre><p>####2.复制排序</p><pre><code>data2 = sorted(data)     #原列表不变，作为参数传给sorted()方法进行排序</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-python网络编程</title>
    <link href="/02-Python/13-python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/02-Python/13-python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>###网络编程<br>requests模块是rullib3的拓展模块</p><pre><code>#抓取网络示例import requestsczm = requests.get(&#39;http://cenzhongman.cn&#39;)file = open(&#39;html.html&#39;,&#39;w&#39;)    file.write(czm.content)file.close()#我的请求头czm.text#get方式传参myparams = &#123;&#39;wd&#39;:&#39;岑忠满&#39;,&#39;qwe&#39;:&#39;asd&#39;&#125;so = requests.get(&#39;https://www.so.com/s&#39;,params = myparams)so.url             #u&#39;https://www.so.com/s?wd=岑忠满&amp;qwe=asd&#39;#post方式提交表单mydata = &#123;&#39;wd&#39;:&#39;linux&#39;,&#39;name&#39;:&#39;czm&#39;&#125;rst = requests.post(&#39;http://httpbin.org/get&#39;,data = mydata)#提交文件myfile = &#123;&#39;file&#39;:open(&#39;file.jpg&#39;),&#39;rb&#39;&#125;r = requests.post(&#39;http://cenzhongman.cn&#39;,files = myfile)</code></pre><p>###使用socket作为服务器</p><pre><code>from socket import *sockobj = socket(AF_INET,SOCK_STREAM)        #说明使用ipv4和tcp作为传输协议sockobj.bind((&#39;&#39;,9090))        #使用元组绑定端口号，本地9090端口sockobj.listen(100)            #最多建立100个连接while True：    connection,address = sockobj.accept()        #接收两个参数，连接，链接的地址    print(&#39;connect:&#39; + adress)    data = connection,recv()    #接收到的数据    connection.send(data)        #回传数据    connection.close()            #任务完成，关闭连接</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-python字符串处理</title>
    <link href="/02-Python/14-python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/02-Python/14-python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python字符串处理"><a href="#Python字符串处理" class="headerlink" title="Python字符串处理"></a>Python字符串处理</h1><pre><code>mystr = &#39;i am a hanson boy&#39;&#39;a&#39; in mystr             # true&#39;q&#39; not in mystr         # truemystr[2]                 # amystr[1:4]                 # 截取索引1~4    myste[:10]                               # 从0~10    mystr[::4]                                 # 每4个取一个    mystr * 2　                # 重复mystr#find查找，返回索引，找不到返回-1mystr.find(&#39;a&#39;,start = 0,end = len(str))        # 2#index返回索引，找不到抛出ValueError异常mystr.index(&#39;z&#39;,start,end)    # ValueError: substring not found#计算字符出现次数mystr.count(&#39;a&#39;,start,end)     #2# encode以encoding = XXX格式编码，出错则报valueError异常mystr.encode(encoding = &#39;UTF-8&#39;,errors = &#39;strict&#39;)# decode以encoding = XXX格式解码，出错则报valueError异常# replace替换,不改变原值，返回新的值newstr = mystr.replace(&#39;a&#39;,&#39;b&#39;)# 切分,默认是空格分割，返回一个列表mystr.split()                 #[&#39;i&#39;, &#39;am&#39;, &#39;a&#39;, &#39;hanson&#39;, &#39;boy&#39;]# capitalize句首第一个字母大写mystr.capitalize()          # I am a hanson boy# endswith以什么结束,返回booleanmystr.endswith(&#39;y&#39;)# expandtabs把tab换成空格，默认是8mystr.expandtabs(3)# center把字符串放中间mystr.center(50)# isalnam至少有一个字符，并且都是字母或数字甚至是中文，也就是说不不能有符号mystr.isalnum()             #False# isalpha全是字母mystr.isalpha()              #False# isdigit全是数字mystr.isdigit()# islower()全是小写# isupper()全是大写# isapace()全是空格# lower()大写全部变成小写# upper()小写全部变成大写# ljust(20)左对齐# rjust(20)右对齐# lstrip()删除左边的空格# rstrip()删除右边空格# rfind()从右向左查找# rindex()同上# partition(&#39;str&#39;)用&#39;str&#39;分隔字符串，返回一个元组mystr.partition(&#39;am&#39;)         #(&#39;i &#39;, &#39;am&#39;, &#39; a hanson boy&#39;)</code></pre><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>is 比较对象<br>== 比较内容<br>cmp()已弃用</p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-使用Python脚本</title>
    <link href="/02-Python/15-%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC/"/>
    <url>/02-Python/15-%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted">来自官方文档</a></p><p>###一、写 python 脚本：</p><pre><code>import sysimport datetimefor line in sys.stdin:  line = line.strip()  userid, movieid, rating, unixtime = line.split(&#39;\t&#39;)  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()  print &#39;\t&#39;.join([userid, movieid, rating, str(weekday)])</code></pre><p>###二、添加脚本</p><pre><code>add file /opt/datas/xxx.py</code></pre><p>###三、使用脚本</p><pre><code>CREATE TABLE u_data_new (  userid INT,  movieid INT,  rating INT,  weekday INT)ROW FORMAT DELIMITEDFIELDS TERMINATED BY &#39;\t&#39;;add FILE weekday_mapper.py;INSERT OVERWRITE TABLE u_data_newSELECT  TRANSFORM (userid, movieid, rating, unixtime)        # 传入参数  USING &#39;python weekday_mapper.py&#39;                    # 使用的脚本文件  AS (userid, movieid, rating, weekday)                # 输出的字段FROM u_data;SELECT weekday, COUNT(*)FROM u_data_newGROUP BY weekday;</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-Python连接MySQL数据库</title>
    <link href="/02-Python/11-Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/02-Python/11-Python%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>#连接方法</p><ul><li>使用 Python DB API（整合了绝大部分的数据库）</li><li>使用 pymysql 包</li></ul><p>##整体思想<br><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102151089-537432631.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102156574-1493533474.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102206777-1405042435.png"></p><p>##数据库连接对象 connection<br><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102219058-1610697255.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102235308-1700192859.png"></p><p>##数据库游标对象 cursor<br><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102859042-984115607.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811102629761-1156590582.png"></p><p>#程序Demo</p><pre><code>import pymysql.cursorsclass MySQLUtils():    def executeSQL(self, db, sql):        connection = pymysql.connect(            host=&#39;118.89.59.181&#39;,            port=3306,            user=&#39;root&#39;,            passwd=&#39;ubuntu&#39;,            db=db,            charset=&#39;utf8&#39;        )        try:            with connection.cursor() as cursor:                cursor.execute(sql)                connection.commit()        except:            print(&#39;ERROE While write MySQL&#39;)        finally:            connection.close()if __name__ == &#39;__main__&#39;:    sql = &#39;CREATE TABLE xxx()&#39;    MySQLUtils().executeSQL(db =&#39;test&#39;, sql=sql)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python List</title>
    <link href="/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20List/"/>
    <url>/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20List/</url>
    
    <content type="html"><![CDATA[<p>链表,有序的项目, 通过索引进行查找,使用方括号”[]”,元素允许修改</p><p>####定义</p><pre><code>L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]L = [&#39;asdf&#39;,1,True]</code></pre><p>####索引</p><pre><code>L[0]L[-1]</code></pre><p>####尾部添加</p><pre><code>L.append(&#39;asd&#39;)</code></pre><p>####任意位置插入</p><pre><code>L.insert(0, &#39;Paul&#39;)</code></pre><p>####替换</p><pre><code>L[0] = &#39;Paul&#39;</code></pre><p>####删除</p><pre><code># 删除最后一个L.pop()# 删除指定位置(删除后索引动态改变)L.pop(2)</code></pre><p>####切片</p><pre><code>L[1:20]</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Set</title>
    <link href="/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20Set/"/>
    <url>/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20Set/</url>
    
    <content type="html"><![CDATA[<p>集合,无序,元素只出现一次, 自动去重,使用”set([])”<br>相当于只有 key 的字典<br>##！无序<br>##！自动去重</p><p>####定义</p><pre><code># 使用已有的list创建setL = [1,2,3,4,6,7,8,9,0]s = set(L)s = set([1,2,4,5,6,7,8])# 对于有重复元素的list ，set会自动去重L = [1,2,3,4,4,4,4,4,5]s = set(L)s = ([1,2,3,4,5])</code></pre><p>####判断在集合中</p><pre><code>&#39;value&#39; in s</code></pre><p>####增（无序）</p><pre><code>s.add(&#39;newValue&#39;)</code></pre><p>####删</p><pre><code># 不存在会报错s.remove(&#39;Value&#39;)</code></pre><p>####遍历</p><pre><code>mSet = set([&#39;python1&#39;,&#39;python2&#39;])for item in mSet:    print(item)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python dict</title>
    <link href="/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20dict/"/>
    <url>/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20dict/</url>
    
    <content type="html"><![CDATA[<p>典,字典是一组键(key)和值(value)的组合,通过键(key)进行查找,<strong>没有顺序</strong>, 使用大括号”{}”<br>##!key不允许重复<br>##!key不可变，list不能作为key</p><p>####定义</p><pre><code>d = &#123;&#39;key&#39;:&#39;value&#39;,&#39;name&#39;:&#39;czm&#39;,&#39;id&#39;:1&#125;</code></pre><p>####获取值</p><pre><code># 键值索引d[&#39;key&#39;]# 使用方法d.get(&#39;key&#39;)</code></pre><p>####增、改</p><pre><code># 对于不存在的 key 直接赋值既增加d[&#39;anotherKey&#39;] = &#39;value&#39;# 对于存在的 key ，直接赋值相当于替换d[&#39;existsKey&#39;] = &#39;newValue&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python tuple</title>
    <link href="/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20tuple/"/>
    <url>/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%20tuple/</url>
    
    <content type="html"><![CDATA[<p>元组,元组将多样的对象集合到一起,元素不能修改,通过索引进行查找, 使用括号”()”<br>允许重复<br>####定义</p><pre><code># 空元组t = ()# 单个元组,需要加逗号结尾，用于区别元组t = (1,)t = (&#39;你几号&#39;,)# 多元组t = (1,23,45,5,6)</code></pre><h4 id="“可变”元组"><a href="#“可变”元组" class="headerlink" title="“可变”元组"></a>“可变”元组</h4><pre><code># 其中的list内容依旧可变，因为元组存储的是list的地址，而不是内容本身t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])</code></pre><h4 id="追加方式参考字符串"><a href="#追加方式参考字符串" class="headerlink" title="追加方式参考字符串"></a>追加方式参考字符串</h4>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python module</title>
    <link href="/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/python%20module/"/>
    <url>/02-Python/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/python%20module/</url>
    
    <content type="html"><![CDATA[<p>###模块化程序<br>##1.编写需要模块化的程序</p><pre><code># file name mTest.pydef fun():    print(&#39;I&#39;m a module!&#39;)    return</code></pre><p>##2.在同一个文件夹下添加setup.py文件，说明发布的元数据</p><pre><code>from distutils.core import setup    # 导包setup(    name=&#39;mTestModule&#39;,                    # 模块名,在pip中显示这个    version=&#39;1.0.0&#39;,    author=&#39;czm&#39;,    author_email=&#39;345666561@qq.com&#39;,         py_modules = [&#39;mTest&#39;],                # 关联源代码，在pyCharm中这个是没有的，不知道为什么    url=&#39;http://cenzhongman.cn&#39;,    description=&#39;这是一个测试发布用的模块&#39;,)</code></pre><p>##3.文件夹中打开终端</p><pre><code>$python setup.py sdist    # 构建发布$python setup.py install    # 安装发布,在linux中需要root权限$pip list                    #查看模块列表$pip uninstall 模块名        #卸载模块</code></pre><p>这样就生成了两个文件及build 和 sdist和一个MANIFAST文件，源码在build文件夹下的lib目录下<br>mTest<br>|<br>|–MANIFEST    #说明发布的文件列表<br>|<br>|–build<br>|  |–lib<br>|     |–mTest.py    # 所安装的源码文件<br>|<br>|–sdist<br>|  |–mTestModule-1.0.0.tar.gz    # 自动生成发布的包<br>|<br>|–mTest.py    # 源文件<br>|<br>|–setup.py    # 元数据文件</p><p>##4.使用模块</p><pre><code>import mTestmTest.fun()</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-数据类型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-简单爬虫架构解析</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/01-%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/01-%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a><a href="http://www.cnblogs.com/cenzhongman/p/7344364.html">主函数</a></h3><p> <img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100417167-1880583484.png"></p><h2 id="一、-URL管理器"><a href="#一、-URL管理器" class="headerlink" title="一、    URL管理器"></a>一、    URL管理器</h2><p>管理即将爬取的URL和已经爬取的URL</p><h3 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a><a href="http://www.cnblogs.com/cenzhongman/p/7344386.html">URL管理器</a></h3><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100422933-1713805086.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100425714-964001645.png"></p><h2 id="二、-网页下载器"><a href="#二、-网页下载器" class="headerlink" title="二、    网页下载器"></a>二、    网页下载器</h2><p>用于下载网页</p><h3 id="三种urllib实现网页下载，含cookie模拟登陆"><a href="#三种urllib实现网页下载，含cookie模拟登陆" class="headerlink" title="三种urllib实现网页下载，含cookie模拟登陆"></a><a href="http://www.cnblogs.com/cenzhongman/p/7344406.html">三种urllib实现网页下载，含cookie模拟登陆</a></h3><p> <img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100431839-1138119914.png"></p><p>  <img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100436824-2071017653.png"></p><p> <img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100447558-454287024.png"></p><p> <img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100453386-1218961192.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100459214-672667202.png"></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100506824-422428543.png"></p><h2 id="三、-网页解析器"><a href="#三、-网页解析器" class="headerlink" title="三、    网页解析器"></a>三、    网页解析器</h2><p>用于解析网页，获得有价值数据或者新的待爬取URL填充URL管理器</p><p>###<a href="http://www.cnblogs.com/cenzhongman/p/7344416.html">使用bs4的网页解析器</a></p><p><img src="http://images2017.cnblogs.com/blog/1047249/201708/1047249-20170811100515964-684122336.png"></p><p>##四、文件输出<br>###<a href="http://www.cnblogs.com/cenzhongman/p/7344431.html">文件输出</a></p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Python BeautifulSoup</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/03-Python%20BeautifulSoup/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/03-Python%20BeautifulSoup/</url>
    
    <content type="html"><![CDATA[<h2 id="获得HTML"><a href="#获得HTML" class="headerlink" title="获得HTML"></a>获得HTML</h2><pre><code>html = urlopen(&#39;http://example.com&#39;)</code></pre><p>##获得 BeautifulSoup对象 (完整的DOM Tree)</p><pre><code>bsObj = BeautifulSoup(html.read)                                    #过时bsObj = BeautifulSoup(html,&#39;html.parser&#39;,from_encoding=&#39;utf8&#39;)        #新标准(参数三非必须)</code></pre><p>##获得 Tag对象 (可以一直点下去)</p><pre><code>#最好使用try包围起来，否则读到不存在的标签会报错body = bsObj.body     //title包含tag之间的所有内容</code></pre><h2 id="find-和-find-all-可以使用以上两种对象"><a href="#find-和-find-all-可以使用以上两种对象" class="headerlink" title="find 和 find_all ( 可以使用以上两种对象 )"></a>find 和 find_all ( 可以使用以上两种对象 )</h2><pre><code>findAll(tag, attributes, recursive, text, limit, keywords)#标签名    用于匹配的字典    是否迭代(默认是)    使用text = &#39;关键字&#39;匹配，无需参数12    限制前n项    keyword 是冗余设计，相当于bsObj.findAll(&quot;&quot;, &#123;&quot;id&quot;:&quot;text&quot;&#125;)find(tag, attributes, recursive, text, keywords)</code></pre><h2 id="查找标签-对于Python中的关键字，如：class-可以使用-class-或者-‘class’"><a href="#查找标签-对于Python中的关键字，如：class-可以使用-class-或者-‘class’" class="headerlink" title="查找标签(对于Python中的关键字，如：class 可以使用 class_ 或者 ‘class’)"></a>查找标签(对于Python中的关键字，如：class 可以使用 class_ 或者 ‘class’)</h2><pre><code># &lt;span class=&quot;red&quot;&gt;nameList = bsObj.find_all(name=&#39;span&#39;, attrs=&#123;    &#39;class&#39;: &#39;red&#39;&#125;)  # 得到的是一个bs4的自定义对象[&lt;span class=&quot;red&quot;&gt; 我是中间的文字1 &lt;/span&gt;, &lt;span class=&quot;red&quot;&gt; 我是中间的文字2 &lt;/span&gt;for name in nameList:    print(name.get_text()) # 获得标签间的内容    print(&#39;-------------------&#39;)</code></pre><h2 id="子，后代，兄弟标签（使用find会舍得代码更健壮，此处仅为展示家族关系）"><a href="#子，后代，兄弟标签（使用find会舍得代码更健壮，此处仅为展示家族关系）" class="headerlink" title="子，后代，兄弟标签（使用find会舍得代码更健壮，此处仅为展示家族关系）"></a>子，后代，兄弟标签（使用find会舍得代码更健壮，此处仅为展示家族关系）</h2><pre><code># 子标签for child in bsObj.children:    print(child)# 后代标签for descendant in bsObj.descendants:    print(descendant)、# 兄弟标签 next_sibling previous_sibling 一个；next_siblings previous_siblings 一组for next_sibling in bsObj.body.h1.next_siblings:    print(next_sibling)# 父标签 parent 和 parentsfor parent in bsObj.body.h1.parents:    print(&#39;===========&#39;)    print(parent)</code></pre><h2 id="正则表达式-可以在任何一个需要参数的地方传递正则"><a href="#正则表达式-可以在任何一个需要参数的地方传递正则" class="headerlink" title="正则表达式(可以在任何一个需要参数的地方传递正则)"></a>正则表达式(可以在任何一个需要参数的地方传递正则)</h2><pre><code>bsObj.find_all(re.compile(&#39;&lt;span class=&quot;red&quot;&gt;&#39;))images = bsObj.findAll(&quot;img&quot;,&#123;&quot;src&quot;:re.compile(&quot;\.\.\/img\/gifts/img.*\.jpg&quot;)&#125;)</code></pre><p>##获取 Tag 的属性</p><pre><code>myTag.attrs</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Python爬虫之JS异步加载</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/04-Python%E7%88%AC%E8%99%AB%E4%B9%8BJS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/04-Python%E7%88%AC%E8%99%AB%E4%B9%8BJS%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>#一.判断异步加载方式(常用的JS库)<br>###1. jQuery(70%)</p><pre><code># 搜索 jquery 茅塞顿开&lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/Scripts/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>###2.Google Analytics(50%)</p><pre><code># 搜索 Google Analytics &lt;!-- Google Analytics --&gt;&lt;script type=&quot;text/javascript&quot;&gt;</code></pre><p>#二.解决</p><ul><li>安装pip Selenium</li><li>下载PhantomJS <a href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a></li></ul><p>###1.Ajax Asynchronous JavaScript and XML（异步 JavaScript 和 XML）<br>使用Ajax向服务器发送表单(如，延迟加载，下拉刷新，底部刷新…)</p><p>###2.动态HTML（dynamic HTML， DHTML）<br>一系列用于解决网络问题的技术集合(如，鼠标指向显示，下拉菜单实现)</p><p>##代码实现</p><pre><code>from selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byimport time# 指明phantomjs的执行路径driver = webdriver.PhantomJS(executable_path=r&#39;E:\software\phantomjs-2.1.1-windows\bin\phantomjs.exe&#39;)driver.get(&quot;http://pythonscraping.com/pages/javascript/ajaxDemo.html&quot;)# 方法1：显式给3秒加载时间time.sleep(3)# 方法2：让 Selenium 不断地检查某个元素是否存在，以此确定页面是否已经完全加载(需要导入库)try:    element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, &quot;loadedButton&quot;)))finally:    print(driver.page_source)    driver.close()# 获取内容# print(driver.page_source)## driver.close()</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-scrapy从入门到删库跑路</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/06-scrapy%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/06-scrapy%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="scrapy从入门到删库跑路"><a href="#scrapy从入门到删库跑路" class="headerlink" title="scrapy从入门到删库跑路"></a>scrapy从入门到删库跑路</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs sh">sudo pip3 install virtualenvsudo pip3 install scrapy</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="hljs sh"><span class="hljs-comment"># 创建项目</span>scrapy startproject tutorial</code></pre><ul><li>创建出的项目目录</li></ul><pre><code class="hljs sh">tutorial/    scrapy.cfg            <span class="hljs-comment"># deploy configuration file</span>    tutorial/             <span class="hljs-comment"># project&#x27;s Python module, you&#x27;ll import your code from here</span>        __init__.py        items.py          <span class="hljs-comment"># project items definition file</span>        middlewares.py    <span class="hljs-comment"># project middlewares file</span>        pipelines.py      <span class="hljs-comment"># project pipelines file</span>        settings.py       <span class="hljs-comment"># project settings file</span>        spiders/          <span class="hljs-comment"># a directory where you&#x27;ll later put your spiders</span>            __init__.py</code></pre><ul><li>创建文件<code>tutorial/spiders/quotes_spider.py</code></li></ul><pre><code class="hljs sh">import scrapyclass QuotesSpider(scrapy.Spider):    name = <span class="hljs-string">&quot;quotes&quot;</span>    def start_requests(self):        urls = [            <span class="hljs-string">&#x27;http://quotes.toscrape.com/page/1/&#x27;</span>,            <span class="hljs-string">&#x27;http://quotes.toscrape.com/page/2/&#x27;</span>,        ]        <span class="hljs-comment"># 这个yield是返回信息，将返回一个列表的 生成器 对象</span>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:            yield scrapy.Request(url=url, callback=self.parse)    def parse(self, response):        page = response.url.split(<span class="hljs-string">&quot;/&quot;</span>)[-2]        filename = <span class="hljs-string">&#x27;quotes-%s.html&#x27;</span> % page        with open(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) as f:            f.write(response.body)        self.log(<span class="hljs-string">&#x27;Saved file %s&#x27;</span> % filename)        <span class="hljs-comment"># todo 实现递归</span></code></pre><ul><li>运行</li></ul><pre><code class="hljs sh">scrapy crawl quotes</code></pre><h2 id="使用scrapy的shelll"><a href="#使用scrapy的shelll" class="headerlink" title="使用scrapy的shelll"></a>使用scrapy的shelll</h2><pre><code class="hljs sh">scrapy shell <span class="hljs-string">&#x27;http://quotes.toscrape.com/page/1/&#x27;</span></code></pre><ul><li>这时候我们拥有了<code>response</code>对象</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 匹配title</span>response.css(<span class="hljs-string">&#x27;title&#x27;</span>)<span class="hljs-comment"># [&lt;Selector xpath=&#x27;descendant-or-self::title&#x27; data=&#x27;&lt;title&gt;Quotes to Scrape&lt;/title&gt;&#x27;&gt;]</span><span class="hljs-comment"># 获取titleList的text</span>response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>).extract()<span class="hljs-comment"># [&#x27;Quotes to Scrape&#x27;]</span><span class="hljs-comment"># 获取第一个title的text</span>response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>).extract_first()<span class="hljs-comment"># 或</span>response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>)[<span class="hljs-number">0</span>].extract()<span class="hljs-comment"># &#x27;Quotes to Scrape&#x27;</span><span class="hljs-comment"># 使用正则</span>response.css(<span class="hljs-string">&#x27;title::text&#x27;</span>).re(<span class="hljs-string">r&#x27;Quotes.*&#x27;</span>)[<span class="hljs-string">&#x27;Quotes to Scrape&#x27;</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-三种urllib实现网页下载，含cookie模拟登陆</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/05-%E4%B8%89%E7%A7%8Durllib%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%90%ABcookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/05-%E4%B8%89%E7%A7%8Durllib%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%90%ABcookie%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<h1 id="coding-UTF-8"><a href="#coding-UTF-8" class="headerlink" title="coding=UTF-8"></a>coding=UTF-8</h1><pre><code>import reimport urllib.request, http.cookiejar, urllib.parse## print(&#39;---------------第一种方法----------------------&#39;)# URL = &#39;https://baike.baidu.com/item/%E5%B7%B4%E6%B2%99%E5%B0%94%C2%B7%E9%98%BF%E8%90%A8%E5%BE%B7/2867946?fromtitle=%E9%98%BF%E8%90%A8%E5%BE%B7&amp;fromid=9693472&#39;# response = urllib.request.urlopen(URL)# if response.getcode() == 200:#     conf = response.read()#     print(conf)# else:#     print(&#39;Fail&#39;)## print(&#39;---------------第二种方法----------------------&#39;)# # 创建 request 对象# request = urllib.request.Request(URL)## # 封装 request 对象# request.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;)## # 发送带头信息的请求# response1 = urllib.request.urlopen(request)# if response1.getcode() == 200:#     conf = response1.read()#     print(conf)# else:#     print(&#39;Fail&#39;)print(&#39;---------------第三种方法----------------------&#39;)URL2 = &#39;http://lczl.cnki.net/jbdetail/index?query=1&#39;URL3 = &#39;http://r.cnki.net/Klogin/Login.aspx?ReturnUrl=http://lczl.cnki.net/jbdetail/index?query=1&#39;# 创建cookieJar作为cookie容器cj = http.cookiejar.CookieJar()# 创建一个openeropener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))# 给urllib.request安装openerurllib.request.install_opener(opener)# 封装 request 对象request1 = urllib.request.urlopen(URL2)def getVIEWSTATE(data):    cer = re.compile(&#39;name=\&quot;__VIEWSTATE\&quot; id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot;&#39;, flags=0)    strlist = cer.findall(data)    # print(data)    return strlist[0]VIEWSTATE = getVIEWSTATE(request1.read().decode())# print(VIEWSTATE)data = &#123;&#39;__VIEWSTATE&#39;: VIEWSTATE.encode(), &#39;userName&#39;: &#39;345666561@qq.com&#39;, &#39;passWord&#39;: &#39;215501&#39;,        &#39;iplogin&#39;: 0&#125;  # 登陆用户名和密码post_data = urllib.parse.urlencode(data).encode()request2 = urllib.request.Request(URL3, post_data)request2.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;)response2 = urllib.request.urlopen(request2)if response2.getcode() == 200:    conf = response2.read()    print(conf.decode(&#39;utf8&#39;))    print(cj)else:    print(&#39;Fail&#39;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-代理IP</title>
    <link href="/02-Python/01-Python%E7%88%AC%E8%99%AB/07-%E4%BB%A3%E7%90%86IP/"/>
    <url>/02-Python/01-Python%E7%88%AC%E8%99%AB/07-%E4%BB%A3%E7%90%86IP/</url>
    
    <content type="html"><![CDATA[<h1 id="代理IP"><a href="#代理IP" class="headerlink" title="代理IP"></a>代理IP</h1><p>唯一一个能用的博客<br><a href="http://www.cnblogs.com/qiyeboy/p/5693128.html">博客</a></p><p>可以点开GitHub讨论里面有人做了Docker镜像</p>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>01-Python爬虫</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Flsk之Request</title>
    <link href="/02-Python/02-Flask/02-Flsk%E4%B9%8BRequest/"/>
    <url>/02-Python/02-Flask/02-Flsk%E4%B9%8BRequest/</url>
    
    <content type="html"><![CDATA[<h1 id="Flask中的Request-amp-Response"><a href="#Flask中的Request-amp-Response" class="headerlink" title="Flask中的Request&amp;Response"></a>Flask中的Request&amp;Response</h1><h2 id="Request传参"><a href="#Request传参" class="headerlink" title="Request传参"></a>Request传参</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask,request,Response<span class="hljs-meta">@app.route(&#x27;/login&#x27;,methods=[&quot;GET&quot;,&quot;POST&quot;])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:        <span class="hljs-comment"># 以POST方式传参数，通过form取值</span>        <span class="hljs-comment"># 如果Key之不存在，报错KeyError，返回400的页面</span>        username = request.form[<span class="hljs-string">&#x27;username&#x27;</span>]        password = request.form[<span class="hljs-string">&#x27;password&#x27;</span>]        <span class="hljs-keyword">print</span> (username,password)    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># 以GET方式传参数，通过args取值</span>        username = request.args[<span class="hljs-string">&#x27;username&#x27;</span>]        password = request.args[<span class="hljs-string">&#x27;password&#x27;</span>]        user_dict = &#123;<span class="hljs-string">&quot;username&quot;</span>:username,<span class="hljs-string">&quot;password&quot;</span>:password&#125;        <span class="hljs-keyword">print</span> (username,password)    <span class="hljs-keyword">return</span> Response(json.dumps(user_dict), mimetype=<span class="hljs-string">&#x27;application/json&#x27;</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>02-Flask</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Flask初体验</title>
    <link href="/02-Python/02-Flask/01-Flask%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/02-Python/02-Flask/01-Flask%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Flask初体验"><a href="#Flask初体验" class="headerlink" title="Flask初体验"></a>Flask初体验</h1><h2 id="Flask是什么"><a href="#Flask是什么" class="headerlink" title="Flask是什么"></a>Flask是什么</h2><p>Flask是一个Python的微服务框架</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs sh">pip install Flask</code></pre><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__)<span class="hljs-meta">@app.route(&#x27;/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span><span class="hljs-comment"># 旧的运行方式</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,port=<span class="hljs-string">&#x27;80&#x27;</span>)</code></pre><pre><code class="hljs sh"><span class="hljs-comment"># 新的运行方式</span><span class="hljs-built_in">export</span> FLASK_APP=hello.py<span class="hljs-comment"># 修改月允许访问主机名，默认只有localhost</span>flask run --host=0.0.0.0python -m flask run</code></pre><p>访问<a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>即可得到Respond</p><p>代码做了什么</p><ol><li>导入包</li><li>实例化WSGI(Web Server Gateway Interface)，并指定APP_NAME</li><li>地址映射，并实现功能</li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="固定路由-没有斜杠结尾"><a href="#固定路由-没有斜杠结尾" class="headerlink" title="固定路由(没有斜杠结尾)"></a>固定路由(没有斜杠结尾)</h3><pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Index Page&#x27;</span><span class="hljs-meta">@app.route(&#x27;/hello&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, World&#x27;</span></code></pre><h3 id="可变路由-没有斜杠结尾"><a href="#可变路由-没有斜杠结尾" class="headerlink" title="可变路由(没有斜杠结尾)"></a>可变路由(没有斜杠结尾)</h3><pre><code class="hljs python"><span class="hljs-meta">@app.route(&#x27;/user/&lt;username&gt;&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_user_profile</span>(<span class="hljs-params">username</span>):</span>    <span class="hljs-comment"># show the user profile for that user</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User %s&#x27;</span> % username<span class="hljs-meta">@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_post</span>(<span class="hljs-params">post_id</span>):</span>    <span class="hljs-comment"># show the post with the given id, the id is an integer</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Post %d&#x27;</span> % post_id</code></pre><h3 id="既定URL-斜杠结尾"><a href="#既定URL-斜杠结尾" class="headerlink" title="既定URL(斜杠结尾)"></a>既定URL(斜杠结尾)</h3><pre><code class="hljs python"><span class="hljs-comment"># 两个祖传的页面(斜杠结尾，相当于文件夹下的index.html文件)</span><span class="hljs-meta">@app.route(&#x27;/projects/&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">projects</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The project page&#x27;</span><span class="hljs-meta">@app.route(&#x27;/about&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">about</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The about page&#x27;</span></code></pre><h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<span class="hljs-meta">@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:        do_the_login()    <span class="hljs-keyword">else</span>:        show_the_login_form()</code></pre>]]></content>
    
    
    <categories>
      
      <category>02-Python</category>
      
      <category>02-Flask</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-html</title>
    <link href="/05-Web/01-HTML/01-html/"/>
    <url>/05-Web/01-HTML/01-html/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML超文本标记语言"><a href="#HTML超文本标记语言" class="headerlink" title="HTML超文本标记语言"></a>HTML超文本标记语言</h1><p>超文本:比普通文本更加强<br>标记语言:使用标签来描述事件的语言</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Page Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;main.css&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
      <category>01-HTML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-javaScripct入门教程.html</title>
    <link href="/05-Web/02-JavaScript/01-javaScripct%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/05-Web/02-JavaScript/01-javaScripct%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2>1.JavaScript环境安装</h2> <blockquote> <p>JavaScript是一个轻量级的编程语言，安装自然很简单。</p> <h3>a.打开你的电脑，找到一个Web浏览器，再找一个文本编辑器（比如记事本）</h3> <h3>b.没有了。。。</h3></blockquote> <h2>2.JavaScript中的基本数据类型</h2> <h3>2.1数字（number）64位浮点值</h3> <blockquote> <p>js中数字都是用number来表示，<strong>不区分整型</strong>和浮点型（其实就是浮点型），100.0===100===1e2(<strong>===表示恒等</strong>)</p> <p>NaN(not a number)表示一个非数字（<font color="#ff0000">如1/0,待测试，Java中是用正无穷大表示，即Double.NEGETIVE_INFINITY</font>），它不等于0，也不等于自己</p> <p>Infanity表示可表示的最大值===1.79769…e308</p> <p>数字的方法：Math.floor(number）得到整数</p></blockquote> <h3>2.2字符串（String）js里面的字符串并不是对象（<font color="#ff0000">待求证</font>）</h3> <blockquote> <p><font color="#000000">用’’和“ ”都可以表示字符串</font></p> <p><font color="#000000"><strong>没有char类型</strong>，只有只含一个字符的字符串</font></p> <p><font color="#000000">字符串的属性"char”.length ===4;</font></p> <p><font color="#000000">字符串是有方法的如：'char’.toUpperCase === ‘CAHR’;</font></p></blockquote> <h3>2.3boolean</h3> <blockquote> <p><font color="#000000">这个跟Java是有很大区别，跟PHP很像</font></p> <p><font color="#0000ff">false包括以下几种：</font></p> <ol> <li><font color="#000000">false</font>  <li><font color="#000000">null</font>  <li><font color="#000000">NaN</font>  <li><font color="#000000">unDefined</font>  <li><font color="#000000">空字符串’’</font>  <li><font color="#000000">0</font></li></ol> <p><font color="#0000ff">true包括其他的所有：</font></p> <ol> <li><font color="#000000">所有的除0和NaN以外的数字</font>  <li><font color="#000000">所有的对象</font>  <li><font color="#000000">所有的字符串包括字符串＇false＇</font></li></ol></blockquote> <h2><font color="#000000">3.流程控制语句（for while if swich do …）</font></h2> <blockquote> <p><font color="#000000">相同的就不赘述了，说一下不一样的地方</font></p> <p><font color="#000000"><strong>for in语句</strong></font></p> <p><font color="#000000">for(myVar in obj){</font><font color="#8fb08c">//对元素进行循环</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp; if(obj.hasOwnProperty(maVar)){</font><font color="#8fb08c">//判断myVar属性是都属于对象</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font color="#8fb08c">//todo…</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp; }</font></p> <p><font color="#000000">}</font></p></blockquote> <h2>4.对象</h2> <h3>4.1对象字面量（定义对象）</h3> <h3></h3> <blockquote> <p>在js中的字面量是神奇的，有点像PHP中的数组（js的数组是对象）</p> <p>对象字面量是一种简单的对象申明方式</p> <p><font color="#000000">var empty_obj = {};</font><font color="#8fb08c">//申明了一个空对象</font></p> <p><font color="#000000">var people = {</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp; “name”:”Tony”,</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp; “age”:”19”,</font><font color="#9bbb59">//用逗号分隔属性</font></p> <p><font color="#8fb08c">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font color="#000000">id: 17</font><font color="#9bbb59">//并不强制要求用引号</font></p> <p><font color="#9bbb59">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font color="#000000">friend:{</font><font color="#9bbb59">//允许属性嵌套</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name:”james”,</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phone:12300123</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p> <p><font color="#000000">&nbsp;&nbsp;&nbsp; };</font></p> <p><font color="#000000">看到这里你是否觉得似曾相识呢，JSON的创始人说这个东西启发了它创造了JSON</font></p></blockquote> <h3>4.2对象检索</h3> <blockquote> <p><font color="#000000">检索的方法有两种</font></p> <ol> <li><font color="#000000">people[“name”]</font>  <li><font color="#000000">people.friend.name </font><font color="#9bbb59">//更推荐这种，更加直观，还支持链式</font></li></ol> <p><font color="#000000">||字符串用于填充默认值</font></p> <p><font color="#000000">people.name||”admin”;</font><font color="#9bbb59">//如果没有值填入admin</font></p> <p><font color="#000000"><strong>检索不存在的值将会返回undefined</strong></font></p></blockquote> <h3>4.3更新对象</h3> <blockquote> <p>people.name = “GOGO”;</p></blockquote> <h3>4.4原型（父对象）</h3> <blockquote> <p>Object.Prototype是js中的标准对象，和Java的object类最大的不同就是<font color="#ff0000"><strong>js是对象不基于类（free-clss）的</strong></font></p> <p>创建基于原型的新对象<font color="#ff0000">(待研究)</font></p> <p><font color="#ff0000">注意：原型在更新时候不起作用，只会更新自对象中的属性</font></p> <p><font color="#ff0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在检索时候，子对象中没有属性会去原型中检索，直到祖宗也没有才返回undefined，这个过程叫做</font><font color="#0000ff"><strong>委托</strong></font></p></blockquote> <h3>4.5反射</h3> <p>获得类型：</p> <blockquote> <p>typeof people.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9bbb59">&nbsp;&nbsp;&nbsp; //”string ”</font></p></blockquote> <blockquote> <p>typeof people.toString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9bbb59">&nbsp; //”function</font> <font color="#9bbb59">”</font></p></blockquote> <p>检查元素是否属于对象</p> <blockquote> <p><font color="#000000">people.hasOwnProperty(‘name’);//true</font></p> <p><font color="#000000">people.hasOwnProperty(‘constructor’</font><font color="#9bbb59">);//hasOwmProperty方法不会检查原型链(constructor属性属于原型链)</font></p></blockquote> <h3>4.6删除对象</h3> <blockquote> <p>delete people.name;</p></blockquote> <h3>4.7全局变量</h3> <blockquote> <p>js中非常牛逼的是，变量很随意就是全局的，这样就很容易发生名字冲突问题，解决这个问题的方法是</p> <p>使用唯一一个全局变量把他们包装起来</p> <p>var MyApp = {</p> <p>&nbsp;&nbsp;&nbsp; “app_name”:”langji”,</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “time”:20150808</p> <p>};</p></blockquote> <h2>5.函数对象（function）</h2> <blockquote> <p><strong>函数也是对象，函数对象的原型是Function.prototype(这个原型的原型也是Object.prototype)</strong></p></blockquote> <h3>5.1函数字面量（定义函数）</h3> <blockquote> <p>var add = function(a,b){<font color="#ff0000">//注意，这里的add是变量名，函数名，函数名在function后面（待考究）被隐藏了</font></p> <p>&nbsp;&nbsp;&nbsp; return a+b;</p> <p>};</p> <p>对比一下对象字面量</p> <p>var people = {</p> <p>&nbsp;&nbsp;&nbsp; //属性</p> <p>};</p> <p><strong>值得一提的是函数可以出现在任何地方，函数中可以包含函数，</strong>函数出生就包含了上下文（<strong>闭包</strong>），<font color="#ff0000"><strong>允许链式</strong>调用</font></p></blockquote> <h3><strong><font color="#ff0000"></font></strong>5.2函数</h3>的调用 <blockquote> <p>js中函数存在4中调用模式：<strong>方法调用模式，函数调用模式，构造器调用模式，apply调用模式</strong>，这些模式在如何初始化this上存在区别</p> <ul> <li>方法调用模式</li></ul> <p>当一个函数被保存为一个对象的属性时，我们称函数为<strong>方法，即对象的方法，this绑定该对象</strong></p> <p>var people={</p> <p>&nbsp;&nbsp;&nbsp; name : “czm”,</p> <p>&nbsp;&nbsp;&nbsp; getName : function(){</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name;<font color="#9bbb59">//可以通过this获取上下文属性的方法称为公共方法</font></p> <p>&nbsp;&nbsp;&nbsp; } </p> <p>};</p> <p>调用: people.getName()；</p> <ul> <li>函数调用模式</li></ul> <p>当函数不属于一个对象时候，它就是一个函数（怎么听起来怪怪的），<strong>this绑定全局对象，导致内部函数不能访问外部函数的值（<font color="#ff0000">this本该绑定外部函数的this</font>）</strong></p> <p><strong>解决方法：自定义一个变量that，把外部函数的this赋值给它，内部函数通过that访问外部函数的属性</strong></p></blockquote> <ul> <li>构造器调用模式</li></ul>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
      <category>02-JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-http协议-请求&amp;响应</title>
    <link href="/05-Web/07-HTTP/01-http%E5%8D%8F%E8%AE%AE-%E8%AF%B7%E6%B1%82&amp;%E5%93%8D%E5%BA%94/"/>
    <url>/05-Web/07-HTTP/01-http%E5%8D%8F%E8%AE%AE-%E8%AF%B7%E6%B1%82&amp;%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="Http协议解析"><a href="#Http协议解析" class="headerlink" title="Http协议解析"></a>Http协议解析</h1><h2 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h2><ul><li>请求行<ul><li>提交方式:<ul><li>提交方式有很多,常用的GET和POST:</li><li>GET和POST的区别:<ul><li>GET的提交的参数会显示到地址栏上,而POST不显示.</li><li>GET往往是有大小限制的,而POST没有大小的限制.</li><li>GET没有请求体,而POST有请求体.</li></ul></li></ul></li><li>提交路径:</li><li>协议版本:</li></ul></li><li>请求头<ul><li>都是键值对的形式显示的.一般一个key对应一个value,也有个别的是一个key对应多个value.</li><li>User-Agent                :代表浏览器的类型. — 文件下载:下载中文文件:IE使用URLEncodor进行编码,而Firefox使用Base64编码.</li><li>Referer                :代表的是网页的来源. — 防盗链.</li><li>If-Modified-Since        :通常与响应中的头Last-Modified一起使用查找本地缓存.</li></ul></li><li>请求体<ul><li>就是POST提交方式的提交的参数.</li></ul></li></ul><h2 id="响应部分"><a href="#响应部分" class="headerlink" title="响应部分"></a>响应部分</h2><ul><li>响应行:<ul><li>协议版本</li><li>状态码        ：<ul><li>200    ：成功</li><li>301    ：重定向（302也是重定向，但是不建议用）</li><li>304    ：查找本地缓存</li><li>404    ：资源不存在</li><li>500    ：服务器内部错误</li></ul></li><li>状态码描述</li></ul></li><li>响应头：键值对,一般一个key对应一个value,也有一个key对应多个value.<ul><li>Last-Modified            :与请求中的If-Modified-Since一起使用查找本地缓存.</li><li>Content-Dispostion    :文件下载的使用使用的一个头信息.</li><li>Location                :重定向的跳转的路径.</li><li>Refresh                :定时刷新/定时跳转.</li></ul></li><li>响应体:显示浏览器的页面的内容.</li></ul>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
      <category>07-HTTP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-lamp.html</title>
    <link href="/05-Web/08-PHP/01-lamp/"/>
    <url>/05-Web/08-PHP/01-lamp/</url>
    
    <content type="html"><![CDATA[<h2 id="articleHeader1">安装Apache</h2><p><strong>1.安装Apache</strong></p><pre class="hljs sql"><code>yum -y <span class="hljs-operator"><span class="hljs-keyword">install httpd</span></span></code></pre><p><strong>2. Apache配置httpd.conf</strong></p><ul><li>通过命令&nbsp;<code>find / -name httpd.conf</code>&nbsp;找到<code>Apache</code>配置文件<code>httpd.conf</code>（默认在/etc/httpd/conf/httpd.conf）</li><li>编辑<code>httpd.conf</code>文件<pre class="hljs nginx"><code><span class="hljs-title">vi /etc/httpd/conf/httpd.conf</span></code></pre>修改<code>DocumentRoot "/xx/xx/xxx"</code>，项目在哪个目录下，就将<code>"/xx/xx/xxx"</code>改为哪个目录，例如<code>DocumentRoot "/var/www/html"&nbsp;</code>，同样将<code>&lt;Directory "/xx/xx/xxx"&gt;</code>修改为<code>&lt;Directory "/var/www/html"&gt;</code>。</li><li>查看是否安装<code>成功</code>（启动<code>Apache</code>，并查看<code>Apache</code>状态）<pre class="hljs sql"><code>  service httpd <span class="hljs-operator"><span class="hljs-keyword">start  service httpd <span class="hljs-keyword">status</span></span></span></code></pre></li></ul><p>显示<code>OK</code>说明<code>安装成功</code></p><ul><li>配置<code>Apache开机启动项</code><pre class="hljs nginx"><code>   <span class="hljs-title">chkconfig --add httpd (在服务清单中添加httpd服务)   chkconfig httpd <span class="hljs-built_in">on   </span></span></code></pre></li></ul><h2 id="articleHeader2">安装Mysql</h2><p><strong>1. 安装Mysql</strong></p><pre class="hljs sql"><code>yum -y <span class="hljs-operator"><span class="hljs-keyword">install mysql mysql-devel mysql-<span class="hljs-keyword">server mysql-libs</span></span></span></code></pre><p><strong>2. 查看Mysql版本</strong></p><pre class="hljs nginx"><code><span class="hljs-title">rpm -qi mysql-server</span></code></pre><p><strong>3. 数据库字符集设置</strong></p><ul><li><code>Mysql</code>配置文件<code>/etc/my.cnf</code>中加入<code>default-character-set=utf8</code></li></ul><p><strong>4. 启动Mysql</strong></p><pre class="hljs sql"><code>service mysqld <span class="hljs-operator"><span class="hljs-keyword">start</span></span></code></pre><p><strong>5. 创建root管理员</strong></p><pre class="hljs nginx"><code><span class="hljs-title">mysqladmin -u root password 密码</span></code></pre><p><strong>6. 配置Mysql开机启动服务</strong></p><pre class="hljs nginx"><code> <span class="hljs-title">chkconfig --add mysqld  (在服务清单中添加mysql服务) chkconfig mysqld <span class="hljs-built_in">on     (设置mysql服务随开机启动) </span></span></code></pre><p><strong>7. 登录Mysql</strong></p><pre class="hljs nginx"><code><span class="hljs-title">mysql -u root -p 回车输入密码</span></code></pre><h2 id="articleHeader3">安装PHP</h2><p><strong>1. 安装PHP</strong></p><pre class="hljs sql"><code>yum -y <span class="hljs-operator"><span class="hljs-keyword">install php</span></span></code></pre><p><strong>2. 安装PHP扩展</strong></p><pre class="hljs sql"><code>yum -y <span class="hljs-operator"><span class="hljs-keyword">install php-mysql php-gd php-imap php-ldap php-odbc php-mbstring php-devel php-soap php-cli php-pdo    yum -y <span class="hljs-keyword">install php-mcrypt php-tidy php-<span class="hljs-keyword">xml php-xmlrpc php-pearyum -y <span class="hljs-keyword">install php-pecl-memcache php-eaccelerator</span></span></span></span></span></code></pre><p><strong>3. 重启Apache</strong></p><pre class="hljs nginx"><code><span class="hljs-title">service httpd restart</span></code></pre><p><strong>4. 测试</strong></p><ul><li>在<code>/var/www/html/</code>下创建<code>index.php</code>文件，并写入<code>phpinfo()</code></li><li>浏览器访问<code>index.php</code>文件,如果输出<code>phpinfo</code>信息，<code>安装成功</code></li></ul><p>关于外网访问不了的解决方法： 在终端中输入如下命令打开防火墙： chkconfig iptables on 如闭防火墙则输入： chkconfig iptables off 上述两条命令均要重启系统才能生效。 如果不想通过重启系统而即时生效的话，可以用&ldquo;service&rdquo;命令。缺点是重启系统后设置会丢失。 开启了防火墙： service iptables start 关闭防火墙： service iptables stop 要在防火墙中设置某些端口的开关，可修改编辑/etc/sysconfig/iptables文件，比如开启SSH 端口22，可以加上如下内容： -A RH-Firewall-1-INPUT -m state ――state NEW -m tcp -p tcp ――dport 22 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 3690 -j ACCEPT &nbsp;80端口</p>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
      <category>08-PHP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Windows下搭建PHP开发环境.html</title>
    <link href="/05-Web/08-PHP/02-Windows%E4%B8%8B%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/05-Web/08-PHP/02-Windows%E4%B8%8B%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<div class="postTitle"><div class="postTitle">　　PHP集成开发环境有很多，如XAMPP、AppServ......只要一键安装就把PHP环境给搭建好了。但这种安装方式不够灵活，软件的自由组合不方便，同时也不利于学习。所以我还是喜欢手工搭建PHP开发环境，需要哪个模块自己安装就行了，或者那个软件需要升级，直接升级那个软件就行了，并不影响其他软件，非常方便。</div><div id="cnblogs_post_body"><p>&nbsp;</p><p>　　<strong>一、准备工作-下载所需软件</strong></p><ul><li>Apache&nbsp;&nbsp;<a href="http://www.apachelounge.com/download/VC14/binaries/httpd-2.4.25-win64-VC14.zip" target="_blank">httpd-2.4.25-win64-VC14.zip</a><a href="http://jingyan.baidu.com/article/29697b912f6539ab20de3cf8.html" target="_blank"><br /></a></li><li>PHP &nbsp; &nbsp; &nbsp;&nbsp;<a href="http://windows.php.net/downloads/releases/php-7.1.0-Win32-VC14-x64.zip" target="_blank">php-7.1.0-Win32-VC14-x64.zip</a></li><li>MySQL&nbsp;&nbsp;&nbsp;<a href="http://cdn.mysql.com//Downloads/MySQLInstaller/mysql-installer-community-5.7.17.0.msi">mysql-5.5.20-win32.msi</a></li></ul><p>&nbsp;</p><p>　　<strong>二、安装软件（由于新版不再提供安装文件，只提供源码，<a href="http://jingyan.baidu.com/article/29697b912f6539ab20de3cf8.html" target="_blank">VC14安装方法</a>）</strong></p><p>　　<a href="http://www.cnblogs.com/cenzhongman/p/6242622.html" target="_blank">解决httpd: Could not reliably determine the server's fully qualified domain name</a></p><p>&nbsp;</p><p>　　　　<strong>安装Apache</strong>: 双击安装，与安装其他Windows软件没有什么区别，在填Server Infomation时，并没有特殊规定，只要输入的信息符合格式即可。</p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620544829.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620553361.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620554265.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620555230.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620560244.png" alt="" /></p><p>　　　　安装完成之后，在浏览器输入http://localhost，如果显示It Works!，表示Apache安装成功。</p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020620583012.png" alt="" /></p><p>&nbsp;</p><p>　　　　<strong>安装PHP</strong>:将php-5.3.10-Win32-VC9-x86.zip解压到一个目录即可。</p><p>　　</p><p>　　　　<strong>安装MySQL</strong>:双击安装，如果需要更改安装目录，则在Choose Setup Type选择Custom</p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020621052832.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020621062017.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020621064375.png" alt="" /></p><p>　　　　安装完成后开始配置MySQL，全部保持默认选项即可，但最好把MySQL默认编码改为utf8，在Modify Security Settings选项中设置密码，输入两次密码即可完成，最后点Execute完成配置。</p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020621105636.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020621111596.png" alt="" /></p><p>&nbsp;</p><p>　　<strong>三、整合Apache+PHP+MySQL</strong></p><p>　　　　Apache : 首先修改Apache的配置文件，让Apache支持解析PHP文件。Apache配置文件在Apache安装目录的conf目录下的httpd.conf。</p><p>&nbsp;</p><p>　　　　1. 让Apache可以解析php文件，在配置文件中找到</p><p>　　　　　　　　#LoadModule vhost_alias_module modules/mod_vhost_alias.so</p><p>　　　　　 在下一行添加 (绿色的位置是根据PHP的所在目录而定的)</p><p>　　　　　　　　LoadModule php5_module "<strong>D:/Develop/PHP/php5apache2_2.dll</strong>"<br />　　　　　　　　PHPIniDir "<strong>D:/Develop/PHP</strong>"<br />　　　　　　　　AddType application/x-httpd-php .php .html .htm</p><p>&nbsp;</p><p>　　　　2. 在配置文件中找到</p><p>　　　　　　　　DirectoryIndex index.html</p><p>　　　　　 改为</p><p>　　　　　　　　DirectoryIndex&nbsp;<strong>index.php</strong>&nbsp;index.html</p><p>&nbsp;</p><p>　　　　3. 修改Apache站点目录，在配置文件中找到(Apache安装的目录不同，显示的值不一样)</p><p>　　　　　　　　DocumentRoot "<strong>D:/Develop/Apache2.2/htdocs</strong>"</p><p>　　　　　　改为</p><p>　　　　　　　　DocumentRoot "<strong>D:/Workspace/PHP</strong>"</p><p>　　　　　　</p><p>　　　　　　再找到</p><p>　　　　　　　　&lt;Directory "<strong>D:/Develop/Apache2.2/htdocs</strong>"&gt;</p><p>　　　　　　改为</p><p>　　　　　　　　&lt;Directory "<strong>D:/Workspace/PHP</strong>"&gt;　　</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>　　　　PHP : 把php.ini-development改名为php.ini，作为PHP的配置文件。修改php.ini</p><p>&nbsp;</p><p>　　　　　　1. 设置PHP扩展包的具体目录，找到</p><p>　　　　　　　　; On windows:<br />　　　　　　　　; extension_dir = "ext"</p><p>　　　　　　改为 (值是ext文件夹的目录)</p><p>　　　　　　　　; On windows:<br />　　　　　　　　&nbsp; extension_dir = "<strong>D:/Develop/PHP/ext</strong>"</p><p>&nbsp;</p><p>　　　　　　2. 开启相应的库功能，找到需要开启的库的所在行</p><p>　　　　　　　　;extension=php_curl.dll</p><p>　　　　　　　　;extension=php_gd2.dll</p><p>　　　　　　　　;extension=php_mbstring.dll</p><p>　　　　　　　　;extension=php_mysql.dll</p><p>　　　　　　　　;extension=php_xmlrpc.dll</p><p>　　　　　　 &nbsp; 去掉前面的分号(注释)，即改为</p><p>　　　　　　　　extension=php_curl.dll</p><p>　　　　　　　　extension=php_gd2.dll</p><p>　　　　　　　　extension=php_mbstring.dll</p><p>　　　　　　　　extension=php_mysql.dll</p><p>　　　　　　　　extension=php_xmlrpc.dll</p><p>　　　　　　</p><p>　　　　　　3. 设置时区，找到</p><p>　　　　　　　　;date.timezone =</p><p>　　　　　　　 改为</p><p>　　　　　　　　date.timezone = Asia/Shanghai</p><p>　　　　　　　</p><p>　　　　配置完成，检测一下配置是否成功。重启Apache，在站点目录下新建文件index.php，输入内容：</p><p>&nbsp;</p><div class="cnblogs_code"><pre>&lt;?php<br />    phpinfo();<br />?&gt;</pre></div><p>&nbsp;</p><p>　　打开浏览器输入http://localhost，显示如下内容，则安装成功，并且成功关联MySQL。</p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020622053727.png" alt="" /></p><p><img src="http://pic002.cnblogs.com/images/2012/330389/2012020622055921.png" alt="" /></p></div></div>]]></content>
    
    
    <categories>
      
      <category>05-Web</category>
      
      <category>08-PHP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Sqoop 工具使用</title>
    <link href="/07-Bigdata/05-Sqoop/01-Sqoop%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/07-Bigdata/05-Sqoop/01-Sqoop%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Sqoop 是什么及安装<br><a href="http://sqoop.apache.org/">Hadoop sqoop</a><br>#Apache sqoop (SQL to Hadoop)<br>Sqoop is a tool designed to transfer data between Hadoop and relational databases or mainframes. You can use Sqoop to import data from a relational database management system (RDBMS) such as MySQL or Oracle or a mainframe into the Hadoop Distributed File System (HDFS), transform the data in Hadoop MapReduce, and then export the data back into an RDBMS.<br>Sqoop是一种用于在Hadoop和关系数据库或大型机之间传输数据的工具。你可以使用Sqoop从一个关系数据库管理系统(RDBMS)中导入数据，比如MySQL或Oracle，或者一个大型机到Hadoop分布式文件系统(HDFS)，在Hadoop MapReduce中转换数据，然后将数据导出到RDBMS中。</p><h1 id="sqoop-安装"><a href="#sqoop-安装" class="headerlink" title="sqoop 安装"></a>sqoop 安装</h1><p>###1.解压<br>###2.配置sqoop-env.sh文件</p><pre><code>#Set path to where bin/hadoop is availableexport HADOOP_COMMON_HOME=/opt/cdh-5.3.6/hadoop-2.5.0-cdh5.3.6#Set path to where hadoop-*-core.jar is availableexport HADOOP_MAPRED_HOME=/opt/cdh-5.3.6/hadoop-2.5.0-cdh5.3.6#Set the path to where bin/hive is availableexport HIVE_HOME=/opt/cdh-5.3.6/hive-0.13.1-cdh5.3.6</code></pre><p>###3.拷贝 MySQL 连接 jar 包到 lib 目录下<br>###4.使用工具</p><pre><code># 帮助文档bin/sqoop helpbin/sqoop list-databases --help# 连接数据库bin/sqoop list-databases \--connect jdbc:mysql://hostname-ubuntu:3306 \--username root \--password ubuntu</code></pre><h1 id="Imports-RDBMS-gt-HDFS"><a href="#Imports-RDBMS-gt-HDFS" class="headerlink" title="Imports( RDBMS  &gt;  HDFS )"></a>Imports( RDBMS  &gt;  HDFS )</h1><p>####底层通过JDBC连接数据库，通过生成 JAVA (只有 map 程序) 代码，编译成 jar ，经过 YARN 执行</p><pre><code>#执行命令(五要素)bin/sqoop import \--connect jdbc:mysql://hostname-ubuntu:3306/test \--username root \--password ubuntu \--table user \--target-dir /user/cen/sqoop/imp_user \# 注意文件夹不能存在# 若此项不设置默认会在 /user/cen/tablename/ 创建文件夹# 可添加以下选项解决# 删除目标目录--delete-target-dir \# 选择列--columns id,name \# 增加查询条件--where &quot;age = &#39;18&#39;&quot; \# 设置压缩--compress \--compression-codec org.apache.hadoop.io.compress.SnappyCodec# 设置输出的分隔符--fields-terminated-by &#39;\t&#39; \# 设置map数目--num-mappers 1 \# 设置文件存储格式(默认是textfile)--as-parquetfile \# 设置直接从 MySQL 直接导入(不经过MapReduce)--direct #日志分析Running Sqoop version: 1.4.5-cdh5.3.6         说明执行版本Setting your password on the command-line is insecure. Consider using -P instead.    这样使用密码是不安全的，推荐使用-p的方式Preparing to use a MySQL streaming resultset.        使用MySQL流导出数据Beginning code generation         开始生成Java代码Executing SQL statement: SELECT t.* FROM `user` AS t LIMIT 1     执行SQL查询语句Executing SQL statement: SELECT t.* FROM `user` AS t LIMIT 1     执行SQL查询语句HADOOP_MAPRED_HOME is /opt/cdh-5.3.6/hadoop-2.5.0-cdh5.3.6         Hadoop的目录是。。。Note: /tmp/sqoop-cen/compile/55ff43412ccc6eae25cf74ff6a4b119a/user.java uses or overrides a deprecated API.        生成jarNote: Recompile with -Xlint:deprecation for details.Writing jar file: /tmp/sqoop-cen/compile/55ff43412ccc6eae25cf74ff6a4b119a/user.jar        写入jar文件It looks like you are importing from mysql.This transfer can be faster! Use the --direct        这个转换可以更快，使用直接模式option to exercise a MySQL-specific fast path.    Setting zero DATETIME behavior to convertToNull (mysql)Beginning import of user                             开始导入数据Unable to load native-hadoop library for your platform... using builtin-java classes where applicablemapred.jar is deprecated. Instead, use mapreduce.job.jar     使用mapreduce的jar包</code></pre><p>###使用SQL查询语句(无需 tablename 无需选择列 无需where )</p><pre><code>bin/sqoop import \--connect jdbc:mysql://hostname-ubuntu:3306/test \--username root \--password ubuntu \--query &#39;select id from user where $CONDITIONS&#39; \--target-dir /user/cen/sqoop/imp_user_query \--split-by id</code></pre><ul><li><p>错误：When importing query results in parallel, you must specify –split-by.</p></li><li><p>增加：–split-by id</p></li><li><p>错误：Query [select id from user] must contain ‘$CONDITIONS’ in WHERE clause.</p></li><li><p>解决：–query ‘select id from user where $CONDITIONS’ \</p></li></ul><p>###增量数据导入Incremental import（只导入新增加的）<br>####1. query 对时间戳进行条件查询（更好用）</p><pre><code>where createtime =&gt; 20170721000000 and createtimt &lt; 201707220000</code></pre><p>####2. 使用 sqoop 的参数</p><p>   –check-column <column>        Source column to check for incremental<br>                                  change 根据哪一个字段进行查询<br>   –incremental <import-type>    Define an incremental import of type<br>                                  ‘append’ or ‘lastmodified’ 追加方式<br>   –last-value <value>           Last imported value in the incremental<br>                                  check column 查询的开始值</p><h1 id="Export-HDFS-gt-RDBMS-Hive-gt-RDBMS"><a href="#Export-HDFS-gt-RDBMS-Hive-gt-RDBMS" class="headerlink" title="Export( HDFS  &gt;  RDBMS )( Hive  &gt;  RDBMS )"></a>Export( HDFS  &gt;  RDBMS )( Hive  &gt;  RDBMS )</h1><p>####底层通过JDBC连接数据库，通过生成 JAVA (只有 map 程序) 代码，编译成 jar ，经过 YARN 执行</p><pre><code>#执行命令(五要素)bin/sqoop export \--connect jdbc:mysql://hostname-ubuntu:3306/test \--username root \--password ubuntu \--table user \--export-dir /user/cen/sqoop/imp_user</code></pre><h1 id="Import-Hive-table"><a href="#Import-Hive-table" class="headerlink" title="Import Hive table"></a>Import Hive table</h1><p>####从 RDBMS 导入到 Hive 表中，底层实现：正常 Import &gt; HDFS &gt; load </p><pre><code># 关系型数据库 4 要素(IP+database/username/pw/table) + Hive 4 要素(import/database/table/分隔符) bin/sqoop import \--connect jdbc:mysql://hostname-ubuntu:3306/test \--username root \--password ubuntu \--table user \--hive-import \--hive-database default \--hive-table user \--fields-terminated-by &#39;\t&#39; \--delete-target-dir \# 需要缓冲目录，若目录存在则删除--create-hive-table     #若表不存在，需要创建的话</code></pre><h1 id="通过文件执行-sqoop-命令"><a href="#通过文件执行-sqoop-命令" class="headerlink" title="通过文件执行 sqoop 命令"></a>通过文件执行 sqoop 命令</h1><p>！！格式如下：</p><pre><code>#这是注释！！bin/sqoopimport--connectjdbc:mysql://hostname-ubuntu:3306/test--usernameroot--passwordubuntu--tableuser--target-dir/user/cen/sqoop/imp_user</code></pre><p>####执行：</p><pre><code>sqoop --options-file /opt/datas/xxx.xx</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>05-Sqoop</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hue 工具使用</title>
    <link href="/07-Bigdata/12-Hue/Hue%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/07-Bigdata/12-Hue/Hue%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="http://images2017.cnblogs.com/blog/1047249/201707/1047249-20170731025724677-1580741462.png"><br>Hue 是一个 Web 接口的 Hadoop 分析数据工具，由 Cloudra 公司开源<br>###<a href="http://gethue.com/">官方网址</a><br>###<a href="https://github.com/cloudera/hue">Github 地址 -&gt; 安装方法</a><br>###<a href="http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.12.0/manual.html">文档地址</a></p><p>##一.Build<br>####1.ubuntu安装所需环境(以Github为准)</p><pre><code># JDK# maven# 其他环境$ sudo apt-get install git ant gcc g++ libffi-dev libkrb5-dev libmysqlclient-dev libsasl2-dev libsasl2-modules-gssapi-mit libsqlite3-dev libssl-dev libxml2-dev libxslt-dev make maven libldap2-dev python-dev python-setuptools libgmp3-dev</code></pre><p>####2.build</p><pre><code>$ make apps</code></pre><p>##二.配置</p><p>###1.基础配置（位于官方文档3.1节）</p><pre><code>secret_key=jFE93j;2[290-eiw.KEiwN2s3[&#39;d;/.q[eIW^y#e=+Iei*@Mn&lt;qW5ohttp_host=cen-ubuntuhttp_port=8888time_zone=Asia/Shanghai</code></pre><p>###2.WebHDFS 配置 </p><pre><code># hdfs-site.xml(默认为true)&lt;property&gt;    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;# core-site.xml 配置代理&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.hue.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.hue.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;# hue.ini 配置 3 处，若配置 HA 需要配置 logical_name [hadoop]  # Configuration for HDFS NameNode  # ------------------------------------------------------------------------  [[hdfs_clusters]]    # HA support by using HttpFs    [[[default]]]      # Enter the filesystem uri      fs_defaultfs=hdfs://cen-ubuntu:8020      # NameNode logical name.      ## logical_name=      # Use WebHdfs/HttpFs as the communication mechanism.      # Domain should be the NameNode or HttpFs host.      # Default port is 14000 for HttpFs.      webhdfs_url=http://cen-ubuntu:50070/webhdfs/v1      # Change this if your HDFS cluster is Kerberos-secured      ## security_enabled=false      # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs      # have to be verified against certificate authority      ## ssl_cert_ca_verify=True      # Directory of the Hadoop configuration      hadoop_conf_dir=/opt/cdh5.3.6/hadoop-2.6.0-cdh5.12.0/etc/hadoop</code></pre><p>###3.YARN 配置</p><pre><code># hue.ini[[yarn_clusters]]  [[[default]]]    # Enter the host on which you are running the ResourceManager    resourcemanager_host=cen-ubuntu    # The port where the ResourceManager IPC listens on    resourcemanager_port=8032    # Whether to submit jobs to this cluster    submit_to=True    # Resource Manager logical name (required for HA)    ## logical_name=    # Change this if your YARN cluster is Kerberos-secured    ## security_enabled=false    # URL of the ResourceManager API    resourcemanager_api_url=http://cen-ubuntu:8088    # URL of the ProxyServer API    proxy_api_url=http://cen-ubuntu:8088    # URL of the HistoryServer API    history_server_api_url=http://cen-ubuntu:19888    # URL of the Spark History Server    ## spark_history_server_url=http://localhost:18088    # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs    # have to be verified against certificate authority    ## ssl_cert_ca_verify=True</code></pre><p>###4.临时文件目录</p><pre><code>[filebrowser]  # Location on local filesystem where the uploaded archives are temporary stored.  archive_upload_tempdir=/tmp</code></pre><p>###5.Hive 配置(需要启动Hive server2 服务 启动 Hive  服务)</p><pre><code># hive-site.xml&lt;!-- 配置server2 的地址和端口 --&gt;&lt;property&gt;  &lt;name&gt;hive.server2.thrift.port&lt;/name&gt;  &lt;value&gt;10000&lt;/value&gt;  &lt;description&gt;Port number of HiveServer2 Thrift interface when hive.server2.transport.mode is &#39;binary&#39;.&lt;/description&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;  &lt;value&gt;cen-ubuntu&lt;/value&gt;  &lt;description&gt;Bind host on which to run the HiveServer2 Thrift service.&lt;/description&gt;&lt;/property&gt;# 启动hiveserver2$ bin/hiveserver2 # hive-site.xml&lt;!-- 配置远程 remote metastore 的uri 见hive官方文档--&gt;&lt;property&gt;  &lt;name&gt;hive.metastore.uris&lt;/name&gt;  &lt;value&gt;thrift://cen-ubuntu:9083&lt;/value&gt;&lt;/property&gt;# 启动 metastore serverhive --service metastore# hue.ini[beeswax]  # Host where HiveServer2 is running.  # If Kerberos security is enabled, use fully-qualified domain name (FQDN).  hive_server_host=cen-ubuntu  # Port where HiveServer2 Thrift server runs on.  hive_server_port=10000  # Hive configuration directory, where hive-site.xml is located  hive_conf_dir=/opt/cdh5.3.6/hive-1.1.0-cdh5.12.0/conf  # Timeout in seconds for thrift calls to Hive service  server_conn_timeout=120</code></pre><p>###6.database 链接管理关系型数据库(SQLite3 是 que 自带的数据库)(注意：需要删除[[[xxx]]]前注释)</p><pre><code>############################################################################ Settings for the RDBMS application###########################################################################[librdbms]  # The RDBMS app can have any number of databases configured in the databases  # section. A database is known by its section name  # (IE sqlite, mysql, psql, and oracle in the list below).  [[databases]]    # sqlite configuration.    ## [[[sqlite]]]      # Name to show in the UI.      nice_name=SQLite      # For SQLite, name defines the path to the database.      name=/opt/cdh5.3.6/hue-3.9.0-cdh5.12.0/desktop/desktop.db      # Database backend to use.      engine=sqlite      # Database options to send to the server when connecting.      # https://docs.djangoproject.com/en/1.4/ref/databases/      ## options=&#123;&#125;    # mysql, oracle, or postgresql configuration.    [[[mysql]]]      # Name to show in the UI.      nice_name=&quot;My SQL DB&quot;      # For MySQL and PostgreSQL, name is the name of the database.      # For Oracle, Name is instance of the Oracle server. For express edition      # this is &#39;xe&#39; by default.      name=mysqldb      # Database backend to use. This can be:      # 1. mysql      # 2. postgresql      # 3. oracle      engine=mysql      # IP or hostname of the database to connect to.      host=cen-ubuntu      # Port the database server is listening to. Defaults are:      # 1. MySQL: 3306      # 2. PostgreSQL: 5432      # 3. Oracle Express Edition: 1521      port=3306      # Username to authenticate with when connecting to the database.      user=root      # Password matching the username to authenticate with when      # connecting to the database.      password=ubuntu      # Database options to send to the server when connecting.      # https://docs.djangoproject.com/en/1.4/ref/databases/      ## options=&#123;&#125;</code></pre><p>###7.Oozie 配置</p><pre><code>[liboozie]  # The URL where the Oozie service runs on. This is required in order for  # users to submit jobs. Empty value disables the config check.  oozie_url=http://cen-ubuntu:11000/oozie  # Requires FQDN in oozie_url if enabled  ## security_enabled=false  # Location on HDFS where the workflows/coordinator are deployed when submitted.  remote_deployement_dir=/user/cen/examples/apps  [oozie]    # Location on local FS where the examples are stored.    local_data_dir=/opt/cdh5.3.6/oozie-4.1.0-cdh5.12.0/examples    # Location on local FS where the data for the examples is stored.    sample_data_dir=/opt/cdh5.3.6/oozie-4.1.0-cdh5.12.0/examples/input-data    # Location on HDFS where the oozie examples and workflows are stored.    # Parameters are $TIME and $USER, e.g. /user/$USER/hue/workspaces/workflow-$TIME    remote_data_dir=/user/cen/examples/apps/</code></pre><p>##三.运行</p><pre><code># 0.0.0.0意味着所有ip都能访问，本来是在hue.ini中配置的，但是配置不生效，因此手动设置$ build/env/bin/hue runserver 0.0.0.0:8000</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>12-Hue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 MySQL 存储 Hue 元数据</title>
    <link href="/07-Bigdata/12-Hue/%E4%BD%BF%E7%94%A8%20MySQL%20%E5%AD%98%E5%82%A8%20Hue%20%E5%85%83%E6%95%B0%E6%8D%AE/"/>
    <url>/07-Bigdata/12-Hue/%E4%BD%BF%E7%94%A8%20MySQL%20%E5%AD%98%E5%82%A8%20Hue%20%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>###1.在 MySQL 中增加数据库 hue<br>###2.编辑 hue.ini 文件</p><pre><code>[[database]]  # Database engine is typically one of:  # postgresql_psycopg2, mysql, sqlite3 or oracle.  #  # Note that for sqlite3, &#39;name&#39;, below is a path to the filename. For other backends, it is the database name  # Note for Oracle, options=&#123;&quot;threaded&quot;:true&#125; must be set in order to avoid crashes.  # Note for Oracle, you can use the Oracle Service Name by setting &quot;host=&quot; and &quot;port=&quot; and then &quot;name=&lt;host&gt;:&lt;port&gt;/&lt;service_name&gt;&quot;.  # Note for MariaDB use the &#39;mysql&#39; engine.  engine=mysql  host=cen-ubuntu  port=3306  user=root  password=ubuntu  # conn_max_age option to make database connection persistent value in seconds  # https://docs.djangoproject.com/en/1.9/ref/databases/#persistent-connections  ## conn_max_age=0  # Execute this script to produce the database password. This will be used when &#39;password&#39; is not set.  ## password_script=/path/script  name=hue</code></pre><p>###3.初始化数据库</p><pre><code>$ build/env/bin/hue syncdb$ build/env/bin/hue migrate</code></pre>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>12-Hue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive 的企业优化</title>
    <link href="/07-Bigdata/11-Hive/Hive%20%E7%9A%84%E4%BC%81%E4%B8%9A%E4%BC%98%E5%8C%96/"/>
    <url>/07-Bigdata/11-Hive/Hive%20%E7%9A%84%E4%BC%81%E4%B8%9A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>#优化<br>##数据优化<br>###一、从大表拆分成小表（更快地检索）<br>引用：<a href="http://www.cnblogs.com/cenzhongman/p/7163257.html">Hive LanguageManual DDL</a></p><pre><code>eg2:常用于分表create table if not exists default.cenzhongman_2AS select ip,date from default.cenzhongman;</code></pre><p>###二、使用外部表（多部门共用，指定存储目录，删表不删数据），分区表（按月按XXX分区）<br>引用：<a href="http://www.cnblogs.com/cenzhongman/p/7163257.html">Hive LanguageManual DDL</a></p><pre><code>#创建外部表CREATE EXTERNAL TABLE IF NOT EXISTS table_name();#创建分区表create table emp_partition(ID int, name string, job string, mrg int, hiredate string, sal double, comm double, deptno int) partitioned by (mouth string);</code></pre><p>###三、使用 ORC | parquet 数据存储格式<br>引用：<a href="http://www.cnblogs.com/cenzhongman/p/7197380.html">Hive 表数据的存储和压缩格式</a></p><pre><code>#官网例子create table Addresses (  name string,  street string,  city string,  state string,  zip int) stored as orc tblproperties (&quot;orc.compress&quot;=&quot;NONE&quot;);</code></pre><p>###四、使用 snappy 压缩格式<br>引用：<a href="http://www.cnblogs.com/cenzhongman/p/7197380.html">Hive 表数据的存储和压缩格式</a></p><pre><code> 如上例</code></pre><p>###五、FetchTask 抓取任务转换 &gt; more</p><pre><code>&lt;property&gt;  &lt;name&gt;hive.fetch.task.conversion&lt;/name&gt;  &lt;value&gt;more&lt;/value&gt;  &lt;description&gt;    Expects one of [none, minimal, more].    Some select queries can be converted to single FETCH task minimizing latency.    Currently the query should be single sourced not having any subquery and should not have    any aggregations or distincts (which incurs RS), lateral views and joins.    0. none : disable hive.fetch.task.conversion    1. minimal : SELECT STAR, FILTER on partition columns, LIMIT only （Select * 、筛选分区、limit 限制显示行数 这三种行为不会经过 mapreduce）    2. more    : SELECT, FILTER, LIMIT only (support TABLESAMPLE and virtual columns)（相对nimimal 增加了时间戳，虚拟列，还有所有的选择）  &lt;/description&gt;&lt;/property&gt;</code></pre><p>##优化 SQL 语句</p><h3 id="join-优化"><a href="#join-优化" class="headerlink" title="join 优化"></a>join 优化</h3><p><a href="http://www.cnblogs.com/cenzhongman/p/7128140.html">关于mapreduce的各个阶段</a><br><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins#LanguageManualJoins-MapJoinRestrictions">Join 的官方文档</a><br>####common/shuffle/reduce join ：join 发生在 reduce 阶段<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718105242115-1523736433.png"><br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718105251208-670525945.png"><br>大表对大表，每个表的数据都从文件中读取<strong>（发生在Reduce shuffle 的分组Group过程(相同的key的value放在一起)）</strong><br>####Map join ：join 发生在 Map 阶段<br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718105321068-942054504.png"></p><p>小表对大表，大表的数据从文件中读取，小表的数据在内存中，通过 DistributedCache 类进行缓存<br>####SMB join ：Sort-Merge-Bucket join<br>####<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+JoinOptimization#LanguageManualJoinOptimization-AutoConversiontoSMBMapJoin">SMB 的设置</a><br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718110804708-2128160471.png"></p><pre><code>注：Bucket CLUSTERED 按照 num_buckets 对数据进行分区并排序[CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</code></pre><p><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718105334177-1201681320.png"><br><img src="http://images2015.cnblogs.com/blog/1047249/201707/1047249-20170718105340599-1831675400.png"><br>面对大表对大表处理时候的优化，Merge  &gt;  sort  &gt;   join<br>根据两个表的相同字段进行 按 num_buckets  分组（Merge） 并 在组内 排序（Sort）</p><p>###execution plan 执行计划<br>###<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Explain">官方文档</a><br>####查看执行计划</p><pre><code>EXPLAIN [EXTENDED|DEPENDENCY|AUTHORIZATION] queryeg:explain select * from emp;</code></pre><p>####能够看到的信息</p><ul><li>The Abstract Syntax Tree for the query 语法树</li><li>The dependencies between the different stages of the plan 依赖关系</li><li>The description of each of the stages 每个阶段的描述</li></ul><p>##其他高级优化<br>####1.设置任务并行执行</p><table><thead><tr><th>参数</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>hive.exec.parallel</td><td>false</td><td>默认为 false</td></tr><tr><td>hive.exec.parallel.thread.number</td><td>8</td><td>建议10 ~ 20 之间</td></tr></tbody></table><p>####2.合理设置 reduce 任务的数量</p><table><thead><tr><th>参数</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>mapreduce.job.reduces</td><td>1</td><td>测试出真知</td></tr></tbody></table><p>####3.推测执行 speculative<br>在 mapReduce 运行过程中，当 ApplicationMaster 检测到任务执行时间差异明显比正常时间长时，会多运行一个任务，结果取决于最先结束运行的任务。<br>在 Hive 执行过程中出现长时间任务为正常现象，为了防止系统创建重复任务占用过多的资源，应该关闭该功能</p><table><thead><tr><th>参数</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>hive.mapred.reduce.tasks.speculative.execution</td><td>true</td><td>当用 Hive 时候推荐为 false</td></tr><tr><td>mapreduce.map.speculative</td><td>true</td><td>当用 Hive 时候推荐为 false</td></tr><tr><td>mapreduce.reduce.speculative</td><td>true</td><td>当用 Hive 时候推荐为 false</td></tr></tbody></table><p>####4.合理设置 Map 值<br>一般来说，根据文件大小就是很合理的了。</p><p>####5.动态分区调整</p><table><thead><tr><th>参数</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>hive.exec.dynamic.partition</td><td>true</td><td>是否开启动态分区属性</td></tr><tr><td>hive.exec.dynamic.partition.mode</td><td>strict</td><td>strict mode, 用户必须指定至少一个静态分区以防用户意外地覆盖了所有的分区。nonstrict mode 所有的分区都是动态的</td></tr></tbody></table><p>####6.查询模式设置</p><table><thead><tr><th>参数</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>hive.mapred.mode  nonstrict</td><td>nostrict</td><td>strict/nostrict</td></tr></tbody></table><p>设置严格模式将禁止三种类型查询</p><ul><li>1）对于分区表，不加分区字段过滤条件，不能执行：分区表中，where 子句中不加分区过滤<br>  Error eg:select * from emp_partition where name = ‘cenzhongman’;<br>  Right eg:select * from emp_partition where name = ‘cenzhongman’, month = ‘201707’;</li><li>2）对于 oder by 语句，必须使用 limit 语句</li><li>3）限制笛卡尔积的查询（Join 的时候不适用 on 而使用 where 的）</li></ul>]]></content>
    
    
    <categories>
      
      <category>07-Bigdata</category>
      
      <category>11-Hive</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Adapt适配器.html</title>
    <link href="/09-Android/Adapt%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <url>/09-Android/Adapt%E9%80%82%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>为接口提供所有的空实现，让使用者仅仅覆盖需要的部分；</p><p>本思想肯定有问题，慢慢考究</p><p>&nbsp;</p><div class="cnblogs_code"><pre>　　　　frame.addWindowListener(<span style="color: #0000ff;">new</span><span style="color: #000000;"> WindowAdapter() {            @Override            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowClosing(WindowEvent e) {                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>                <span style="color: #0000ff;">super</span><span style="color: #000000;">.windowClosing(e);            }        });</span></pre></div><p>Window是一个接口，拥有众多方法等等待实现，如关闭，打开，最小化。。。。</p><p>WindowAdapter()是一个适配器，提供了所有Window方法的空实现，在不覆盖时，什么也不做</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> WindowAdapter</span><span style="color: #0000ff;">implements</span><span style="color: #000000;"> WindowListener, WindowStateListener, WindowFocusListener{</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowOpened(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowClosing(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowClosed(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowIconified(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowDeiconified(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowActivated(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowDeactivated(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowStateChanged(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowGainedFocus(WindowEvent e) {}</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> windowLostFocus(WindowEvent e) {}}</span></pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity之间的数据传递</title>
    <link href="/09-Android/Activity%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <url>/09-Android/Activity%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h3 id="Intent作为component（组件）之间的信使，被传递的extra信息（可以是任意数据）将由使者Intent发送出去，传递给下一个Component"><a href="#Intent作为component（组件）之间的信使，被传递的extra信息（可以是任意数据）将由使者Intent发送出去，传递给下一个Component" class="headerlink" title="Intent作为component（组件）之间的信使，被传递的extra信息（可以是任意数据）将由使者Intent发送出去，传递给下一个Component"></a>Intent作为component（组件）之间的信使，被传递的extra信息（可以是任意数据）将由使者Intent发送出去，传递给下一个Component</h3><p>调用intent.putExtra()方法，参数：1.键，2.值<br>    intent.putExtra(“KEY_a”,a);<br>使用包名修饰extra数据信息，可以避免来自不同应用的extra间发生命名冲突<br>    private static final String EXTRA_ANSWER_IS_TRUE = “com.cenzhognman.myapplication2.Quiz.EXTRA_ANSWER_IS_TRUE “;<br>    intent.putExtra(EXTRA_ANSWER_IS_TRUE ,mQuestionBank[mCurrentIndex].isAnswerTure());<br>返回值也是一个intent实例，可以链式调用<br>    intent.putExtra(“KEY_A”,a).putExtra(“KEY_B”,1)……</p><p>获取extra信息<br>    boolean mAnswerIsTrue = getIntent().getBooleanExtra(“KEY_A”, false);//自带默认参数</p><p>需要被启动的Activity返回数据给原来的activity<br>    startActivityForResult(intent,0)<br>一般来说，参数result code可以是以下两个预定义常量中的任何一个：</p><ul><li>Activity.RESULT_OK；</li><li>Activity.RESULT_CANCELED。<br>（如需自己定义结果代码，还可使用另一个常量： RESULT_FIRST_USER。）</li></ul>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fragment碎片的创建和动态更新.html</title>
    <link href="/09-Android/Fragment%E7%A2%8E%E7%89%87%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <url>/09-Android/Fragment%E7%A2%8E%E7%89%87%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>Fragment，在平板应用中较为参见，把视图分为两个甚至多个模块。</p><h2>一，一个简单的fragment</h2><h4>1.创建两个局部文件,用于等待被调用</h4><p>（1）left_fragment</p><p>（2）right_fragment</p><h4>2.分别创建两个继承于fragment类的类</h4><p>（1）leftFragment（加载xml文件）</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> LeftleftFragment <span style="color: #0000ff;">extends</span> Fragment {    @Nullable    @Override    <span style="color: #0000ff;">public</span> View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {       View view = inflater.inflate(R.layout.left_fragment,container,<span style="color: #0000ff;">false</span>);<span style="color: #008000;">//动态加载xml</span>        <span style="color: #0000ff;">return</span> view;    }}</pre></div><p>（2）rightFragment</p><div class="cnblogs_code"><pre>我是代码（同上）；</pre></div><h4>3.在activity所调用的xml中添加&lt;fragment&gt;控件</h4><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;?</span>xml version="1.0" encoding="utf-8"<span style="color: #0000ff;">?&gt;</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout</span> <span style="color: #ff0000;">xmlns</span>:<span style="color: #ff0000;">android</span>=<span style="color: #0000ff;">"http://schemas.android.com/apk/res/android"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">fragment</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/left_fragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">name</span>=<span style="color: #0000ff;">"com.cenzhongman.myapplication.fragment.LeftleftFragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"wrap_content"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_weight</span>=<span style="color: #0000ff;">"1"</span><span style="color: #0000ff;">/&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">fragment</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/right_fragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">name</span>=<span style="color: #0000ff;">"com.cenzhongman.myapplication.fragment.RightFragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"wrap_content"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_weight</span>=<span style="color: #0000ff;">"1"</span><span style="color: #0000ff;">/&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre></div><h3>二，动态切换fragment</h3><h4>4.在原基础之上创建AnotherRightFragment(指向要调用的layout)</h4><div class="cnblogs_code"><pre>我是代码（同上，较少重复加载）</pre></div><h4>5.在MainActivity所调用xml中更改布局方式</h4><p>用两FrameLayout（强制左上角对齐的布局），来存放fragment，<span style="color: #ff0000;">动态更新时候将会更换FrameLayout中的内容，也就是旗下的<span style="color: #800000;">FrameLayout</span></span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;?</span>xml version="1.0" encoding="utf-8"<span style="color: #0000ff;">?&gt;</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout</span> <span style="color: #ff0000;">xmlns</span>:<span style="color: #ff0000;">android</span>=<span style="color: #0000ff;">"http://schemas.android.com/apk/res/android"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">FrameLayout</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/left_fragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_weight</span>=<span style="color: #0000ff;">"1"</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">fragment</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">name</span>=<span style="color: #0000ff;">"com.cenzhongman.myapplication.fragment.LeftleftFragment"</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/fragment"</span> <span style="color: #0000ff;">/&gt;</span>    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">FrameLayout</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">FrameLayout</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/right_fragment"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_weight</span>=<span style="color: #0000ff;">"1"</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">fragment</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">name</span>=<span style="color: #0000ff;">"com.cenzhongman.myapplication.fragment.RightFragment"</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>            <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span> <span style="color: #0000ff;">/&gt;</span>    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">FrameLayout</span><span style="color: #0000ff;">&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre></div><h4>6.在MainActivity中更换fragment</h4><div class="cnblogs_code"><pre>public void onClick(View v) {                AnotherRightFragment anotherRightFragment = new AnotherRightFragment();                FragmentManager fragmentManager = getFragmentManager();                FragmentTransaction transaction = fragmentManager.beginTransaction();                transaction.replace(R.id.right_fragment, anotherRightFragment);                transaction.commit();<span style="color: #ff0000;">//必须调用commit（）方法，否则显示不出来</span>            }</pre></div><blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 创建待添加的碎片实例。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 获取到 FragmentManager，在活动中可以直接调用 getFragmentManager()方法得到。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. 开启一个事务，通过调用 beginTransaction()方法开启。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. 向容器内加入碎片，一般使用 replace()方法实现，需要传入容器的 id 和待添加的碎<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 片实例。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5. 提交事务，调用 commit()方法来完成。</p></blockquote><h2>三，把fragment添加到返回栈</h2><div class="cnblogs_code"><pre>transaction.addToBackStack(<span style="color: #0000ff;">null</span>);//接收一个名字用于描述返回栈的状态，一般传入null即可</pre></div><p>&nbsp;</p><p>&nbsp;</p><h1>用fragment来做导航</h1><h4>1.在MainActivity的xml留出用于装fragment的容器</h4><h4>2.写好Fragment的xml描述文件</h4><p>3.<strong>写四个Fragment的实现类，继承于Fragment</strong></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> IdeaFragment <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fragment {    @Nullable    @Override    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {        View view </span>= inflater.inflate(R.layout.<span style="color: #ff00ff;">fragment_idea</span>,container,<span style="color: #0000ff;">false</span><span style="color: #000000;">);        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> view;    }}</span></pre></div><p>&nbsp;</p><p><strong>4.MainActivity应继承于FragmentActivity，并创建Fragment对象</strong></p><div class="cnblogs_code"><pre><span style="color: #008000;">//</span><span style="color: #008000;">定义fragment对象，基于v4包</span>    <span style="color: #0000ff;">private</span><span style="color: #000000;"> Fragment study_fragment;    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Fragment app_fragment;    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Fragment idea_fragment;    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Fragment personal_fragment;    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义fragmentManager对象</span><span style="color: #000000;">    FragmentManager mFragmentManager;    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mFragmentManager </span>=<span style="color: #000000;"> getSupportFragmentManager();<span style="color: #339966;">//</span></span><span style="color: #339966;">基于v4包</span></pre><pre><span style="color: #000000;">initView(); }</span></pre></div><p>&nbsp;</p><p><strong>5.得到</strong><span style="font-family: 宋体;">FragmentTransaction</span><strong>对象，并根据情况选择添加或者显示fragment</strong></p><p><strong>！！！一定要commit（）！！！</strong></p><div class="cnblogs_code"><pre>FragmentTransaction transaction =<span style="color: #000000;"> mFragmentManager.beginTransaction();idea_Button.setImageResource(R.drawable.idea_blue);                idea_TextView.setTextColor(getResources().getColor(R.color.sky_blue));                </span><span style="color: #0000ff;">if</span> (idea_fragment == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {                    idea_fragment </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> IdeaFragment();                    transaction.add(R.id.content, idea_fragment);                    transaction.commit();                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {                    transaction.show(idea_fragment);                    transaction.commit();                }</span></pre></div><p>&nbsp;参考资料：<a href="http://blog.csdn.net/qq_15096707/article/details/46581799">Fragment之底部导航栏的实现</a></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SharedPreferences使用(通过键值保存数据).html</title>
    <link href="/09-Android/SharedPreferences%E4%BD%BF%E7%94%A8(%E9%80%9A%E8%BF%87%E9%94%AE%E5%80%BC%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE)/"/>
    <url>/09-Android/SharedPreferences%E4%BD%BF%E7%94%A8(%E9%80%9A%E8%BF%87%E9%94%AE%E5%80%BC%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE)/</url>
    
    <content type="html"><![CDATA[<h2><span style="line-height: 1.5;">保存数据到</span>SharedPreferences中</h2><p><span class="fontstyle0">　　要想使用<span class="fontstyle1">SharedPreferences<span class="fontstyle0">来存储数据， 首先需要获取到<span class="fontstyle1">SharedPreferences<span class="fontstyle0">对象。 <span class="fontstyle1">Android<span class="fontstyle0">中主要提供了三种方法用于得到 <span class="fontstyle1">SharedPreferences <span class="fontstyle0">对象 </span></span></span></span></span></span></span></span></span></p><h3><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0">1.<span class="fontstyle0">&nbsp;Context <span class="fontstyle2">类中的 <span class="fontstyle0">getSharedPreferences()<span class="fontstyle2">方法</span></span></span></span></span></span></span></span></span></span></span></span></span></h3><p>　　此方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences 文件都是存放在/data/data/&lt;packagename&gt;/shared_prefs/目录下的。第二个参数用于指定操作模式，主要有两种模式可以选择，MODE_PRIVATE 和 MODE_MULTI_PROCESS。MODE_PRIVATE 仍然是默认的操作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。 MODE_MULTI_PROCESS 则一般是用于会有多个进程中对同一个 SharedPreferences 文件进行读写的情况。类似地，MODE_WORLD_READABLE和 MODE_WORLD_WRITEABLE 这两种模式已在 Android 4.2 版本中被废弃。</p><h3><br />2. Activity 类中的 getPreferences()方法</h3><p>　　这个方法和 Context 中的 getSharedPreferences()方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文件名。</p><h3><br />3. PreferenceManager 类中的 getDefaultSharedPreferences()方法</h3><p>　　这是一个静态方法，它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。得到了 SharedPreferences 对象之后， 就可以开始向 haredPreferences 文件中存储数据了</p><h2>主要可以分为三步实现。</h2><h3>　　1. 调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象。</h3><div class="cnblogs_code"><pre>SharedPreferences.Editor editor = getSharedPreferences("data"<span style="color: #000000;">,MODE_PRIVATE).edit();<br /></span></pre></div><h3>　　2. 向 SharedPreferences.Editor 对象中添加数据，比如添加一个布尔型数据就使用putBoolean 方法，添加一个字符串则使用 putString()方法，以此类推。</h3><div class="cnblogs_code"><pre>editor.putString("name", "Tom"<span style="color: #000000;">);editor.putInt(</span>"age", 28<span style="color: #000000;">);editor.putBoolean(</span>"married", <span style="color: #0000ff;">false</span><span style="color: #000000;">);<br /></span></pre></div><h3>　　3. 调用 commit()方法将添加的数据提交，从而完成数据存储操作</h3><div class="cnblogs_code"><pre>editor.commit();</pre></div><p>&nbsp;</p><h2><span style="line-height: 1.5;">从SharedPreferences中获取数据</span></h2><h3>（1）getSharedPreferences()方法得到SharedPreferences对象，两个参数，1：文件名，2：模式</h3><div class="cnblogs_code"><pre>SharedPreferences GetDataSharedPreferences = getSharedPreferences("SharePreferences", MODE_PRIVATE);</pre></div><h3>（2）SharedPreferences对象中获取数据，getXXX()方法，两个参数，1：键值，2：默认值</h3><div class="cnblogs_code"><pre>String name = GetDataSharedPreferences.getString("name", "");<br /><span style="color: #0000ff;">int</span> age = GetDataSharedPreferences.getInt("age", 0);<br /><span style="color: #0000ff;">boolean</span> handsome = GetDataSharedPreferences.getBoolean("handsome", <span style="color: #0000ff;">false</span>);</pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内容提供器（Content Provider）.html</title>
    <link href="/09-Android/%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%EF%BC%88Content%20Provider%EF%BC%89/"/>
    <url>/09-Android/%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%EF%BC%88Content%20Provider%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3>一个跟数据库很相似的用于与其他程序传递信息的组件，用的也是数据库的CRUD操作</h3><h3>　　相关权限</h3><ul><li>注册内容提供者以及权限</li></ul><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">provider</span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".ContentResolver.CreateContentResplver"</span><span style="color: #ff0000;">android:authorities</span><span style="color: #0000ff;">="com.cenzhongman.provider"</span><span style="color: #ff0000;">android:exported</span><span style="color: #0000ff;">="true"</span><span style="color: #0000ff;">&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">provider</span><span style="color: #0000ff;">&gt;</span></pre></div><ul><li><span style="line-height: 1.5;">获取系统联系人权限</span></li></ul><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">uses-permission </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.permission.READ_CONTACTS"</span> <span style="color: #0000ff;">/&gt;</span></pre></div><h3>内容URI(标识)</h3><p>协议声明://权限（authority）/路径（path）</p><div class="cnblogs_code"><pre><span style="color: #000000;">content://com.example.app.provider/table1-------------------table1表格的数据content://com.example.app.provider/table1/1-----------------包含id值为1数据content://com.example.app.provider/*------------------------包含任意的表格content://com.example.app.provider/table1/#-----------------包含table1表格的任意行的数据</span></pre></div><h3>调用 Uri.parse()方法，将内容 URI 字符串解析成 Uri 对象</h3><div class="cnblogs_code"><pre>Uri uri = Uri.parse("content://com.example.app.provider/table1")</pre></div>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建自己的Activity.html</title>
    <link href="/09-Android/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Activity/"/>
    <url>/09-Android/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Activity/</url>
    
    <content type="html"><![CDATA[<h3>创建自己的Activity</h3><p>&nbsp;</p><h4>　　1.新建class，继承Activity类</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201610/1047249-20161030144157390-844615242.png" alt="" /></p><p><img src="http://images2015.cnblogs.com/blog/1047249/201610/1047249-20161030144314578-1150170994.png" alt="" /></p><h4>　　2.重写新建类的onCreate 方法</h4><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> SecondActivity <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Activity {    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle SaveInstanceState){        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(SaveInstanceState);        setContentView(R.layout.second_layout);   </span><span style="color: #008000;">//</span><span style="color: #008000;">引用layout文件，要先建好文件，见下面<br />}</span></pre></div><h4>　　3.新建layout文件</h4><p><img src="http://images2015.cnblogs.com/blog/1047249/201610/1047249-20161030145023437-551818054.png" alt="" /></p><p>&nbsp;</p><p><img src="http://images2015.cnblogs.com/blog/1047249/201610/1047249-20161030145031984-591516058.png" alt="" /></p><p>&nbsp;</p><h4>　　4.在AndroidMainfest.xml中添加描述（必须在application中）</h4><p>第一个Activity描述中的intent-filter是作为第一个启动页面的描述语句</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">　　　　　　&lt;</span><span style="color: #800000;">activity            </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".FirstActivity"</span><span style="color: #ff0000;">            android:label</span><span style="color: #0000ff;">="自己创建的Activity"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.action.MAIN"</span> <span style="color: #0000ff;">/&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">category </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.category.LAUNCHER"</span> <span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">activity</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">activity </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".SecondActivity"</span><span style="color: #ff0000;">            android:label</span><span style="color: #0000ff;">="这是第二个activity"</span><span style="color: #0000ff;">/&gt;</span></pre></div><p><br />&nbsp;&nbsp;&nbsp; 创建完成，通过CTRL+鼠标检测引用成功</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步消息处理机制,UI更新.html</title>
    <link href="/09-Android/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6,UI%E6%9B%B4%E6%96%B0/"/>
    <url>/09-Android/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6,UI%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h4>UI只能在主线程中完成更新，在子线程中更新UI报错如下</h4><div class="cnblogs_code"><pre>Only the original thread that created a view hierarchy can touch its views.</pre></div><p><span style="font-size: 15px;">但是，在主线程中完成耗时操作容易引起使用体验不佳，进程卡顿问题，为了解决此问题引入<span style="color: #ff0000;">异步消息处理机制</span></span></p><h1><span style="font-family: 'Microsoft YaHei';"><strong>异步消息处理机制</strong></span></h1><ol><li><h3>message 携带少量信息的消息，what字段，arg1字段，arg2字段，obj字段（三个整型，一个obj型）</h3></li><li><h3>handler 消息管理者，sengMessage()方法和handlerMessage()方法，一个用于发送信息，一个用于接<strong>收信息</strong></h3></li><li><h3><strong>MessageQueue 消息队列，存放消息，等待被处理</strong></h3></li><li><h3><strong>Looper 循环器，MessageQueue的管家，调用looper的loop()方法后，MessageQueue中的消息进去无限循环，将消息传递至handlerMessage中</strong></h3></li></ol><h2>&nbsp;</h2><h2><strong>使用异步消息的步骤</strong></h2><ol><li><strong>再主线程中创建handler，并重写handlerMessage()方法</strong></li></ol><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">private</span> Handler mHandler = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Handler() {        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> handleMessage(Message msg) {            </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (msg.what) {                </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> SHOW_RESPONSE:                    String response </span>=<span style="color: #000000;"> (String) msg.obj;                    NetworkTextView.setText(response);                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;            }        }    };</span></pre></div><p><strong>　　2.在子线程中更新UI时，创建Message对象，给Message对象的字段赋值，并把使用Handler.sengMessage()方法，将Message对象发送出去</strong></p><div class="cnblogs_code"><pre>       Message message = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Message();       message.what </span>=<span style="color: #000000;"> SHOW_RESPONSE;       message.obj </span>=<span style="color: #000000;"> response.toString();       mHandler.sendMessage(message);</span></pre></div><p><strong>　　3.在主线程中的handlerMessage接收到Messsge并进行判断，执行操作</strong></p><p>&nbsp;</p><h1><strong>使用AsyncTask更新UI(封装好的异步消息处理机制)</strong></h1><h2><strong><span class="fontstyle0">由于 <span class="fontstyle2">AsyncTask <span class="fontstyle0">是一个抽象类，要<span style="color: #ff0000;">创建一个子类去继承它</span>。在继承时我们可以为 <span class="fontstyle2">AsyncTask <span class="fontstyle0">类指定三个泛型参数，这三个参数的用途如下。</span></span></span></span></span></strong></h2><p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">1. Params<br /><span class="fontstyle0">　　在执行 <span class="fontstyle2">AsyncTask <span class="fontstyle0">时需要传入的参数，可用于在后台任务中使用。<br /><span class="fontstyle2">2. Progress<br /><span class="fontstyle0">　　后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。<span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle3"><br /><span class="fontstyle2">3. Result<br /><span class="fontstyle0">当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle0">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">class</span> DownloadTask <span style="color: #0000ff;">extends</span> AsyncTask&lt;Void, Integer, Boolean&gt;<span style="color: #000000;"> {&hellip;&hellip;}</span></pre></div><p>&nbsp;</p><h2>重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个。</h2><p>1. onPreExecute()<br />　　这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。<br />2. doInBackground(Params...)<br />　　这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress...)方法来完成。<br />3. onProgressUpdate(Progress...)<br />　　当在后台任务中调用了 publishProgress(Progress...)方法后，这个方法就会很快被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应地更新。<br />4. onPostExecute(Result)<br />　　当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 </p><h3><span class="fontstyle0"><span style="color: #3366ff;">使用 </span><span class="fontstyle2"><span style="color: #3366ff;">AsyncTask </span><span class="fontstyle0"><span style="color: #3366ff;">的诀窍就是，在 </span><span class="fontstyle2"><span style="color: #3366ff;">doInBackground()</span><span class="fontstyle0"><span style="color: #3366ff;">方法中去执行具体的耗时任务，在 </span><span class="fontstyle2"><span style="color: #3366ff;">onProgressUpdate()</span><span class="fontstyle0"><span style="color: #3366ff;">方法中进行 </span><span class="fontstyle2"><span style="color: #3366ff;">UI </span><span class="fontstyle0"><span style="color: #3366ff;">操作，在 </span><span class="fontstyle2"><span style="color: #3366ff;">onPostExecute()</span><span class="fontstyle0"><span style="color: #3366ff;">方法中执行一些任务的收尾工作</span> </span></span></span></span></span></span></span></span></span></span></span></h3><h3><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0">如果想要启动这个任务，只需编写以下代码即可：<br /></span></span></span></span></span></span></span></span></span></span></span></span></h3><div class="cnblogs_code"><pre><span style="color: #0000ff;">new</span> DownloadTask().execute(); </pre></div><p>&nbsp;</p><h3><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle1"><br /></span></span><br /></span></span></span></span></span></span></span></span></span></span></span></h3>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义MapReduce中数据类型</title>
    <link href="/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89MapReduce%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89MapReduce%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>###数据类型(都实现了Writable接口)</p><pre><code>BooleanWritable        布尔类型ByteWritable        单字节数值DoubleWritable        双字节数值FloatWritable        浮点数IntWritable            整型数LongWritable        长整型Text                UTF-8格式存储的文本NullWritable        空类型</code></pre><p>####因为shuffle中排序依据是key,若定义的数据类型为Key,必须实现writable和comparable接口，即WritableComparable接口</p><p>####Writable<br>    write()把每个对象序列化到输出流<br>    readFilds()把输入流字节反序列化到输入流        </p><p>###自定义数据类型实例<br>1.定义私有变量<br>2.setter，getter方法<br>3.无参有参构造器<br>4.set()方法，帮助构造器初始化数据（Hadoop偏爱）<br>5.hashCode()方法和equals()方法<br>6.toString()方法<br>7.implement Writable并实现write()方法readFilds()方法<br>8.implement WritableComparable并实现compareTo()方法</p><p>package com.cenzhongman.io;</p><pre><code>import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;import org.apache.hadoop.io.Writable;import org.apache.hadoop.io.WritableComparable;public class UserWritable implements WritableComparable&lt;UserWritable&gt; &#123;    private int ip;    private String name;    public UserWritable() &#123;    &#125;    public UserWritable(int ip, String name) &#123;        this.set(ip, name);    &#125;    @Override    public int hashCode() &#123;        final int prime = 31;        int result = 1;        result = prime * result + ip;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    &#125;    @Override    public String toString() &#123;        return ip + &quot;\t&quot; + name;    &#125;    @Override    public boolean equals(Object obj) &#123;        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        UserWritable other = (UserWritable) obj;        if (ip != other.ip)            return false;        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;    public void set(int ip, String name) &#123;        this.setIp(ip);        this.setName(name);    &#125;    public int getIp() &#123;        return ip;    &#125;    public void setIp(int ip) &#123;        this.ip = ip;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    // read和write方法元素的顺序必须一致    @Override    public void readFields(DataInput arg0) throws IOException &#123;        this.ip = arg0.readInt();        this.name = arg0.readUTF();    &#125;    @Override    public void write(DataOutput arg0) throws IOException &#123;        arg0.writeInt(ip);        arg0.writeUTF(name);    &#125;    @Override    public int compareTo(UserWritable o) &#123;        int comp = Integer.valueOf(this.getIp()).compareTo(o.getIp());        if (comp != 0) &#123;            return comp;        &#125;        return this.getName().compareTo(o.getName());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义checkbox风格.html</title>
    <link href="/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E9%A3%8E%E6%A0%BC/"/>
    <url>/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 class="postTitle"><span style="font-size: 14px; line-height: 1.5;">1.在drawable中创建文件checkbox_selector.xml：</span></h1><div class="cnblogs_code"><pre> <span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">selector </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">item </span><span style="color: #ff0000;">android:state_checked</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">           android:drawable</span><span style="color: #0000ff;">="@drawable/checkbox_ok"</span> <span style="color: #0000ff;">/&gt;</span><span style="color: #008000;">&lt;!--</span><span style="color: #008000;">设置选中图片</span><span style="color: #008000;">--&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">item </span><span style="color: #ff0000;">android:state_checked</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">          android:drawable</span><span style="color: #0000ff;">="@drawable/checkbox_empty"</span> <span style="color: #0000ff;">/&gt;</span><span style="color: #008000;">&lt;!--</span><span style="color: #008000;">设置未选中图片</span><span style="color: #008000;">--&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">selector</span><span style="color: #0000ff;">&gt;</span></pre></div><p>&nbsp;</p><div class="postBody"><div id="cnblogs_post_body"><h3><span style="line-height: 1.5;">2.&nbsp;在values中创建styles.xml：</span></h3><p>&nbsp;</p><div class="cnblogs_code"><pre> <span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">resources</span><span style="color: #0000ff;">&gt;</span>      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">style </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="MyCheckBox"</span><span style="color: #ff0000;"> parent</span><span style="color: #0000ff;">="@android:style/Widget.CompoundButton.CheckBox"</span><span style="color: #0000ff;">&gt;</span>       <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">item </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="android:button"</span><span style="color: #0000ff;">&gt;</span>@drawable/checkbox_selector<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">item</span><span style="color: #0000ff;">&gt;</span>       <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">item </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="android:paddingLeft"</span><span style="color: #0000ff;">&gt;</span>25.0dip<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">item</span><span style="color: #0000ff;">&gt;</span>       <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">item </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="android:maxHeight"</span><span style="color: #0000ff;">&gt;</span>10.0dip<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">item</span><span style="color: #0000ff;">&gt;</span>      <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">style</span><span style="color: #0000ff;">&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">resources</span><span style="color: #0000ff;">&gt;</span></pre></div><p>&nbsp;</p><h3>3.&nbsp;在你的CheckBox中添加属性：</h3><p>&nbsp;</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">CheckBox        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/check"</span><span style="color: #ff0000;">        android:layout_width</span><span style="color: #0000ff;">="20dp"</span><span style="color: #ff0000;">        android:layout_height</span><span style="color: #0000ff;">="20dp"</span><span style="color: #ff0000;">        android:layout_marginLeft</span><span style="color: #0000ff;">="5dp"</span><span style="color: #ff0000;">        style</span><span style="color: #0000ff;">="@style/MyCheckBox"</span>          <span style="color: #0000ff;">/&gt;</span></pre></div><p>&nbsp;</p><p><br />搞定！这样就把你的checkbox换成你设置的那两张图片了</p></div></div>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android权限大全.html</title>
    <link href="/09-Android/android%E6%9D%83%E9%99%90%E5%A4%A7%E5%85%A8/"/>
    <url>/09-Android/android%E6%9D%83%E9%99%90%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<div class="postTitle"><table style="width: 100%;" border="0" cellspacing="1" cellpadding="5"><tbody><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8" width="152">访问登记属性</td><td valign="top" bgcolor="#d8d8d8" width="616">android.permission.ACCESS_CHECKIN_PROPERTIES ，读取或写入登记check-in数据库属性表的权限</td></tr><tr bgcolor="#ffffff"><td valign="top" width="152">获取错略位置</td><td valign="top">android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8" width="152">获取精确位置</td><td valign="top" bgcolor="#d8d8d8">android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内</td></tr><tr bgcolor="#ffffff"><td valign="top">访问定位额外命令</td><td valign="top">android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8" width="152">获取模拟定位信息</td><td valign="top" bgcolor="#d8d8d8">android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用</td></tr><tr bgcolor="#ffffff"><td valign="top" width="152">获取网络状态</td><td valign="top">android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8" width="152">访问Surface Flinger</td><td valign="top" bgcolor="#d8d8d8">android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图</td></tr><tr bgcolor="#ffffff"><td valign="top" width="152">获取WiFi状态</td><td valign="top">android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">账户管理</td><td valign="top" bgcolor="#d8d8d8">android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限</td></tr><tr bgcolor="#ffffff"><td valign="top">验证账户</td><td valign="top">android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8" width="152">电量统计</td><td valign="top" bgcolor="#d8d8d8">android.permission.BATTERY_STATS，获取电池电量统计信息</td></tr><tr bgcolor="#ffffff"><td valign="top">绑定小插件</td><td valign="top">android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">绑定设备管理</td><td valign="top" bgcolor="#d8d8d8">android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用</td></tr><tr bgcolor="#ffffff"><td valign="top">绑定输入法</td><td valign="top">android.permission.BIND_INPUT_METHOD ，请求InputMethodService服务，只有系统才能使用</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">绑定RemoteView</td><td valign="top" bgcolor="#d8d8d8">android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用</td></tr><tr bgcolor="#ffffff"><td valign="top">绑定壁纸</td><td valign="top">android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">使用蓝牙</td><td valign="top" bgcolor="#d8d8d8">android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备</td></tr><tr bgcolor="#ffffff"><td valign="top">蓝牙管理</td><td valign="top">android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">变成砖头</td><td valign="top" bgcolor="#d8d8d8">android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头</td></tr><tr bgcolor="#ffffff"><td valign="top">应用删除时广播</td><td valign="top">android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">收到短信时广播</td><td valign="top" bgcolor="#d8d8d8">android.permission.BROADCAST_SMS，当收到短信时触发一个广播</td></tr><tr bgcolor="#ffffff"><td valign="top">连续广播</td><td valign="top">android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">WAP PUSH广播</td><td valign="top" bgcolor="#d8d8d8">android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播</td></tr><tr bgcolor="#ffffff"><td valign="top">拨打电话</td><td valign="top">android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">通话权限</td><td valign="top" bgcolor="#d8d8d8">android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面</td></tr><tr bgcolor="#ffffff"><td valign="top">拍照权限</td><td valign="top">android.permission.CAMERA，允许访问摄像头进行拍照</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">改变组件状态</td><td valign="top" bgcolor="#d8d8d8">android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态</td></tr><tr bgcolor="#ffffff"><td valign="top">改变配置</td><td valign="top">android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">改变网络状态</td><td valign="top" bgcolor="#d8d8d8">android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网</td></tr><tr bgcolor="#ffffff"><td valign="top">改变WiFi多播状态</td><td valign="top">android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">改变WiFi状态</td><td valign="top" bgcolor="#d8d8d8">android.permission.CHANGE_WIFI_STATE，改变WiFi状态</td></tr><tr bgcolor="#ffffff"><td valign="top">清除应用缓存</td><td valign="top">android.permission.CLEAR_APP_CACHE，清除应用缓存</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">清除用户数据</td><td valign="top" bgcolor="#d8d8d8">android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据</td></tr><tr bgcolor="#ffffff"><td valign="top">底层访问权限</td><td valign="top">android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">手机优化大师扩展权限</td><td valign="top" bgcolor="#d8d8d8">android.permission.CELL_PHONE_MASTER_EX，手机优化大师扩展权限</td></tr><tr bgcolor="#ffffff"><td valign="top">控制定位更新</td><td valign="top">android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">删除缓存文件</td><td valign="top" bgcolor="#d8d8d8">android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件</td></tr><tr bgcolor="#ffffff"><td valign="top">删除应用</td><td valign="top">android.permission.DELETE_PACKAGES，允许程序删除应用</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">电源管理</td><td valign="top" bgcolor="#d8d8d8">android.permission.DEVICE_POWER，允许访问底层电源管理</td></tr><tr bgcolor="#ffffff"><td valign="top">应用诊断</td><td valign="top">android.permission.DIAGNOSTIC，允许程序到RW到诊断资源</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">禁用键盘锁</td><td valign="top" bgcolor="#d8d8d8">android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁</td></tr><tr bgcolor="#ffffff"><td valign="top">转存系统信息</td><td valign="top">android.permission.DUMP，允许程序获取系统dump信息从系统服务</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">状态栏控制</td><td valign="top" bgcolor="#d8d8d8">android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏</td></tr><tr bgcolor="#ffffff"><td valign="top">工厂测试模式</td><td valign="top">android.permission.FACTORY_TEST，允许程序运行工厂测试模式</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">使用闪光灯</td><td valign="top" bgcolor="#d8d8d8">android.permission.FLASHLIGHT，允许访问闪光灯</td></tr><tr bgcolor="#ffffff"><td valign="top">强制后退</td><td valign="top">android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">访问账户Gmail列表</td><td valign="top" bgcolor="#d8d8d8">android.permission.GET_ACCOUNTS，访问GMail账户列表</td></tr><tr bgcolor="#ffffff"><td valign="top">获取应用大小</td><td valign="top">android.permission.GET_PACKAGE_SIZE，获取应用的文件大小</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">获取任务信息</td><td valign="top" bgcolor="#d8d8d8">android.permission.GET_TASKS，允许程序获取当前或最近运行的应用</td></tr><tr bgcolor="#ffffff"><td valign="top">允许全局搜索</td><td valign="top">android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">硬件测试</td><td valign="top" bgcolor="#d8d8d8">android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试</td></tr><tr bgcolor="#ffffff"><td valign="top">注射事件</td><td valign="top">android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">安装定位提供</td><td valign="top" bgcolor="#d8d8d8">android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供</td></tr><tr bgcolor="#ffffff"><td valign="top">安装应用程序</td><td valign="top">android.permission.INSTALL_PACKAGES，允许程序安装应用</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">内部系统窗口</td><td valign="top" bgcolor="#d8d8d8">android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限</td></tr><tr bgcolor="#ffffff"><td valign="top">访问网络</td><td valign="top">android.permission.INTERNET，访问网络连接，可能产生GPRS流量</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">结束后台进程</td><td valign="top" bgcolor="#d8d8d8">android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程</td></tr><tr bgcolor="#ffffff"><td valign="top">管理账户</td><td valign="top">android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">管理程序引用</td><td valign="top" bgcolor="#d8d8d8">android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统</td></tr><tr bgcolor="#ffffff"><td valign="top">高级权限</td><td valign="top">android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">社区权限</td><td valign="top" bgcolor="#d8d8d8">android.permission.MTWEAK_FORUM，允许使用mTweak社区权限</td></tr><tr bgcolor="#ffffff"><td valign="top">软格式化</td><td valign="top">android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">修改声音设置</td><td valign="top" bgcolor="#d8d8d8">android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息</td></tr><tr bgcolor="#ffffff"><td valign="top">修改电话状态</td><td valign="top">android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">格式化文件系统</td><td valign="top" bgcolor="#d8d8d8">android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡</td></tr><tr bgcolor="#ffffff"><td valign="top">挂载文件系统</td><td valign="top">android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">允许NFC通讯</td><td valign="top" bgcolor="#d8d8d8">android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持</td></tr><tr bgcolor="#ffffff"><td valign="top">永久Activity</td><td valign="top">android.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">处理拨出电话</td><td valign="top" bgcolor="#d8d8d8">android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话</td></tr><tr bgcolor="#ffffff"><td valign="top">读取日程提醒</td><td valign="top">android.permission.READ_CALENDAR，允许程序读取用户的日程信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读取联系人</td><td valign="top" bgcolor="#d8d8d8">android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息</td></tr><tr bgcolor="#ffffff"><td valign="top">屏幕截图</td><td valign="top">android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读取收藏夹和历史记录</td><td valign="top" bgcolor="#d8d8d8">com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录</td></tr><tr bgcolor="#ffffff"><td valign="top">读取输入状态</td><td valign="top">android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读取系统日志</td><td valign="top" bgcolor="#d8d8d8">android.permission.READ_LOGS，读取系统底层日志</td></tr><tr bgcolor="#ffffff"><td valign="top">读取电话状态</td><td valign="top">android.permission.READ_PHONE_STATE，访问电话状态</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读取短信内容</td><td valign="top" bgcolor="#d8d8d8">android.permission.READ_SMS，读取短信内容</td></tr><tr bgcolor="#ffffff"><td valign="top">读取同步设置</td><td valign="top">android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读取同步状态</td><td valign="top" bgcolor="#d8d8d8">android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态</td></tr><tr bgcolor="#ffffff"><td valign="top">重启设备</td><td valign="top">android.permission.REBOOT，允许程序重新启动设备</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">开机自动允许</td><td valign="top" bgcolor="#d8d8d8">android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行</td></tr><tr bgcolor="#ffffff"><td valign="top">接收彩信</td><td valign="top">android.permission.RECEIVE_MMS，接收彩信</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">接收短信</td><td valign="top" bgcolor="#d8d8d8">android.permission.RECEIVE_SMS，接收短信</td></tr><tr bgcolor="#ffffff"><td valign="top">接收Wap Push</td><td valign="top">android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">录音</td><td valign="top" bgcolor="#d8d8d8">android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克</td></tr><tr bgcolor="#ffffff"><td valign="top">排序系统任务</td><td valign="top">android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">结束系统任务</td><td valign="top" bgcolor="#d8d8d8">android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃</td></tr><tr bgcolor="#ffffff"><td valign="top">发送短信</td><td valign="top">android.permission.SEND_SMS，发送短信</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置Activity观察其</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试</td></tr><tr bgcolor="#ffffff"><td valign="top">设置闹铃提醒</td><td valign="top">com.android.alarm.permission.SET_ALARM，设置闹铃提醒</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置总是退出</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出</td></tr><tr bgcolor="#ffffff"><td valign="top">设置动画缩放</td><td valign="top">android.permission.SET_ANIMATION_SCALE，设置全局动画缩放</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置调试程序</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发</td></tr><tr bgcolor="#ffffff"><td valign="top">设置屏幕方向</td><td valign="top">android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置应用参数</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍</td></tr><tr bgcolor="#ffffff"><td valign="top">设置进程限制</td><td valign="top">android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置系统时间</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_TIME，设置系统时间</td></tr><tr bgcolor="#ffffff"><td valign="top">设置系统时区</td><td valign="top">android.permission.SET_TIME_ZONE，设置系统时区</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">设置桌面壁纸</td><td valign="top" bgcolor="#d8d8d8">android.permission.SET_WALLPAPER，设置桌面壁纸</td></tr><tr bgcolor="#ffffff"><td valign="top">设置壁纸建议</td><td valign="top">android.permission.SET_WALLPAPER_HINTS，设置壁纸建议</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">发送永久进程信号</td><td valign="top" bgcolor="#d8d8d8">android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号</td></tr><tr bgcolor="#ffffff"><td valign="top">状态栏控制</td><td valign="top">android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">访问订阅内容</td><td valign="top" bgcolor="#d8d8d8">android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库</td></tr><tr bgcolor="#ffffff"><td valign="top">写入订阅内容</td><td valign="top">android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">显示系统窗口</td><td valign="top" bgcolor="#d8d8d8">android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口</td></tr><tr bgcolor="#ffffff"><td valign="top">更新设备状态</td><td valign="top">android.permission.UPDATE_DEVICE_STATS，更新设备状态</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">使用证书</td><td valign="top" bgcolor="#d8d8d8">android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager</td></tr><tr bgcolor="#ffffff"><td valign="top">使用SIP视频</td><td valign="top">android.permission.USE_SIP，允许程序使用SIP视频服务</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">使用振动</td><td valign="top" bgcolor="#d8d8d8">android.permission.VIBRATE，允许振动</td></tr><tr bgcolor="#ffffff"><td valign="top">唤醒锁定</td><td valign="top">android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">写入GPRS接入点设置</td><td valign="top" bgcolor="#d8d8d8">android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置</td></tr><tr bgcolor="#ffffff"><td valign="top">写入日程提醒</td><td valign="top">android.permission.WRITE_CALENDAR，写入日程，但不可读取</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">写入联系人</td><td valign="top" bgcolor="#d8d8d8">android.permission.WRITE_CONTACTS，写入联系人，但不可读取</td></tr><tr bgcolor="#ffffff"><td valign="top">写入外部存储</td><td valign="top">android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">写入Google地图数据</td><td valign="top" bgcolor="#d8d8d8">android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据</td></tr><tr bgcolor="#ffffff"><td valign="top">写入收藏夹和历史记录</td><td valign="top">com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">读写系统敏感设置</td><td valign="top" bgcolor="#d8d8d8">android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项</td></tr><tr bgcolor="#ffffff"><td valign="top">读写系统设置</td><td valign="top">android.permission.WRITE_SETTINGS，允许读写系统设置项</td></tr><tr bgcolor="#ffffff"><td valign="top" bgcolor="#d8d8d8">编写短信</td><td valign="top" bgcolor="#d8d8d8">android.permission.WRITE_SMS，允许编写短信</td></tr><tr bgcolor="#ffffff"><td valign="top">写入在线同步设置</td><td valign="top">android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Alarm机制用于定时服务</title>
    <link href="/09-Android/Alarm%E6%9C%BA%E5%88%B6%E7%94%A8%E4%BA%8E%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1/"/>
    <url>/09-Android/Alarm%E6%9C%BA%E5%88%B6%E7%94%A8%E4%BA%8E%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>##获取一个 AlarmManager 的实例：<br>    AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);<br>####调用 AlarmManager 的 set()方法设置一个定时任务了，比如说想要设定一个任务在 10 秒钟后执行，就可以写成：<br>    long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;<br>    manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);<br>####或者写成<br>    long triggerAtTime = System.currentTimeMillis() + 10 * 1000;<br>    manager.set(AlarmManager.RTC_WAKEUP, triggerAtTime, pendingIntent);<br>####1.第一个参数是一个整型参数，用于指定 AlarmManager 的工作类型，有四种值可选，分别是 ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC 和 RTC_WAKEUP。</p><blockquote><p>ELAPSED_REALTIME 表示让定时任务的触发时间从系统开机开始算起，但不会唤醒 CPU。<br>ELAPSED_REALTIME_WAKEUP 同样表示让定时任务的触发时间从系统开机开始算起，但会唤醒 CPU。<br>RTC 表示让定时任务的触发时间从 1970 年 1月 1 日 0 点开始算起，但不会唤醒 CPU。<br>RTC_WAKEUP 同样表示让定时任务的触发时间从1970 年 1 月 1 日 0 点开始算起，但会唤醒 CPU。<br>####使用 SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数，<br>####使用 System.currentTimeMillis()方法可以获取到 1970 年 1 月 1 日 0 点至今所经历时间的毫秒数。<br>####2.第二个参数，定时任务触发的时间，以毫秒为单位。<br>如果第一个参数使用的是 ELAPSED_REALTIME 或 ELAPSED_REALTIME_WAKEUP，则这里传入开机至今的时间再加上延迟执行的时间。<br>如果第一个参数使用的是 RTC 或RTC_WAKEUP，则这里传入 1970 年 1 月 1 日 0 点至今的时间再加上延迟执行的时间。<br>####3.第三个参数是一个 PendingIntent.这里我们一般会调用getBroadcast()方法来获取一个能够执行广播的 PendingIntent。这样当定时任务被触发的时候，广播接收器的onReceive()方法就可以得到执行。</p></blockquote><p>####由于安卓官方为了CUP节能考虑，把相近时间唤醒CPU的服务都放到一期来启动，需要精确时间唤醒的可以把set()换成setExact()</p><p>##实现定时启动的服务<br>###1.创建服务，并定时发出广播<br>    @Override<br>    public int onStartCommand(Intent intent, int flags, int startId) {<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                Log.d(TAG, “当前时间是”+ new Date().toString());<br>            }<br>        }).start();</p><pre><code>    AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);    int HowLong = 60 * 60 * 1000;                                                //设定定时时间    long triggerAtTime = SystemClock.elapsedRealtime() + HowLong;               //加上系统开机时间    Intent intent1 = new Intent(this, AlarmReceiver.class);                       //创建Intent指向广播接收器    PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, intent1, 0);//调用 getBroadcast()方法来获取一个能够执行广播的 PendingIntent    alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);//设置定时唤醒，并发出广播    return super.onStartCommand(intent, flags, startId);&#125;</code></pre><p>###2.在广播中执行开始下一次定时任务<br>    public class AlarmReceiver extends BroadcastReceiver {<br>        @Override<br>        public void onReceive(Context context, Intent intent) {<br>            Intent AlarmIntent;<br>            AlarmIntent = new Intent(context,LongRunningService.class);<br>            context.startService(AlarmIntent);<br>        }<br>    }<br>###3.在需要的地方首次启动服务<br>    Intent intent = new Intent(this,LongRunningService.class);<br>    startService(intent);</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Studio快捷键.html</title>
    <link href="/09-Android/Android%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/09-Android/Android%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>Ctrl+G / Ctrl+Alt+Shift+G：查询变量或者函数或者类在哪里被使用或被调用，后者是前者的复杂表现，可以选择查询范围等。</p><p>Alt+H：查找功能，全局查找</p><p>F4：查看类继承关系</p><p>F2：查看文档说明（函数使用说明）</p><p>Ctrl+E：查看最近打开过的文件</p><p>Ctrl+Shift+E：查看最近编辑过的文件</p><p>double Shift：全局查找，这个查看和Alt+H稍稍有些不同，这个是全局文件查找，到文件名称层面。</p><p>Ctrl+Shift+R：快速定位到你所想打开的文件。</p><p>Alt+&uarr;：光标所在位置那行代码往上移动</p><p>Alt+&darr;：光标所在位置那行代码往下移动</p><p>Ctrl+D：删除光标所在位置那行代码</p><p>Ctrl+X：剪切光标所在位置那行代码</p><p>Alt+Shift+&darr;/Ctrl+C：复制光标所在行代码到下一行</p><p>Ctrl+O:快捷查找当前类中的函数，变量</p><p>Ctrl+Shift+R：修改名称</p><p>Alt+Enter：导入包</p><p>Alt+&larr;：后退，定位到上个查看或者编辑的地方</p><p>Alt+&rarr;：往前定位，比如你定位到上个点后，想回去，就可以用这个快捷键</p><p>Ctrl+/：当行注释，反注释再按一次即可</p><p>Ctrl+Shift+/：模块注释，反注释再按一次即可,注意这边的&rdquo;/&ldquo;不能用小键盘的</p><p>Ctrl+Shift+小键盘/：折叠代码（Ctrl+Shift+小键盘*这个不灵了，今天没空了，后面会针对这个问题做解决，并更新上来），当然笔记本没小键盘，你可以自己改快捷键</p><p>Ctrl+Alt+S：打开settings界面</p><p>Ctrl+Alt+Shift+S：打开Project Structure界面</p><p>Alt+Shift+X：运行（Run）</p><p>Alt+Shift+D：调试运行（Debug）</p><p>Ctrl+F9：编译工程</p><p>Ctrl+Shift+K：push文件到Server（git）</p><p>Debug类快捷键</p><p>F5：但不调试进入函数内部。</p><p>F6：但不调试不进入函数内部。</p><p>F7：由函数内部返回调用处。</p><p>F8：执行到下一个断点，没断点则执行完成。</p><table><thead><tr><th>Action</th><th>Mac OSX</th><th>Win/Linux</th></tr></thead><tbody><tr><td>注释代码(//)</td><td>Cmd + /</td><td>Ctrl + /</td></tr><tr><td>注释代码(/**/)</td><td>Cmd + Option + /</td><td>Ctrl + Shift + /</td></tr><tr><td>格式化代码</td><td>Cmd + Option + L</td><td>Ctrl + Alt + L</td></tr><tr><td>清除无效包引用</td><td>Option + Control + O</td><td>Alt + Ctrl + O</td></tr><tr><td>查找</td><td>Cmd + F</td><td>Ctrl + F</td></tr><tr><td>查找+替换</td><td>Cmd + R</td><td>Ctrl + R</td></tr><tr><td>上下移动代码</td><td>Option + Shift + Up/Down</td><td>Alt + Shift + Up/Down</td></tr><tr><td>删除行</td><td>Cmd + Delete</td><td>Ctrl + Y</td></tr><tr><td>扩大缩小选中范围</td><td>Option + Up/Down</td><td>Ctrl + W/Ctrl + Shift + W</td></tr><tr><td>快捷生成结构体</td><td>Cmd + Option + T</td><td>Ctrl + Alt + T</td></tr><tr><td>快捷覆写方法</td><td>Ctrl + O</td><td>Ctrl + O</td></tr><tr><td>快捷定位到行首/尾</td><td>Cmd + Left/Right</td><td>Ctrl + Left/Right</td></tr><tr><td>折叠展开代码块</td><td>Cmd + Plus,Minus</td><td>Ctrl + Plus/Minus</td></tr><tr><td>折叠展开全部代码块</td><td>Cmd + Shift + Plus,Minus</td><td>Ctrl + Shift + Plus,Minus</td></tr><tr><td>文件方法结构</td><td>Cmd + F12</td><td>Ctrl + F12</td></tr><tr><td>查找调用的位置</td><td>Ctrl + Option + H</td><td>Ctrl + Alt + H</td></tr><tr><td>大小写转换</td><td>Cmd + Shift + U</td><td>Ctrl + Shift + U</td></tr></tbody></table><p>&nbsp;</p><p>原文地址：http://www.cnblogs.com/weidingqiang/p/5056076.html</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android studio 的初始设置.html</title>
    <link href="/09-Android/Android%20studio%20%E7%9A%84%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/"/>
    <url>/09-Android/Android%20studio%20%E7%9A%84%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>【声明】</strong>&nbsp;</p><p>欢迎转载，但请保留文章原始出处&rarr;_&rarr;&nbsp;</p><p>生命壹号：<a href="http://www.cnblogs.com/smyhvae/" target="_blank">http://www.cnblogs.com/smyhvae/</a></p><p>文章来源：<a href="http://www.cnblogs.com/smyhvae/p/4390905.html">http://www.cnblogs.com/smyhvae/p/4390905.html</a><a href="http://www.cnblogs.com/smyhvae/p/4013535.html"><br /></a></p><p><span style="line-height: 1.5;">&nbsp;Android Studio下载的绿色通道：</span><a style="line-height: 1.5;" href="http://www.androiddevtools.cn/" target="_blank">http://www.androiddevtools.cn/</a></p><p>&nbsp;</p><p><strong>一、第一次安装：</strong></p><p>Android Studio安装完成后，第一次启动AS前，为了<strong>避免重新下载新版本的SDK</strong>，需要做如下操作：</p><p>AS启动前，打开安装目录，请先将bin目录的idea.properties文件中增加一行：disable.android.first.run=true就行了，避免第一次打开AS时自动重新下载SDK。mac平台的右键安装包-&gt;Show Package Contents 就找到bin目录了</p><p>第一次打开Android Studio时，需要配置JDK和SDK：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223016293-1324408193.png" alt="" /></p><p>上图中，选择&ldquo;Project Structure&rdquo;，弹出如下界面：（选择JDK和Android SDK的路径）</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809222759199-1573362003.png" alt="" /></p><p>&nbsp;注：不要问我JDK和Android SDK怎么来的吧？要提前自行安装好哦，这种帖子一搜一大把，不是我的写作风格。&nbsp;</p><p>&nbsp;</p><p><strong>二、新建一个Android Studio工程：</strong></p><p>配置好JDK和Android SDK后，就可以开始新建Android项目了：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223129668-785110585.png" alt="" /></p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223333793-624684194.png" alt="" /></p><p>上图中，设置好工程名和路径之后，接下来可以一路next：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223502215-1711399311.png" alt="" /></p><p>&nbsp;&nbsp;用户如果是第一次安装Android Studio，会出现如下窗口：</p><p>&nbsp;<img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223550856-912533858.png" alt="" /></p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223806543-139363929.png" alt="" /></p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809223911684-334148762.png" alt="" /></p><p>上图中，是在下载最新版的SDK（API 23），几分钟就下载好了，由于访问的是国外的网站，建议<a href="http://honx.in/_U-mc6Oz5NGRmLX2S" target="_blank">FQ</a>。继续下一步：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809224104887-715926097.png" alt="" /></p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809224133293-275267523.png" alt="" /></p><p>上图中，点击&ldquo;finish&rdquo;按钮，应用即可创建完成。&nbsp;</p><p>用户如果是第一次安装Android Studio，会出现如下窗口：</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950141073652.png"><img title="2851aa44-b082-4ebe-a330-7cc21e6aae2c" src="http://images.cnitblog.com/blog/641601/201504/031950147016537.png" alt="2851aa44-b082-4ebe-a330-7cc21e6aae2c" width="695" height="547" border="0" /></a></p><p>上图中，是在下载Gradle，文件不大，大概几十兆吧，下载起来很快。由于访问的是国外的网站，建议<a href="http://honx.in/_U-mc6Oz5NGRmLX2S" target="_blank">FQ</a>。</p><p>&nbsp;</p><p><strong>三、Android Studio的简单设置：</strong></p><p><strong>1、主题修改：</strong></p><p>可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏&ldquo;File--settings--apperance--theme&rdquo;，主题选择Darcula：</p><p>&nbsp;<img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809233232527-1524149464.png" alt="" /></p><p><strong>2、导入第三方主题：</strong></p><p>系统提供的两种主题可能都不太好看，我们可以进入网站<a href="http://color-themes.com/" target="_blank">http://color-themes.com/</a>来获取第三方主题，比如说Sublime主题就是我个人喜爱的：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809233441824-1386798292.png" alt="" /></p><p>&nbsp;</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160809233528309-783456964.png" alt="" /></p><p>上图中，下载下来之后，是一个jar包。那怎么导入到Android Studio呢？</p><p>别着急，回到Android Studio，选择菜单栏&ldquo; File-Import Settings&rdquo;，将下载好的jar包导入即可。</p><p>&nbsp;</p><p><strong>3、代码字体修改：</strong></p><p>选择菜单栏&ldquo;File--settings--Editor--Colors&amp;Fonts--Font&rdquo;：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072112034542723.png" alt="" /></p><p>同样也可以修改控制台的字体：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072113295172430.png" alt="" /></p><p>修改完之后发现AS的一些默认字体如侧边栏的工程目录的字体并没有发生变化，如果想改的话，那还是改一下吧（我个人一般是不改的），修改AS的默认字体：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072114237677589.png" alt="" /></p><p>&nbsp;</p><p>&nbsp;<strong>4、关闭更新：</strong></p><p>如下图所示：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810094556809-142977772.png" alt="" /></p><p>&nbsp;&nbsp;</p><p><strong>5、快捷键习惯的修改：</strong></p><p>如果想修改成Eclipse的快捷键习惯，可以选择菜单栏"file--Settings--Keymap"：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072116357208578.png" alt="" /></p><p>我这里就不改了哈。</p><p>&nbsp;</p><p><strong>6、添加api文档悬浮提示：</strong></p><p>AS默认是没有api文档悬浮提示的，只有按住【Ctrl+Q】太会出现提示。如果要添加api的自动悬浮提示，设置如下：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810094650684-343880749.png" alt="" /></p><p>上图中，在红框部分打钩就行了，不过这样做对电脑的性能消耗会增加，可以不设置，根据个人习惯。</p><p>&nbsp;</p><p><strong>7、配置代码的自动提示：（新版AS默认具有代码自动提示的设置）</strong></p><p>新版的AS默认具有代码自动补齐的功能（老版本的AS是没有的），自动补齐的设置如下：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810094807246-1644638455.png" alt="" /></p><p>保持上方红框部分出于打勾状态，就可以设置成代码自动补齐了。</p><p>&nbsp;</p><p>代码提示的快捷键是在下面这个位置：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072122115955000.png" alt="" /></p><p>上图中，在搜索框输入&ldquo;class name completion&rdquo;，就看到了代码提示的默认快捷键是Ctrl+Alt+空格，如果想把这个快捷键改掉，操作如下：</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950361398620.png"><img title="cddfa4db-d109-4f83-891d-4bc9b37cb45c" src="http://images.cnitblog.com/blog/641601/201504/031950366078777.png" alt="cddfa4db-d109-4f83-891d-4bc9b37cb45c" width="748" height="263" border="0" /></a></p><p>上图中，右键选择红框部分，在弹出的对话框中进行修改。</p><p>注：如果你习惯了用Eclipse，但是要注意，android Studio中的【Alt+/】是另外一个快捷键：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072124436575343.png" alt="" /></p><p>习惯了用Eclipse的人可以将上图红框部分的两个快捷键交换一下。</p><p>&nbsp;</p><p><strong>配置代码提示的大小写区分：</strong></p><p>AS默认的代码提示是<strong>大小写敏感</strong>的，不信看一下。我们输入小写的intent，提示效果如下：</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950386399190.png"><img title="bd2167a2-5235-481e-b7a0-8e939c5ae17f[7]" src="http://images.cnitblog.com/blog/641601/201504/031950393575804.png" alt="bd2167a2-5235-481e-b7a0-8e939c5ae17f[7]" width="523" height="327" border="0" /></a></p><p>而当输入大写的Intent时，提示效果如下：（这个时候才出现了Intent类）</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950399206933.png"><img title="7a69ab77-5638-4d33-99c1-6e0c0bfa1c3c[4]" src="http://images.cnitblog.com/blog/641601/201504/031950404823361.png" alt="7a69ab77-5638-4d33-99c1-6e0c0bfa1c3c[4]" width="545" height="352" border="0" /></a></p><p>上面两张图可以看到，AS默认的代码提示是<strong>大小写敏感</strong>的。那我想让AS对大小写不敏感，该怎么弄呢？操作如下：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810095124793-871900743.png" alt="" /></p><p>上图中，我们将箭头处的部分改成&ldquo;none&rdquo;即可。演示效果如下：</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950424822017.png"><img title="ce80d1ea-41bf-4334-8bff-07a50e3dd5c7" src="http://images.cnitblog.com/blog/641601/201504/031950430764902.png" alt="ce80d1ea-41bf-4334-8bff-07a50e3dd5c7" width="507" height="269" border="0" /></a>&nbsp;</p><p>&nbsp;</p><p><strong>按住Ctrl键的同时单击鼠标查看源码：（新版AS已默认具有该设置）　　　　</strong></p><p>如果已经成功加载sdk，那这个其实是在快捷键里面设置的：</p><p><a href="http://images.cnitblog.com/blog/641601/201504/031950436391330.jpg"><img title="f4498531-6295-4349-ba7c-b4601cd225d0" src="http://images.cnitblog.com/blog/641601/201504/031950443898700.jpg" alt="f4498531-6295-4349-ba7c-b4601cd225d0" width="1136" height="710" border="0" /></a></p><p>上图中的蓝栏框部分的快捷键的意思就是：按住Ctrl键的同时单击鼠标就可以查看源码。</p><p>&nbsp;</p><p><strong>8、设置自动导包：</strong></p><p>之前在Eclipse中，我们只有每次引用一些类的时候必须要导包，而AS可以设置成自动导包。设置如下：</p><p><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810095451340-1973533860.png" alt="" /></p><p>上图中，将红矿部分的两个位置处勾选就行了。</p><p>&nbsp;</p><p><strong>9、显示代码行数：</strong></p><p><strong><img src="http://images2015.cnblogs.com/blog/641601/201608/641601-20160810095556637-1247847901.png" alt="" /></strong></p><p>上图中，将红框部分打钩即可。</p><p>&nbsp;</p><p><strong>10、禁止自动打开上次的工程：</strong></p><p>我喜欢自己选择打开哪个工程，果断禁用（这个根据个人喜好哈），设置如下：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072131416107389.png" alt="" /></p><p>&nbsp;</p><p><strong>11、禁止代码折叠：</strong></p><p>Intellij IDEA默认有很多地方的代码都会自动折叠，不过我看不惯，所以取消了，设置如下：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072135397516370.png" alt="" /></p><p>&nbsp;</p><p><strong>12、修改注释位置，禁用&ldquo;语句堆一行&rdquo;：</strong></p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072139246884416.png" alt="" /></p><ul><li>Comment at frist column：启用的话，注释的位置就会处于行首，否则就根据缩进来注释。我取消掉了。</li><li>Control statement in one line：格式化代码的时候，会把些很短的语句合并成一行。我觉得这样影响代码可读性，故取消。</li></ul><p>&nbsp;</p><p><strong>13、修改新建文件文件头：</strong></p><p>每次建新类的话，对下面这段注释肯定很熟悉吧？</p><div class="cnblogs_code"><pre>/*** Created by smyhvae on 2015/5/7.*/</pre></div><p>&nbsp;</p><p>其实它的设置是在下面这个位置：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072142107821807.png" alt="" /></p><p>&nbsp;</p><h3 id="utf-8">14、修改文件编码为UTF-8：</h3><p>Android Studio 1.1默认的编码方式是utf-8，到了Android Studio 1.2默认的编码方式竟然是GBK，到了Android Studio 2.1，默认的部分编码方式是utf-8，我们还是统一设置为UTF-8吧，不要坑队友哦：</p><p><img src="http://images.cnitblog.com/blog2015/641601/201505/072145290958389.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android studio 软件板块.html</title>
    <link href="/09-Android/Android%20studio%20%E8%BD%AF%E4%BB%B6%E6%9D%BF%E5%9D%97/"/>
    <url>/09-Android/Android%20studio%20%E8%BD%AF%E4%BB%B6%E6%9D%BF%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="http://images2015.cnblogs.com/blog/1047249/201612/1047249-20161204212142927-1829944223.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android四大组件之服务.html</title>
    <link href="/09-Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1/"/>
    <url>/09-Android/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1>创建一个服务，并与活动绑定</h1><h3><span style="color: #ff0000;">作为安卓四大组件之一的服务，毫无例外也要在manifast中进行注册</span></h3><ul><li>新建服务类继承于Service，并覆盖onBind( )方法，用于与活动绑定</li></ul><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MySevice <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Service {    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建DownloadBinder对象mBinder</span>    <span style="color: #0000ff;">private</span> DownloadBinder mBinder = <span style="color: #0000ff;">new</span><span style="color: #000000;"> DownloadBinder();    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建DownloadBinder类，实现服务中需要等待活动指示来执行的方法</span>    <span style="color: #0000ff;">class</span> DownloadBinder <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Binder {<br /><span style="color: #339966;">　  //必须是pubilc修饰的方法        </span></span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getProcess() {            </span><span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;        }    }    @Nullable    @Override    </span><span style="color: #008000;">//</span><span style="color: #008000;">返回DownloadBinder对象mBinder</span>    <span style="color: #0000ff;">public</span><span style="color: #000000;"> IBinder onBind(Intent intent) {        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mBinder;    }    @Override    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建服务时执行</span>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate() {        Toast.makeText(</span><span style="color: #0000ff;">this</span>, "服务创建成功"<span style="color: #000000;">, Toast.LENGTH_LONG).show();        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate();    }    @Override    </span><span style="color: #008000;">//</span><span style="color: #008000;">启动服务时执行</span>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> onStartCommand(Intent intent, <span style="color: #0000ff;">int</span> flags, <span style="color: #0000ff;">int</span><span style="color: #000000;"> startId) {        Toast.makeText(</span><span style="color: #0000ff;">this</span>, "服务启动成功"<span style="color: #000000;">, Toast.LENGTH_LONG).show();        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.onStartCommand(intent, flags, startId);    }    @Override    </span><span style="color: #008000;">//</span><span style="color: #008000;">关闭服务时执行</span>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onDestroy() {        Toast.makeText(</span><span style="color: #0000ff;">this</span>, "服务关闭成功"<span style="color: #000000;">, Toast.LENGTH_LONG).show();        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onDestroy();    }}</span></pre></div><ul><li><span style="color: #000000;">在Activity中找到传递过来的mBinder对象</span></li></ul><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">private</span><span style="color: #000000;"> MySevice.DownloadBinder mDownloadBinder;    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建匿名内部类ServiceConnection（）,重写方法onServiceConnected（），onServiceDisconnected（）分别在绑定和取消绑定时调用</span>    <span style="color: #0000ff;">private</span> ServiceConnection mConnection = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ServiceConnection() {        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onServiceConnected(ComponentName name, IBinder service) {            </span><span style="color: #008000;">//</span><span style="color: #008000;">向下转型，找到mDownloadBinder对象，并调用对象中的public方法</span>            mDownloadBinder =<span style="color: #000000;"> (MySevice.DownloadBinder) service;            mDownloadBinder.getProcess();        }        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onServiceDisconnected(ComponentName name) {        }    };</span></pre></div><ul><li>绑定服务与活动</li></ul><div class="cnblogs_code"><pre>    Intent thread_bind_service = <span style="color: #0000ff;">new</span> Intent(ThreadDemoActivity.<span style="color: #0000ff;">this</span>, MySevice.<span style="color: #0000ff;">class</span><span style="color: #000000;">);    bindService(thread_bind_service,mConnection,BIND_AUTO_CREATE);    </span><span style="color: #008000;">/* </span><span style="color: #008000;">bindService()方法接收三个参数，第一个参数就是刚刚构建出的 Intent 对象，    *  第二个参数是前面创建出的 ServiceConnection 的实例，    *  第三个参数则是一个标志位，这里传入 BIND_AUTO_CREATE 表示在活动和服务进行绑定后自动创建服务    </span><span style="color: #008000;">*/</span></pre></div><ul><li>&nbsp;解除绑定</li></ul><div class="cnblogs_code"><pre>　　unbindService(mConnection);</pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImageView的常用属性.html</title>
    <link href="/09-Android/ImageView%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/"/>
    <url>/09-Android/ImageView%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>ImageView的一些常用属性，并且这些属性都有与之对应的getter、setter方法：</p><ul><li>android:adjustViewBounds：设置ImageView是否调整自己的边界来保持所显示图片的长宽比。</li><li>android:maxHeight：设置ImageView的最大高度。</li><li>android:maxWidth：设置ImageView的最大宽度。</li><li>android:scaleType：设置所显示的图片如何缩放或移动以适应ImageView的大小。</li><li>android:src：设置ImageView所显示的Drawable对象的ID。</li></ul><p>　　对于android:scaleType属性，因为关于图像在ImageView中的显示效果，所以有如下属性值可以选择：</p><ul><li>matrix：使用matrix方式进行缩放。</li><li>fitXY：横向、纵向独立缩放，以适应该ImageView。</li><li>fitStart:保持纵横比缩放图片，并且将图片放在ImageView的左上角。</li><li>fitCenter：保持纵横比缩放图片，缩放完成后将图片放在ImageView的中央。</li><li>fitEnd：保持纵横比缩放图片，缩放完成后将图片放在ImageView的右下角。</li><li>center：把图片放在ImageView的中央，但是不进行任何缩放。</li><li>centerCrop：保持纵横比缩放图片，以使图片能完全覆盖ImageView。</li><li>centerInside：保持纵横比缩放图片，以使得ImageView能完全显示该图片。</li></ul>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IntentService和Service执行子线程对比</title>
    <link href="/09-Android/IntentService%E5%92%8CService%E6%89%A7%E8%A1%8C%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/"/>
    <url>/09-Android/IntentService%E5%92%8CService%E6%89%A7%E8%A1%8C%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>#1.为何要用子程序<br>服务是在主线程中执行的，直接在服务中执行耗时操作明显不可取，于是安卓官方增加了IntentService类来方便使用</p><p>##在Service中执行子程序代码如下<br>    @Override<br>    public int onStartCommand(Intent intent, int flags, int startId) {<br>        new Thread(new Runnable() {<br>        @Override<br>        public void run() {<br>            // 处理具体的逻辑<br>            stopSelf();//需要自行关闭服务<br>            }<br>        }).start();<br>    return super.onStartCommand(intent, flags, startId);<br>    }</p><p>##在IntentService中执行子程序代码如下<br>    /**<br>     * 用途：用于测试IntentService类服务的特性<br>     * 特性：1.该服务必须覆盖onHandleIntent方法，该方法在子线程中运行<br>     *       2.该服务实行结束后会自动关闭，即调用onDestory( )方法<br>     */<br>    public class MyIntentService extends IntentService {<br>        public MyIntentService() {<br>            //1.创建无参数构造函数，调用父类有参构造器<br>            super(“MyIntentService”);<br>        }</p><pre><code>    @Override    protected void onHandleIntent(Intent intent) &#123;        Log.d(TAG,&quot;线程ID是&quot;+Thread.currentThread().getId());    &#125;    @Override    public void onDestroy() &#123;        Log.d(TAG,&quot;IntentService关闭了&quot;);        super.onDestroy();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OncrickListener的实现.html</title>
    <link href="/09-Android/OncrickListener%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/09-Android/OncrickListener%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>在Java中实现的监控事件的方法</strong></li></ul><div class="cnblogs_code"><pre>　　　　button.addActionListener(<span style="color: #0000ff;">new</span><span style="color: #000000;"> ActionListener() {            @Override            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> actionPerformed(ActionEvent e) {                System.out.println(</span>"哈哈哈"<span style="color: #000000;">);            }                    });</span></pre></div><p>&nbsp;</p><p>实际上：ActionListener是一个接口，在这里是用了<span style="color: #ff0000;"><strong>匿名内部类</strong></span>的语法 , new + 接口名 + （） + {接口实现}</p><ul><li>因此:</li></ul><p>　　addActionListener(&nbsp;new 接口名() {</p><p>　　接口实现;</p><p>　　});<span style="color: #339966;">//这一行是这么来的</span></p><p>&nbsp;</p><ul><li>&nbsp;因此</li></ul><p>　　<img src="http://images2015.cnblogs.com/blog/1047249/201612/1047249-20161205225229257-1802679517.png" alt="" width="627" height="224" /></p><p>　　<span style="color: #339966;">//在<span style="color: #993366;"><strong>匿名内部类中的常量需要用final修饰</strong></span>，放在方法区中去，防止销毁后出空指针引用（局部变量在方法中，方法结束后，栈帧消失，变量也消失，对象还在堆中等待垃圾回收器回收，就可能出现空指针引用）；</span></p><p>&nbsp;</p><ul><li><span style="color: #000000;"><strong>android 中的OnCrickListener也是如此；</strong></span></li></ul>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UI控件之ListView.html</title>
    <link href="/09-Android/UI%E6%8E%A7%E4%BB%B6%E4%B9%8BListView/"/>
    <url>/09-Android/UI%E6%8E%A7%E4%BB%B6%E4%B9%8BListView/</url>
    
    <content type="html"><![CDATA[<h3>一，一个简单的TextView列表</h3><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FirstActivity <span style="color: #0000ff;">extends</span> Activity {    <span style="color: #0000ff;">private</span> String[] data = {"<span style="color: #8b0000;">Apple</span>", "<span style="color: #8b0000;">Banana</span>", "<span style="color: #8b0000;">Orange</span>", "<span style="color: #8b0000;">Watermelon</span>",            "<span style="color: #8b0000;">Pear</span>", "<span style="color: #8b0000;">Grape</span>", "<span style="color: #8b0000;">Pineapple</span>", "<span style="color: #8b0000;">Strawberry</span>", "<span style="color: #8b0000;">Cherry</span>", "<span style="color: #8b0000;">Mango</span>","<span style="color: #8b0000;">Apple</span>", "<span style="color: #8b0000;">Banana</span>", "<span style="color: #8b0000;">Orange</span>", "<span style="color: #8b0000;">Watermelon</span>","<span style="color: #8b0000;">Pear</span>", "<span style="color: #8b0000;">Grape</span>", "<span style="color: #8b0000;">Pineapple</span>", "<span style="color: #8b0000;">Strawberry</span>", "<span style="color: #8b0000;">Cherry</span>", "<span style="color: #8b0000;">Mango</span>"};    @Override    <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onCreate(Bundle savedInstanceState) {        <span style="color: #0000ff;">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.first_layout);        ArrayAdapter&lt;String&gt; adapter = <span style="color: #0000ff;">new</span> ArrayAdapter&lt;String&gt;(         <span style="color: #008000;">//ArrayAdapter数组适配器</span>                FirstActivity.<span style="color: #0000ff;">this</span>, android.R.layout.simple_list_item_1, data);      <span style="color: #008000;">//第一个参数，上下文对象；第二个参数，一个官方的内置布局的id（这是一个TexView）;第三个参数，传入的数据</span>        ListView listView = (ListView) findViewById(R.id.ListView);        listView.setAdapter(adapter);    }}</pre></div><p>&nbsp;</p><h3>二，好玩的东西怎么可以只有Text View呢（来点复杂的）</h3><h4>1.新建一个用于存放水果的类</h4><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Fruit {    <span style="color: #0000ff;">private</span> String name;    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> imageId;    <span style="color: #008000;">//构造器初始化</span>    <span style="color: #0000ff;">public</span> Fruit(String name, <span style="color: #0000ff;">int</span> imageId) {        <span style="color: #0000ff;">this</span>.name = name;        <span style="color: #0000ff;">this</span>.imageId = imageId;    }    <span style="color: #0000ff;">public</span> String getName() {        <span style="color: #0000ff;">return</span> name;    }    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> getImageId() {        <span style="color: #0000ff;">return</span> imageId;    }}</pre></div><h4>2.新建一个自定义的布局文件</h4><p>用于描述布局方式，等待被调用</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout</span> <span style="color: #ff0000;">xmlns</span>:<span style="color: #ff0000;">android</span>=<span style="color: #0000ff;">"http://schemas.android.com/apk/res/android"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"match_parent"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"match_parent"</span>    <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">orientation</span>=<span style="color: #0000ff;">"horizontal"</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ImageView</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/fruit_image"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"50dp"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"50dp"</span> <span style="color: #0000ff;">/&gt;</span>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">id</span>=<span style="color: #0000ff;">"@+id/fruit_name"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_width</span>=<span style="color: #0000ff;">"wrap_content"</span>        <span style="color: #ff0000;">android</span>:<span style="color: #ff0000;">layout_height</span>=<span style="color: #0000ff;">"wrap_content"</span> <span style="color: #0000ff;">/&gt;</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre></div><h4>3.自定义适配器，继承于ArrayAdapter，并重写getView方法</h4><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FruitAdapter <span style="color: #0000ff;">extends</span> ArrayAdapter&lt;Fruit&gt; {      <span style="color: #008000;">//</span><span style="color: #008000;">泛型指定为Fruit类，就像String也是一个类</span>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> resourceId;    </span><span style="color: #008000;">//</span><span style="color: #008000;">新建FruitAdapter（）方法，参数一：上下文对象；参数二：布局文件的ID；参数三：传入的数据</span>    <span style="color: #0000ff;">public</span> FruitAdapter(Context context, <span style="color: #0000ff;">int</span> textViewResourceId, List&lt;Fruit&gt;<span style="color: #000000;"> objects){        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context,textViewResourceId,objects);        resourceId </span>=<span style="color: #000000;"> textViewResourceId;    }    @NonNull    @Override    </span><span style="color: #008000;">//</span><span style="color: #008000;">重写getView() 方法，这个方法在内容被加载之前会执行</span>    <span style="color: #0000ff;">public</span> View getView(<span style="color: #0000ff;">int</span><span style="color: #000000;"> position, View convertView, ViewGroup parent) {        Fruit fruit </span>= getItem(position);<span style="color: #008000;">//</span><span style="color: #008000;">得到方法传入的Fruit实例</span>        View view = LayoutInflater.from(getContext()).inflate(resourceId,<span style="color: #0000ff;">null</span>);<span style="color: #008000;">//</span><span style="color: #008000;">把构造器获取的id值传入view</span>        <span style="color: #008000;">/*</span><span style="color: #008000;">ListView的赋值</span><span style="color: #008000;">*/</span><span style="color: #000000;">        ImageView fruitImage </span>=<span style="color: #000000;"> (ImageView) view.findViewById(R.id.fruit_image);        TextView fruitName </span>=<span style="color: #000000;"> (TextView) view.findViewById(R.id.fruit_name);        fruitImage.setImageResource(fruit.getImageId());        fruitName.setText(fruit.getName());        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> view;    }}</span></pre></div><h2><span style="color: #ff0000;">注：在setText的时候不能用int类型数据。</span></h2><h3>4.在Activity引用的layout中添加&lt;ListView&gt;</h3><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ListView        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/ListView"</span><span style="color: #ff0000;">        android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #0000ff;">&gt;</span>    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">ListView</span><span style="color: #0000ff;">&gt;</span></pre></div><h3>5.在Activity中初始化数据并引用ListView</h3><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FirstActivity <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Activity {    </span><span style="color: #0000ff;">private</span> List&lt;Fruit&gt; fruitList = <span style="color: #0000ff;">new</span> ArrayList&lt;Fruit&gt;();         <span style="color: #008000;">//</span><span style="color: #008000;">创建数组适配器的对象fruitList，范型为&lt;Fruit类&gt;</span><span style="color: #000000;">    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);        setContentView(R.layout.first_layout);        initFruits();                                           </span><span style="color: #008000;">//</span><span style="color: #008000;">调用数据初始化函数</span>        FruitAdapter adapter = <span style="color: #0000ff;">new</span> FruitAdapter(FirstActivity.<span style="color: #0000ff;">this</span><span style="color: #000000;">,R.layout.fruit_item,fruitList);        </span><span style="color: #008000;">//</span><span style="color: #008000;">对应的三个参数，上下文，id，适配器数据</span>        <span style="color: #008000;">/*</span><span style="color: #008000;">对ListView设置自定义适配器的值</span><span style="color: #008000;">*/</span><span style="color: #000000;">        ListView listView </span>=<span style="color: #000000;"> (ListView) findViewById(R.id.ListView);        listView.setAdapter(adapter);    }    </span><span style="color: #008000;">/*</span><span style="color: #008000;">列表参数的值的传入和列表的添加</span><span style="color: #008000;">*/</span>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> initFruits(){        Fruit apple </span>= <span style="color: #0000ff;">new</span> Fruit("Apple"<span style="color: #000000;">,R.drawable.apple);        fruitList.add(apple);</span><span style="color: #008000;">//</span><span style="color: #008000;">一定记得要把对象添加进列表中</span>        Fruit banana = <span style="color: #0000ff;">new</span> Fruit("banana"<span style="color: #000000;">,R.drawable.banane);        fruitList.add(banana);        Fruit grape </span>= <span style="color: #0000ff;">new</span> Fruit("grape"<span style="color: #000000;">,R.drawable.grape);        fruitList.add(grape);        Fruit pear </span>= <span style="color: #0000ff;">new</span> Fruit("pear"<span style="color: #000000;">,R.drawable.pear);        fruitList.add(pear);        Fruit watermelon </span>= <span style="color: #0000ff;">new</span> Fruit("watermelon"<span style="color: #000000;">,R.drawable.watermelon);        fruitList.add(watermelon);        Fruit orange </span>= <span style="color: #0000ff;">new</span> Fruit("orange"<span style="color: #000000;">,R.drawable.orange);        fruitList.add(orange);    }}</span></pre></div><h2>&nbsp;二，ListView之优化</h2><h3>1：控件重用，减少重复加载</h3><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> View getView(<span style="color: #0000ff;">int</span><span style="color: #000000;"> position, View convertView, ViewGroup parent) {        Music music </span>=<span style="color: #000000;"> getItem(position);        View view;        </span><span style="color: #0000ff;">if</span> (convertView == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {            </span><span style="color: #008000;">//</span><span style="color: #008000;">对应getView中的参数coverView,一个加载缓存布局的参数。如果没有加载好的布局，则使用LayoutInflater进行布局加载</span>            view = LayoutInflater.from(getContext()).inflate(ResourceId, <span style="color: #0000ff;">null</span><span style="color: #000000;">);        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {            view </span>= convertView;<span style="color: #008000;">//</span><span style="color: #008000;">存在布局，则重载布局</span>        }</pre></div><h3>2：虽然解决了加载次数，但仍旧每次加载都findViewById</h3><p>ViewHolder在As加载中出现问题，暂未解决，后续更新优化问题，再研究研究。</p><p>&nbsp;</p><h2>三，添加点击事件，为ListView 添加setOnItemClickListener</h2><div class="cnblogs_code"><pre>listView.setOnItemClickListener(<span style="color: #0000ff;">new</span><span style="color: #000000;"> AdapterView.OnItemClickListener() {            @Override            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onItemClick(AdapterView&lt;?&gt; parent, View view, <span style="color: #0000ff;">int</span> position, <span style="color: #0000ff;">long</span><span style="color: #000000;"> id) {                MainList APP </span>= mainList.get(position);<span style="color: #008000;">//</span><span style="color: #008000;">确定点击位置，返回值为点击类的的对象</span>                <span style="color: #0000ff;">if</span> (APP.getImageId() ==<span style="color: #000000;"> R.drawable.list_view_icon) {                    Intent intent </span>= <span style="color: #0000ff;">new</span> Intent(MainActivity.<span style="color: #0000ff;">this</span>,MyListView.<span style="color: #0000ff;">class</span><span style="color: #000000;">);                    startActivity(intent);                }            }        });</span></pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebView的初体验</title>
    <link href="/09-Android/WebView%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/09-Android/WebView%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>###使用安卓自带控件可以实现不通过浏览器即可上网的功能<br>突然就觉得安卓好强大，是不是我太无知了，太容易满足了<br>###1.在layout中添加VebView控件<br>###2.在Activity中设置WebView的属性<br>    public class NetWorkActivity extends BaseActivity {<br>        private WebView mWebView;</p><pre><code>    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.network_webview_layout);        mWebView = (WebView) findViewById(R.id.NetworkWebView );        mWebView.getSettings().setJavaScriptEnabled(true);        //调用setJavaScriptEnabled()方法来让 WebView 支持 JavaScript 脚本        mWebView.setWebViewClient(new WebViewClient()&#123;            //设置跳转setWebViewClient（）方法，传入匿名内部类对象WebViewClient                                                                  //重写shouldOverrideUrlLoading方法，来告诉安卓自己能够处理这个网页，无须启动浏览器            @Override            public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;                view.loadUrl(url);                return true;            &#125;        &#125;);        mWebView.loadUrl(&quot;http://www.cnblogs.com/cenzhongman&quot;);    //传入UIL    &#125;&#125;</code></pre><p>##注意声明权限<br>    <uses-permission android:name="android.permission.INTERNET" /></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>draw9的使用说明.html</title>
    <link href="/09-Android/draw9%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/09-Android/draw9%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>转载来自：<a href="http://isux.tencent.com/android-ui-9-png.html" rel="nofollow">http://isux.tencent.com/android-ui-9-png.html</a></p><p><a href="http://isux.tencent.com/android-ui-9-png.html" rel="nofollow"><img src="http://static.oschina.net/uploads/img/201507/14111305_JrK7.png" alt="cover3" width="630" height="360" /></a></p><p><a href="http://isux.tencent.com/category/vd" rel="nofollow"><img src="http://static.oschina.net/uploads/img/201507/14111305_LziE.png" alt="视觉设计" /></a></p><p>在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式&ldquo;.9.png&rdquo;。这种图片是用于Android开发的一种特殊的图片格式，它的好处在于可以用简单的方式把一张图片中哪些区域可以拉伸，哪些区域不可以拉伸设定好，同时可以把显示内容区域的位置标示清楚。<br />本文结合一些具体的例子来看下.9.png的具体用法。</p><p>首先看下普通的.png资源与.9.png的资源区别：<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130808100852504.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_vAVw.png" alt="Android设计中的.9.png" width="590" height="174" /></a></p><p>普通的png资源就不多介绍了，可以明显看到.9.png的外围是有一些黑色的线条的，那这些线条是用来做什么的呢？我们来看下放大的图像：<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130808100935745.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_75st.png" alt="Android设计中的.9.png" width="590" height="287" /></a></p><p>放大后可以比较明显的看到上下左右分别有一个像素的黑色线段，这里分别标注了序号。简单来说，序号1和2标识了可以拉伸的区域，序号3和4标识了内容区域。当设定了按钮实际应用的宽和高之后，横向会拉伸1区域的像素，纵向会拉伸2区域的像素。如下图：<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130808105605940.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_1hMr.png" alt="Android设计中的.9.png" width="590" height="247" /></a></p><p>拉伸的含义应该比较容易理解，但是内容区域的标注有什么意义呢？我们来看下图：<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130808105705727.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_ZbL8.png" alt="Android设计中的.9.png" width="590" height="223" /></a></p><p>这里程序设置的文字垂直居中，水平居左的对齐方式。对齐方式是没有问题的，但是对于这种大圆角同时又有些不规则边框的的图形来说，错误的标注方式会让排版看起来很混乱。所以我们需要修正内容区域的线段位置和长度。<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130808105728711.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_gldI.png" alt="Android设计中的.9.png" width="590" height="200" /></a><br />把横向的内容区域缩短到圆角以内，纵向的内容区域控制在输入框的高度以内，这样文字就可以正常显示了。</p><p>这里还有一种特殊情况，就是本身是.9.png的资源，但是在修改过程中你希望这张.9.png不能被拉伸（在做皮肤的情况中有可能会遇到），那怎么办呢？只要把拉伸区域的点点在透明像素的地方就可以了，这样拉伸的时候会拉伸透明部分的像素，而不会拉伸图像本身。如下图:<br /><a href="http://isux.tencent.com/wp-content/uploads/2013/08/20130817084021139.png" rel="nofollow" target="_blank"><img src="http://static.oschina.net/uploads/img/201507/14111305_JHzW.png" alt="Android设计中的.9.png" width="590" height="276" /></a><br />大家可以看到拉伸区域的黑点是可以不连续的</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用HTTP协议访问网路</title>
    <link href="/09-Android/%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE%E7%BD%91%E8%B7%AF/"/>
    <url>/09-Android/%E4%BD%BF%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE%E7%BD%91%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>#使用HTTP协议访问网路<br>##一、使用HttpURLConnection</p><pre><code>//new一个URL对象URL url = new URL(&quot;http://www.qq.com&quot;);//千万不要用www.baidu.com，坑爹东西//调用openConnection()方法,得到HttpURLConnection对象HttpURLConnection connection = (HttpURLConnection) url.openConnection();//对HttpURLConnection对象设置模式，GET 表示希望从服务器那里获取数据，而 POST 则表示希望提交数据给服务器。connection.setRequestMethod(&quot;GET&quot;);//设置连接超时、读取超时的毫秒数connection.setConnectTimeout(8000);connection.setReadTimeout(8000);//调用 getInputStream()方法获取到服务器返回的输入流InputStream in = connection.getInputStream();//对输入流进行读取操作BufferedReader reader = new BufferedReader(new InputStreamReader(in));StringBuilder response = new StringBuilder();String line;//当该行不为空，返回一行while ((line = reader.readLine()) != null) &#123;    Log.d(TAG, &quot;line != null&quot; + line);    response.append(line);&#125;//通过handler把message发送出去Message message = new Message();message.what = SHOW_RESPONSE;if (response.toString() == null) &#123;    message.obj = response.toString() + &quot;啥也没有&quot;;&#125; else &#123;    message.obj = response.toString();&#125;mHandler.sendMessage(message);</code></pre><p>###主线程中创建handler，并重写handlerMessage()方法，等待来自sendMessage的信息<br>    private Handler mHandler = new Handler() {<br>        @Override<br>        public void handleMessage(Message msg) {<br>            switch (msg.what) {<br>                case SHOW_RESPONSE:<br>                //判断信息并更新UI操作<br>                    String response = (String) msg.obj;<br>                    NetworkTextView.setText(response);<br>                    break;<br>            }<br>        }<br>    };<br><img src="http://images2015.cnblogs.com/blog/1047249/201702/1047249-20170215205834332-1817603930.png"></p><p>##向服务器推送数据<br>    connection.setRequestMethod(“POST”);<br>    DataOutputStream out = new DataOutputStream(connection.getOutputStream());<br>    out.writeBytes(“username=admin&amp;password=123456”);//数据与数据之间用”&amp;”隔开</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>再按一次退出程序的实现.html</title>
    <link href="/09-Android/%E5%86%8D%E6%8C%89%E4%B8%80%E6%AC%A1%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/09-Android/%E5%86%8D%E6%8C%89%E4%B8%80%E6%AC%A1%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3>重写返回按键的方法：（个人认为这是最简单的）</h3><p>用一个参数来纪录按下按键的返回时间，与上一次作比较。</p><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">long</span> exitTime = 0<span style="color: #000000;">;    @Override    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onBackPressed() {        </span><span style="color: #0000ff;">if</span> ((System.currentTimeMillis() - exitTime) &gt; 2000) {<span style="color: #008000;">//</span><span style="color: #008000;">判断此次按键于上一次按键的时间差是否&gt;2s</span>            Toast.makeText(MainActivity.<span style="color: #0000ff;">this</span>, "再按一次退出应用"<span style="color: #000000;">, Toast.LENGTH_SHORT).show();            exitTime </span>= System.currentTimeMillis();<span style="color: #008000;">//</span><span style="color: #008000;">纪录这次按键的时间，下次有用</span>            <span style="color: #0000ff;">return</span>;<span style="color: #008000;">//</span><span style="color: #008000;">时间差大于2s，退出返回事件</span><span style="color: #000000;">        }        finish();</span><span style="color: #008000;">//</span><span style="color: #008000;">时间差小于2s，销毁</span>    }</pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建menu文件.html</title>
    <link href="/09-Android/%E5%88%9B%E5%BB%BAmenu%E6%96%87%E4%BB%B6/"/>
    <url>/09-Android/%E5%88%9B%E5%BB%BAmenu%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一问题">一、问题：</h1><h3 id="android-studio项目中没有看到menu文件夹">android studio项目中没有看到menu文件夹：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224161937911-374835294.png" alt="" /></p><h3 id="在android-studio项目中想要添加menu布局文件一开始我的做法是直接在res文件夹右键选择xml文件来添加如下图">在android studio项目中想要添加menu布局文件，一开始我的做法是：直接在res文件夹右键选择xml文件来添加，如下图：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224160605474-2130245661.png" alt="" /></p><h3 id="但是会发现新建的布局文件好像很奇怪不能添加menu以及item如下图">但是会发现新建的布局文件好像很奇怪，不能添加menu以及item，如下图：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224160857802-2002071540.png" alt="" /></p><p>&nbsp;</p><h1 id="二解决办法">二、解决办法：</h1><h3 id="经过百度才知道menu布局文件要在menu文件夹地下创建才行正确的做法如下">经过百度才知道menu布局文件要在menu文件夹地下创建才行，正确的做法如下：</h3><h3 id="先在res文件夹右键然后如下图选择">（1）先在res文件夹右键，然后如下图选择：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224161222240-578401972.png" alt="" /></p><h3 id="然后会出现下面的页面在resource-type下拉栏选择menu如下图">然后会出现下面的页面，在Resource type下拉栏选择menu，如下图：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224161623958-1629427781.png" alt="" /></p><h3 id="最后点击ok就行了这时候可以看到menu文件夹已经出来了">最后点击OK就行了，这时候可以看到menu文件夹已经出来了；</h3><p>&nbsp;</p><h3 id="接着在menu文件夹下右键选择如下">（2）接着在menu文件夹下右键，选择如下：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224162119005-636037644.png" alt="" /></p><h3 id="输入文件名点击ok即可">输入文件名点击OK即可：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224162217708-545886018.png" alt="" /></p><h3 id="这样就可以了">这样就可以了：</h3><p><img src="http://images2015.cnblogs.com/blog/808795/201602/808795-20160224162356927-560726649.png" alt="" /></p><p>&nbsp;</p><h2>二.菜单响应定义</h2><p>重写<span class="fontstyle0">onOptionsItemSelected 方法</span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> onOptionsItemSelected(MenuItem item) {</span><span style="color: #0000ff;">　　switch</span><span style="color: #000000;"> (item.getItemId()) {</span><span style="color: #0000ff;">　　case</span><span style="color: #000000;"> R.id.add_item:　　　　Toast.makeText(</span><span style="color: #0000ff;">this</span>, "You clicked Add"<span style="color: #000000;">, Toast.LENGTH_SHORT).show();</span><span style="color: #0000ff;">　　　　break</span><span style="color: #000000;">;</span><span style="color: #0000ff;">　　case</span><span style="color: #000000;"> R.id.remove_item:　　　　Toast.makeText(</span><span style="color: #0000ff;">this</span>, "You clicked Remove"<span style="color: #000000;">, Toast.LENGTH_SHORT).show();</span><span style="color: #0000ff;">　　　　break</span><span style="color: #000000;">;</span><span style="color: #0000ff;">　　　　default</span><span style="color: #000000;">:　　}</span><span style="color: #0000ff;">　  return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;}</span></pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>创建自定义控件.html</title>
    <link href="/09-Android/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    <url>/09-Android/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3>新建 TitleLayout 继承自 LinearLayout</h3> <div class="cnblogs_code"><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> TitleLayout <span style="color: #0000ff">extends</span> LinearLayout {    <span style="color: #0000ff">public</span> TitleLayout(Context context , AttributeSet attrs){<span style="color: #008000">//重写构造器</span>        <span style="color: #0000ff">super</span>(context,attrs);        LayoutInflater.from(context).inflate(R.layout.topbar,<span style="color: #0000ff">this</span>);        <span style="color: #008000">//LayoutInflater.from()构建LayoutInflater对象，对象的inflate方法，第一个参数布局文件的id，第二个参数，this&lt;==&gt;TitleLayout</span>    }}</pre></div><p><font color="#ff0000">需要注意的是在引用时候必须使用完整类名。</font></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的Android笔记</title>
    <link href="/09-Android/%E6%88%91%E7%9A%84Android%E7%AC%94%E8%AE%B0/"/>
    <url>/09-Android/%E6%88%91%E7%9A%84Android%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>#小问题集合<br>##1.动态加载View<br>###（1）FindViewByid找到对应的Layout<br>    LinearLayout FileSaveLinearLayout = (LinearLayout) findViewById(R.id.FileSaveLinearLayout);<br>###（2）Layout对象addView()<br>    TextView Line1 = new TextView(FileSaveActivity.this);<br>    TextView Line2 = new TextView(FileSaveActivity.this);<br>    TextView Line3 = new TextView(FileSaveActivity.this);<br>    FileSaveLinearLayout.addView(Line1);<br>    FileSaveLinearLayout.addView(Line2);<br>    FileSaveLinearLayout.addView(Line3);</p><p>##2.同时实现多个按键<br>    FileSaveButton.setOnClickListener(mListener);<br>    FileGetButton.setOnClickListener(mListener);</p><pre><code>private View.OnClickListener mListener = new View.OnClickListener() &#123;    @Override    public void onClick(View v) &#123;        switch (v.getId()) &#123;            case R.id.FileSaveButton:                    //todo                break;            case R.id.FileGetButton:                    //todo                    break;                &#125;        &#125;    &#125;&#125;;</code></pre><p>##3.error: more than one device/emulator<br>原    因：存在多个设备或模拟设备<br>解决办法：列出所有设备</p><blockquote><p>adb devices<br>adb -s 选择所需设备</p></blockquote><p>##4.启动别的程序<br>    Intent intent1 = new Intent();<br>    //通过包名和activity名启动应用<br>    intent1.setComponent(new ComponentName(“com.cenzhongman.myapplication2”,”com.cenzhongman.myapplication2.MainActivity”));<br>    startActivity(intent1);</p><p>###查询所装APP的包名</p><p>#安卓学习<br>##从SharedPreferences中获取数据<br>###（1）getSharedPreferences()方法得到SharedPreferences对象，两个参数，1：文件名，2：模式<br>    SharedPreferences GetDataSharedPreferences = getSharedPreferences(“SharePreferences”, MODE_PRIVATE);<br>###（2）SharedPreferences对象中获取数据，getXXX()方法，两个参数，1：键值，2：默认值<br>    String name = GetDataSharedPreferences.getString(“name”, “”);<br>    int age = GetDataSharedPreferences.getInt(“age”, 0);<br>    boolean handsome = GetDataSharedPreferences.getBoolean(“handsome”, false);</p><p>##SQLite学习和使用<br>###创建数据库并创建表格<br>####1.创建MyDatabaseHelper继承于SQLiteOpenHelper(抽象类，必须实现onCreate()和onUpgrade()方法)<br>####2.把数据库建表指令弄成一个字符串CREATE_BOOK常量，并在onCreate()函数中执行建表<br>    public class MyDatabaseHelper extends SQLiteOpenHelper {</p><pre><code>//把数据库建表指令弄成一个字符串CREATE_BOOK常量public static final String CREATE_BOOK = &quot;create table book (&quot;        + &quot;id integer primary key autoincrement, &quot;        + &quot;author text, &quot;        + &quot;price real, &quot;        + &quot;pages integer, &quot;        + &quot;name text)&quot;;public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123;    super(context,name,factory,version);&#125;@Overridepublic void onCreate(SQLiteDatabase db) &#123;    db.execSQL(CREATE_BOOK);//执行建表    Log.d(TAG,&quot;数据库初始化完成&quot;);&#125;@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;&#125;&#125;</code></pre><p>####3.在MianActivity()中新建数据库<br>    private MyDatabaseHelper dbHelper = new MyDatabaseHelper(this, “BookStore.db”, null, 1);<br>    //新建一个MyDatabaseHelper对象，上下文；数据库名；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；数据库版本号<br>    dbHelper.getWritableDatabase();</p><p>###升级数据库方法1（覆盖式）<br>####需    求：增加一个新的表格，Category<br>由于数据库BookStore.db已经存在，onCreate()方法不会再次执行，直接在onCreate()方法中，添加table不能被更新。<br>####解决方案：使用onUpgrade()方法更新数据库<br>#####添加表格常量；在onCreate()方法中建表；在upGreate()方法中删去存在表格，并重新执行onCreate()方法；在引用数据库时更改数据库版本号<br>    public class MyDatabaseHelper extends SQLiteOpenHelper {</p><pre><code>    //把数据库建表指令弄成一个字符串CREATE_BOOK常量    public static final String CREATE_BOOK = &quot;create table book (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer, &quot;            + &quot;name text)&quot;;    //integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。另外，上述建表语句中我们还    //使用了 primary key 将 id 列设为主键，并用 autoincrement 关键字表示 id 列是自增长的    public static final String CREATE_CATEGORY = &quot;create table category(&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;category_name text, &quot;            + &quot;category_code integer)&quot;;    public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123;        super(context,name,factory,version);    &#125;    @Override    public void onCreate(SQLiteDatabase db) &#123;        db.execSQL(CREATE_BOOK);//执行建表        db.execSQL(CREATE_CATEGORY);        Log.d(TAG,&quot;数据库初始化完成&quot;);    &#125;    //当检测到数据库版本变化，就会执行onUpgrade()中的代码    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        //调用SQL语句，若存在表格则删去，之后在重新调用onCreate()方法        db.execSQL(&quot;drop table if exists Book&quot;);        db.execSQL(&quot;drop table if exists Category&quot;);        onCreate(db);    &#125;&#125;</code></pre><p>###升级数据库方法2（追加式）<br>####需    求：根据所需变更数据库，增加一个新的表格，Category<br>由于覆盖式更新数据库的方法会重置数据库，导致用户数据丢失，不能在产品中使用<br>####解决方案：为每一个版本号赋予它各自改变的内容，然后在onUpgrade()方法中对当前数据库的版本号进行判断，再执行相应的改变就可以了<br>    @Override<br>    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {<br>        //调用SQL语句，若存在表格则删去，之后在重新调用onCreate()方法<br>        /**<br>         * 注释时间：20170117<br>         * 代码作用：覆盖式更新数据库，删除之前的数据库再新建库<br>         * 注释原因：学习新的数据库更新方法<br>        db.execSQL(“drop table if exists Book”);<br>        db.execSQL(“drop table if exists Category”);<br>        onCreate(db);<br>         */<br>        switch (newVersion)<br>        {<br>            case 2:db.execSQL(CREATE_CATEGORY);<br>                //！！！注意，无break；<br>            case 3:db.execSQL(“alter table Book add column category_id integer”);<br>                //！！！注意，无break；<br>                //因为无论覆盖哪一个版本安装，都需要安装其他更新，从第二版安装第三版时，只需要更新case3,确保数据库最新<br>                Log.d(TAG,”第3版数据库更新成功”);<br>                break;<br>            default:<br>                Log.d(TAG,”数据库更新失败”);<br>                break;<br>        }<br>    }</p><p>###增删改查操作(SQL语句操作)<br>对数据进行的操作也就无非四种，即CRUD。其中 C 代表添加（Create） ，R 代表查询（Retrieve） ，U 代表更新（Update） ，D 代表删除（Delete）</p><pre><code>SQLiteDatabase db = dbBookStoreHelper.getWritableDatabase();//新建两个数据db.execSQL(&quot;insert into Book (name, author, pages, price) values(?, ?, ?, ?)&quot;,new String[] &#123; &quot;The Da Vinci Code&quot;, &quot;Dan Brown&quot;, &quot;454&quot;, &quot;16.96&quot; &#125;);db.execSQL(&quot;insert into Book (name, author, pages, price) values(?, ?, ?, ?)&quot;,new String[] &#123; &quot;The Lost Symbol&quot;, &quot;Dan Brown&quot;, &quot;510&quot;, &quot;19.95&quot; &#125;);//查询所有数据db.rawQuery(&quot;select * from Book&quot;, null);//把《The Da Vinci Code》这本书改成10.99db.execSQL(&quot;update Book set price = ? where name = ?&quot;, new String[] &#123; &quot;10.99&quot;,&quot;The Da Vinci Code&quot; &#125;);//把500页以上的书删了db.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[] &#123; &quot;500&quot; &#125;);</code></pre><p>###增删改查操作(Android语法操作)<br>####增加数据<br>insert()方法，1.表名；2.未指定添加数据的情况下给某些可为空的列自动赋值 NULL；3.ContentValues 对象，它提供了一系列的 put()<br>方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可</p><pre><code>//！！！先组装数据，再插入数据SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();// 开始组装第一条数据values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 454);values.put(&quot;price&quot;, 16.96);db.insert(&quot;Book&quot;, null, values); // 插入第一条数据values.clear();// 开始组装第二条数据values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 510);values.put(&quot;price&quot;, 19.95);db.insert(&quot;Book&quot;, null, values); // 插入第二条数据</code></pre><p>####更改数据<br>update()方法，1.表名；2.ContentValues 对象，要把更新数据在这里组装进去;第三、第四个参数用于去约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行</p><pre><code>SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(&quot;price&quot;, 10.99);db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] &#123; &quot;The DaVinci Code&quot; &#125;);values.clean();</code></pre><p>####删除数据<br>delete()方法，1.表名；第二、第三个参数用于去约束删除某一行或某几行的数据，不指定的话默认就是删除所有行</p><pre><code>db.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[] &#123;&quot;300&quot;&#125;);</code></pre><p>####查询数据<br>query()方法，1.表名；2.指定去查询哪几列，如果不指定则默认查询所有列；3.第三、第四个参数用于去约束查询某一行或某几行的数据，不指定则默认是查询所有行的数据；5.指定需要去 group by 的列，不指定则表示不对查询结果进行 group by 操作；6. group by 之后的数据进行进一步的过滤，不指定则表示不进行过滤；7，指定查询结果的排序方式，不指定则表示使用默认的排序方式。</p><blockquote><p>query()方法参数     对应 SQL 部分                     描述<br>table                 from table_name                 指定查询的表名<br>columns            select column1, column2         指定查询的列名<br>selection             where column = value             指定 where 的约束条件<br>selectionArgs         -                                 为 where 中的占位符提供具体的值<br>groupBy             group by column                 指定需要 group by 的列<br>having             having column = value             对 group by 后的结果进一步约束<br>orderBy             order by column1, column2         指定查询结果的排序方式</p></blockquote><p>###使用事务Transaction<br>事情要有始有终，就像转账，钱没到达对方账户就会退回原始账户<br>####需    求：删除旧的数据库，更换新的数据库<br>####解决方案：使用beginTransaction，setTransactionSuccessful，endTransaction三个来监控事务的执行，一旦执行失败，返回原始的数据库<br>    db.beginTransaction();//开始事务<br>    try {<br>        db.delete(“Book”, null, null);<br>        if (true) {<br>            // 在这里手动抛出一个异常，让事务失败<br>            throw new NullPointerException();<br>        }<br>        db.execSQL(“insert into Book (name, author, pages, price) values(?, ?, ?, ?)”,<br>                new String[]{“马克思主义2”, “中国共产党”, “1000”, “100.00”});<br>        db.setTransactionSuccessful(); // 事务已经执行成功<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>    } finally {<br>        db.endTransaction(); // 结束事务<br>    }</p><p>##内容提供器（Content Provider）<br>一个跟数据库很相似的用于与其他程序传递信息的组件，用的也是数据库的CRUD操作</p><blockquote><p>相关权限<br>注册内容提供者以及权限<br>    <provider        android:name=".ContentResolver.CreateContentResplver"        android:authorities="com.cenzhongman.provider"        android:exported="true"><br>    </provider><br>获取系统联系人权限<br>    <uses-permission android:name="android.permission.READ_CONTACTS" /></p></blockquote><p>###内容URI(标识)</p><blockquote><p>协议声明://权限（authority）/路径（path）<br>content://com.example.app.provider/table1——————-table1表格的数据<br>content://com.example.app.provider/table1/1—————–包含id值为1数据<br>content://com.example.app.provider/*————————包含任意的表格<br>content://com.example.app.provider/table1/#—————–包含table1表格的任意行的数据</p></blockquote><p>###调用 Uri.parse()方法，将内容 URI 字符串解析成 Uri 对象<br>    Uri uri = Uri.parse(“content://com.example.app.provider/table1”)</p><p>##从别的程序获取数据<br>###通过getContentResolver()方法获得ContentResolver实例<br>####增加数据<br>    ContentValues values = new ContentValues();<br>    values.put(“column1”, “text”);<br>    values.put(“column2”, 1);<br>    getContentResolver().insert(uri, values);</p><p>####删除数据<br>    getContentResolver().delete(uri, “column2 = ?”, new String[] { “1” });</p><p>####更改数据<br>    ContentValues values = new ContentValues();<br>    values.put(“column1”, “”);<br>    getContentResolver().update(uri, values, “column1 = ? and column2 = ?”, new<br>    String[] {“text”, “1”});</p><p>####查询数据<br>    Cursor cursor = getContentResolver().query(<br>    uri,            //uri对应的表<br>    projection,        //指定查询的列名<br>    selection,        //指定 where 的约束条件<br>    selectionArgs,    //为 where 中的占位符提供具体的值<br>    sortOrder);        //指定查询结果的排序方式</p><blockquote><p>query()方法参数         对应 SQL 部分                     描述<br>uri                     from table_name                 指定查询某个应用程序下的某一张表<br>projection                 select column1, column2         指定查询的列名<br>selection                 where column = value             指定 where 的约束条件<br>selectionArgs             -                                 为 where 中的占位符提供具体的值<br>orderBy                 order by column1, column2         指定查询结果的排序方式</p></blockquote><p>#####遍历 Cursor<br>查询得到Cursor对象，通过移动游标的位置来遍历 Cursor 的所有行，然后再取出每一行中相应列的数据</p><p>##创造ContentProvider，给别的程序提供数据<br>###新建 MyProvider 继承自 ContentProvider，重写6个方法<br>###UriMatcher中提供了一个 addURI()方法，1.权限、2.路径、3.自定义代码<br>当调用 UriMatcher 的 match()方法时，就可以将一个 Uri 对象传入，返回值是某个能够匹配这个 Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了</p><blockquote><p>MIME 类型<br>content://com.example.app.provider/table1 ——————–vnd.android.cursor.dir/vnd.com.example.app.provider.table1<br>content://com.example.app.provider/table1/1——————-vnd.android.cursor.item/vnd.com.example.app.provider.table1</p></blockquote><p>#Git学习<br>####1.初始化init</p><blockquote><p>git init<br>####2.选择哪些文件和文件夹不保存到Git<br>通过在 .gitignore文件中添加问价路径描述来，可以使用通配符</p></blockquote><pre><code>*.iml.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build/captures.externalNativeBuild</code></pre><p>####3.添加文件add</p><blockquote><p>gir add .          ————添加所有文件<br>git add abc.xml    ————添加单个文件<br>git add src        ————添加文件夹<br>####4.提交保存commit<br>git commit -m “First commit.”<br>####5.查询修改内容<br>git status         ———–查看修改哪个文件<br>git diff            ———–查看所有文件的修改内容<br>git diff app/src/main/java/com/cenzhongman/myapplication2/MainActivity.java         ——-查看修改的单个文件<br>####6.撤回(未提交)checkout<br>git checkout app/src/main/java/com/cenzhongman/myapplication2/MainActivity.java<br>####7.撤回(已提交)reset<br>git </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>永久文件存储技术</title>
    <link href="/09-Android/%E6%B0%B8%E4%B9%85%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/09-Android/%E6%B0%B8%E4%B9%85%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>###永久文件存储技术</p><pre><code>#1.通过打印流输出到文件out = open(&#39;file_name&#39;,&#39;w&#39;)print(&#39;输出的字符串序列&#39;,file = out)#2.通过输出流保存out = open(&#39;file_name&#39;,&#39;w&#39;)out.</code></pre><p>####使用try/expect/finally来打开文件</p><pre><code>try:    data = open(&#39;data.txt&#39;,&#39;w&#39;)    print(&#39;这是存储内容&#39;,file = data)expect IOError as err:    print(&#39;错误提示：&#39; + str(err))finally:    if &#39;data&#39; in locals()         #使用locals()可以检查对象‘data’是否存在当前作用域里面                                #如果没有这句，文件不存在，则data也不存在        data.colse()</code></pre><p>####由于用try/except/finally/模式来打开和关闭代码非常常见，py提供了用whih语句,无需考虑文件的关闭</p><pre><code>try:    with open (&#39;data.txt&#39;,&#39;w&#39;) as data:        print(&#39;这是存储内容&#39;,file = data)expect IOError as err:     print(&#39;错误提示：&#39; + str(err))</code></pre><p>###使用pickle保存</p><pre><code># 腌制数据,就是原格式保存数据import picklewith open(&#39;mydata.pickle&#39;, &#39;wb&#39;) as myPickleSave:  # 使用二进制保存文件    pickle.dump([1, 23, 4, 5, &#39;aa&#39;], myPickleSave)  # 使用dump方法进行保存数据with open(&#39;mydata.pickle&#39;, &#39;rb&#39;) as myPickleRead:    testList = pickle.load(myPickleRead)  # 使用load方法恢复数据print(testList)</code></pre><p>###文件读写模式<br>r    只读，不存在报错<br>w    写，不存在创建<br>a    追加，不存在创建</p><p>r+    可读可写，不存在报错<br>w+    可读可写，不存在创建<br>a+    可读可写，不存在创建</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>沉浸式状态栏.html</title>
    <link href="/09-Android/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <url>/09-Android/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<p>知识来源：https://zhidao.baidu.com/question/1989575143165411427.html</p><p>　　（1）内容应用到状态栏（360流量允许拖动到状态栏的效果）</p><div class="cnblogs_code"><pre>Window window =<span> getWindow();            window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,                WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);            window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION,                WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span></pre></div><p><img src="http://images2015.cnblogs.com/blog/1047249/201612/1047249-20161203152523662-98383083.png" alt="" /></p><p>　　（2）在xml中设置一个带背景的与状态栏同高的空白</p><p><span style="font-size: 18px;"><strong>总代码如下</strong></span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.cenzhongman.myapplication.Note;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.app.Activity;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.os.Bundle;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.view.Window;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.view.WindowManager;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.widget.TextView;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.widget.Toast;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> com.cenzhongman.myapplication.R;</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Field;</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> NoteActivity <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Activity {    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);        setContentView(R.layout.note_layout);        </span><span style="color: #0000ff;">if</span> (android.os.Build.VERSION.SDK_INT &gt; 18<span style="color: #000000;">) {        </span><span style="color: #008000;">/*</span><span style="color: #008000;">        *    API需要大于18        *    隐藏状态栏        *    让内容置于屏幕顶部        *  1.如需隔开，在xml中添加android:fitsSystemWindows="true"        *  2.添加一个状态栏高度的空白（此次使用方法2）        * </span><span style="color: #008000;">*/</span><span style="color: #000000;">            Window window </span>=<span style="color: #000000;"> getWindow();            window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);            window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION,                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);        </span><span style="color: #008000;">/*</span><span style="color: #008000;">        * 设置空白处高度        *        *        * </span><span style="color: #008000;">*/</span>            <span style="color: #0000ff;">int</span> StatusBarHeight =<span style="color: #000000;"> getStatusBarHeight();            Toast.makeText(</span><span style="color: #0000ff;">this</span>, StatusBarHeight + "123"<span style="color: #000000;">, Toast.LENGTH_SHORT).show();            TextView status_bar </span>=<span style="color: #000000;"> (TextView) findViewById(R.id.status_bar);            status_bar.setHeight(StatusBarHeight);        }    }    </span><span style="color: #008000;">/*</span><span style="color: #008000;">    * 获取状态栏高度    * 返回值，int 高度    </span><span style="color: #008000;">*/</span>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getStatusBarHeight() {        Class c </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;        Object obj </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;        Field field </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;        </span><span style="color: #0000ff;">int</span> x = 0, statusBarHeight = 0<span style="color: #000000;">;        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {            c </span>= Class.forName("com.android.internal.R$dimen"<span style="color: #000000;">);            obj </span>=<span style="color: #000000;"> c.newInstance();            field </span>= c.getField("status_bar_height"<span style="color: #000000;">);            x </span>=<span style="color: #000000;"> Integer.parseInt(field.get(obj).toString());            statusBarHeight </span>=<span style="color: #000000;"> getResources().getDimensionPixelSize(x);        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e1) {            e1.printStackTrace();        }        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> statusBarHeight;    }}</span></pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>活动生命周期问题.html</title>
    <link href="/09-Android/%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <url>/09-Android/%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2>一：活动的七个生命周期</h2><p><span class="fontstyle0">在<span class="fontstyle1">onCreate(...)<span class="fontstyle0">方法里，必须首先调用超类的实现方法，然后再调用其他方法。 <br /></span></span></span></p><h1><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="2016-11-02_1610142" src="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102165718611-1749968147.png" alt="2016-11-02_1610142" width="442" height="541" border="0" />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102165717127-824287010.png"><img src="http://images2015.cnblogs.com/blog/1047249/201702/1047249-20170217155857144-271592990.png" alt="" /></a></h1><h4>&nbsp;在翻转屏幕时候，会更新Activity，这时候就需要用bundle保存好数据，根据键值来保存数据，不建议用来保存实例，可能在返回时候已经过时了</h4><h4>同时，建议所有的activity最好都做好数据保存工作，在内存低时候，可以自动保存，提高用户体验</h4><p>在系统干掉我们的活动之前会调用&nbsp; onSaveInstanceState（）方法来保存一下死亡数据，如果你觉得数据还是有点价值的话，Override这个方法就可以存储死亡时候的数据。</p><div class="cnblogs_code"><pre> @Override<span style="color: #0000ff;">    protected</span> <span style="color: #0000ff;">void</span> onSaveInstanceState(Bundle outState) { //Bundle对应onCreate方法中的Bundul对象<span style="color: #0000ff;">         super</span>.onSaveInstanceState(outState);         String tempData = "<span style="color: #8b0000;">Something you just typed</span>";         outState.putString("<span style="color: #8b0000;">data_key</span>", tempData);//    }</pre></div><p>存好了，总得取出来的。于是就有了取出的代码</p><div class="cnblogs_code"><pre> @Override<span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onCreate(Bundle savedInstanceState) {<span style="color: #0000ff;">    super</span>.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);<span style="color: #0000ff;">    if</span> (savedInstanceState != <span style="color: #0000ff;">null</span>) {    //如果存储的数据不是空的        String tempData = savedInstanceState.getString("<span style="color: #8b0000;">data_key</span>");   //调savedInstanceState的getString()方法就可以调出数据        Log.d(&ldquo;MainActivity&rdquo;, tempData);    }}</pre></div>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>活动的启动模式.html</title>
    <link href="/09-Android/%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/09-Android/%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ul> <li><strong><font color="#ff0000">在AndroidMainifest注册中说明启动模式</font></strong></li></ul> <div class="cnblogs_code"><pre>android:launchMode="singleTop"</pre></div><h3>1.standard标准模式</h3><p>系统不去检测是否该在栈顶，直接暴力创建一个相同的活动，<font color="#9b00d3">不管三七二十一创建了再说</font></p><p><a href="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211234705-171253560.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211235565-1083905680.png" width="493" height="299"></a><h3>2.singleTop模式</h3><p>系统检测到返回栈的<font color="#ff0000">栈顶</font>已经是该活动，if true不会再创建，不在栈顶，不好意思，<strong>创！</strong></p><p><a href="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211236486-1690221449.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211237346-566781679.png" width="496" height="262"></a></p><h3>3.singleTask模式</h3><p>&nbsp; 系统检测返回栈中是否存在该活动，存在则置顶，并把在它之上的直接请到外面去。</p><p><font color="#ff0000">特别的：注册android:taskAffinity=""也可以创建新的返回栈</font></p><p><a href="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211238643-1412519893.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211239736-1946429239.png" width="522" height="339"></a></p><h3>4.singleInstance模式（独立（单栈）模式，共享的活动实例，如微信登录之类的（我猜的，打我啊））返回就出栈了，说明不是在主程序返回栈中的<a href="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211240268-1234883954.png"><img title="无标题" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="无标题" src="http://images2015.cnblogs.com/blog/1047249/201611/1047249-20161102211240658-562913661.png" width="517" height="252"></a></h3><p><strong>独立创建一个存放自己的返回栈，有且只有一个活动！</strong></p><p><strong></strong>&nbsp;</p><p><strong>注：好看图片来自《第一行代码》截图，不好看的自己画的</strong></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View</title>
    <link href="/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <url>/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    
    <content type="html"><![CDATA[<p>###构造器</p><blockquote><p>自定义构造器或调用父类构造器来初始化View<br>注意：自定义view需要注意构造函数，所有的xml布局，初始化时构造函数使用的都是 (Context context, AttributeSet attrs)，需要两个参数的构造器</p></blockquote><p>###onFinishInflate()</p><blockquote><p>在XML文件加载完毕，界面初始化完成回调该方法</p></blockquote><p>###onMeasure(int int)</p><blockquote><p>初始化组件大小</p></blockquote><p>###onLayout(boolean,int,int,int,int)</p><blockquote><p>分配子组件的位置和大小</p></blockquote><p>###onDraw(Canvas)<br>    @Override<br>    publivc void onDraw(Canvas canvas){<br>        super.onDraw(canvas);<br>        paint.setColor(Color.RED);//设置画笔颜色<br>        paint.drawCircle(currentX,currentY,15,piant);//用15点大小的笔paint画圆<br>    }</p><p>###onKeyDown(int,KeyEvent)</p><blockquote><p>按键按下的监控</p></blockquote><p>###onKeyUp(int,KeyEvent)</p><blockquote><p>按键松开的监控</p></blockquote><p>###onTrackballEvent(MotionEvent)</p><blockquote><p>轨迹球事件的监控</p></blockquote><p>###onTouchEvent(MotionEvent)</p><blockquote><p>触摸事件的监控</p></blockquote><p>###onFocusChanged(…)</p><blockquote><p>焦点改变监控</p></blockquote><p>###onWindowFocusChange(boolean)</p><blockquote><p>窗口焦点改变监控</p></blockquote><p>###onAttachedToWindow()</p><blockquote><p>组件加入窗口触发</p></blockquote><p>###onDetachedFromWindow()</p><blockquote><p>组件从窗口删除触发</p></blockquote><p>###onWindowVisibilityChange()</p><blockquote><p>窗口可见性发生改变触发</p></blockquote><p>###onMeasure( )方法<br><a href="http://blog.csdn.net/carterjin/article/details/8264120">http://blog.csdn.net/carterjin/article/details/8264120</a></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>资源的引用.html</title>
    <link href="/09-Android/%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <url>/09-Android/%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>res文件夹中的资源分类</strong></li></ul><p>　　（可直接通过R类调用），assets文件夹中的资源，如mp3必须通过二进制流来读取</p><ol><li>anim(xml动画)</li><li>drawable(图片资源)</li><li>layout（布局文件）</li><li>menu（菜单）</li><li>raw(二进制文件)</li><li>values（常量值）</li><li>xml(xml文件)</li></ol><p>&nbsp;</p><ul><li>引用资源的两种方法</li></ul><ol><li><span style="font-family: Microsoft YaHei;">在xml文件中</span></li></ol><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/textView"</span><span style="color: #ff0000;">        android:textColor</span><span style="color: #0000ff;">="@color/gray81"</span><span style="color: #ff0000;">        android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">        android:text</span><span style="color: #0000ff;">="Hello World!"</span> <span style="color: #0000ff;">/&gt;</span></pre></div><p><span style="font-size: 13px;"><span style="font-family: Microsoft YaHei; font-size: 14px;">　　2.在activity中<br /></span></span></p><div class="cnblogs_code"><pre>        <span style="color: #0000ff;">int</span> gray91 =  <span style="color: #0000ff;">this</span>.getResources().getColor(R.color.gray91);     <span style="color: #008000;">//</span><span style="color: #008000;">通过getResources对象获取资源，（string资源context.getString()即可获得）</span>        Toast.makeText(<span style="color: #0000ff;">this</span>,""+<span style="color: #000000;">gray91,Toast.LENGTH_LONG).show();        </span><span style="color: #0000ff;">this</span>.getWindow().setBackgroundDrawableResource(R.color.gray91); <span style="color: #008000;">//</span><span style="color: #008000;">通过getWindows对象获取资源</span></pre></div><ul><li><h4><span style="font-size: 13px;"><span style="font-family: Microsoft YaHei; font-size: 14px;">尺寸资源（dimens）(调用方式同上)</span></span></h4></li></ul><hr /><p><br />px　　　　像素　　　　　　　　屏幕真实像素</p><p>in　　　　英寸　　　　　　　　属于屏幕的物理英寸</p><p>pd　　　　与密度无关的像素　　相对屏幕物理密度的抽象单位</p><p>sp　　　　与精度无关的像素　　同上</p><p>mm　　　可以直接引用物理单位（支持小数）（实测cm不能用）</p><hr /><ul><li>xml资源</li></ul><p>　　只能在java中调用，不能在xml中调用</p><pre><span style="font-size: 13px;">&nbsp;</span></pre><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨程序提供及获取内容.html</title>
    <link href="/09-Android/%E8%B7%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BE%9B%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9/"/>
    <url>/09-Android/%E8%B7%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BE%9B%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1>从别的程序获取数据</h1><h2>通过getContentResolver()方法获得ContentResolver实例</h2><ul><li><h3>增加数据</h3></li></ul><div class="cnblogs_code"><pre>ContentValues values = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ContentValues();values.put(</span>"column1", "text"<span style="color: #000000;">);values.put(</span>"column2", 1<span style="color: #000000;">);getContentResolver().insert(uri, values);</span></pre></div><p>&nbsp;</p><ul><li><h3>删除数据</h3></li></ul><div class="cnblogs_code"><pre>getContentResolver().delete(uri, "column2 = ?", <span style="color: #0000ff;">new</span> String[] { "1" });</pre></div><p>&nbsp;</p><ul><li><h3>更改数据</h3></li></ul><div class="cnblogs_code"><pre>ContentValues values = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ContentValues();values.put(</span>"column1", ""<span style="color: #000000;">);getContentResolver().update(uri, values, </span>"column1 = ? and column2 = ?", <span style="color: #0000ff;">new</span><span style="color: #000000;">String[] {</span>"text", "1"});</pre></div><p>&nbsp;</p><ul><li><h3>查询数据</h3></li></ul><div class="cnblogs_code"><pre>Cursor cursor =<span style="color: #000000;"> getContentResolver().query(uri,    </span><span style="color: #008000;">//</span><span style="color: #008000;">uri对应的表</span>projection,    <span style="color: #008000;">//</span><span style="color: #008000;">指定查询的列名</span>selection,    <span style="color: #008000;">//</span><span style="color: #008000;">指定 where 的约束条件</span>selectionArgs,    <span style="color: #008000;">//</span><span style="color: #008000;">为 where 中的占位符提供具体的值</span>sortOrder);    <span style="color: #008000;">//</span><span style="color: #008000;">指定查询结果的排序方式</span></pre></div><p>&nbsp;</p><table style="height: 161px; width: 1088px;" border="0"><tbody><tr><td>query()方法参数</td><td>对应 SQL 部分</td><td>&nbsp;描述</td></tr><tr><td>uri&nbsp;</td><td>from table_name&nbsp;</td><td>指定查询某个应用程序下的某一张表</td></tr><tr><td>projection&nbsp;</td><td>select column1, column2</td><td>&nbsp;指定查询的列名</td></tr><tr><td>selection</td><td>&nbsp;where column = value&nbsp;</td><td>指定 where 的约束条件</td></tr><tr><td>selectionArgs</td><td>&nbsp;-&nbsp;</td><td>为 where 中的占位符提供具体的值</td></tr><tr><td>orderBy</td><td>&nbsp;order by column1, olumn2</td><td>&nbsp;指定查询结果的排序方式</td></tr></tbody></table><p><br /><br /></p><h4>遍历 Cursor</h4><p>查询得到Cursor对象，通过移动游标的位置来遍历 Cursor 的所有行，然后再取出每一行中相应列的数据</p><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">if</span> (cursor != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {        </span><span style="color: #0000ff;">while</span> (cursor.moveToNext()) {<span style="color: #008000;">//</span><span style="color: #008000;">当到型循环  </span>        String column1 = cursor.getString(cursor.getColumnIndex("column1"<span style="color: #000000;">));        </span><span style="color: #0000ff;">int</span> column2 = cursor.getInt(cursor.getColumnIndex("column2"<span style="color: #000000;">));        }    cursor.close();    }<br /></span></pre></div><p>&nbsp;</p><h1>创造ContentProvider，给别的程序提供数据</h1><h2>新建 MyProvider 继承自 ContentProvider，重写6个方法</h2><h3>UriMatcher中提供了一个 addURI()方法，1.权限、2.路径、3.自定义代码</h3><p>当调用 UriMatcher 的 match()方法时，就可以将一个 Uri 对象传入，返回值是某个能够匹配这个 Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了<br /></p><p>&gt;MIME 类型<br />content://com.example.app.provider/table1 --------------------vnd.android.cursor.dir/vnd.com.example.app.provider.table1<br />content://com.example.app.provider/table1/1-------------------vnd.android.cursor.item/vnd.com.example.app.provider.table1</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>退出所有应用，监控打开了什么活动.html</title>
    <link href="/09-Android/%E9%80%80%E5%87%BA%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8%EF%BC%8C%E7%9B%91%E6%8E%A7%E6%89%93%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%B4%BB%E5%8A%A8/"/>
    <url>/09-Android/%E9%80%80%E5%87%BA%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8%EF%BC%8C%E7%9B%91%E6%8E%A7%E6%89%93%E5%BC%80%E4%BA%86%E4%BB%80%E4%B9%88%E6%B4%BB%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2>1.新建类活动管理器类ActivityCollector&nbsp;</h2><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ActivityCollector {    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> List&lt;Activity&gt;activities = <span style="color: #0000ff;">new</span> ArrayList&lt;Activity&gt;<span style="color: #000000;">();    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> addActivity(Activity activity){        activities.add(activity);    }    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> removeActivity(Activity activity){        activities.remove(activity);    }    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> finishALl(){        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Activity activity : activities){            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">activity.isFinishing()){                activity.finish();            }        }    }}</span></pre></div><p><span class="fontstyle0">提供了一个 <span class="fontstyle2">addActivity()<span class="fontstyle0">方法用于向 <span class="fontstyle2">List <span class="fontstyle0">中添加一个活动</span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">提供了一个 <span class="fontstyle2">removeActivity()<span class="fontstyle0">方法用于从 <span class="fontstyle2">List <span class="fontstyle0">中移除活动</span></span></span></span></span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">最后提供了一个 <span class="fontstyle2">finishAll()<span class="fontstyle0">方法用于将 <span class="fontstyle2">List <span class="fontstyle0">中存储的活动全部都销毁掉 </span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2>2.新建类BaseActivity继承于Activity</h2><p>在BaseActivity中不设置界面，<strong><span style="color: #ff0000;">把其他所有类继承于BaseActivity</span></strong>，他们也会继承Activity中的所有内容；</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> BaseActivity <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Activity {    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);        Log.d(</span>"BaseActivity", getClass().getSimpleName());<span style="color: #008000;">//</span><span style="color: #008000;">监控是哪个activity启动</span>        ActivityCollector.addActivity(<span style="color: #0000ff;">this</span><span style="color: #000000;">);    }    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onDestroy() {</span><span style="color: #008000;">//活动关闭，则从activity中移除该活动</span></pre><pre><span style="color: #0000ff;">super</span><span style="color: #000000;">.onDestroy(); ActivityCollector.removeActivity(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">); } }</span></pre></div><h2>3.在你需要的时候，调用<span class="fontstyle0">ActivityCollector.finishAll(); 就能关掉所有活动啦！<br /></span></h2>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重写BaseAdapter实现ListView.html</title>
    <link href="/09-Android/%E9%87%8D%E5%86%99BaseAdapter%E5%AE%9E%E7%8E%B0ListView/"/>
    <url>/09-Android/%E9%87%8D%E5%86%99BaseAdapter%E5%AE%9E%E7%8E%B0ListView/</url>
    
    <content type="html"><![CDATA[<div class="cnblogs_code" style="border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; border-bottom: #cccccc 1px solid; padding-bottom: 5px; padding-top: 5px; padding-left: 5px; border-left: #cccccc 1px solid; padding-right: 5px; background-color: #f5f5f5"><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> BaseAdapterActivity <span style="color: #0000ff">extends</span><span style="color: #000000"> BaseActivity {    </span><span style="color: #0000ff">private</span><span style="color: #000000"> ListView base_adapter_listView;    </span><span style="color: #0000ff">private</span><span style="color: #000000"> ListViewFruit[] fruitList;    @Override    </span><span style="color: #0000ff">protected</span> <span style="color: #0000ff">void</span><span style="color: #000000"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff">super</span><span style="color: #000000">.onCreate(savedInstanceState);        setContentView(R.layout.activity_base_adapter);        base_adapter_listView </span>=<span style="color: #000000"> (ListView) findViewById(R.id.base_adapter_listView);        BaseAdapter baseAdapter </span>= <span style="color: #0000ff">new</span><span style="color: #000000"> BaseAdapter() {            </span><span style="color: #008000">//</span><span style="color: #008000">重写该方法指定数量40</span><span style="color: #000000">            @Override            </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span><span style="color: #000000"> getCount() {                </span><span style="color: #0000ff">return</span> 40<span style="color: #000000">;            }            @Override            </span><span style="color: #0000ff">public</span> Object getItem(<span style="color: #0000ff">int</span><span style="color: #000000"> position) {                </span><span style="color: #0000ff">return</span> 0<span style="color: #000000">;            }            </span><span style="color: #008000">//</span><span style="color: #008000">重写该方法获得id</span><span style="color: #000000">            @Override            </span><span style="color: #0000ff">public</span> <span style="color: #0000ff">long</span> getItemId(<span style="color: #0000ff">int</span><span style="color: #000000"> position) {                </span><span style="color: #0000ff">return</span><span style="color: #000000"> position;            }            </span><span style="color: #008000">//</span><span style="color: #008000">重写getView() 方法，这个方法在内容被加载之前会执行</span><span style="color: #000000">            @Override            </span><span style="color: #0000ff">public</span> View getView(<span style="color: #0000ff">int</span><span style="color: #000000"> position, View convertView, ViewGroup parent) {                LinearLayout.LayoutParams layoutParams </span>= <span style="color: #0000ff">new</span> LinearLayout.LayoutParams(100,100,0<span style="color: #000000">);                LinearLayout linearLayout </span>= <span style="color: #0000ff">new</span> LinearLayout(BaseAdapterActivity.<span style="color: #0000ff">this</span><span style="color: #000000">);                linearLayout.setOrientation(LinearLayout.HORIZONTAL);                ImageView imageView </span>= <span style="color: #0000ff">new</span> ImageView(BaseAdapterActivity.<span style="color: #0000ff">this</span><span style="color: #000000">);                TextView textView </span>= <span style="color: #0000ff">new</span> TextView(BaseAdapterActivity.<span style="color: #0000ff">this</span><span style="color: #000000">);                imageView.setImageResource(R.drawable.qq_icon);                textView.setText(</span>"第" + (position + 1) + "个列表"<span style="color: #000000">);                linearLayout.addView(imageView,layoutParams);                linearLayout.addView(textView);                </span><span style="color: #0000ff">return</span><span style="color: #000000"> linearLayout;            }        };        base_adapter_listView.setAdapter(baseAdapter);</span></pre></div>重写四个方法，在getView中设置布局]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-LinkedHashSet</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/02-LinkedHashSet/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/02-LinkedHashSet/</url>
    
    <content type="html"><![CDATA[<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>使用Hash表来保证不重复，使用链表来实现迭代顺序</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>04-Set</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-TreeSet</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/03-TreeSet/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/04-Set/03-TreeSet/</url>
    
    <content type="html"><![CDATA[<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet使用红黑树实现，实现了<code>NavigableSet</code>接口，<code>NavigableSet</code>接口实现<code>SortedSet</code>接口</p><h2 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序顺序</h2><table><thead><tr><th>类型</th><th>排序标准</th></tr></thead><tbody><tr><td>数字</td><td>从小到大</td></tr><tr><td>Character</td><td>Unicode从小到大</td></tr><tr><td>String</td><td>Unicode从小到大</td></tr></tbody></table><p><img src="../images/2019-05-15-23-35-43.png"></p><h2 id="自然排序-comparable接口-compareTo-T-o-方法"><a href="#自然排序-comparable接口-compareTo-T-o-方法" class="headerlink" title="自然排序-comparable接口-compareTo(T  o)方法"></a>自然排序-comparable接口-compareTo(T  o)方法</h2><ul><li>在类中实现comparable接口</li></ul><p>0 等于<br>-1 当前对象小于对象o<br>1 当前对象大于对象o</p><h2 id="定制排序-Comparator接口-compare-T-o1-T-o2"><a href="#定制排序-Comparator接口-compare-T-o1-T-o2" class="headerlink" title="定制排序-Comparator接口-compare(T o1,T o2)"></a>定制排序-Comparator接口-compare(T o1,T o2)</h2><p>原pojo可以不实现<code>comparable</code>接口，即使实现了也不会被使用</p><ul><li>使用自定的比较器类作为构造器参数</li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameLenceComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1,Person o2)</span></span>&#123;        <span class="hljs-keyword">return</span> Integer.compare(o1.name.length(),o2.name.length());    &#125;&#125;Set&lt;Person&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;Person&gt;(<span class="hljs-keyword">new</span> NameLenceComparator());</code></pre><h2 id="去重原理"><a href="#去重原理" class="headerlink" title="去重原理"></a>去重原理</h2><p>其去重原理是基于<code>compareTo()</code>方法而不是<code>HashCode()</code></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>04-Set</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Intent启动一个新的页面.html</title>
    <link href="/09-Android/Intent%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <url>/09-Android/Intent%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><h2>一，Intent（目的） 的分类</h2><ul><li><h4>显式 Intent</h4></li></ul><p>构造函数重载之一：</p><div class="cnblogs_Highlighter"><pre class="brush:java;gutter:true;">     Intent intent = new Intent(FirstActivity.this,SecondActivity.class);         //创建一个Intent 对象，第一个参数content（传入上下文），第二个参数传入目标活动。     startActivity(intent);                                                       //通过startActivity方法启动活动，传入参数（intent）    </pre></div><p>&nbsp;</p><ul><li><h4>隐形 Intent（个人理解：隐式就是不能直接看到跳转的目的地，而是叫了一声名字，名字符合的人对号入座）</h4></li></ul><p><span style="color: #ff0000;"><span style="color: #000000;">在AndroidMainfest中对action和category 进行描述，只有当intent中的action和category都匹配时才能启动活动（</span><span style="background-color: #ffffff;"><strong>category默认为DEFAULT（默认的</strong>）</span>）</span></p><div class="cnblogs_code"><pre>        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">activity </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".SecondActivity"</span><span style="color: #ff0000;">            android:label</span><span style="color: #0000ff;">="这是要启动的activity"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="com.example.cenzhongman.ACTION_START"</span><span style="color: #0000ff;">/&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">category </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.category.DEFAULT"</span><span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">activity</span><span style="color: #0000ff;">&gt;</span></pre></div><p>&nbsp;</p><p>构造函数重载之二：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">　　　　　　　public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onClick(View view) {                Toast.makeText(FirstActivity.</span><span style="color: #0000ff;">this</span>, "启动页面二"<span style="color: #000000;">, Toast.LENGTH_SHORT).show();                Intent intent </span>= <span style="color: #0000ff;">new</span> Intent("com.example.cenzhongman.ACTION_START");<span style="color: #008000;">//</span><span style="color: #008000;">直接传入action的字符串                </span><span style="color: #008000;">//</span><span style="color: #008000;">默认的category默认匹配</span><span style="color: #000000;">                startActivity(intent);            }</span></pre></div><h3>&nbsp;</h3><h3>二，关于intent 隐式的更多用法</h3><p>可以调用（其他app）如浏览器打开网页：</p><div class="cnblogs_code"><pre>button1.setOnClickListener(<span style="color: #0000ff;">new</span><span style="color: #000000;"> OnClickListener() {　　@Override　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onClick(View v) {　　　　Intent intent </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Intent(Intent.ACTION_VIEW);　　　　intent.setData(Uri.parse(</span>"http://www.baidu.com"<span style="color: #000000;">));　　　　startActivity(intent);   </span><span style="color: #008000;">//</span><span style="color: #008000;">特别注意的是，一定要启动！！！</span><span style="color: #000000;">　　}});</span></pre></div><p>&nbsp;</p><p><span class="fontstyle0"><span class="fontstyle2">　　这里我们首先指定了 <span class="fontstyle3">Intent <span class="fontstyle2">的 <span class="fontstyle3">action <span class="fontstyle2">是 <span class="fontstyle3">Intent.ACTION_VIEW<span class="fontstyle2">， 这是一个 <span class="fontstyle3">Android <span class="fontstyle2">系统内<br />置的动作，其常量值为 <span class="fontstyle3">android.intent.action.VIEW<span class="fontstyle2">。然后通过 <span class="fontstyle3">Uri.parse()<span class="fontstyle2">方法，将一个网址字<br />符串解析成一个 <span class="fontstyle3">Uri <span class="fontstyle2">对象，再调用 <span class="fontstyle3">Intent <span class="fontstyle2">的 <span class="fontstyle3">setData()<span class="fontstyle2">方法将这个 <span class="fontstyle3">Uri <span class="fontstyle2">对象传递进去。 <br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h3><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2">三，设定自己的intent接口</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h3><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2"><span class="fontstyle3"><span class="fontstyle2">在AndroidMaintest.xml中注册</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">　　　　&lt;</span><span style="color: #800000;">activity </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".ThirdActivity"</span><span style="color: #ff0000;">            android:label</span><span style="color: #0000ff;">="hehe"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.action.VIEW"</span><span style="color: #0000ff;">/&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">category </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.category.DEFAULT"</span><span style="color: #0000ff;">/&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">data </span><span style="color: #ff0000;">android:scheme</span><span style="color: #0000ff;">="http"</span><span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">activity</span><span style="color: #0000ff;">&gt;</span></pre></div><p>action.View(应该是浏览器接口，我猜是这样。。。。日后完善)<br />通过隐式Intent找到 action.VIEW 这个 action ,category 依旧是默认；</p><p>&lt;data&gt;标签指定数据协议&nbsp; http &nbsp;协议<span style="color: #339966;">。（不是http：//）</span></p><ul><li>&nbsp;来一个拨打电话的</li><li>action.DIAL&nbsp;&nbsp; 动作</li><li>tel&nbsp;&nbsp;&nbsp; 协议&nbsp; （tel:10086）</li><li><span style="color: #ff00ff; font-size: 16px;"><strong>永远别忘记启动</strong></span></li></ul><p><span style="color: #000000; font-size: 16px;"><strong>四，Intent传递参数</strong></span></p><p><span style="font-size: 12px;"><span class="fontstyle0"><span style="font-size: 13px;">Intent </span><span class="fontstyle2"><span style="font-size: 13px;">中提供了一系列 </span><span class="fontstyle0"><span style="font-size: 13px;">putExtra()</span><span class="fontstyle2"><span style="font-size: 13px;">方法的重载</span></span></span></span></span></span></p><ul><li class="fontstyle2"><span style="font-size: 12px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">参数传入</span></span></span></span></span></li></ul><p>&nbsp;</p><div class="cnblogs_code"><pre>        button2.setOnClickListener(<span style="color: #0000ff;">new</span><span style="color: #000000;"> View.OnClickListener() {            @Override            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onClick(View view) {                Intent intent </span>= <span style="color: #0000ff;">new</span> Intent("com.example.cenzhongman.ACTION_START"<span style="color: #000000;">);                String data </span>= "Hello SecondActivity"<span style="color: #000000;">;                intent.putExtra(</span>"extra_data",data);<span style="color: #008000;">//</span><span style="color: #008000;">第一个参数是键（亲测，可以随便取），string name 数据的名字，第二个参数，数据</span><span style="color: #000000;">                startActivity(intent);            }        });</span></pre></div><p><span style="font-size: 12px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span style="font-size: 13px;"><span class="fontstyle0">注意这里 <span class="fontstyle2">putExtra()<span class="fontstyle0">方法接收两个参数，第一个参数是键，用于后面从 <span class="fontstyle2">Intent<span class="fontstyle0">中取值，第二个参数才是真正要传递的数据。 <br /><br /></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><span style="font-size: 12px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span style="font-size: 13px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">参数获取</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>&nbsp;</p><div class="cnblogs_code"><pre>        Intent intent = getIntent();<span style="color: #008000;">//</span><span style="color: #008000;">获取启动Intent</span>        String data = intent.getStringExtra("extra_data");<span style="color: #008000;">//</span><span style="color: #008000;">获取数据关键字</span>        Log.d("SecondActivity", data);<span style="color: #008000;">//</span><span style="color: #008000;">打印日志</span></pre></div><h3>&nbsp;五,参数的返回</h3><h4>1.调用startActivityForResult（）方法启动activity，需要返回数据</h4><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> myOnclick(View view) {        Intent intent </span>= <span style="color: #0000ff;">new</span> Intent(FirstActivity.<span style="color: #0000ff;">this</span>,SecondActivity.<span style="color: #0000ff;">class</span><span style="color: #000000;">);        startActivityForResult(intent,</span>1<span style="color: #000000;">);    }    </span></pre></div><h4>2.点击返回按键，事件中创建Intent对象</h4><div class="cnblogs_code" style="width: 95.08%; height: 140px;"><pre><span style="color: #0000ff;">　　　　　　　public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onClick(View view) {              Intent intent </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Intent();                intent.putExtra(</span>"Data_return","Hello FirstActivity"<span style="color: #000000;">);                setResult(RESULT_OK,intent);                finish();            }</span></pre></div><p>Intent对象仅仅传递数据，不启动新的Activity</p><p><span class="fontstyle0">调用了 <span class="fontstyle2">setResult()<span class="fontstyle0">方法，用于向上一个活动返回数据的。<span class="fontstyle2">setResult()<span class="fontstyle0">方法接收两个参数 ，第一个 参数用于向上一个活动返回处理结果 ，一 般只使用 <span class="fontstyle2">RESULT_OK <span class="fontstyle0">或<br /><span class="fontstyle2">RESULT_CANCELED <span class="fontstyle0">这两个值，第二个参数则是把带有数据的 <span class="fontstyle2">Intent <span class="fontstyle0">传递回去 </span></span></span></span></span></span></span></span></span></span></span></p><h4><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><br />3.<span class="fontstyle0">Activity<span class="fontstyle1">被销毁之后会回调上一个活动的 <span class="fontstyle0">onActivityResult()<span class="fontstyle1">方法 ，重写该方法</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h4><div class="cnblogs_code"><pre><span style="color: #000000;">@Override</span><span style="color: #0000ff;">　　protected</span> <span style="color: #0000ff;">void</span> onActivityResult(<span style="color: #0000ff;">int</span> requestCode, <span style="color: #0000ff;">int</span><span style="color: #000000;"> resultCode, Intent data) {</span><span style="color: #0000ff;">　　　switch</span><span style="color: #000000;"> (requestCode) {                                                         //<span class="fontstyle0">检查 <span class="fontstyle2">equestCode<span class="fontstyle0">的值来判断数据来源 </span></span></span></span><span style="color: #0000ff;">　　　case</span> 1<span style="color: #000000;">:</span><span style="color: #0000ff;">　　　　　if</span> (resultCode ==<span style="color: #000000;"> RESULT_OK) {                                              //判断是否处理成功　　　　　　　String returnedData </span>= data.getStringExtra("data_return"<span style="color: #000000;">);　　　　　　　Log.d(</span>"FirstActivity"<span style="color: #000000;">, returnedData);　　　　}</span><span style="color: #0000ff;">　　　　break</span><span style="color: #000000;">;</span><span style="color: #0000ff;">　　default</span><span style="color: #000000;">:　　}}</span></pre></div><h4><br />4，按下返回键的情况，重写<span class="fontstyle0">onBackPressed() 方法</span></h4><div class="cnblogs_code"><pre><span style="color: #000000;">@Override</span><span style="color: #0000ff;">　　public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onBackPressed() {　　　　Intent intent </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Intent();　　　　intent.putExtra(</span>"data_return", "Hello FirstActivity"<span style="color: #000000;">);　　　　setResult(RESULT_OK, intent);　　　　finish();}</span></pre></div><p>&nbsp;</p><h2>自行销毁一个活动</h2><p>杀死一个人只需要一句话，销毁活动也一样：</p><div class="cnblogs_code"><pre>finish();</pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQLite学习和使用.html</title>
    <link href="/09-Android/SQLite%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/09-Android/SQLite%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>创建数据库并创建表格</h1><h4>1.创建MyDatabaseHelper继承于SQLiteOpenHelper(抽象类，必须实现onCreate()和onUpgrade()方法)<br />2.把数据库建表指令弄成一个字符串CREATE_BOOK常量，并在onCreate()函数中执行建表</h4><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyDatabaseHelper <span style="color: #0000ff;">extends</span><span style="color: #000000;"> SQLiteOpenHelper {    </span><span style="color: #008000;">//</span><span style="color: #008000;">把数据库建表指令弄成一个字符串CREATE_BOOK常量</span>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CREATE_BOOK = "create table book ("            + "id integer primary key autoincrement, "            + "author text, "            + "price real, "            + "pages integer, "            + "name text)"<span style="color: #000000;">;    </span><span style="color: #0000ff;">public</span> MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, <span style="color: #0000ff;">int</span><span style="color: #000000;"> version) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context,name,factory,version);    }    @Override    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);</span><span style="color: #008000;">//</span><span style="color: #008000;">执行建表</span>        Log.d(TAG,"数据库初始化完成"<span style="color: #000000;">);    }    @Override    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onUpgrade(SQLiteDatabase db, <span style="color: #0000ff;">int</span> oldVersion, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newVersion) {    }    }</span></pre></div><h4>3.在MianActivity()中新建数据库</h4><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">private</span> MyDatabaseHelper dbHelper = <span style="color: #0000ff;">new</span> MyDatabaseHelper(<span style="color: #0000ff;">this</span>, "BookStore.db", <span style="color: #0000ff;">null</span>, 1<span style="color: #000000;">);    </span><span style="color: #008000;">//</span><span style="color: #008000;">新建一个MyDatabaseHelper对象，上下文；数据库名；第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null；数据库版本号</span>    dbHelper.getWritableDatabase();</pre></div><p>&nbsp;</p><h3>升级数据库方法1（覆盖式）</h3><h4>需 求：增加一个新的表格，Category</h4><p>　　由于数据库BookStore.db已经存在，onCreate()方法不会再次执行，直接在onCreate()方法中，添加table不能被更新。</p><h4>解决方案：使用onUpgrade()方法更新数据库</h4><p>添加表格常量；在onCreate()方法中建表；在upGreate()方法中删去存在表格，并重新执行onCreate()方法；在引用数据库时更改数据库版本号</p><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyDatabaseHelper <span style="color: #0000ff;">extends</span><span style="color: #000000;"> SQLiteOpenHelper {        </span><span style="color: #008000;">//</span><span style="color: #008000;">把数据库建表指令弄成一个字符串CREATE_BOOK常量</span>        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CREATE_BOOK = "create table book ("                + "id integer primary key autoincrement, "                + "author text, "                + "price real, "                + "pages integer, "                + "name text)"<span style="color: #000000;">;        </span><span style="color: #008000;">//</span><span style="color: #008000;">integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。另外，上述建表语句中我们还        </span><span style="color: #008000;">//</span><span style="color: #008000;">使用了 primary key 将 id 列设为主键，并用 autoincrement 关键字表示 id 列是自增长的</span>        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String CREATE_CATEGORY = "create table category("                + "id integer primary key autoincrement, "                + "category_name text, "                + "category_code integer)"<span style="color: #000000;">;        </span><span style="color: #0000ff;">public</span> MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, <span style="color: #0000ff;">int</span><span style="color: #000000;"> version) {            </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context,name,factory,version);        }        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(SQLiteDatabase db) {            db.execSQL(CREATE_BOOK);</span><span style="color: #008000;">//</span><span style="color: #008000;">执行建表</span><span style="color: #000000;">            db.execSQL(CREATE_CATEGORY);            Log.d(TAG,</span>"数据库初始化完成"<span style="color: #000000;">);        }        </span><span style="color: #008000;">//</span><span style="color: #008000;">当检测到数据库版本变化，就会执行onUpgrade()中的代码</span><span style="color: #000000;">        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onUpgrade(SQLiteDatabase db, <span style="color: #0000ff;">int</span> oldVersion, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newVersion) {            </span><span style="color: #008000;">//</span><span style="color: #008000;">调用SQL语句，若存在表格则删去，之后在重新调用onCreate()方法</span>            db.execSQL("drop table if exists Book"<span style="color: #000000;">);            db.execSQL(</span>"drop table if exists Category"<span style="color: #000000;">);            onCreate(db);        }    }</span></pre></div><h3>升级数据库方法2（追加式）</h3><h4>需 求：根据所需变更数据库，增加一个新的表格，Category</h4><p>　　由于覆盖式更新数据库的方法会重置数据库，导致用户数据丢失，不能在产品中使用</p><h4><br />解决方案：为每一个版本号赋予它各自改变的内容，然后在onUpgrade()方法中对当前数据库的版本号进行判断，再执行相应的改变就可以了</h4><div class="cnblogs_code"><pre><span style="color: #000000;">    @Override    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onUpgrade(SQLiteDatabase db, <span style="color: #0000ff;">int</span> oldVersion, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newVersion) {        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用SQL语句，若存在表格则删去，之后在重新调用onCreate()方法</span>        <span style="color: #008000;">/**</span><span style="color: #008000;">         * 注释时间：20170117         * 代码作用：覆盖式更新数据库，删除之前的数据库再新建库         * 注释原因：学习新的数据库更新方法        db.execSQL("drop table if exists Book");        db.execSQL("drop table if exists Category");        onCreate(db);         </span><span style="color: #008000;">*/</span>        <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (newVersion)        {            </span><span style="color: #0000ff;">case</span> 2<span style="color: #000000;">:db.execSQL(CREATE_CATEGORY);                </span><span style="color: #008000;">//</span><span style="color: #008000;">！！！注意，无break；</span>            <span style="color: #0000ff;">case</span> 3:db.execSQL("alter table Book add column category_id integer"<span style="color: #000000;">);                </span><span style="color: #008000;">//</span><span style="color: #008000;">！！！注意，无break；                </span><span style="color: #008000;">//</span><span style="color: #008000;">因为无论覆盖哪一个版本安装，都需要安装其他更新，从第二版安装第三版时，只需要更新case3,确保数据库最新</span>                Log.d(TAG,"第3版数据库更新成功"<span style="color: #000000;">);                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;            </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:                Log.d(TAG,</span>"数据库更新失败"<span style="color: #000000;">);                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;        }    }</span></pre></div><p>&nbsp;</p><h2>增删改查操作(SQL语句操作)</h2><p>对数据进行的操作也就无非四种，即CRUD。其中 C 代表添加（Create） ，R 代表查询（Retrieve） ，U 代表更新（Update） ，D 代表删除（Delete）</p><div class="cnblogs_code"><pre>SQLiteDatabase db =<span style="color: #000000;"> dbBookStoreHelper.getWritableDatabase();    </span><span style="color: #008000;">//</span><span style="color: #008000;">新建两个数据</span>    db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)",<span style="color: #0000ff;">new</span> String[] { "The Da Vinci Code", "Dan Brown", "454", "16.96"<span style="color: #000000;"> });    db.execSQL(</span>"insert into Book (name, author, pages, price) values(?, ?, ?, ?)",<span style="color: #0000ff;">new</span> String[] { "The Lost Symbol", "Dan Brown", "510", "19.95"<span style="color: #000000;"> });     </span><span style="color: #008000;">//</span><span style="color: #008000;">查询所有数据</span>    db.rawQuery("select * from Book", <span style="color: #0000ff;">null</span><span style="color: #000000;">);       </span><span style="color: #008000;">//</span><span style="color: #008000;">把《The Da Vinci Code》这本书改成10.99</span>    db.execSQL("update Book set price = ? where name = ?", <span style="color: #0000ff;">new</span> String[] { "10.99","The Da Vinci Code"<span style="color: #000000;"> });      </span><span style="color: #008000;">//</span><span style="color: #008000;">把500页以上的书删了</span>    db.execSQL("delete from Book where pages &gt; ?", <span style="color: #0000ff;">new</span> String[] { "500" });</pre></div><h2><span style="line-height: 1.5;">增删改查操作(Android语法操作)</span></h2><ul><li><h3>增加数据</h3></li></ul><p>insert()方法，1.表名；2.未指定添加数据的情况下给某些可为空的列自动赋值 NULL；3.ContentValues 对象，它提供了一系列的 put()方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可<br /></p><div class="cnblogs_code"><pre><span style="color: #008000;">//</span><span style="color: #008000;">！！！先组装数据，再插入数据</span>SQLiteDatabase db =<span style="color: #000000;"> dbHelper.getWritableDatabase();ContentValues values </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ContentValues();</span><span style="color: #008000;">//</span><span style="color: #008000;"> 开始组装第一条数据</span>values.put("name", "The Da Vinci Code"<span style="color: #000000;">);values.put(</span>"author", "Dan Brown"<span style="color: #000000;">);values.put(</span>"pages", 454<span style="color: #000000;">);values.put(</span>"price", 16.96<span style="color: #000000;">);db.insert(</span>"Book", <span style="color: #0000ff;">null</span>, values); <span style="color: #008000;">//</span><span style="color: #008000;"> 插入第一条数据</span><span style="color: #000000;">values.clear();</span><span style="color: #008000;">//</span><span style="color: #008000;"> 开始组装第二条数据</span>values.put("name", "The Lost Symbol"<span style="color: #000000;">);values.put(</span>"author", "Dan Brown"<span style="color: #000000;">);values.put(</span>"pages", 510<span style="color: #000000;">);values.put(</span>"price", 19.95<span style="color: #000000;">);db.insert(</span>"Book", <span style="color: #0000ff;">null</span>, values); <span style="color: #008000;">//</span><span style="color: #008000;"> 插入第二条数据</span></pre></div><ul><li><h3>更改数据</h3></li></ul><p>update()方法，1.表名；2.ContentValues 对象，要把更新数据在这里组装进去;第三、第四个参数用于去约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行</p><div class="cnblogs_code"><pre>SQLiteDatabase db =<span style="color: #000000;"> dbHelper.getWritableDatabase();ContentValues values </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ContentValues();values.put(</span>"price", 10.99<span style="color: #000000;">);db.update(</span>"Book", values, "name = ?", <span style="color: #0000ff;">new</span> String[] { "The DaVinci Code"<span style="color: #000000;"> });values.clean();</span></pre></div><ul><li><h3><span style="line-height: 1.5;">删除数据</span></h3></li></ul><p><span style="line-height: 1.5;">delete()方法，1.表名；第二、第三个参数用于去约束删除某一行或某几行的数据，不指定的话默认就是删除所有行</span></p><div class="cnblogs_code"><pre>db.delete("Book","pages &gt; ?",<span style="color: #0000ff;">new</span> String[] {"300"});</pre></div><ul><li><h3><span style="line-height: 1.5;">查询数据</span></h3></li></ul><p><span style="line-height: 1.5;">query()方法，1.表名；2.指定去查询哪几列，如果不指定则默认查询所有列；3.第三、第四个参数用于去约束查询某一行或某几行的数据，不指定则默认是查询所有行的数据；5.指定需要去 group by 的列，不指定则表示不对查询结果进行 group by 操作；6. group by 之后的数据进行进一步的过滤，不指定则表示不进行过滤；7，指定查询结果的排序方式，不指定则表示使用默认的排序方式。</span></p><p style="margin-left: 30px;">&nbsp;</p><table style="height: 178px; width: 531px;" border="0"><tbody><tr><td>query()方法参数</td><td>对应 SQL 部分</td><td>&nbsp; 描述</td></tr><tr><td>table</td><td>&nbsp;<span class="Apple-tab-span">from table_name</span></td><td><span class="Apple-tab-span">&nbsp;<span class="Apple-tab-span">指定查询的表名</span></span></td></tr><tr><td>columns</td><td>&nbsp;select column1, column2&nbsp;</td><td>指定查询的列名</td></tr><tr><td>selection</td><td>&nbsp;where column = value</td><td>&nbsp;指定 where 的约束条件</td></tr><tr><td>selectionArgs</td><td>&nbsp;-</td><td>&nbsp;为 where 中的占位符提供具体的值</td></tr><tr><td>groupBy</td><td>&nbsp;group by column&nbsp;</td><td>指定需要 group by 的列</td></tr><tr><td>having</td><td>&nbsp;having column = value</td><td>&nbsp;对 group by 后的结果进一步约束</td></tr><tr><td>orderBy</td><td>&nbsp;order by column1, column2&nbsp;</td><td>指定查询结果的排序方式</td></tr></tbody></table><p style="margin-left: 30px;">&nbsp;</p><p style="margin-left: 30px;">&nbsp;</p><div class="cnblogs_code"><pre>Cursor cursor = db.query("Book",<span style="color: #0000ff;">null</span>,"1",<span style="color: #0000ff;">null</span>,<span style="color: #0000ff;">null</span>,<span style="color: #0000ff;">null</span>,<span style="color: #0000ff;">null</span><span style="color: #000000;">);    </span><span style="color: #0000ff;">if</span> (cursor != <span style="color: #0000ff;">null</span><span style="color: #000000;">)    {        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(cursor.moveToFirst())        {            </span><span style="color: #0000ff;">do</span> {<span style="color: #008000;">//</span><span style="color: #008000;">直到型循环</span>                String name = cursor.getString(cursor.getColumnIndex("name"<span style="color: #000000;">));                String author </span>= cursor.getString(cursor.getColumnIndex("author"<span style="color: #000000;">));                Double price </span>= cursor.getDouble(cursor.getColumnIndex("price"<span style="color: #000000;">));                </span><span style="color: #0000ff;">int</span> pages = cursor.getInt(cursor.getColumnIndex("pages"<span style="color: #000000;">));                Log.d(TAG,</span>"name = " +<span style="color: #000000;"> name);                Log.d(TAG,</span>"author = " +<span style="color: #000000;"> author);                Log.d(TAG,</span>"price = " +<span style="color: #000000;"> price);                Log.d(TAG,</span>"pages = " +<span style="color: #000000;"> pages);            }</span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cursor.moveToNext());        }    }    cursor.close();</span></pre></div><h2>&nbsp;</h2><h2>使用事务Transaction</h2><p>事情要有始有终，就像转账，钱没到达对方账户就会退回原始账户</p><h3><br />需    求：删除旧的数据库，更换新的数据库</h3><h3>解决方案：使用beginTransaction，setTransactionSuccessful，endTransaction三个来监控事务的执行，一旦执行失败，返回原始的数据库</h3><div class="cnblogs_code"><pre>    db.beginTransaction();<span style="color: #008000;">//</span><span style="color: #008000;">开始事务</span>    <span style="color: #0000ff;">try</span><span style="color: #000000;"> {        db.delete(</span>"Book", <span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 在这里手动抛出一个异常，让事务失败</span>            <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> NullPointerException();        }        db.execSQL(</span>"insert into Book (name, author, pages, price) values(?, ?, ?, ?)"<span style="color: #000000;">,                </span><span style="color: #0000ff;">new</span> String[]{"马克思主义2", "中国**党", "1000", "100.00"<span style="color: #000000;">});//居然和谐        db.setTransactionSuccessful(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 事务已经执行成功</span>    } <span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception e) {        e.printStackTrace();    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {        db.endTransaction(); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 结束事务</span>    }</pre></div><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前台服务.html</title>
    <link href="/09-Android/%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1/"/>
    <url>/09-Android/%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1>转载来自<a href="http://www.jianshu.com/p/5505390503fa#" target="_blank">http://www.jianshu.com/p/5505390503fa#</a></h1><h1>作者:<a class="title" href="http://www.jianshu.com/u/873e0f534bae">紫豪</a></h1><h1>1.什么是前台服务</h1><p>　　前台服务是那些被认为用户知道（用户认可所认可）且在系统内存不足的时候不允许系统杀死的服务。前台服务必须给状态栏提供一个通知，它被放到正在运行(Ongoing)标题之下&mdash;&mdash;这就意味着通知只有在这个服务被终止或从前台主动移除通知后才能被解除。<br />官方描述：<br /><code>A foreground service（前台服务） is a service that's considered to be（被用户所认可的） something the user is actively aware of and thus not a candidate for（而不是一个候选的，可以在内存不足时，被系统杀死的） the system to kill when low on memory. A foreground service must provide a notification for the status bar（前台服务必须提供一个显示通知）, which is placed under the "Ongoing" heading（它是不可以忽略的）, which means that the notification cannot be dismissed unless the service is either stopped or removed from the foreground.（意思是通知信息不能被忽略，除非服务停止或主动移除，否则将一直显示。）</code></p><hr /><h1>2.为什么要使用前台服务</h1><p>　　在一般情况下，Service几乎都是在后台运行，一直默默地作者辛苦的工作。但这种情况下，后台运行的Service系统优先级相对较低，当系统内存不足时，在后台运行的Service就有可能被回收。<br />　　那么，如果我们希望Service可以一直保持运行状态且不会在内存不足的情况下被回收时，可以选择将需要保持运行的Service设置为前台服务。</p><blockquote><p>例：<br />App中的音乐播放服务应被设置在前台运行(前台服务)&mdash;&mdash;在App后台运行时，便于用户明确知道它的当前操作、在状态栏中指明当前歌曲信息、提供对应操作。</p></blockquote><hr /><h1>3.如何创建一个前台服务</h1><ul><li>新建一个服务<pre class="hljs java"><code class="java"><span class="hljs-keyword">public <span class="hljs-class"><span class="hljs-keyword">class <span class="hljs-title">MusicPlayerService <span class="hljs-keyword">extends <span class="hljs-title">Service &#123;　　　　<span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-keyword">final String TAG = MusicPlayerService.class.getSimpleName();　　　　<span class="hljs-meta">@Override　　<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">void <span class="hljs-title">onCreate<span class="hljs-params">() &#123;　　  <span class="hljs-keyword">super.onCreate();  　　Log.d(TAG, <span class="hljs-string">"onCreate()");　　&#125;　　　　<span class="hljs-meta">@Override　　<span class="hljs-function"><span class="hljs-keyword">public <span class="hljs-keyword">int <span class="hljs-title">onStartCommand<span class="hljs-params">(Intent intent, <span class="hljs-keyword">int flags, <span class="hljs-keyword">int startId) &#123;　　　　Log.d(TAG, <span class="hljs-string">"onStartCommand()");　　&#125;　　　　<span class="hljs-meta">@Override　　<span class="hljs-function"><span class="hljs-keyword">public IBinder <span class="hljs-title">onBind<span class="hljs-params">(Intent intent) &#123;  　　　Log.d(TAG, <span class="hljs-string">"onBind()");  　　　<span class="hljs-comment">// <span class="hljs-doctag">TODO: Return the communication channel to the service.　　　　<span class="hljs-keyword">throw <span class="hljs-keyword">new UnsupportedOperationException(<span class="hljs-string">"Not yet implemented");　　&#125;｝</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li><li>构建通知消息<br />在Service的onStartCommand中添加如下代码构建Notification：<pre class="hljs cpp"><code class="cpp">@<span class="hljs-function">Override<span class="hljs-keyword">public <span class="hljs-keyword">int <span class="hljs-title">onStartCommand<span class="hljs-params">(Intent intent, <span class="hljs-keyword">int flags, <span class="hljs-keyword">int startId) &#123;　　Log.d(TAG, <span class="hljs-string">"onStartCommand()");　　<span class="hljs-comment">// 在API11之后构建Notification的方式　　Notification.Builder builder = <span class="hljs-keyword">new Notification.Builder　　　　(<span class="hljs-keyword">this.getApplicationContext()); <span class="hljs-comment">//获取一个Notification构造器　　Intent nfIntent = <span class="hljs-keyword">new Intent(<span class="hljs-keyword">this, MainActivity.<span class="hljs-keyword">class);　　　　builder.setContentIntent(PendingIntent.　　　　getActivity(<span class="hljs-keyword">this, <span class="hljs-number">0, nfIntent, <span class="hljs-number">0)) <span class="hljs-comment">// 设置PendingIntent　　　　.setLargeIcon(BitmapFactory.decodeResource(<span class="hljs-keyword">this.getResources(),　　　　　　R.mipmap.ic_large)) <span class="hljs-comment">// 设置下拉列表中的图标(大图标)　　　　.setContentTitle(<span class="hljs-string">"下拉列表中的Title") <span class="hljs-comment">// 设置下拉列表里的标题　　　　.setSmallIcon(R.mipmap.ic_launcher) <span class="hljs-comment">// 设置状态栏内的小图标　　　　.setContentText(<span class="hljs-string">"要显示的内容") <span class="hljs-comment">// 设置上下文内容　　　　.setWhen(System.currentTimeMillis()); <span class="hljs-comment">// 设置该通知发生的时间　　　　Notification notification = builder.build(); <span class="hljs-comment">// 获取构建好的Notification　　notification.defaults = Notification.DEFAULT_SOUND; <span class="hljs-comment">//设置为默认的声音&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><blockquote><p>其它Notification构建方式：<br />Notification(int icon, CharSequence tickerText, long when)<br />　　<em>This constructor was deprecated in API level 11. Use Notification.Builder instead.</em></p><pre class="hljs gauss"><code class="gauss"><span class="hljs-comment">// 已过时--在API11之后就被淘汰了,之后需要调用Notification.Builder()来构建Notification.Notification notification = <span class="hljs-keyword">new Notification(R.mipmap.ic_launcher,<span class="hljs-string">"前台服务测试",<span class="hljs-keyword">System.currentTimeMillis());</span></span></span></span></code></pre><p>getNotification()<br />　　<em>This method was deprecated in API level 16. Use build() instead.</em></p><pre class="hljs pony"><code class="pony"><span class="hljs-comment">// 在API16之后，可以使用build()来进行Notification的构建 Notificationnotification = <span class="hljs-function"><span class="hljs-keyword">new <span class="hljs-title">Notification.<span class="hljs-title">Builder(this.getApplicationContext())　　.<span class="hljs-title">setContentText("这是一个前台服务")　　.<span class="hljs-title">setSmallIcon(<span class="hljs-type">R.mipmap.ic_launcher)　　.<span class="hljs-title">setWhen(<span class="hljs-type">System.currentTimeMillis())　　.<span class="hljs-title">build();</span></span></span></span></span></span></span></span></span></span></span></code></pre></blockquote></li><li>启动前台服务<br />在完成Notification通知消息的构建后，在Service的onStartCommand中可以使用startForeground方法来让Android服务运行在前台。<pre class="hljs less"><code class="less"><span class="hljs-comment">// 参数一：唯一的通知标识；参数二：通知消息。<span class="hljs-selector-tag">startForeground(<span class="hljs-number">110, notification);<span class="hljs-comment">// 开始前台服务</span></span></span></span></code></pre><blockquote><p>注：当使用的通知ID一致时，只会更新当前Notification。</p></blockquote></li><li>停止前台服务<br />在Service的onDestory中使用stopForeground方法来停止正在运行的前台服务。<pre class="hljs aspectj"><code class="aspectj"><span class="hljs-meta">@Override<span class="hljs-keyword">public <span class="hljs-function"><span class="hljs-keyword">void <span class="hljs-title">onDestroy<span class="hljs-params">() &#123;　　Log.d(TAG, <span class="hljs-string">"onDestroy()");　　stopForeground(<span class="hljs-keyword">true);<span class="hljs-comment">// 停止前台服务--参数：表示是否移除之前的通知　　<span class="hljs-keyword">super.onDestroy();&#125;</span></span></span></span></span></span></span></span></span></span></code></pre></li></ul><hr /><h1>4.自定义Notification布局并设置点击事件</h1><ul><li><p>自定义Notification布局<br />　有时候我们需要个性化前台服务的通知内容，那么我么就需要通过自定义Notification布局的方式来达到想要的效果：</p><pre class="hljs pony"><code class="pony"><span class="hljs-type">RemoteViews remoteViews = <span class="hljs-function"><span class="hljs-keyword">new <span class="hljs-title">RemoteViews(this.getPackageName(),　　<span class="hljs-title">R.<span class="hljs-title">layout.<span class="hljs-title">notification_layout);<span class="hljs-comment">// 获取remoteViews（参数一：包名；参数二：布局资源）<span class="hljs-title">builder = <span class="hljs-title">new <span class="hljs-title">Notification.<span class="hljs-title">Builder(this.getApplicationContext())　　　　　　.<span class="hljs-title">setContent(remoteViews);<span class="hljs-comment">// 设置自定义的Notification内容<span class="hljs-title">builder.<span class="hljs-title">setWhen(<span class="hljs-type">System.currentTimeMillis())　　　　.<span class="hljs-title">setSmallIcon(<span class="hljs-type">R.mipmap.ic_launcher);　　<span class="hljs-title">Notification <span class="hljs-title">notification = <span class="hljs-title">builder.<span class="hljs-title">getNotification();<span class="hljs-comment">// 获取构建好的通知--.build()最低要求在　　　　　　　　　　　　　　　　　　<span class="hljs-comment">// API16及以上版本上使用，低版本上可以使用.getNotification()。<span class="hljs-title">Notificationnotification.<span class="hljs-title">defaults = <span class="hljs-title">Notification.<span class="hljs-title">DEFAULT_SOUND;<span class="hljs-comment">//设置为默认的声音　　<span class="hljs-title">startForeground(<span class="hljs-number">110, notification);<span class="hljs-comment">// 开始前台服务</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><div class="image-package"><img src="http://upload-images.jianshu.io/upload_images/625706-3306f878e3677374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" data-original-src="http://upload-images.jianshu.io/upload_images/625706-3306f878e3677374.png?imageMogr2/auto-orient/strip%7CimageView2/2" /><br /><div class="image-caption">自定义效果.png</div></div></li><li><p>为自定义通知内容上的控件绑定点击事件<br />　　在通知(Notification)中为自定义布局上的控件绑定点击事件监听，我们需要通广播的形式来实现效果。</p><ul><li>注册广播<pre class="hljs processing"><code class="processing"><span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-keyword">final <span class="hljs-built_in">int REQUEST_CODE = <span class="hljs-number">100;<span class="hljs-keyword">private <span class="hljs-keyword">static <span class="hljs-keyword">final <span class="hljs-keyword">String ACTION_PLAY = <span class="hljs-string">"play";　　Intent intentPlay = <span class="hljs-keyword">new Intent(ACTION_PLAY);<span class="hljs-comment">// 指定操作意图--设置对应的行为ACTIONPendingIntent pIntentPlay = PendingIntent.getBroadcast(<span class="hljs-keyword">this.getApplicationContext(),REQUEST_CODE, intentPlay, PendingIntent.FLAG_UPDATE_CURRENT);<span class="hljs-comment">// 取的一个PendingIntent，　　　　　　　　　　　　　　　　　　　　　　<span class="hljs-comment">// 它会发送一个广播，如同Context.sendBroadcast.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li><li>绑定点击事件<pre class="hljs less"><code class="less"><span class="hljs-selector-tag">remoteViews<span class="hljs-selector-class">.setOnClickPendingIntent(R.id.iv_pause, pIntentPlay);<span class="hljs-comment">// 绑定点击事件（参数一：　　<span class="hljs-comment">// 控件id；参数二：对应触发的PendingIntent）</span></span></span></span></code></pre></li></ul></li><li>注册广播监听器，监听对应广播<ul><li>动态注册<ul><li>在Service的onCreate中添加如下代码注册广播监听：<pre class="hljs pony"><code class="pony"><span class="hljs-comment">// 动态注册广播@<span class="hljs-type">Overridepublic void onCreate() &#123;　　super.onCreate();　　<span class="hljs-type">Log.d(<span class="hljs-type">TAG, <span class="hljs-string">"onCreate()");　　　　playerReceiver = <span class="hljs-function"><span class="hljs-keyword">new <span class="hljs-title">PlayerReceiver();　　<span class="hljs-title">IntentFilter <span class="hljs-title">mFilter = <span class="hljs-title">new <span class="hljs-title">IntentFilter();　　　　<span class="hljs-title">mFilter.<span class="hljs-title">addAction(<span class="hljs-type">ACTION_PLAY);　　<span class="hljs-title">mFilter.<span class="hljs-title">addAction(<span class="hljs-type">ACTION_PAUSE);　　<span class="hljs-title">mFilter.<span class="hljs-title">addAction(<span class="hljs-type">ACTION_LAST);　　<span class="hljs-title">mFilter.<span class="hljs-title">addAction(<span class="hljs-type">ACTION_NEXT);　　　　<span class="hljs-title">registerReceiver(playerReceiver, mFilter);&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li><li>在Service销毁时(OnDestory中)解除广播注册：<pre class="hljs aspectj"><code class="aspectj"><span class="hljs-meta">@Override<span class="hljs-keyword">public <span class="hljs-function"><span class="hljs-keyword">void <span class="hljs-title">onDestroy<span class="hljs-params">() &#123;　　Log.d(TAG, <span class="hljs-string">"onDestroy()");　　　　stopForeground(<span class="hljs-keyword">true);<span class="hljs-comment">// 停止前台服务　　<span class="hljs-keyword">if (playerReceiver != <span class="hljs-keyword">null)　　　　unregisterReceiver(playerReceiver);<span class="hljs-comment">// 解除广播注册　　<span class="hljs-keyword">super.onDestroy();&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li></ul></li><li>静态注册<br />在AndroidManifest.xml的receiver标签内添加需要过滤的内容，如：<pre class="hljs sqf"><code class="sqf">&lt;receiver　android:<span class="hljs-built_in">name=<span class="hljs-string">".PlayerReceiver"　android:exported=<span class="hljs-string">"true"&gt;　&lt;intent-filter&gt;　　&lt;<span class="hljs-built_in">action android:<span class="hljs-built_in">name=<span class="hljs-string">"play"/&gt;　　&lt;<span class="hljs-built_in">action android:<span class="hljs-built_in">name=<span class="hljs-string">"pause"/&gt;　　&lt;<span class="hljs-built_in">action android:<span class="hljs-built_in">name=<span class="hljs-string">"last"/&gt;　　&lt;<span class="hljs-built_in">action android:<span class="hljs-built_in">name=<span class="hljs-string">"next"/&gt;　&lt;/intent-filter&gt;&lt;/receiver&gt;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li><li>BroadcastReceiver代码如下：<pre class="hljs scala"><code class="scala">public <span class="hljs-class"><span class="hljs-keyword">class <span class="hljs-title">PlayerReceiver <span class="hljs-keyword">extends <span class="hljs-title">BroadcastReceiver &#123;　　　　<span class="hljs-keyword">private static <span class="hljs-keyword">final <span class="hljs-type">String <span class="hljs-type">TAG = <span class="hljs-type">PlayerReceiver.<span class="hljs-keyword">class.getSimpleName();　　　　public <span class="hljs-type">PlayerReceiver() &#123;　　&#125;　　　　<span class="hljs-meta">@Override　　public void onReceive(<span class="hljs-type">Context context, <span class="hljs-type">Intent intent) &#123;　　　　<span class="hljs-comment">// <span class="hljs-doctag">TODO: This method is called when the BroadcastReceiver is receiving　　　　<span class="hljs-type">String action = intent.getAction();<span class="hljs-comment">// 获取对应Action　　　　<span class="hljs-type">Log.d(<span class="hljs-type">TAG,<span class="hljs-string">"action:"+action);　　　　　　<span class="hljs-keyword">if(action.equals(<span class="hljs-type">MusicPlayerService.<span class="hljs-type">ACTION_PLAY))&#123;　　　　　　<span class="hljs-comment">// 进行对应操作　　　　&#125; <span class="hljs-keyword">else <span class="hljs-keyword">if(action.equals(<span class="hljs-type">MusicPlayerService.<span class="hljs-type">ACTION_PAUSE))&#123;　　　　&#125; <span class="hljs-keyword">else <span class="hljs-keyword">if(action.equals(<span class="hljs-type">MusicPlayerService.<span class="hljs-type">ACTION_LAST))&#123;　　　　&#125; <span class="hljs-keyword">else <span class="hljs-keyword">if(action.equals(<span class="hljs-type">MusicPlayerService.<span class="hljs-type">ACTION_NEXT))&#123;　　　　&#125; 　　　　&#125;&#125;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></li></ul></li></ul><div class="image-package"><img src="http://upload-images.jianshu.io/upload_images/625706-d88d54a11b604a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" data-original-src="http://upload-images.jianshu.io/upload_images/625706-d88d54a11b604a53.png?imageMogr2/auto-orient/strip%7CimageView2/2" /><br /><div class="image-caption">点击后监听到的动作.png</div></div><blockquote><p>1.建立对应的Intent(意图)--即指定对应操作的行为Action；<br />2.PendingIntent来处理意图，(Pending译为&ldquo;待定的&rdquo;、&ldquo;延迟&rdquo;，PendingIntent类提供了一种创建可由其它应用程序在稍晚时间触发的Intent的机制--推荐阅读<br /><a href="http://blog.sina.com.cn/s/blog_5f30147a0101m888.html" target="_blank">解析Android延迟消息（PendingIntent）处理&nbsp;</a>；<br />3.通过RemoteViews.setOnClickPendingIntent(int viewId，PendingIntent pendingIntent)方法来为指定的控件绑定对应的意图；<br />4.在Service中注册广播，监听对应操作。</p></blockquote><hr /><h1>5.修改自定义通知(Notification)上的显示内容</h1><p>　　在自定义通知布局后，我们在有些场景下需要修改一些控件的显示内容(如修改<code>TextView</code>显示文字、<code>ImageView</code>图片、<code>ProgressBar</code>进度等)，那么我们可以通过如<code>Notification.contentView</code>的<code>setTextViewText、setImageViewBitmap、setProgressBar</code>等方法打成效果，示例代码如下：</p><pre class="hljs css"><code class="css"><span class="hljs-selector-tag">notification<span class="hljs-selector-class">.contentView<span class="hljs-selector-class">.setTextViewText(<span class="hljs-selector-tag">R<span class="hljs-selector-class">.id<span class="hljs-selector-class">.title_tv, "标题");</span></span></span></span></span></span></code></pre><blockquote><p>注：方法的差异不大，都需要传递控件的id，需要设置的内容、属性等参数。</p></blockquote><hr /><h1>6.前台服务与普通服务的区别</h1><ul><li>前台Service的系统优先级更高、不易被回收；</li><li>前台Service会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>广播接收者Receiver.html</title>
    <link href="/09-Android/%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85Receiver/"/>
    <url>/09-Android/%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85Receiver/</url>
    
    <content type="html"><![CDATA[<h2>一，动态创建网络状态监控</h2><h2>思路：</h2><h4>1：需要注册一个广播接收者，registerReceiver（）需要两个参数</h4><div class="cnblogs_code"><pre>    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Intent registerReceiver(        BroadcastReceiver receiver, IntentFilter filter) {//接收者，过滤器（需要接收的内容）        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mBase.registerReceiver(receiver, filter);    }</span></pre></div><h4>2：参数一，接收者。新建一个NetworkChanceReceiver内部类，继承于BroadcastReceiver，并重写执行方法onReceive（）{方法体中就是接收后要做的事情}；</h4><h4>3.参数二，目的过滤器。创建过滤器实例，并addAction("要监听的广播信息")；</h4><h4>4：动态注册的广播接收器需要手动取消。onDestroy()方法中的unregisterReceiver(传入取消的过滤器)方法；</h4><p><span style="line-height: 1.5;">&nbsp;</span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> broadcastReceiverDemo <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Activity {    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> IntentFilter intentFilter;    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> NetworkChanceReceiver networkChangeReceiver;    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);        setContentView(R.layout.broadcase_recever_layout);        intentFilter </span>=<span style="color: #0000ff;">new</span> IntentFilter();<span style="color: #008000;">//</span><span style="color: #008000;">创建intentFilter（目的过滤器）实例</span>        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");<span style="color: #008000;">//</span><span style="color: #008000;">添加系统广播的网络变化的值</span>        networkChangeReceiver = <span style="color: #0000ff;">new</span> NetworkChanceReceiver();<span style="color: #008000;">//</span><span style="color: #008000;">创建NetworkChanceReceiver实例</span>        registerReceiver(networkChangeReceiver,intentFilter);<span style="color: #008000;">//</span><span style="color: #008000;">调用registerReceiver()方法进行注册，将NetworkChangeReceiver的实例        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 和 IntentFilter 的实例都传了进去，这样NetworkChangeReceiver就会收到所有值为android.net.conn.CONNECTIVITY_CHANGE的广播              播</span><span style="color: #000000;">    }    @Override    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onDestroy() {<span style="color: #008000;">//</span><span style="color: #008000;">动态注册的广播接收器一定都要取消注册才行，在onDestroy()方法中通过调用unregisterReceiver()方法来实现的</span>        <span style="color: #0000ff;">super</span><span style="color: #000000;">.onDestroy();        unregisterReceiver(networkChangeReceiver);    }    </span><span style="color: #0000ff;">class</span> NetworkChanceReceiver <span style="color: #0000ff;">extends</span> BroadcastReceiver{<span style="color: #008000;">//</span><span style="color: #008000;">定义内部类NetworkChanceReceiver，继承于BroadcastReceiver</span><span style="color: #000000;">        @Override        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onReceive(Context context, Intent intent) {<span style="color: #008000;">//</span><span style="color: #008000;">当网络发生改变的时候就会执行onReceiver里的代码</span>            ConnectivityManager connectivityManager =<span style="color: #000000;"> (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);            </span><span style="color: #008000;">//</span><span style="color: #008000;">获取系统服务的ConnectivityManager（网络连接管理器）实例</span>            NetworkInfo networkInfo =<span style="color: #000000;"> connectivityManager.getActiveNetworkInfo();            </span><span style="color: #008000;">//</span><span style="color: #008000;">通过ConnectivityManager获取网络信息，赋值给networkInfo</span>            <span style="color: #0000ff;">if</span> (networkInfo != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> networkInfo.isAvailable()) {                </span><span style="color: #008000;">//</span><span style="color: #008000;">通过isAvailable()判断网络是否联通</span>                Toast.makeText(context, "网络连接可用"<span style="color: #000000;">,                        Toast.LENGTH_SHORT).show();            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {                Toast.makeText(context, </span>"请检查网络连接"<span style="color: #000000;">,                        Toast.LENGTH_SHORT).show();            }        }    }}</span></pre></div><p>&nbsp;</p><h4><span style="line-height: 1.5; color: #ff0000;">调用网络信息需要系统权限</span></h4><div class="postBody"><div id="cnblogs_post_body"><div class="cnblogs_code"><pre> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">uses-permission </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.permission.ACCESS_NETWORK_STATE"</span><span style="color: #0000ff;">/&gt;</span></pre></div><h2>二,静态创建注册开机监控事件</h2><p>1.静态创建启动监控的类<span class="fontstyle0">BootCompleteReceiver &nbsp;继承于<span class="fontstyle0">BroadcastReceiver&nbsp;</span></span></p><div class="cnblogs_code"><pre>重写onReceive（）方法；</pre></div><p>2.在ManiFest中注册权限</p><p><strong><span style="color: #ff0000;">&nbsp; &nbsp; 广播组件开机启动权限</span></strong></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">uses-permission </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.permission.RECEIVE_BOOT_COMPLETED"</span> <span style="color: #0000ff;">/&gt;</span></pre></div><p>&nbsp; &nbsp;<span style="color: #ff0000;">&nbsp;<strong>注册广播接收器和要接收的广播</strong></span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">      &lt;</span><span style="color: #800000;">receiver </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".broadReceiver.BootCompleteReceiver"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="android.intent.action.BOOT_COMPLETED"</span> <span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>      <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">receiver</span><span style="color: #0000ff;">&gt;</span></pre></div><h2>&nbsp;三，系统广播大全</h2><div class="cnblogs_code"><pre><span style="color: #008000;">//</span><span style="color: #008000;">关闭或打开飞行模式时的广播</span><span style="color: #000000;">Intent.ACTION_AIRPLANE_M;</span><span style="color: #008000;">//</span><span style="color: #008000;">充电状态，或者电池的电量发生变化;</span><span style="color: #008000;">//</span><span style="color: #008000;">电池的充电状态、电荷级别改变，不能通过组建声;</span><span style="color: #000000;">Intent.ACTION_BATTERY_CH;</span><span style="color: #008000;">//</span><span style="color: #008000;">表示电池电量低</span><span style="color: #000000;">Intent.ACTION_BATTERY_LO;</span><span style="color: #008000;">//</span><span style="color: #008000;">表示电池电量充足</span><span style="color: #000000;">Intent.ACTION_BATTERY_OK;</span><span style="color: #008000;">//</span><span style="color: #008000;">关闭或打开飞行模式时的广播</span><span style="color: #000000;">Intent.ACTION_AIRPLANE_MODE_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">充电状态，或者电池的电量发生变化</span><span style="color: #008000;">//</span><span style="color: #008000;">电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册</span><span style="color: #000000;">Intent.ACTION_BATTERY_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">表示电池电量低</span><span style="color: #000000;">Intent.ACTION_BATTERY_LOW;</span><span style="color: #008000;">//</span><span style="color: #008000;">表示电池电量充足，即从电池电量低变化到饱满时会发出广播</span><span style="color: #000000;">Intent.ACTION_BATTERY_OKAY;</span><span style="color: #008000;">//</span><span style="color: #008000;">在系统启动完成后，这个动作被广播一次（只有一次）。</span><span style="color: #000000;">Intent.ACTION_BOOT_COMPLETED;</span><span style="color: #008000;">//</span><span style="color: #008000;">按下照相时的拍照按键(硬件按键)时发出的广播</span><span style="color: #000000;">Intent.ACTION_CAMERA_BUTTON;</span><span style="color: #008000;">//</span><span style="color: #008000;">当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息</span><span style="color: #000000;">Intent.ACTION_CLOSE_SYSTEM_DIALOGS;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)</span><span style="color: #000000;">Intent.ACTION_CONFIGURATION_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备日期发生改变时会发出此广播</span><span style="color: #000000;">Intent.ACTION_DATE_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用</span><span style="color: #000000;">Intent.ACTION_DEVICE_STORAGE_LOW;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用</span><span style="color: #000000;">Intent.ACTION_DEVICE_STORAGE_OK;</span><span style="color: #008000;">//</span><span style="color: #008000;">发出此广播的地方frameworks\base\services\java\com\android\server\DockObserver.java</span><span style="color: #000000;">Intent.ACTION_DOCK_EVENT;</span><span style="color: #008000;">//</span><span style="color: #008000;">移动APP完成之后，发出的广播(移动是指:APP2SD)</span><span style="color: #000000;">Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;</span><span style="color: #008000;">//</span><span style="color: #008000;">正在移动APP时，发出的广播(移动是指:APP2SD)</span><span style="color: #000000;">Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;</span><span style="color: #008000;">//</span><span style="color: #008000;">Gtalk已建立连接时发出的广播</span><span style="color: #000000;">Intent.ACTION_GTALK_SERVICE_CONNECTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">Gtalk已断开连接时发出的广播</span><span style="color: #000000;">Intent.ACTION_GTALK_SERVICE_DISCONNECTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">在耳机口上插入耳机时发出的广播</span><span style="color: #000000;">Intent.ACTION_HEADSET_PLUG;</span><span style="color: #008000;">//</span><span style="color: #008000;">改变输入法时发出的广播</span><span style="color: #000000;">Intent.ACTION_INPUT_METHOD_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备当前区域设置已更改时发出的广播</span><span style="color: #000000;">Intent.ACTION_LOCALE_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">表示用户和包管理所承认的低内存状态通知应该开始。</span><span style="color: #000000;">Intent.ACTION_MANAGE_PACKAGE_STORAGE;</span><span style="color: #008000;">//</span><span style="color: #008000;">未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 ,扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)</span><span style="color: #000000;">Intent.ACTION_MEDIA_BAD_REMOVAL;</span><span style="color: #008000;">//</span><span style="color: #008000;">按下"Media Button" 按键时发出的广播,假如有"Media Button" 按键的话(硬件按键)</span><span style="color: #000000;">Intent.ACTION_MEDIA_BUTTON;</span><span style="color: #008000;">//</span><span style="color: #008000;">插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?</span><span style="color: #000000;">Intent.ACTION_MEDIA_CHECKING;</span><span style="color: #008000;">//</span><span style="color: #008000;">已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播, 用户想要移除扩展介质（拔掉扩展卡）。</span><span style="color: #000000;">Intent.ACTION_MEDIA_EJECT;</span><span style="color: #008000;">//</span><span style="color: #008000;">插入SD卡并且已正确安装（识别）时发出的广播, 扩展介质被插入，而且已经被挂载。</span><span style="color: #000000;">Intent.ACTION_MEDIA_MOUNTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">拓展介质存在，但使用不兼容FS（或为空）的路径安装点检查介质包含在Intent.mData领域。</span><span style="color: #000000;">Intent.ACTION_MEDIA_NOFS;</span><span style="color: #008000;">//</span><span style="color: #008000;">外部储存设备已被移除，不管有没正确卸载,都会发出此广播， 扩展介质被移除。</span><span style="color: #000000;">Intent.ACTION_MEDIA_REMOVED;</span><span style="color: #008000;">//</span><span style="color: #008000;">广播：已经扫描完介质的一个目录</span><span style="color: #000000;">Intent.ACTION_MEDIA_SCANNER_FINISHED;</span><span style="color: #008000;">//</span><span style="color: #008000;">请求媒体扫描仪扫描文件并将其添加到媒体数据库。</span><span style="color: #000000;">Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;</span><span style="color: #008000;">//</span><span style="color: #008000;">广播：开始扫描介质的一个目录</span><span style="color: #000000;">Intent.ACTION_MEDIA_SCANNER_STARTED;</span><span style="color: #008000;">//</span><span style="color: #008000;"> 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。</span><span style="color: #000000;">Intent.ACTION_MEDIA_SHARED;Intent.ACTION_MEDIA_UNMOUNTABLE;</span><span style="color: #008000;">//</span><span style="color: #008000;">//</span><span style="color: #008000;"> 广播：扩展介质存在，但是还没有被挂载 (mount)</span><span style="color: #000000;">Intent.ACTION_MEDIA_UNMOUNTEDIntent.ACTION_NEW_OUTGOING_CALL;</span><span style="color: #008000;">//</span><span style="color: #008000;">成功的安装APK之后</span><span style="color: #008000;">//</span><span style="color: #008000;">广播：设备上新安装了一个应用程序包。</span><span style="color: #008000;">//</span><span style="color: #008000;">一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播）</span><span style="color: #000000;">Intent.ACTION_PACKAGE_ADDED;</span><span style="color: #008000;">//</span><span style="color: #008000;">一个已存在的应用程序包已经改变，包括包名</span><span style="color: #000000;">Intent.ACTION_PACKAGE_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)</span><span style="color: #008000;">//</span><span style="color: #008000;">用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）</span><span style="color: #000000;">Intent.ACTION_PACKAGE_DATA_CLEARED;</span><span style="color: #008000;">//</span><span style="color: #008000;">触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？</span><span style="color: #000000;">Intent.ACTION_PACKAGE_INSTALL;</span><span style="color: #008000;">//</span><span style="color: #008000;">成功的删除某个APK之后发出的广播, 一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）</span><span style="color: #000000;">Intent.ACTION_PACKAGE_REMOVED;</span><span style="color: #008000;">//</span><span style="color: #008000;">替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）</span><span style="color: #000000;">Intent.ACTION_PACKAGE_REPLACED;</span><span style="color: #008000;">//</span><span style="color: #008000;">用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）</span><span style="color: #000000;">Intent.ACTION_PACKAGE_RESTARTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">插上外部电源时发出的广播</span><span style="color: #000000;">Intent.ACTION_POWER_CONNECTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">已断开外部电源连接时发出的广播</span><span style="color: #000000;">Intent.ACTION_POWER_DISCONNECTED;Intent.ACTION_PROVIDER_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">//</span><span style="color: #008000;">重启设备时的广播</span><span style="color: #000000;">Intent.ACTION_REBOOT;</span><span style="color: #008000;">//</span><span style="color: #008000;">屏幕被关闭之后的广播</span><span style="color: #000000;">Intent.ACTION_SCREEN_OFF;</span><span style="color: #008000;">//</span><span style="color: #008000;">屏幕被打开之后的广播</span><span style="color: #000000;">Intent.ACTION_SCREEN_ON;</span><span style="color: #008000;">//</span><span style="color: #008000;">关闭系统时发出的广播</span><span style="color: #000000;">Intent.ACTION_SHUTDOWN;</span><span style="color: #008000;">//</span><span style="color: #008000;">时区发生改变时发出的广播</span><span style="color: #000000;">Intent.ACTION_TIMEZONE_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">时间被设置时发出的广播</span><span style="color: #000000;">Intent.ACTION_TIME_CHANGED;</span><span style="color: #008000;">//</span><span style="color: #008000;">广播：当前时间已经变化（正常的时间流逝）， 当前时间改变，每分钟都发送，不能通过组件声明来接收</span><span style="color: #000000;">，只有通过Context.registerReceiver()方法来注册Intent.ACTION_TIME_TICK;</span><span style="color: #008000;">//</span><span style="color: #008000;">一个用户ID已经从系统中移除发出的广播</span><span style="color: #000000;">Intent.ACTION_UID_REMOVED;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备已进入USB大容量储存状态时发出的广播？</span><span style="color: #000000;">Intent.ACTION_UMS_CONNECTED;</span><span style="color: #008000;">//</span><span style="color: #008000;">设备已从USB大容量储存状态转为正常状态时发出的广播？</span><span style="color: #000000;">Intent.ACTION_UMS_DISCONNECTED;Intent.ACTION_USER_PRESENT;</span><span style="color: #008000;">//</span><span style="color: #008000;">//</span><span style="color: #008000;">设备墙纸已改变时发出的广播</span>Intent.ACTION_WALLPAPER_CHANGED;</pre></div><h2>&nbsp;&nbsp;四，自定义系统广播</h2><h4>1.新建发送标准广播意图</h4><div class="cnblogs_code"><pre>                Intent intent = <span style="color: #0000ff;">new</span> Intent("com.cenzhongman.myapplication.MY_BROADCAST"<span style="color: #000000;">);                sendBroadcast(intent);</span></pre></div><p>通过sendBroadcast( );发出了标准广播</p><h3>2.发送有序广播</h3><p>（1）发出有序广播</p><div class="cnblogs_code"><pre>                Intent intent = <span style="color: #0000ff;">new</span> Intent("com.cenzhongman.myapplication.MY_BROADCAST"<span style="color: #000000;">);                sendOrderedBroadcast(intent,</span><span style="color: #0000ff;">null</span>);</pre></div><p><span class="fontstyle0">第二个参数是一个与权限相关的字符串，这里传入 <span class="fontstyle2">null <span class="fontstyle0">就行了。 （有机会再搞明白）<br /></span></span></span></p><h3>3.接收标准广播</h3><p>1.创建广播接收者类MyBoradcastReceiver继承于BoradcastReceiver</p><p>&nbsp;2.注册标准接收者权限</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">        &lt;</span><span style="color: #800000;">receiver </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".broadReceiver.MyBroadcastReceiver"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="com.cenzhongman.myapplication.MY_BROADCAST"</span><span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">receiver</span><span style="color: #0000ff;">&gt;</span></pre></div><h3>4.接收有序接收者</h3><p>1.创建广播接收者类MyBoradcastReceiver继承于BoradcastReceiver</p><p>&nbsp;2.注册有序接收者权限（注册优先级）</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">　　　　 &lt;</span><span style="color: #800000;">receiver </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">=".broadReceiver.MyBroadcastReceiver"</span><span style="color: #0000ff;">&gt;</span>            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">intent-filter </span><span style="color: #ff0000;">android:priority</span><span style="color: #0000ff;">="100"</span><span style="color: #0000ff;">&gt;</span>                <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">action </span><span style="color: #ff0000;">android:name</span><span style="color: #0000ff;">="com.cenzhongman.myapplication.MY_BROADCAST"</span><span style="color: #0000ff;">/&gt;</span>            <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">intent-filter</span><span style="color: #0000ff;">&gt;</span>        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">receiver</span><span style="color: #0000ff;">&gt;</span></pre></div><p><span style="color: #3366ff;"><strong>获得优先级的接收者可以选择是否允许广播继续传递，数越大优先级别越高，最大值是2147483647，默认优先级是1；</strong></span></p><div class="cnblogs_code"><pre>abortBroadcast();</pre></div><p>在onReceiver中加入<span class="fontstyle0">abortBroadcast(); 可以拦截广播，不继续传播。<br /></span></p><h2>&nbsp; 四，自定义本地广播（不能静态注册）</h2><p><span class="fontstyle0">基本上就和的动态注册广播接收器以及发送广播的代码是一样。只不过现在</span></p><h5><span class="fontstyle0">　　首先是通过 <span class="fontstyle2">LocalBroadcastManager<span class="fontstyle0">的 <span class="fontstyle2">getInstance()<span class="fontstyle0">方法得到了它的一个实例，</span></span></span></span></span></h5><h5><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　然后在注册广播接收器的时候调用的是 <span class="fontstyle2">LocalBroadcastManager<span class="fontstyle0">的 <span class="fontstyle2">registerReceiver()<span class="fontstyle0">方法，</span></span></span></span></span></span></span></span></span></h5><h5><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　在发送广播的时候调用的是 <span class="fontstyle2">LocalBroadcastManager <span class="fontstyle0">的 <span class="fontstyle2">sendBroadcast()<span class="fontstyle0">方法，</span></span></span></span></span></span></span></span></span></span></span></span></span></h5><h5><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　取消注册调用的是</span></span></span></span></span></span></span></span></span></span></span></span></span>localBroadcastManager的unregisterReceiver方法</h5><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">仅此而已。这里我们在按钮的点击事件里面发出了一条自己的<span class="fontstyle2"><span class="fontstyle0">广播，然后在 <span class="fontstyle2">LocalReceiver <span class="fontstyle0">里去接收这条广播。&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div></div>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>永久化文件存储技术.html</title>
    <link href="/09-Android/%E6%B0%B8%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/09-Android/%E6%B0%B8%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><h1>一.文件存储方式</h1><h2>　　1.写入文件</h2><p>&nbsp;</p><p style="margin-left: 30px;">Context 类中的<strong>openFileOutput ()</strong>方法，接收两个参数，</p><p style="margin-left: 30px;">　　第一个参数是文件名，在文件创建的时候使用的就是这个名称，所有的文件都是默认存储到/data/data/&lt;packagename&gt;/files/ 目录下的（<strong>暂且认为不可更改</strong>）。</p><p style="margin-left: 30px;">　　第二个参数是文件的操作模式，MODE_PRIVATE<strong> （覆盖）</strong>和 MODE_APPEND<strong>（追加）</strong>。<span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div class="cnblogs_code"><pre>    <span style="color: #008000;">/**</span><span style="color: #008000;">     * 数据存储程序     *  参数：需要存储的String类型数据     *  return :void     </span><span style="color: #008000;">*/</span>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> save(String inputText) {        FileOutputStream out;</span><span style="color: #008000;">//</span><span style="color: #008000;">文件字节输出流</span>        BufferedWriter writer = <span style="color: #0000ff;">null</span>;<span style="color: #008000;">//</span><span style="color: #008000;">使用缓冲写入流</span>        <span style="color: #0000ff;">try</span><span style="color: #000000;"> {            out </span>= openFileOutput("data", Context.MODE_PRIVATE);<span style="color: #008000;">//</span><span style="color: #008000;">openFileOutput方法，文件名，写入方式</span>            writer = <span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span> OutputStreamWriter(out));<span style="color: #008000;">//</span><span style="color: #008000;">创建写入缓冲流对象</span><span style="color: #000000;">            writer.write(inputText);            Log.d(</span>"cenEditerActivity","存储完毕"<span style="color: #000000;">);        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {            e.printStackTrace();        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {                </span><span style="color: #0000ff;">if</span> (writer != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {                    writer.close();                }            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {                e.printStackTrace();            }        }    }</span></pre></div><p style="margin-left: 30px;"><span class="fontstyle0">　　通过<span class="fontstyle1">openFileOutput()<span class="fontstyle0">方法能够得到一个 <span class="fontstyle1">FileOutputStream <span class="fontstyle0">对象，然后再借助它构建出一个<span class="fontstyle1">OutputStreamWriter <span class="fontstyle0">对象，接着再使用 <span class="fontstyle1">OutputStreamWriter <span class="fontstyle0">构建出一个 <span class="fontstyle1">BufferedWriter <span class="fontstyle0">对象 </span></span></span></span></span></span></span></span></span></span></span></p><h2>　　2.读取文件</h2><p style="margin-left: 30px;"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle0">Context <span class="fontstyle2">类中还提供了一个 <span class="fontstyle0">openFileInput()<span class="fontstyle2">方法，用于从文件中读取数据。这个方法要比 <span class="fontstyle0">openFileOutput()<span class="fontstyle2">简单一些，它只接收一个参数，即要读取的文件名，然后系统会自动到</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left: 30px;"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">/data/data/&lt;package name&gt;/files/<span class="fontstyle2">目录下去加载这个文件，并返回一个<span class="fontstyle0">FileInputStream <span class="fontstyle2">对象<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left: 30px;"><strong><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle1"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">（为了简单，直接抛出异常，不处理）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><div class="cnblogs_code"><pre>    <span style="color: #008000;">/**</span><span style="color: #008000;">     * 从文件获取笔记内容     * 参数：笔记ID(暂无)     * return：String     </span><span style="color: #008000;">*/</span><span style="color: #000000;">    String getDataFromFile() </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {        BufferedReader reader;        FileInputStream in;        String line;        StringBuilder content </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder();        in </span>= openFileInput("data"<span style="color: #000000;">);        reader </span>= <span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #0000ff;">new</span><span style="color: #000000;"> InputStreamReader(in));        </span><span style="color: #0000ff;">while</span> ((line = reader.readLine()) != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {            content.append(line);        }        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> content.toString();    }</span></pre></div><p><span class="fontstyle0">通过 <span class="fontstyle2">openFileInput()<span class="fontstyle0">方法获取到了一个 <span class="fontstyle2">FileInputStream <span class="fontstyle0">对象，然后借助它又构建出了一个 <span class="fontstyle2">InputStreamReader <span class="fontstyle0">对象，接着再使用 <span class="fontstyle2">InputStreamReader <span class="fontstyle0">构建出一个<span class="fontstyle2">BufferedReader <span class="fontstyle0">对象，这样我们就可以通过 <span class="fontstyle2">BufferedReader <span class="fontstyle0">进行一行行地读取，把文件中所有的文本内容全部读取出来并存放在一个 <span class="fontstyle2">StringBuilder <span class="fontstyle0">对象中，最后将读取到的内容返回就可以了。 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h1>二.<span class="fontstyle0">SharedPreferences (共享参数)<br /></span></h1><h2><span class="fontstyle0">　　I.通过SharePreferences存储数据</span></h2><ul><li><h3><span class="fontstyle0"><span class="fontstyle0">三种方法用于得到 <span class="fontstyle2">SharedPreferences <span class="fontstyle0">对象 <br /></span></span></span></span></h3></li></ul><p><span class="fontstyle0"><span class="fontstyle0">　　　　<strong>1.&nbsp;Context <span class="fontstyle2">类中的 <span class="fontstyle0">getSharedPreferences()<span class="fontstyle2">方法</span></span></span></strong></span></span></p><p><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">　　　　　　　　第一个参数，<span class="fontstyle0">用于指定 <span class="fontstyle2">SharedPreferences <span class="fontstyle0">文件的名称，<span class="fontstyle2">SharedPreferences <span class="fontstyle0">文件都是存放在<span class="fontstyle2">/data/data/&lt;packagename&gt;/shared_prefs/<span class="fontstyle0">目录下的。</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　　　　　　　第二个参数用于指定操作模式，<span class="fontstyle2">MODE_PRIVATE<strong>（私有的，自由当前应用能读写）</strong>&nbsp;<span class="fontstyle0">和 <span class="fontstyle2">MODE_MULTI_PROCESS<strong>（多端处理）</strong><span class="fontstyle0">。默认为0，即private。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="line-height: 1.5;">　　　　<strong>2.&nbsp;Activity </strong></span><strong><span class="fontstyle2" style="line-height: 1.5;">类中的 <span class="fontstyle0">getPreferences()<span class="fontstyle2">方法</span></span></span></strong></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　　　　　　　以当前活动类名为文件名，只接收模式参数</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">　　　　<strong>3.<span class="fontstyle0">PreferenceManager <span class="fontstyle2">类中的 <span class="fontstyle0">getDefaultSharedPreferences()<span class="fontstyle2">方法这是一个静态方法</span></span></span></span></strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">　　　　　　它接收一个 <span class="fontstyle0">Context <span class="fontstyle2">参数，并自动使用当前应用程序的包名作为前缀来命名 <span class="fontstyle0">SharedPreferences <span class="fontstyle2">文件</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><h5><span style="font-size: 1.5em; line-height: 1.5;">得到了 </span><span class="fontstyle2" style="font-size: 1.5em; line-height: 1.5;">SharedPreferences <span class="fontstyle0">对象之后， 就可以开始向 <span class="fontstyle2">SharedPreferences <span class="fontstyle0">文件中存储数据了</span></span></span></span></h5></li></ul><p style="margin-left: 60px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">1. <span class="fontstyle0">调用 <span class="fontstyle2">SharedPreferences <span class="fontstyle0">对象的 <span class="fontstyle2">edit()<span class="fontstyle0">方法来获取一个 <span class="fontstyle2">SharedPreferences.Editor <span class="fontstyle0">对象。<br /><span class="fontstyle2">2. <span class="fontstyle0">向 <span class="fontstyle2">SharedPreferences.Editor <span class="fontstyle0">对象中添加数据，比如添加一个布尔型数据就使用<span class="fontstyle2">putBoolean <span class="fontstyle0">方法，添加一个字符串则使用 <span class="fontstyle2">putString()<span class="fontstyle0">方法，以此类推。<br /><span class="fontstyle2">3. <span class="fontstyle0">调用 <span class="fontstyle2">commit()或apply()<span class="fontstyle0">方法将添加的数据提交，从而完成数据存储操作。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div class="cnblogs_code"><pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onClick(View v) {                SharedPreferences sharedPreferences</span>= getSharedPreferences("SharePreferences",0<span style="color: #000000;">);                </span><span style="color: #008000;">//</span><span style="color: #008000;">调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象</span>                SharedPreferences.Editor  editor =<span style="color: #000000;"> sharedPreferences.edit();                </span><span style="color: #008000;">//</span><span style="color: #008000;">向 SharedPreferences.Editor 对象中添加数据</span>                editor.putString("name","岑忠满");<span style="color: #008000;">//</span><span style="color: #008000;">以键来保存， name就是键</span>                editor.putInt("age",28<span style="color: #000000;">);                editor.putBoolean(</span>"帅不帅",<span style="color: #0000ff;">true</span><span style="color: #000000;">);                </span><span style="color: #008000;">//</span><span style="color: #008000;">调用 commit()方法将添加的数据提交</span><span style="color: #000000;">                editor.apply();            }</span></pre></div><p>&nbsp;</p><h2>&nbsp;<img src="http://images2015.cnblogs.com/blog/1047249/201701/1047249-20170108225328112-702159620.png" alt="" /></h2><h2>&nbsp;II.<span class="fontstyle0">从&nbsp;<span class="fontstyle2">SharedPreferences&nbsp;<span class="fontstyle0">中读取数据</span></span></span></h2><p style="margin-left: 60px;"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>再更改apache工程路径时候，按照许多教程改了httpd.conf文件，还是不行，问题依旧存在</p><p>解决方式，你的个人文件夹的权限还没改好，看一下自己的个人文件夹的权限，是否可以读写</p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View和ViewGroup的步骤和实现.html</title>
    <link href="/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%92%8CViewGroup%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%92%8CViewGroup%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3>1.设置属性(供XML调用)</h3> <p>在res目录新建attrs.xml文件</p> <div class="cnblogs_code"><pre><span style="color: #0000ff">&lt;?</span>xml version="1.0" encoding="utf-8"<span style="color: #0000ff">?&gt;</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">resources</span><span style="color: #0000ff">&gt;</span>    <span style="color: #0000ff">&lt;</span><span style="color: #800000">declare</span>-<span style="color: #ff0000">styleable</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"MyTopBar"</span><span style="color: #0000ff">&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"title"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"titleSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"titleColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonText"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextBackGround"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonText"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextBackGround"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonText2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextSize2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextColor2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextBackGround2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">declare</span>-styleable<span style="color: #0000ff">&gt;</span><span style="color: #0000ff">&lt;/</span><span style="color: #800000">resources</span><span style="color: #0000ff">&gt;</span></pre></div><h3>2.创建自定义继承于(view/viewGroup/各种组件)</h3><div class="cnblogs_code"><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> MyTopBar <span style="color: #0000ff">extends</span> RelativeLayout {    <span style="color: #008000">//TopBar容器包含的组件</span>    <span style="color: #0000ff">private</span> Button mLeftButton, mRightButton, mRightButton2;    <span style="color: #0000ff">private</span> TextView mTitleTextView;    <span style="color: #008000">// 布局属性，用来控制组件元素在ViewGroup中的位置</span>    <span style="color: #0000ff">private</span> LayoutParams mLeftParams, mTitleParams, mRightParams, mRightParams2;    <span style="color: #008000">//定义title属性</span>    <span style="color: #0000ff">private</span> String mTitle;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mTitleColor;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mTitleSize;    <span style="color: #008000">//定义leftButton属性</span>    <span style="color: #0000ff">private</span> String mLeftButtonText;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mLeftButtonTextSize;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mLeftButtonTextColor;    <span style="color: #0000ff">private</span> Drawable mLeftButtonTextBackGround;    <span style="color: #008000">//定义最右边的RightButton属性</span>    <span style="color: #0000ff">private</span> String mRightButtonText;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mRightButtonTextSize;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mRightButtonTextColor;    <span style="color: #0000ff">private</span> Drawable mRightButtonTextBackGround;    <span style="color: #008000">//定义倒数第二个rightButton的属性</span>    <span style="color: #0000ff">private</span> String mRightButtonText2;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mRightButtonTextSize2;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mRightButtonTextColor2;    <span style="color: #0000ff">private</span> Drawable mRightButtonTextBackGround2;    <span style="color: #008000">// 映射传入的接口对象</span>    <span style="color: #0000ff">private</span> topBarClickListener mListener;    <span style="color: #0000ff">public</span> MyTopBar(Context context) {        <span style="color: #0000ff">super</span>(context);    }    <span style="color: #008000">//这个构造函数是包含attrs的，ＸＭＬ在加载时候会调用这个构造函数</span>    <span style="color: #0000ff">public</span> MyTopBar(Context context, AttributeSet attrs) {        <span style="color: #0000ff">super</span>(context, attrs);        <span style="color: #008000">/*         1.把所有的attrs的值添加到TypeArray中        */</span>        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTopBar);        <span style="color: #008000">//把TypeArray中的值取出来</span>        mTitle = typedArray.getString(R.styleable.MyTopBar_title);        mTitleColor = typedArray.getColor(R.styleable.MyTopBar_titleColor, 0);        mTitleSize = typedArray.getDimension(R.styleable.MyTopBar_titleSize, 10);        mLeftButtonText = typedArray.getString(R.styleable.MyTopBar_leftButtonText);        mLeftButtonTextColor = typedArray.getColor(R.styleable.MyTopBar_leftButtonTextColor, 0);        mLeftButtonTextSize = typedArray.getDimension(R.styleable.MyTopBar_leftButtonTextSize, 10);        mLeftButtonTextBackGround = typedArray.getDrawable(R.styleable.MyTopBar_leftButtonTextBackGround);        mRightButtonText = typedArray.getString(R.styleable.MyTopBar_rightButtonText);        mRightButtonTextColor = typedArray.getColor(R.styleable.MyTopBar_rightButtonTextColor, 0);        mRightButtonTextSize = typedArray.getDimension(R.styleable.MyTopBar_rightButtonTextSize, 10);        mRightButtonTextBackGround = typedArray.getDrawable(R.styleable.MyTopBar_rightButtonTextBackGround);        mRightButtonText2 = typedArray.getString(R.styleable.MyTopBar_rightButtonText2);        mRightButtonTextColor2 = typedArray.getColor(R.styleable.MyTopBar_rightButtonTextColor2, 0);        mRightButtonTextSize2 = typedArray.getDimension(R.styleable.MyTopBar_rightButtonTextSize2, 10);        mRightButtonTextBackGround2 = typedArray.getDrawable(R.styleable.MyTopBar_rightButtonTextBackGround2);        <span style="color: #008000">//取完不要忘记recycle，防止下次调用失败</span>        typedArray.recycle();        <span style="color: #008000">/*        2.组合控件        */</span>        mTitleTextView = <span style="color: #0000ff">new</span> TextView(context);        mLeftButton = <span style="color: #0000ff">new</span> Button(context);        mRightButton = <span style="color: #0000ff">new</span> Button(context);        mRightButton2 = <span style="color: #0000ff">new</span> Button(context);        <span style="color: #008000">//为元素添加设置属性,来自XML的值会自动在这里进行设置</span>        mTitleTextView.setText(mTitle);        mTitleTextView.setTextColor(mTitleColor);        mTitleTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP,mTitleSize);        mLeftButton.setText(mLeftButtonText);        mLeftButton.setTextSize(TypedValue.COMPLEX_UNIT_SP,mLeftButtonTextSize);        mLeftButton.setTextColor(mLeftButtonTextColor);        mLeftButton.setBackground(mLeftButtonTextBackGround);        mLeftButton.setId(R.id.topBar_left_button);        mRightButton.setText(mRightButtonText);        mRightButton.setTextColor(mRightButtonTextColor);        mRightButton.setTextSize(TypedValue.COMPLEX_UNIT_SP,mRightButtonTextSize);        mRightButton.setBackground(mRightButtonTextBackGround);        mRightButton.setId(R.id.topBar_right_button);<span style="color: #008000">//这个id需要在res文件中添加ids.xml文件</span>        mRightButton2.setText(mRightButtonText2);        mRightButton2.setTextColor(mRightButtonTextColor2);        mRightButton2.setTextSize(TypedValue.COMPLEX_UNIT_SP,mRightButtonTextSize2);        mRightButton2.setBackground(mRightButtonTextBackGround2);        <span style="color: #008000">//为组件设置布局</span>        mLeftParams = <span style="color: #0000ff">new</span> LayoutParams(                200,                ViewGroup.LayoutParams.WRAP_CONTENT);        mLeftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT,TRUE);<span style="color: #008000">//居于父布局左侧</span>        addView(mLeftButton,mLeftParams);<span style="color: #008000">//添加到ViewGroup</span>        mRightParams = <span style="color: #0000ff">new</span> LayoutParams(                200,                ViewGroup.LayoutParams.MATCH_PARENT);        mRightParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,TRUE);<span style="color: #008000">//居于父布局右侧</span>        addView(mRightButton,mRightParams);        mRightParams2 = <span style="color: #0000ff">new</span> LayoutParams(                <span style="color: #008000">//px = dp*(dpi/160)这里是像素</span>                80,                80);        mRightParams2.addRule(RelativeLayout.LEFT_OF,R.id.topBar_right_button);<span style="color: #008000">//居于最右侧按键左侧</span>        mRightParams2.addRule(RelativeLayout.CENTER_VERTICAL,TRUE);        addView(mRightButton2,mRightParams2);        mTitleParams = <span style="color: #0000ff">new</span> LayoutParams(                ViewGroup.LayoutParams.WRAP_CONTENT,                ViewGroup.LayoutParams.WRAP_CONTENT);        mTitleParams.addRule(RelativeLayout.CENTER_IN_PARENT,TRUE);        mTitleParams.addRule(RelativeLayout.RIGHT_OF,R.id.topBar_left_button);<span style="color: #008000">//居于最左侧按键右侧</span>        addView(mTitleTextView,mTitleParams);        <span style="color: #008000">//定义事件监听</span>        mLeftButton.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.leftButtonClick();            }        });        mRightButton.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.RightButtonClick();            }        });        mRightButton2.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.RightButtonClick2();            }        });    }    <span style="color: #008000">/*    3.定义接口,留给调用者实现     */</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">interface</span> topBarClickListener {        <span style="color: #008000">//左按键</span>        <span style="color: #0000ff">void</span> leftButtonClick();        <span style="color: #008000">//右按键</span>        <span style="color: #0000ff">void</span> RightButtonClick();        <span style="color: #008000">//右按键2</span>        <span style="color: #0000ff">void</span> RightButtonClick2();    }    <span style="color: #008000">// 暴露一个方法给调用者来注册接口回调</span>    <span style="color: #008000">// 通过接口来获得回调者对接口方法的实现</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> setOnTopBarClickListener(topBarClickListener mListener) {        <span style="color: #0000ff">this</span>.mListener = mListener;    }}</pre></div><h3>3.可见性设置</h3><div class="cnblogs_code"><pre><span style="color: #008000">   /*    4.高度自定义    */</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> setButtonVisible(<span style="color: #0000ff">int</span> id, <span style="color: #0000ff">boolean</span> flag) {        <span style="color: #0000ff">if</span> (flag) {            <span style="color: #0000ff">if</span> (id == 0) {                mLeftButton.setVisibility(View.VISIBLE);            } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (id == 1) {                mRightButton.setVisibility(View.VISIBLE);            } <span style="color: #0000ff">else</span> {                mRightButton2.setVisibility(View.VISIBLE);            }        } <span style="color: #0000ff">else</span> {            <span style="color: #0000ff">if</span> (id == 0) {                mLeftButton.setVisibility(View.GONE);            } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (id == 1) {                mRightButton.setVisibility(View.GONE);            } <span style="color: #0000ff">else</span> {                mRightButton2.setVisibility(View.GONE);            }        }    }</pre></div><p>&nbsp;</p><p><a href="http://images2015.cnblogs.com/blog/1047249/201704/1047249-20170413231610017-1231119758.png"><img title="QQ图片20170407232545" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="QQ图片20170407232545" src="http://images2015.cnblogs.com/blog/1047249/201704/1047249-20170413231610517-1177481313.png" width="412" height="177"></a></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View之onMeasure.html</title>
    <link href="/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BonMeasure/"/>
    <url>/09-Android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BonMeasure/</url>
    
    <content type="html"><![CDATA[<h3>View的三种模式</h3> <ul> <li> <h4>EXACTLY:精确模式，当输入准确的数字时适配此模式</h4> <li> <h4>AT_MOST：最大模式，适配wrap_content</h4> <li> <h4>UNSPECIFIED：不指定模式（不知道干嘛的）</h4></li></ul> <h4>当我们重写onMeasure()方法时，系统回调super.onMeasure();方法中,底层通过setMeasureDimension()方法实现View的侧量</h4> <p>模板代码如下</p> <div class="cnblogs_code"><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> MyView <span style="color: #0000ff">extends</span> View {    <span style="color: #0000ff">public</span> MyView(Context context) {        <span style="color: #0000ff">super</span>(context);    }    @Override    <span style="color: #0000ff">protected</span> <span style="color: #0000ff">void</span> onMeasure(<span style="color: #0000ff">int</span> widthMeasureSpec, <span style="color: #0000ff">int</span> heightMeasureSpec) {        setMeasuredDimension(                measureWidth(widthMeasureSpec),                measureHeight(heightMeasureSpec)        );    }    <span style="color: #008000">/**     * 获得实际宽度     * @param widthMeasureSpec 带模式和值的宽度spec对象     * @return 实际测量值     */</span>    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> measureWidth(<span style="color: #0000ff">int</span> widthMeasureSpec) {        <span style="color: #0000ff">int</span> result = 0;        <span style="color: #0000ff">int</span> spaceMode = MeasureSpec.getMode(widthMeasureSpec);        <span style="color: #0000ff">int</span> spaceSize = MeasureSpec.getSize(widthMeasureSpec);        <span style="color: #0000ff">if</span> (spaceMode == MeasureSpec.EXACTLY){            result = spaceSize;        }<span style="color: #0000ff">else</span>{            result = 200;<span style="color: #008000">//设置宽度默认值</span>            <span style="color: #0000ff">if</span> (spaceMode == MeasureSpec.AT_MOST){                result = Math.min(result,spaceSize);            }        }        <span style="color: #0000ff">return</span> result;    }    <span style="color: #008000">/**     * 获得实际宽度     * @param heightMeasureSpec 带模式和值的高度spec对象     * @return 实际测量值     */</span>    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> measureHeight(<span style="color: #0000ff">int</span> heightMeasureSpec) {        <span style="color: #0000ff">int</span> result = 0;        <span style="color: #0000ff">int</span> specMode = MeasureSpec.getMode(heightMeasureSpec);        <span style="color: #0000ff">int</span> specSize = MeasureSpec.getSize(heightMeasureSpec);        <span style="color: #0000ff">if</span> (specMode == MeasureSpec.EXACTLY){            result = specSize;        }<span style="color: #0000ff">else</span> {            result = 200;<span style="color: #008000">//设置高度默认值</span>            <span style="color: #0000ff">if</span> (specMode == MeasureSpec.AT_MOST){                result = Math.min(result,specSize);            }        }        <span style="color: #0000ff">return</span> result;    }}</pre></div><h3>1.设置属性(供XML调用)</h3> <p>在res目录新建attrs.xml文件</p> <div class="cnblogs_code"><pre><span style="color: #0000ff">&lt;?</span>xml version="1.0" encoding="utf-8"<span style="color: #0000ff">?&gt;</span><span style="color: #0000ff">&lt;</span><span style="color: #800000">resources</span><span style="color: #0000ff">&gt;</span>    <span style="color: #0000ff">&lt;</span><span style="color: #800000">declare</span>-<span style="color: #ff0000">styleable</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"MyTopBar"</span><span style="color: #0000ff">&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"title"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"titleSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"titleColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonText"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"leftButtonTextBackGround"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonText"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextSize"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextColor"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextBackGround"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonText2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"string"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextSize2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"dimension"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextColor2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"color"</span><span style="color: #0000ff">/&gt;</span>        <span style="color: #0000ff">&lt;</span><span style="color: #800000">attr</span> <span style="color: #ff0000">name</span>=<span style="color: #0000ff">"rightButtonTextBackGround2"</span> <span style="color: #ff0000">format</span>=<span style="color: #0000ff">"reference|color"</span><span style="color: #0000ff">/&gt;</span>    <span style="color: #0000ff">&lt;/</span><span style="color: #800000">declare</span>-styleable<span style="color: #0000ff">&gt;</span><span style="color: #0000ff">&lt;/</span><span style="color: #800000">resources</span><span style="color: #0000ff">&gt;</span></pre></div><h3>2.创建自定义继承于(view/viewGroup/各种组件)</h3><div class="cnblogs_code"><pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> MyTopBar <span style="color: #0000ff">extends</span> RelativeLayout {    <span style="color: #008000">//TopBar容器包含的组件</span>    <span style="color: #0000ff">private</span> Button mLeftButton, mRightButton, mRightButton2;    <span style="color: #0000ff">private</span> TextView mTitleTextView;    <span style="color: #008000">// 布局属性，用来控制组件元素在ViewGroup中的位置</span>    <span style="color: #0000ff">private</span> LayoutParams mLeftParams, mTitleParams, mRightParams, mRightParams2;    <span style="color: #008000">//定义title属性</span>    <span style="color: #0000ff">private</span> String mTitle;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mTitleColor;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mTitleSize;    <span style="color: #008000">//定义leftButton属性</span>    <span style="color: #0000ff">private</span> String mLeftButtonText;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mLeftButtonTextSize;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mLeftButtonTextColor;    <span style="color: #0000ff">private</span> Drawable mLeftButtonTextBackGround;    <span style="color: #008000">//定义最右边的RightButton属性</span>    <span style="color: #0000ff">private</span> String mRightButtonText;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mRightButtonTextSize;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mRightButtonTextColor;    <span style="color: #0000ff">private</span> Drawable mRightButtonTextBackGround;    <span style="color: #008000">//定义倒数第二个rightButton的属性</span>    <span style="color: #0000ff">private</span> String mRightButtonText2;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">float</span> mRightButtonTextSize2;    <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> mRightButtonTextColor2;    <span style="color: #0000ff">private</span> Drawable mRightButtonTextBackGround2;    <span style="color: #008000">// 映射传入的接口对象</span>    <span style="color: #0000ff">private</span> topBarClickListener mListener;    <span style="color: #0000ff">public</span> MyTopBar(Context context) {        <span style="color: #0000ff">super</span>(context);    }    <span style="color: #008000">//这个构造函数是包含attrs的，ＸＭＬ在加载时候会调用这个构造函数</span>    <span style="color: #0000ff">public</span> MyTopBar(Context context, AttributeSet attrs) {        <span style="color: #0000ff">super</span>(context, attrs);        <span style="color: #008000">/*         1.把所有的attrs的值添加到TypeArray中        */</span>        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTopBar);        <span style="color: #008000">//把TypeArray中的值取出来</span>        mTitle = typedArray.getString(R.styleable.MyTopBar_title);        mTitleColor = typedArray.getColor(R.styleable.MyTopBar_titleColor, 0);        mTitleSize = typedArray.getDimension(R.styleable.MyTopBar_titleSize, 10);        mLeftButtonText = typedArray.getString(R.styleable.MyTopBar_leftButtonText);        mLeftButtonTextColor = typedArray.getColor(R.styleable.MyTopBar_leftButtonTextColor, 0);        mLeftButtonTextSize = typedArray.getDimension(R.styleable.MyTopBar_leftButtonTextSize, 10);        mLeftButtonTextBackGround = typedArray.getDrawable(R.styleable.MyTopBar_leftButtonTextBackGround);        mRightButtonText = typedArray.getString(R.styleable.MyTopBar_rightButtonText);        mRightButtonTextColor = typedArray.getColor(R.styleable.MyTopBar_rightButtonTextColor, 0);        mRightButtonTextSize = typedArray.getDimension(R.styleable.MyTopBar_rightButtonTextSize, 10);        mRightButtonTextBackGround = typedArray.getDrawable(R.styleable.MyTopBar_rightButtonTextBackGround);        mRightButtonText2 = typedArray.getString(R.styleable.MyTopBar_rightButtonText2);        mRightButtonTextColor2 = typedArray.getColor(R.styleable.MyTopBar_rightButtonTextColor2, 0);        mRightButtonTextSize2 = typedArray.getDimension(R.styleable.MyTopBar_rightButtonTextSize2, 10);        mRightButtonTextBackGround2 = typedArray.getDrawable(R.styleable.MyTopBar_rightButtonTextBackGround2);        <span style="color: #008000">//取完不要忘记recycle，防止下次调用失败</span>        typedArray.recycle();        <span style="color: #008000">/*        2.组合控件        */</span>        mTitleTextView = <span style="color: #0000ff">new</span> TextView(context);        mLeftButton = <span style="color: #0000ff">new</span> Button(context);        mRightButton = <span style="color: #0000ff">new</span> Button(context);        mRightButton2 = <span style="color: #0000ff">new</span> Button(context);        <span style="color: #008000">//为元素添加设置属性,来自XML的值会自动在这里进行设置</span>        mTitleTextView.setText(mTitle);        mTitleTextView.setTextColor(mTitleColor);        mTitleTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP,mTitleSize);        mLeftButton.setText(mLeftButtonText);        mLeftButton.setTextSize(TypedValue.COMPLEX_UNIT_SP,mLeftButtonTextSize);        mLeftButton.setTextColor(mLeftButtonTextColor);        mLeftButton.setBackground(mLeftButtonTextBackGround);        mLeftButton.setId(R.id.topBar_left_button);        mRightButton.setText(mRightButtonText);        mRightButton.setTextColor(mRightButtonTextColor);        mRightButton.setTextSize(TypedValue.COMPLEX_UNIT_SP,mRightButtonTextSize);        mRightButton.setBackground(mRightButtonTextBackGround);        mRightButton.setId(R.id.topBar_right_button);<span style="color: #008000">//这个id需要在res文件中添加ids.xml文件</span>        mRightButton2.setText(mRightButtonText2);        mRightButton2.setTextColor(mRightButtonTextColor2);        mRightButton2.setTextSize(TypedValue.COMPLEX_UNIT_SP,mRightButtonTextSize2);        mRightButton2.setBackground(mRightButtonTextBackGround2);        <span style="color: #008000">//为组件设置布局</span>        mLeftParams = <span style="color: #0000ff">new</span> LayoutParams(                200,                ViewGroup.LayoutParams.WRAP_CONTENT);        mLeftParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT,TRUE);<span style="color: #008000">//居于父布局左侧</span>        addView(mLeftButton,mLeftParams);<span style="color: #008000">//添加到ViewGroup</span>        mRightParams = <span style="color: #0000ff">new</span> LayoutParams(                200,                ViewGroup.LayoutParams.MATCH_PARENT);        mRightParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,TRUE);<span style="color: #008000">//居于父布局右侧</span>        addView(mRightButton,mRightParams);        mRightParams2 = <span style="color: #0000ff">new</span> LayoutParams(                <span style="color: #008000">//px = dp*(dpi/160)这里是像素</span>                80,                80);        mRightParams2.addRule(RelativeLayout.LEFT_OF,R.id.topBar_right_button);<span style="color: #008000">//居于最右侧按键左侧</span>        mRightParams2.addRule(RelativeLayout.CENTER_VERTICAL,TRUE);        addView(mRightButton2,mRightParams2);        mTitleParams = <span style="color: #0000ff">new</span> LayoutParams(                ViewGroup.LayoutParams.WRAP_CONTENT,                ViewGroup.LayoutParams.WRAP_CONTENT);        mTitleParams.addRule(RelativeLayout.CENTER_IN_PARENT,TRUE);        mTitleParams.addRule(RelativeLayout.RIGHT_OF,R.id.topBar_left_button);<span style="color: #008000">//居于最左侧按键右侧</span>        addView(mTitleTextView,mTitleParams);        <span style="color: #008000">//定义事件监听</span>        mLeftButton.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.leftButtonClick();            }        });        mRightButton.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.RightButtonClick();            }        });        mRightButton2.setOnClickListener(<span style="color: #0000ff">new</span> OnClickListener() {            @Override            <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> onClick(View v) {                mListener.RightButtonClick2();            }        });    }    <span style="color: #008000">/*    3.定义接口,留给调用者实现     */</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">interface</span> topBarClickListener {        <span style="color: #008000">//左按键</span>        <span style="color: #0000ff">void</span> leftButtonClick();        <span style="color: #008000">//右按键</span>        <span style="color: #0000ff">void</span> RightButtonClick();        <span style="color: #008000">//右按键2</span>        <span style="color: #0000ff">void</span> RightButtonClick2();    }    <span style="color: #008000">// 暴露一个方法给调用者来注册接口回调</span>    <span style="color: #008000">// 通过接口来获得回调者对接口方法的实现</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> setOnTopBarClickListener(topBarClickListener mListener) {        <span style="color: #0000ff">this</span>.mListener = mListener;    }}</pre></div><h3>3.可见性设置</h3><div class="cnblogs_code"><pre><span style="color: #008000">   /*    4.高度自定义    */</span>    <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> setButtonVisible(<span style="color: #0000ff">int</span> id, <span style="color: #0000ff">boolean</span> flag) {        <span style="color: #0000ff">if</span> (flag) {            <span style="color: #0000ff">if</span> (id == 0) {                mLeftButton.setVisibility(View.VISIBLE);            } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (id == 1) {                mRightButton.setVisibility(View.VISIBLE);            } <span style="color: #0000ff">else</span> {                mRightButton2.setVisibility(View.VISIBLE);            }        } <span style="color: #0000ff">else</span> {            <span style="color: #0000ff">if</span> (id == 0) {                mLeftButton.setVisibility(View.GONE);            } <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (id == 1) {                mRightButton.setVisibility(View.GONE);            } <span style="color: #0000ff">else</span> {                mRightButton2.setVisibility(View.GONE);            }        }    }</pre></div><p>&nbsp;</p><p><a href="http://images2015.cnblogs.com/blog/1047249/201704/1047249-20170413231610017-1231119758.png"><img title="QQ图片20170407232545" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="QQ图片20170407232545" src="http://images2015.cnblogs.com/blog/1047249/201704/1047249-20170413231610517-1177481313.png" width="412" height="177"></a></p>]]></content>
    
    
    <categories>
      
      <category>09-Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-集合框架是什么</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合框架是什么"><a href="#集合框架是什么" class="headerlink" title="集合框架是什么"></a>集合框架是什么</h1><h2 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h2><p>数据结构（数组、链表、树、队列、堆栈） –&gt; 数据容器（Vector、Stack、HashTable） –&gt; 集合框架（Map、List、Set）</p><h2 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h2><p>集合框架出现在Jdk1.2，在集合框架之前，已经存在有<code>Vector</code>、<code>Stack</code>、<code>HashTable</code>等数据容器类，这些容器类解决了数组的弊端</p><ol><li>数组长度不可变</li><li>不同场景下需要重复编写代码实现相同的操作，比如添加一个元素add(){获取当前指针，移动数组指针，赋值}</li><li>需求大而开发者质量参差不齐，对数据结构不了解</li></ol><p>因此sun公司定义了基本的容器类，共开发者调用</p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>集合框架出现是为了规范管理容器类</p><ol><li>定义接口，如List</li><li>定义接口的实现，如ArrayList</li><li>定义集合的运算算法，如sort()</li></ol><p><strong>重要</strong>：集合框架(<code>Java Collections Framework</code>)中的所有包都在<code>java.util</code>包下面</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-URI-URL</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/03-URI-URL/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/03-URI-URL/</url>
    
    <content type="html"><![CDATA[<h1 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI URL"></a>URI URL</h1><h2 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI:Uniform Resource Identifier"></a>URI:Uniform Resource Identifier</h2><p>统一资源标志符，标志一个资源的绝对地址，能看不能摸</p><pre><code class="hljs java">URI uri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;http://192.168.10.11:8080/index.html&quot;</span>);</code></pre><p><img src="../images/2019-05-24-10-52-52.png"></p><h2 id="URL-Uniform-Resource-Locator"><a href="#URL-Uniform-Resource-Locator" class="headerlink" title="URL:Uniform Resource Locator"></a>URL:Uniform Resource Locator</h2><p>统一资源定位符，能看能摸</p><pre><code class="hljs java"><span class="hljs-comment">// 解析字符串</span>URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://192.168.10.125:9200/&quot;</span>);System.out.println(url.getContent());<span class="hljs-comment">// 分别解析</span>URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http&quot;</span>,<span class="hljs-string">&quot;192.168.10.125&quot;</span>,<span class="hljs-number">9200</span>,<span class="hljs-string">&quot;/&quot;</span>);</code></pre><h3 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h3><pre><code class="hljs java">URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http&quot;</span>, <span class="hljs-string">&quot;192.168.10.125&quot;</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">&quot;/&quot;</span>);URLConnection connection = url.openConnection();InputStream in = connection.getInputStream();<span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));&#125;</code></pre><h2 id="URLEncode-URLDecode"><a href="#URLEncode-URLDecode" class="headerlink" title="URLEncode URLDecode"></a>URLEncode URLDecode</h2><p>application/x-www-form-urlencoded</p><ol><li>字母数字字符 “a” 到 “z”、”A” 到 “Z” 和 “0” 到 “9” 保持不变。</li><li>特殊字符 “.”、”-“、”*” 和 “_” 保持不变。</li><li>空格字符 “ “ 转换为一个加号 “+”。</li><li>所有其他字符都是不安全的，因此首先使用一些编码机制将它们转换为一个或多个字节。然后每个字节用一个包含 3 个字符的字符串 “%xy” 表示，其中 xy 为该字节的两位十六进制表示形式。推荐的编码机制是 UTF-8。但是，出于兼容性考虑，如果未指定一种编码，则使用相应平台的默认编码。</li></ol><pre><code class="hljs java">url = URLEncoder.encode(url, <span class="hljs-string">&quot;UTF-8&quot;</span>);url = URLDecoder.decode(url, <span class="hljs-string">&quot;UTF-8&quot;</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-DatagramSocket</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/05-DatagramSocket/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/05-DatagramSocket/</url>
    
    <content type="html"><![CDATA[<h1 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h1><p>UDP协议的实现<br>这里发送数据中包含着发送的地址和端口信息，发送端不知道接收端的存在，不保证数据到达，也不保证达到的先后顺序</p><h2 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h2><pre><code class="hljs java"><span class="hljs-keyword">int</span> receiverPort = <span class="hljs-number">8889</span>;String data = <span class="hljs-string">&quot;Hello World&quot;</span>;DatagramSocket sender = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8888</span>);DatagramPacket datagramPacket = <span class="hljs-keyword">new</span> DatagramPacket(        data.getBytes(),        data.getBytes().length,        InetAddress.getLocalHost(),         <span class="hljs-comment">// 接收端的地址</span>        receiverPort);                      <span class="hljs-comment">// 接收端的端口</span>sender.send(datagramPacket);sender.close();</code></pre><h2 id="receiver"><a href="#receiver" class="headerlink" title="receiver"></a>receiver</h2><pre><code class="hljs java">DatagramSocket receiver = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8889</span>);<span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];DatagramPacket datagramPacket = <span class="hljs-keyword">new</span> DatagramPacket(buffer,buffer.length);receiver.receive(datagramPacket);System.out.println(<span class="hljs-keyword">new</span> String(datagramPacket.getData()));receiver.close();</code></pre><h2 id="DatagramPackage"><a href="#DatagramPackage" class="headerlink" title="DatagramPackage"></a>DatagramPackage</h2><p><img src="../images/2019-05-24-15-57-56.png"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Sockek</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/04-Sockek/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/02-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/04-Sockek/</url>
    
    <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>TPC协议的实现，经过三次握手才进行数据流的传输，保证数据的传递和安全性。</p><h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span>ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;    Socket client = server.accept();    System.out.println(<span class="hljs-string">&quot;client hostname:&quot;</span> + client.getInetAddress());    <span class="hljs-comment">// 客户端给服务端发消息</span>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(client.getInputStream());    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;        System.out.println(scanner.nextLine());    &#125;    scanner.close();&#125;</code></pre><h2 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h2><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span>Socket client = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<span class="hljs-comment">// 客户端给服务端发消息</span>OutputStream out = client.getOutputStream();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">65</span>; i &lt; <span class="hljs-number">65</span> + <span class="hljs-number">26</span>; i++) &#123;    out.write(i);&#125;client.close();</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>02-网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-File类</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/01-File%E7%B1%BB/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/01-File%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File类只操作文件的元数据，不能操作文件的内容</p><pre><code class="hljs java"><span class="hljs-comment">// 获取系统属性分隔符</span>File.pathSeparator;     <span class="hljs-comment">// :;</span><span class="hljs-comment">// 获取系统路径分隔符</span>File.separator;         <span class="hljs-comment">// /\</span><span class="hljs-comment">// 获得元数据信息</span>file.getAbsoluteFile();file.getAbsolutePath();file.getPath();file.getName();file.list();            <span class="hljs-comment">// String[fileName]</span>file.listFiles();       <span class="hljs-comment">// File[file]</span>file.isFile();file.isDirectory();file.isDirectory();file.exists();file.canExecute();file.canRead();file.canWrite();file.lastModified();file.length();<span class="hljs-comment">// 通过过滤器过滤文件</span>file.listFiles(<span class="hljs-keyword">new</span> FilenameFilter() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir, String name)</span> </span>&#123;        <span class="hljs-keyword">if</span> (name.contains(<span class="hljs-string">&quot;123&quot;</span>))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;);<span class="hljs-comment">// 文件创建、删除、重命名</span><span class="hljs-keyword">if</span> (!file.exists())&#123;    file.createNewFile();&#125;file.delete();file.renameTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newFilePath&quot;</span>));file.mkdir();file.mkdirs();<span class="hljs-comment">// 创建临时文件，参数3不填时，调用系统的临时文件配置(&quot;java.io.tmpdir&quot;)</span>File file = File.createTempFile(<span class="hljs-string">&quot;test_&quot;</span> ,<span class="hljs-string">&quot;.tmp&quot;</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/tmp&quot;</span>));</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-节点流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/02-%E8%8A%82%E7%82%B9%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/02-%E8%8A%82%E7%82%B9%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="../images/2019-05-20-15-28-21.png"></p><h2 id="四大基流"><a href="#四大基流" class="headerlink" title="四大基流"></a>四大基流</h2><ul><li>字符输入流Reader</li><li>字符输出流Weiter</li><li>字节输入流InputStream</li><li>字节输出流OutputStream</li></ul><p>四大基流都是接口，作为管道的作用</p><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建源/目标对象</span><span class="hljs-comment">// 2. 创建流对象</span><span class="hljs-comment">// 3. 流操作read/write</span><span class="hljs-comment">// 4. 关流</span></code></pre><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ol><li>InputStream</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 文件 -&gt; 程序</span>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);InputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));&#125;in.close();</code></pre><ol start="2"><li>OutputStream</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 程序 -&gt; 文件</span>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(file,<span class="hljs-keyword">false</span>); out.write(<span class="hljs-number">67</span>);  <span class="hljs-comment">// C</span>out.write(<span class="hljs-string">&quot;ABC&quot;</span>.getByte());out.close();</code></pre><h2 id="文件复制和异常处理"><a href="#文件复制和异常处理" class="headerlink" title="文件复制和异常处理"></a>文件复制和异常处理</h2><pre><code class="hljs java"><span class="hljs-comment">// jdk1.6之前正确的关闭异常</span>InputStream in = <span class="hljs-keyword">null</span>;OutputStream out = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);    File fileSave = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test_copy.txt&quot;</span>);    in = <span class="hljs-keyword">new</span> FileInputStream(file);    out = <span class="hljs-keyword">new</span> FileOutputStream(fileSave);    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        out.write(buffer, <span class="hljs-number">0</span>, len);    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;            in.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;            out.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">// 错误1，out/in可能为null，出现NullPointExcption</span><span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        in.close();        out.close();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">// 错误2，in.close()会抛出异常，导致out.close()没有执行</span><span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;            in.close();        &#125;        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;            out.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><ul><li>jdk1.7开始的自动关闭，基于<code>AutoCloseable</code>接口</li></ul><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);File fileSave = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test_copy.txt&quot;</span>);<span class="hljs-keyword">try</span> (        <span class="hljs-comment">// 需要自动关闭的资源</span>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);        OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(fileSave);) &#123;    <span class="hljs-comment">// 操作代码</span>    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        out.write(buffer, <span class="hljs-number">0</span>, len);    &#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader</p><p>Weiter</p><h2 id="flush操作"><a href="#flush操作" class="headerlink" title="flush操作"></a>flush操作</h2><p>使用了内存的缓冲区，避免每次操作的时候都直接操作IO，flush的时候一次性写到磁盘</p><pre><code class="hljs java"><span class="hljs-comment">// 在不关流的情况下，不使用flush()将无法将输出写出到文件</span><span class="hljs-keyword">try</span> &#123;    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;saveFile.txt&quot;</span>);    Writer writer = <span class="hljs-keyword">new</span> FileWriter(file);    writer.write(<span class="hljs-string">&quot;A&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;</code></pre><ul><li><p>哪些流的flush()方法有效</p><ul><li>字符流</li><li>部分字节流【子类重写的才有】，如缓冲流</li></ul></li><li><p>如何调用flush()方法：无需手动调用，close()方法会自动flush();</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-包装流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/03-%E5%8C%85%E8%A3%85%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/03-%E5%8C%85%E8%A3%85%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="包装流"><a href="#包装流" class="headerlink" title="包装流"></a>包装流</h1><ul><li>节点流：直接操作IO的流操作，如四大基流的实现类</li><li>包装流：封装节点流，提供更加高级的流操作，如缓冲流</li></ul><p>包装流需要一个节点流作为参数</p><pre><code class="hljs java">BufferedOutputStream out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>));</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-缓冲流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/04-%E7%BC%93%E5%86%B2%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/04-%E7%BC%93%E5%86%B2%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><ul><li>提供了默认的缓冲区，以及更佳优越的算法设计，提高流操作的效率，提供更高层的实现，避免直接使用节点流，建议使用</li></ul><h2 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h2><pre><code class="hljs java"><span class="hljs-comment">// JDK1.7之前</span>BufferedOutputStream out = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>));    out.write(<span class="hljs-string">&quot;Hello World&quot;</span>.getBytes());&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 只需要关缓冲流</span>            out.close();        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="hljs-comment">// jdk1.7以后，自动关闭</span><span class="hljs-keyword">try</span> (        BufferedOutputStream out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>));) &#123;    out.write(<span class="hljs-string">&quot;Hello World&quot;</span>.getBytes());&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span> (BufferedInputStream in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file.txt&quot;</span>))) &#123;    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;        System.out.println(<span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len));    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="BufferedReader-readLine"><a href="#BufferedReader-readLine" class="headerlink" title="BufferedReader - readLine"></a>BufferedReader - readLine</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;file_char.txt&quot;</span>))) &#123;    String line;    <span class="hljs-keyword">while</span> ((line = reader.readLine())!=<span class="hljs-keyword">null</span>)&#123;        System.out.println(line);    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="BufferedWriter-newLine"><a href="#BufferedWriter-newLine" class="headerlink" title="BufferedWriter - newLine"></a>BufferedWriter - newLine</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span>(BufferedWriter writer = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;file_char.txt&quot;</span>)))&#123;    writer.write(<span class="hljs-string">&quot;line1&quot;</span>);    writer.newLine();    writer.write(<span class="hljs-string">&quot;line2&quot;</span>);&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;    e.printStackTrace();&#125;</code></pre><h2 id="缓冲区大小"><a href="#缓冲区大小" class="headerlink" title="缓冲区大小"></a>缓冲区大小</h2><p>字节流：8192字节</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="hljs-number">8192</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> </span>&#123;    <span class="hljs-keyword">this</span>(in, DEFAULT_BUFFER_SIZE);&#125;</code></pre><p>字符流：8192字符</p><pre><code class="java">private static int defaultCharBufferSize = 8192;public BufferedReader(Reader in) &#123;    this(in, defaultCharBufferSize);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-内存流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/06-%E5%86%85%E5%AD%98%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/06-%E5%86%85%E5%AD%98%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h1><p>数组流也叫内存流，将数据临时存放在内存中。内存流无需关闭，因为其在内存中，没有资源占用</p><ul><li>一般不会成对使用，内存复制到内存很傻逼,在传入参数为writer 或reader的时候会用，很多时候使用writer来实现无返回参数的方法调用，把结果存在writer中返回</li></ul><h2 id="字节数组流-ByteArrayInputStream-ByteArrayOutputStream"><a href="#字节数组流-ByteArrayInputStream-ByteArrayOutputStream" class="headerlink" title="字节数组流 - ByteArrayInputStream - ByteArrayOutputStream"></a>字节数组流 - ByteArrayInputStream - ByteArrayOutputStream</h2><pre><code class="hljs java"><span class="hljs-comment">// 输出流演示</span>ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream();out.write(<span class="hljs-string">&quot;AAAAA&quot;</span>.getBytes());<span class="hljs-comment">// 从数组输出流中获得缓冲内容</span><span class="hljs-keyword">byte</span>[] buffer = out.toByteArray();System.out.println(<span class="hljs-keyword">new</span> String(buffer));<span class="hljs-comment">// 输入流演示</span>ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(buffer);<span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = in.read(bytes)) != -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len));&#125;</code></pre><h2 id="字符数组流-CharArrayReader-CharArrayWriter"><a href="#字符数组流-CharArrayReader-CharArrayWriter" class="headerlink" title="字符数组流 - CharArrayReader - CharArrayWriter"></a>字符数组流 - CharArrayReader - CharArrayWriter</h2><pre><code class="hljs java"><span class="hljs-comment">// 输出流演示</span>CharArrayWriter writer = <span class="hljs-keyword">new</span> CharArrayWriter();writer.write(<span class="hljs-string">&quot;AAAAA&quot;</span>);<span class="hljs-comment">// 从数组输出流中获得缓冲内容</span><span class="hljs-keyword">char</span>[] buffer = writer.toCharArray();System.out.println(<span class="hljs-keyword">new</span> String(buffer));<span class="hljs-comment">// 输入流演示</span>CharArrayReader reader = <span class="hljs-keyword">new</span> CharArrayReader(buffer);<span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = reader.read(chars)) != -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-keyword">new</span> String(chars, <span class="hljs-number">0</span>, len));&#125;</code></pre><h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><pre><code class="hljs java"><span class="hljs-comment">// 输出流演示</span>StringWriter writer = <span class="hljs-keyword">new</span> StringWriter();writer.write(<span class="hljs-string">&quot;AAAAA&quot;</span>);<span class="hljs-comment">// 从数组输出流中获得缓冲内容</span>String buffer = writer.toString();System.out.println(buffer);<span class="hljs-comment">// 输入流演示</span>StringReader reader = <span class="hljs-keyword">new</span> StringReader(buffer);<span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">while</span> ((len = reader.read(chars)) != -<span class="hljs-number">1</span>) &#123;    System.out.println(<span class="hljs-keyword">new</span> String(chars, <span class="hljs-number">0</span>, len));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-转换流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/05-%E8%BD%AC%E6%8D%A2%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/05-%E8%BD%AC%E6%8D%A2%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><ul><li>在数据类型不同时进行转换，将字符流转为字节流进行处理</li></ul><h2 id="字节流转字符流"><a href="#字节流转字符流" class="headerlink" title="字节流转字符流"></a>字节流转字符流</h2><p>不存在这个转换</p><h2 id="字符流转字节流"><a href="#字符流转字节流" class="headerlink" title="字符流转字节流"></a>字符流转字节流</h2><p>通过<code>OutputStreamWriter()</code> <code>InputStreamReader</code>实现流转换</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> (        OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.txt&quot;</span>);        Writer writer = <span class="hljs-keyword">new</span> OutputStreamWriter(out);) &#123;    writer.write(<span class="hljs-string">&quot;哈哈啊哈&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-顺序流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/07-%E9%A1%BA%E5%BA%8F%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/07-%E9%A1%BA%E5%BA%8F%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序流"><a href="#顺序流" class="headerlink" title="顺序流"></a>顺序流</h1><p>合并流也叫顺序流，只有字节输入流存在合并流，仅此一个</p><h2 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span> (        InputStream in1 = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file1.txt&quot;</span>);        InputStream in2 = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file2.txt&quot;</span>);        InputStream in = <span class="hljs-keyword">new</span> SequenceInputStream(in1, in2);) &#123;    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">int</span> len;    <span class="hljs-keyword">while</span> ((len = in.read(buffer))!=-<span class="hljs-number">1</span>)&#123;        System.out.println(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-对象流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/08-%E5%AF%B9%E8%B1%A1%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/08-%E5%AF%B9%E8%B1%A1%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h1><ul><li>提供了对象的保存方法，将对象进行序列化和反序列化，一般不会自己使用，由JVM完成</li></ul><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>将JAVA对象通过序列化技术转为可以传输/存储的数据流。</p><p><img src="../images/2019-05-22-17-22-34.png"></p><h2 id="java-io-Serializable"><a href="#java-io-Serializable" class="headerlink" title="java.io.Serializable"></a>java.io.Serializable</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-comment">// TOTO</span>&#125;<span class="hljs-comment">// 判断是否可序列化</span>Object object = <span class="hljs-keyword">new</span> SerializeDemo();<span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> Serializable)&#123;    System.out.println(<span class="hljs-string">&quot;可序列化&quot;</span>);&#125;</code></pre><h2 id="序列化-ObjectOutputStream"><a href="#序列化-ObjectOutputStream" class="headerlink" title="序列化 - ObjectOutputStream"></a>序列化 - ObjectOutputStream</h2><p><code>ObjectOutputStream</code>是一个包装流</p><pre><code class="hljs java">SerializeDemo serializeDemo = <span class="hljs-keyword">new</span> SerializeDemo();serializeDemo.setName(<span class="hljs-string">&quot;岑忠满123&quot;</span>);<span class="hljs-comment">// 序列化</span><span class="hljs-keyword">try</span> (ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;Object.txt&quot;</span>))) &#123;    out.writeObject(serializeDemo);&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="反序列化-ObjectInputStream"><a href="#反序列化-ObjectInputStream" class="headerlink" title="反序列化 - ObjectInputStream"></a>反序列化 - ObjectInputStream</h2><p>执行反序列化操作必须存在字节码(.class)文件</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> (ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;Object.txt&quot;</span>))) &#123;    Object object = in.readObject();    <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> SerializeDemo) &#123;        SerializeDemo serializeDemo = (SerializeDemo) object;        System.out.println(serializeDemo.getName());    &#125;&#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="部分字段不进行反系列化（如密码）"><a href="#部分字段不进行反系列化（如密码）" class="headerlink" title="部分字段不进行反系列化（如密码）"></a>部分字段不进行反系列化（如密码）</h2><p>序列化和反序列化不对，<code>静态</code>和<code>非瞬态</code>字段进行操作</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> String passwd;<span class="hljs-keyword">transient</span> String passwd;</code></pre><h2 id="反序列化的版本问题"><a href="#反序列化的版本问题" class="headerlink" title="反序列化的版本问题"></a>反序列化的版本问题</h2><p>在进行序列化操作的时候，序列化的对象会根据class文件的内容（字段），自动生成一个<code>serialVersionUID</code>存储到序列化对象中，如果反序列化的时候，ID不相同会反序列化失败，抛出<code>InvalidClassException</code>异常</p><p><a href="https://blog.csdn.net/wangkaichenjuan/article/details/70053209">IDEA自动生成serialVersionUID</a></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123312523445L</span>;</code></pre><p>若显示指定<code>serialVersionUID</code>，<code>serialVersionUID</code>相同而出现前后字段不一致时，缺失的字段会被忽略，序列化和反序列化正常</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-打印流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/09-%E6%89%93%E5%8D%B0%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/09-%E6%89%93%E5%8D%B0%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><ul><li>提供了print println pringf等流的打印方法</li></ul><h2 id="字节打印流-PrintStream"><a href="#字节打印流-PrintStream" class="headerlink" title="字节打印流 - PrintStream"></a>字节打印流 - PrintStream</h2><p>无缓冲</p><pre><code class="hljs java"><span class="hljs-comment">// 默认关闭自动刷新，但是由于没有缓冲区，因此，即使不刷新也会即时输出</span>PrintStream out = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Print.out&quot;</span>));out.print(<span class="hljs-string">&quot;HaHa&quot;</span>);out.println(<span class="hljs-string">&quot;Haha2&quot;</span>);out.close();</code></pre><h2 id="字符打印流-PrintWriter"><a href="#字符打印流-PrintWriter" class="headerlink" title="字符打印流 - PrintWriter"></a>字符打印流 - PrintWriter</h2><p>带缓冲</p><pre><code class="hljs java"><span class="hljs-comment">// 默认是关闭自动刷新，必须手动刷新或close()</span>PrintWriter writer = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Print.txt&quot;</span>));writer.print(<span class="hljs-string">&quot;HaHa&quot;</span>);writer.println(<span class="hljs-string">&quot;Haha2&quot;</span>);writer.close();<span class="hljs-comment">// 启动自动刷新后，当遇到printf()println()format()方法，刷新输出流</span>PrintWriter writer = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;Print.txt&quot;</span>)),<span class="hljs-keyword">true</span>);writer.print(<span class="hljs-string">&quot;HaHa&quot;</span>);writer.println(<span class="hljs-string">&quot;Haha2&quot;</span>); <span class="hljs-comment">// 自动刷新</span></code></pre><h2 id="println"><a href="#println" class="headerlink" title="println()"></a>println()</h2><pre><code class="hljs java">System.out.println(Object x);<span class="hljs-comment">// 底层实现</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PrintStream out = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// out是一个PrintString常量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(Object x)</span> </span>&#123;    String s = String.valueOf(x);    <span class="hljs-keyword">synchronized</span> (lock) &#123;        print(s);        println();    &#125;&#125;</code></pre><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>%s</td><td>String</td></tr><tr><td>%d</td><td>Int</td></tr><tr><td>%f</td><td>Float</td></tr><tr><td>%b</td><td>boolean</td></tr><tr><td>%c</td><td>char</td></tr><tr><td>%t</td><td>time</td></tr></tbody></table><p>当然，%s可以接受全世界</p><pre><code class="hljs java">System.out.printf(<span class="hljs-string">&quot;我是%s，今年%d岁&quot;</span>,<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-number">19</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-标准输入输出</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/10-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/10-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h1><ul><li>标准输入:键盘, System.in</li><li>标准输出:显示屏, System.out</li><li>标准错误:System.err</li></ul><h2 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h2><pre><code class="hljs java"><span class="hljs-comment">// 接受键盘输入</span><span class="hljs-keyword">try</span> (InputStream in = System.in) &#123;    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];    <span class="hljs-keyword">int</span> len = in.read(bytes);    System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="重定向标准输入流"><a href="#重定向标准输入流" class="headerlink" title="重定向标准输入流"></a>重定向标准输入流</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    System.setIn(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file1.txt&quot;</span>));    InputStream in = System.in;    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];    <span class="hljs-keyword">int</span> len = in.read(bytes);    System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len));&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><pre><code class="hljs java">System.out.println();System.out.print();</code></pre><h2 id="重定向标准输出流"><a href="#重定向标准输出流" class="headerlink" title="重定向标准输出流"></a>重定向标准输出流</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    System.setOut(<span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;std.out&quot;</span>))));    System.out.println(<span class="hljs-string">&quot;哈哈哈&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><h2 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h2><pre><code class="hljs java"><span class="hljs-comment">// 会改变终端的输出顺序，尽量不使用</span>System.err.println(<span class="hljs-string">&quot;Error&quot;</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-扫描器</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/11-%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/11-%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h1><p>java.util.Scanner，提供了readLine()方法</p><ul><li>简化文件操作等</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 扫描文件</span><span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;file1.txt&quot;</span>)))&#123;    <span class="hljs-keyword">while</span> (scanner.hasNext())&#123;        System.out.println(scanner.nextLine());    &#125;&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;    e.printStackTrace();&#125;<span class="hljs-comment">// 扫描标准输入</span>Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;    System.out.println(scanner.nextLine());&#125;scanner.close();</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-数据流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/12-%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/12-%E6%95%B0%E6%8D%AE%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>提供了大量的数据输入输出的方法，如<code>readInt()</code>,<code>writerInt()</code></p><ul><li>作为RandomAccessFile的基类，单独使用不多</li><li>即使我们在下文中输出到文件，但是是二进制编码，不是简单的txt格式</li></ul><h2 id="数据输入流-DataInputStream"><a href="#数据输入流-DataInputStream" class="headerlink" title="数据输入流 - DataInputStream"></a>数据输入流 - DataInputStream</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span>(DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;data.out&quot;</span>))))&#123;    System.out.println(in.readDouble());&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;    e.printStackTrace();&#125;</code></pre><h2 id="数据输出流-DataOutputStream"><a href="#数据输出流-DataOutputStream" class="headerlink" title="数据输出流 - DataOutputStream"></a>数据输出流 - DataOutputStream</h2><pre><code class="hljs java"><span class="hljs-keyword">try</span>(DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;data.out&quot;</span>))))&#123;    out.writeDouble(<span class="hljs-number">1.23</span>);&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;    e.printStackTrace();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13-随机访问文件</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/13-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/13-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="随机访问文件-RandomAccessFile"><a href="#随机访问文件-RandomAccessFile" class="headerlink" title="随机访问文件 RandomAccessFile"></a>随机访问文件 RandomAccessFile</h1><p>随机访问文件，让程序能够操作文件的任意位置而不仅仅是头尾，<code>RandomAccessFile</code>类的实例支持对随机访问文件的读取和写入。</p><ul><li>常常用于多线程文件/断点下载</li><li>这里的UTF为UTF-8修改版，带有两个字节的前缀</li></ul><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>支持的模式</p><table><thead><tr><th>mode</th><th>解释</th></tr></thead><tbody><tr><td>r</td><td>read</td></tr><tr><td>rw</td><td>读写</td></tr><tr><td>rws</td><td>读写，内容和元数据同步到底层设备</td></tr><tr><td>rwd</td><td>读写，内容同步到底层设备</td></tr></tbody></table><h2 id="操作文件指针读取"><a href="#操作文件指针读取" class="headerlink" title="操作文件指针读取"></a>操作文件指针读取</h2><pre><code class="hljs java"><span class="hljs-comment">// 直接设置文件指针的位置进行读取，1+2+6 = 9</span>randomAccessFile.seek(<span class="hljs-number">9</span>);System.out.println(randomAccessFile.readUTF());<span class="hljs-comment">// 设置文件指针跳过n个字节</span>randomAccessFile.skip(<span class="hljs-number">2</span>);System.out.println(randomAccessFile.readByte());</code></pre><h2 id="操作文件指针存储"><a href="#操作文件指针存储" class="headerlink" title="操作文件指针存储"></a>操作文件指针存储</h2><pre><code class="hljs java"><span class="hljs-comment">// 跳到指定位置进行存储</span>randomAccessFile.seek(<span class="hljs-number">9</span>);randomAccessFile.writeUTF(<span class="hljs-string">&quot;前面有9个空白byte&quot;</span>)<span class="hljs-comment">// 设置文件大小，100K</span>randomAccessFile.setLength(<span class="hljs-number">100000</span>);</code></pre><h2 id="多线程下载任务"><a href="#多线程下载任务" class="headerlink" title="多线程下载任务"></a>多线程下载任务</h2><p><img src="../images/2019-05-23-17-41-03.png"></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>3K的文件，根据下载请求任意位置读取-如中间的部分</p> <pre><code class="hljs java">randomAccessFile.seek(<span class="hljs-number">1000</span>);randomAccessFile.read(...);</code></pre></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li><p>创建3K大小的文件</p> <pre><code class="hljs java">randomAccessFile.setLength(<span class="hljs-number">3000</span>);</code></pre></li><li><p>按照下载亲求任意位置写入,如中间的部分</p> <pre><code class="hljs java">randomAccessFile.seek(<span class="hljs-number">1000</span>);randomAccessFile.write(...);</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-管道流</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/14-%E7%AE%A1%E9%81%93%E6%B5%81/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/14-%E7%AE%A1%E9%81%93%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h1><p>管道可以通过构造器进行连接，从而实现从输出流 -&gt; 输入流</p><ul><li>用的不多</li></ul><h2 id="字节管道输入流-PipeInputStream"><a href="#字节管道输入流-PipeInputStream" class="headerlink" title="字节管道输入流 - PipeInputStream"></a>字节管道输入流 - PipeInputStream</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        OutThread out = <span class="hljs-keyword">new</span> OutThread();        InThread in = <span class="hljs-keyword">new</span> InThread(out.getOut());        out.start();        in.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> PipedOutputStream out = <span class="hljs-keyword">new</span> PipedOutputStream();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">65</span>; i &lt; <span class="hljs-number">65</span> + <span class="hljs-number">26</span>; i++) &#123;                out.write(i);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                out.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">super</span>.run();    &#125;    <span class="hljs-function">PipedOutputStream <span class="hljs-title">getOut</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.out;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> InputStream in;    <span class="hljs-comment">// 重点，将out管道对接到in管道</span>    InThread(PipedOutputStream out) <span class="hljs-keyword">throws</span> IOException &#123;        in = <span class="hljs-keyword">new</span> PipedInputStream(out);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> len;            <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;                System.out.println(<span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len));            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">super</span>.run();    &#125;&#125;</code></pre><h2 id="字节管道输出流-PipeOutputStream"><a href="#字节管道输出流-PipeOutputStream" class="headerlink" title="字节管道输出流 - PipeOutputStream"></a>字节管道输出流 - PipeOutputStream</h2><h2 id="字符管道输入流-PipeReader"><a href="#字符管道输入流-PipeReader" class="headerlink" title="字符管道输入流 - PipeReader"></a>字符管道输入流 - PipeReader</h2><h2 id="字符管道输出流-PipeWriter"><a href="#字符管道输出流-PipeWriter" class="headerlink" title="字符管道输出流 - PipeWriter"></a>字符管道输出流 - PipeWriter</h2>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-NIO</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/15-NIO/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/15-NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>我们可以称原本的IO为BIO，New IO ，从JDK1.4开始，将磁盘中的文件映射到内存中，再去内存中读取数据，提高读写效率。用于替代Java中原本的IO API。</p><p><a href="https://mp.weixin.qq.com/s/c9tkrokcDQR375kiwCeV9w">参考博客</a></p><h2 id="java-nio-Files-文件工具类"><a href="#java-nio-Files-文件工具类" class="headerlink" title="java.nio.Files 文件工具类"></a>java.nio.Files 文件工具类</h2><pre><code class="hljs java"><span class="hljs-comment">// 实现文件复制 - 底层通过字节流实现复制</span>Path path = Paths.get(<span class="hljs-string">&quot;file.out&quot;</span>);Files.copy(path,<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file.out.copy&quot;</span>));</code></pre><h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h2><p>Channel对应BIO中的Stream，Stream是单向的，而Channel是双向的，可以进行读写操作，Channel的四种实现</p><ol><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ol><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><img src="../images/2019-05-23-22-24-05.png"></p><p>Buffer顾名思义是缓冲区的意思，具体实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Stack</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/02-Stack/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/02-Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><ul><li>使用的数据结构：数组</li><li>使用建议：不建议使用<ul><li>推荐使用<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></li></ul></li></ul><p>Stack 类是在jdk1.1中就有的容器类方法，表示后进先出（LIFO）的对象堆栈。Stack的实现有两种方式，<code>数组</code>和<code>链表</code>，源码中使用<code>数组实现</code></p><ul><li>源码分析：</li></ul><pre><code class="hljs java"><span class="hljs-comment">// Stack是Vector的继承类</span><span class="hljs-keyword">public</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Vector</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">// 默认的构造器啥也没有</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">// 加到栈顶，位于数组的末尾</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">push</span><span class="hljs-params">(E item)</span> </span>&#123;        addElement(item);        <span class="hljs-keyword">return</span> item;    &#125;    <span class="hljs-comment">// 从栈顶取出</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        E       obj;        <span class="hljs-keyword">int</span>     len = size();        obj = peek();        removeElementAt(len - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> obj;    &#125;    <span class="hljs-comment">// 获得栈顶，但不取出</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span>     len = size();        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();        <span class="hljs-keyword">return</span> elementAt(len - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">// 获得元素到栈顶的距离</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = lastIndexOf(o);        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> size() - i;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 其他方法继承自Vector，如isEmpty()、add()等</span>&#125;</code></pre><p>而，官方建议使用ArrayDeque而不是Stack</p><blockquote><p>Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set，应该优先使用此 set，而非Stack类。例如：<br>Deque<Integer> stack = new ArrayDeque<Integer>();</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>01-List</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-LinkedList</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/04-LinkedList/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01-List/04-LinkedList/</url>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><ul><li><p>使用的数据结构：双向链表</p></li><li><p>实现的数据结构：双向链表、单项队列、双向队列、栈</p></li><li><p>使用建议：建议使用</p><ul><li>LinkedList扩容易，索引难</li><li>ArrayList索引易，扩容难</li><li>多线程使用<code>List list = Collections.synchronizedList(new LinkedList(...));</code></li><li>单线程使用LinkedList</li></ul></li><li><p>源码分析</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">// LinkedList实现了List Deque</span>        <span class="hljs-comment">// Deque继承自Queue</span>&#125;</code></pre><p>建议使用<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</code>而不是<code>List&lt;&gt; list = new LinkedList&lt;&gt;()</code>，这样可以使用<code>list.getFirst()等方法</code></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>01-List</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Iterator迭代器</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/02-%E9%9B%86%E5%90%88%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%93%8D%E4%BD%9C/01-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/02-%E9%9B%86%E5%90%88%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%93%8D%E4%BD%9C/01-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>Iterator是一个接口，实现该接口的类拥有迭代器</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for-each循环底层实现是使用迭代器实现</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Object o:list)&#123;    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="while-Iterator"><a href="#while-Iterator" class="headerlink" title="while Iterator"></a>while Iterator</h2><pre><code class="hljs java">Iterator it = list.iterator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;    Object o = it.next();    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="for-Iterator"><a href="#for-Iterator" class="headerlink" title="for Iterator"></a>for Iterator</h2><p>相比while Iterator有更好的性能，因为变量<code>it</code>在迭代结束时销毁</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Iterator it = list.iterator;it.hasNext();)&#123;    Object o = it.next();    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="for-each原理解析"><a href="#for-each原理解析" class="headerlink" title="for-each原理解析"></a>for-each原理解析</h2><p>for-each是语法糖</p><h3 id="for-each操作Array"><a href="#for-each操作Array" class="headerlink" title="for-each操作Array"></a>for-each操作Array</h3><p>使用for-each操作Array时，实际上使用的是简单<code>for()</code>循环</p><h3 id="for-each操作Iterable的实现类"><a href="#for-each操作Iterable的实现类" class="headerlink" title="for-each操作Iterable的实现类"></a>for-each操作Iterable的实现类</h3><p>使用for-each操作Iterable的实现类时，实际上使用的是迭代器</p><p>然而，<strong>在操作时需要删除元素的时候不能使用for-each</strong>，Iterator在进行迭代时会产生一个迭代线程，该线程将主线程的实现类对象进行了拷贝，其检测到主线程和迭代线程对象的值长度不同时，会抛出<strong>并发修改异常</strong><code>ConcurrentModificationException</code></p><pre><code class="hljs java">Iterator it = list.itrator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;    Object o = it.next();    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;a&quot;</span>.equals(o))&#123;        <span class="hljs-comment">// 操作迭代器的删除方法，将同时删除迭代器线程和主线程的元素</span>        it.remove();        <span class="hljs-comment">// 错误的实现</span>        <span class="hljs-comment">// list.remove();</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>02-集合的迭代操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-泛型</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/03-%E6%B3%9B%E5%9E%8B/01-%E6%B3%9B%E5%9E%8B/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/01-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/03-%E6%B3%9B%E5%9E%8B/01-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是用于给调用这来声明元素/类型的语法糖</p><p>一般有四种表示</p><ul><li>T:type, 如接口的类型</li><li>E:element, 如集合中的元素</li><li>K:key, 如Map中的键</li><li>V:value,  如Map中的值</li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arrays</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// TODO</span>    &#125;    <span class="hljs-comment">// 错误示范,静态方法不支持类的泛型，因为泛型是在类实例化时设置如`new ArrayList&lt;String&gt;()`</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> E <span class="hljs-title">asList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// TODO</span>    &#125;&#125;</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ol><li>需要用到泛型的静态方法</li><li>只有一个方法需要泛型</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 一般来说，静态泛型方法的泛型由参数决定，如Arrays.asList方法</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;(a);&#125;<span class="hljs-comment">// 调用</span>STring[] strings = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>&#125;;List&lt;String&gt; list = Arrays.asList(strings);</code></pre><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>在进行参数传递的过程中，可以通过通配符来进行泛型传递</p><pre><code class="hljs java"><span class="hljs-comment">// 方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;    <span class="hljs-comment">// TODO</span>&#125;<span class="hljs-comment">// 调用</span>List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList();add(strings);</code></pre><h2 id="泛型的上限-extends-和下限-super"><a href="#泛型的上限-extends-和下限-super" class="headerlink" title="泛型的上限(extends)和下限(super)"></a>泛型的上限(extends)和下限(super)</h2><p>限制泛型必须是XX类的子类/父类（包括自己）</p><pre><code class="hljs java"><span class="hljs-comment">// 上限</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyColletions</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>&gt; </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? extends List&gt; list)</span></span>&#123;    <span class="hljs-comment">// TODO</span>&#125;<span class="hljs-comment">// 下限</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyColletions</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">super</span> <span class="hljs-title">List</span>&gt; </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> List&gt; list)</span></span>&#123;    <span class="hljs-comment">// TODO</span>&#125;</code></pre><h2 id="泛型的擦除和转换"><a href="#泛型的擦除和转换" class="headerlink" title="泛型的擦除和转换"></a>泛型的擦除和转换</h2><ol><li>泛型属于编译器级别的语法，在编译成class文件时会自动进行擦除</li><li>将泛型集合赋值给不带泛型集合室，泛型将被手动擦除</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 2. 将泛型集合赋值给不带泛型集合时，泛型将被手动擦除</span>List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();strings.add(<span class="hljs-string">&quot;A&quot;</span>);List list = <span class="hljs-keyword">new</span> ArrayList();list.add(<span class="hljs-number">1L</span>);list = strings;list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">// 此时list有三 个元素，元素0:[String]:A 元素1:[Long]:1 元素2:[Integer]:1</span></code></pre><h2 id="堆污染问题"><a href="#堆污染问题" class="headerlink" title="堆污染问题"></a>堆污染问题</h2><p>在泛型和可变参数共用时，可能导致堆污染问题（from jdk1.7）,可使用<code>@SafeVarargs</code>注解进行保护</p><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>01-集合框架</category>
      
      <category>03-泛型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-java文件操作</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/00-java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/03-IO%E6%93%8D%E4%BD%9C/00-java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Java文件操作"><a href="#Java文件操作" class="headerlink" title="Java文件操作"></a>Java文件操作</h1><ol><li>创建文件夹</li><li>创建文件 </li><li>删除文件</li><li>删除文件夹</li><li>删除一个文件下夹所有的文件夹</li><li>清空文件夹   </li><li>读取文件   </li><li>写入文件</li><li>写入随机文件</li><li>读取文件属性</li><li>写入属性</li><li>枚举一个文件夹中的所有文件</li><li>复制文件夹 </li><li>复制一个文件夹下所有的文件夹到另一个文件夹下</li><li>移动文件夹</li><li>移动一个文件夹下所有的文件夹到另一个目录下</li><li>以一个文件夹的框架在另一个目录创建文件夹和空文件</li><li>复制文件</li><li>复制一个文件夹下所有的文件到另一个目录</li></ol><pre><code class="hljs java"><span class="hljs-comment">//1.创建文件夹   </span><span class="hljs-comment">//import java.io.*;   </span>File myFolderPath = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-keyword">if</span> (!myFolderPath.exists()) &#123;          myFolderPath.mkdir();       &#125;   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;新建目录操作出错&quot;</span>);       e.printStackTrace();   &#125;      <span class="hljs-comment">//2.创建文件   </span><span class="hljs-comment">//import java.io.*;   </span>File myFilePath = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-keyword">if</span> (!myFilePath.exists()) &#123;           myFilePath.createNewFile();       &#125;       FileWriter resultFile = <span class="hljs-keyword">new</span> FileWriter(myFilePath);       PrintWriter myFile = <span class="hljs-keyword">new</span> PrintWriter(resultFile);       myFile.println(str2);       resultFile.close();   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;新建文件操作出错&quot;</span>);       e.printStackTrace();   &#125;      <span class="hljs-comment">//3.删除文件   </span><span class="hljs-comment">//import java.io.*;   </span>File myDelFile = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       myDelFile.delete();   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;删除文件操作出错&quot;</span>);       e.printStackTrace();   &#125;      <span class="hljs-comment">//4.删除文件夹   </span><span class="hljs-comment">//import java.io.*;   </span>File delFolderPath = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       delFolderPath.delete(); <span class="hljs-comment">//删除空文件夹   </span>&#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;删除文件夹操作出错&quot;</span>);       e.printStackTrace();   &#125;      <span class="hljs-comment">//5.删除一个文件下夹所有的文件夹   </span><span class="hljs-comment">//import java.io.*;   </span>File delfile=<span class="hljs-keyword">new</span> File(str1);   File[] files=delfile.listFiles();   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;files.length;i++)&#123;       <span class="hljs-keyword">if</span>(files[i].isDirectory())&#123;           files[i].delete();       &#125;   &#125;        <span class="hljs-comment">//6.清空文件夹   </span><span class="hljs-comment">//import java.io.*;   </span>File delfilefolder=<span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-keyword">if</span> (!delfilefolder.exists()) &#123;           delfilefolder.delete();       &#125;       delfilefolder.mkdir();   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;清空目录操作出错&quot;</span>);       e.printStackTrace();   &#125;      <span class="hljs-comment">//7.读取文件   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">// 逐行读取数据   </span>FileReader fr = <span class="hljs-keyword">new</span> FileReader(str1);   BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(fr);   String str2 = br.readLine();   <span class="hljs-keyword">while</span> (str2 != <span class="hljs-keyword">null</span>) &#123;       str3       str2 = br.readLine();   &#125;   br.close();   fr.close();      <span class="hljs-comment">//8.写入文件   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">// 将数据写入文件   </span><span class="hljs-keyword">try</span> &#123;       FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(str1);       fw.write(str2);       fw.flush();       fw.close();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;       e.printStackTrace();   &#125;     <span class="hljs-comment">//9.写入随机文件   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-keyword">try</span> &#123;       RandomAcessFile logFile=<span class="hljs-keyword">new</span> RandomAcessFile(str1,<span class="hljs-string">&quot;rw&quot;</span>);       <span class="hljs-keyword">long</span> lg=logFile.length();       logFile.seek(str2);       logFile.writeByte(str3);   &#125;<span class="hljs-keyword">catch</span>(IOException ioe)&#123;       System.out.println(<span class="hljs-string">&quot;无法写入文件：&quot;</span>+ioe.getMessage());   &#125;      <span class="hljs-comment">//10.读取文件属性   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">// 文件属性的取得   </span>File f = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">if</span> (af.exists()) &#123;       System.out.println(f.getName() + <span class="hljs-string">&quot;的属性如下： 文件长度为：&quot;</span> + f.length());       System.out.println(f.isFile() ? <span class="hljs-string">&quot;是文件&quot;</span> : <span class="hljs-string">&quot;不是文件&quot;</span>);       System.out.println(f.isDirectory() ? <span class="hljs-string">&quot;是目录&quot;</span> : <span class="hljs-string">&quot;不是目录&quot;</span>);       System.out.println(f.canRead() ? <span class="hljs-string">&quot;可读取&quot;</span> : <span class="hljs-string">&quot;不&quot;</span>);       System.out.println(f.canWrite() ? <span class="hljs-string">&quot;是隐藏文件&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);       System.out.println(<span class="hljs-string">&quot;文件夹的最后修改日期为：&quot;</span> + <span class="hljs-keyword">new</span> Date(f.lastModified()));       &#125; <span class="hljs-keyword">else</span> &#123;       System.out.println(f.getName() + <span class="hljs-string">&quot;的属性如下：&quot;</span>);       System.out.println(f.isFile() ? <span class="hljs-string">&quot;是文件&quot;</span> : <span class="hljs-string">&quot;不是文件&quot;</span>);       System.out.println(f.isDirectory() ? <span class="hljs-string">&quot;是目录&quot;</span> : <span class="hljs-string">&quot;不是目录&quot;</span>);       System.out.println(f.canRead() ? <span class="hljs-string">&quot;可读取&quot;</span> : <span class="hljs-string">&quot;不&quot;</span>);       System.out.println(f.canWrite() ? <span class="hljs-string">&quot;是隐藏文件&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);       System.out.println(<span class="hljs-string">&quot;文件的最后修改日期为：&quot;</span> + <span class="hljs-keyword">new</span> Date(f.lastModified()));   &#125;   <span class="hljs-keyword">if</span>(f.canRead())&#123;       str2   &#125;   <span class="hljs-keyword">if</span>(f.canWrite())&#123;       str3   &#125;     <span class="hljs-comment">//11.写入属性   </span><span class="hljs-comment">//import java.io.*;   </span>File filereadonly=<span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-keyword">boolean</span> b=filereadonly.setReadOnly();   &#125;   <span class="hljs-keyword">catch</span> (Exception e) &#123;       System.out.println(<span class="hljs-string">&quot;拒绝写访问：&quot;</span>+e.printStackTrace());   &#125;      <span class="hljs-comment">//12.枚举一个文件夹中的所有文件   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span>LinkedList&lt;String&gt; folderList = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();   folderList.add(str1);   <span class="hljs-keyword">while</span> (folderList.size() &gt; <span class="hljs-number">0</span>) &#123;       File file = <span class="hljs-keyword">new</span> File(folderList.peek());       folderList.removeLast();       File[] files = file.listFiles();       ArrayList&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;();       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) &#123;           <span class="hljs-keyword">if</span> (files[i].isDirectory()) &#123;               folderList.add(files[i].getPath());           &#125; <span class="hljs-keyword">else</span> &#123;               fileList.add(files[i]);           &#125;       &#125;       <span class="hljs-keyword">for</span> (File f : fileList) &#123;           str2=f.getAbsoluteFile();           str3       &#125;   &#125;     <span class="hljs-comment">//13.复制文件夹    </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span>LinkedList&lt;String&gt; folderList = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();   folderList.add(str1);   LinkedList&lt;String&gt; folderList2 = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();   folderList2.add(str2+ str1.substring(str1.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>)));   <span class="hljs-keyword">while</span> (folderList.size() &gt; <span class="hljs-number">0</span>) &#123;       (<span class="hljs-keyword">new</span> File(folderList2.peek())).mkdirs(); <span class="hljs-comment">// 如果文件夹不存在 则建立新文件夹   </span>    File folders = <span class="hljs-keyword">new</span> File(folderList.peek());       String[] file = folders.list();       File temp = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; file.length; i++) &#123;               <span class="hljs-keyword">if</span> (folderList.peek().endsWith(File.separator)) &#123;                   temp = <span class="hljs-keyword">new</span> File(folderList.peek() + File.separator                   + file[i]);               &#125; <span class="hljs-keyword">else</span> &#123;                   temp = <span class="hljs-keyword">new</span> File(folderList.peek() + File.separator + file[i]);               &#125;               <span class="hljs-keyword">if</span> (temp.isFile()) &#123;                   FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                   FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(                   folderList2.peek() + File.separator + (temp.getName()).toString());                   <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];                   <span class="hljs-keyword">int</span> len;                   <span class="hljs-keyword">while</span> ((len = input.read(b)) != -<span class="hljs-number">1</span>) &#123;                       output.write(b, <span class="hljs-number">0</span>, len);                   &#125;                   output.flush();                   output.close();                   input.close();               &#125;               <span class="hljs-keyword">if</span> (temp.isDirectory()) &#123;<span class="hljs-comment">// 如果是子文件夹   </span>                <span class="hljs-keyword">for</span> (File f : temp.listFiles()) &#123;                       <span class="hljs-keyword">if</span> (f.isDirectory()) &#123;                           folderList.add(f.getPath());                           folderList2.add(folderList2.peek()                           + File.separator + f.getName());                       &#125;                   &#125;               &#125;           &#125;       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;       <span class="hljs-comment">//System.out.println(&quot;复制整个文件夹内容操作出错&quot;);   </span>        e.printStackTrace();       &#125;       folderList.removeFirst();       folderList2.removeFirst();   &#125;     <span class="hljs-comment">//14.复制一个文件夹下所有的文件夹到另一个文件夹下   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span>File copyfolders=<span class="hljs-keyword">new</span> File(str1);   File[] copyfoldersList=copyfolders.listFiles();   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;copyfoldersList.length;k++)&#123;       <span class="hljs-keyword">if</span>(copyfoldersList[k].isDirectory())&#123;           ArrayList&lt;String&gt;folderList=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();           folderList.add(copyfoldersList[k].getPath());           ArrayList&lt;String&gt;folderList2=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();           folderList2.add(str2+<span class="hljs-string">&quot;/&quot;</span>+copyfoldersList[k].getName());           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;folderList.length;j++)&#123;                (<span class="hljs-keyword">new</span> File(folderList2.get(j))).mkdirs(); <span class="hljs-comment">//如果文件夹不存在 则建立新文件夹   </span>             File folders=<span class="hljs-keyword">new</span> File(folderList.get(j));                String[] file=folders.list();                File temp=<span class="hljs-keyword">null</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; file.length; i++) &#123;                        <span class="hljs-keyword">if</span>(folderList.get(j).endsWith(File.separator))&#123;                            temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                        &#125; <span class="hljs-keyword">else</span> &#123;                            temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+File.separator+file[i]);                        &#125;                        FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                        <span class="hljs-keyword">if</span>(temp.isFile())&#123;                            FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                            FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(folderList2.get(j) + <span class="hljs-string">&quot;/&quot;</span> + (temp.getName()).toString());                            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];                            <span class="hljs-keyword">int</span> len;                            <span class="hljs-keyword">while</span> ( (len = input.read(b)) != -<span class="hljs-number">1</span>) &#123;                                output.write(b, <span class="hljs-number">0</span>, len);                            &#125;                            output.flush();                            output.close();                            input.close();                        &#125;                        <span class="hljs-keyword">if</span>(temp.isDirectory())&#123;<span class="hljs-comment">//如果是子文件夹   </span>                         folderList.add(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                            folderList2.add(folderList2.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">catch</span> (Exception e) &#123;                    System.out.println(<span class="hljs-string">&quot;复制整个文件夹内容操作出错&quot;</span>);                    e.printStackTrace();                &#125;           &#125;       &#125;   &#125;     <span class="hljs-comment">//15.移动文件夹   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span>LinkedList&lt;String&gt; folderList = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();   folderList.add(str1);   LinkedList&lt;String&gt; folderList2 = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();   folderList2.add(str2 + str1.substring(str1.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>)));   <span class="hljs-keyword">while</span> (folderList.size() &gt; <span class="hljs-number">0</span>) &#123;       (<span class="hljs-keyword">new</span> File(folderList2.peek())).mkdirs(); <span class="hljs-comment">// 如果文件夹不存在 则建立新文件夹   </span>    File folders = <span class="hljs-keyword">new</span> File(folderList.peek());       String[] file = folders.list();       File temp = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; file.length; i++) &#123;               <span class="hljs-keyword">if</span> (folderList.peek().endsWith(File.separator)) &#123;                   temp = <span class="hljs-keyword">new</span> File(folderList.peek() + File.separator + file[i]);               &#125; <span class="hljs-keyword">else</span> &#123;                   temp = <span class="hljs-keyword">new</span> File(folderList.peek() + File.separator + file[i]);               &#125;               <span class="hljs-keyword">if</span> (temp.isFile()) &#123;                   FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                   FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(                   folderList2.peek() + File.separator + (temp.getName()).toString());                   <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];                   <span class="hljs-keyword">int</span> len;                   <span class="hljs-keyword">while</span> ((len = input.read(b)) != -<span class="hljs-number">1</span>) &#123;                       output.write(b, <span class="hljs-number">0</span>, len);                   &#125;                   output.flush();                   output.close();                   input.close();                   <span class="hljs-keyword">if</span> (!temp.delete())                   System.out.println(<span class="hljs-string">&quot;删除单个文件操作出错!&quot;</span>);               &#125;               <span class="hljs-keyword">if</span> (temp.isDirectory()) &#123;<span class="hljs-comment">// 如果是子文件夹   </span>                <span class="hljs-keyword">for</span> (File f : temp.listFiles()) &#123;                       <span class="hljs-keyword">if</span> (f.isDirectory()) &#123;                           folderList.add(f.getPath());                           folderList2.add(folderList2.peek() + File.separator + f.getName());                       &#125;                   &#125;               &#125;           &#125;       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           <span class="hljs-comment">// System.out.println(&quot;复制整个文件夹内容操作出错&quot;);   </span>        e.printStackTrace();       &#125;       folderList.removeFirst();       folderList2.removeFirst();   &#125;   File f = <span class="hljs-keyword">new</span> File(str1);   <span class="hljs-keyword">if</span> (!f.delete()) &#123;       <span class="hljs-keyword">for</span> (File file : f.listFiles()) &#123;           <span class="hljs-keyword">if</span> (file.list().length == <span class="hljs-number">0</span>) &#123;               System.out.println(file.getPath());               file.delete();           &#125;       &#125;   &#125;   <span class="hljs-comment">//16.移动一个文件夹下所有的文件夹到另一个目录下   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span>File movefolders=<span class="hljs-keyword">new</span> File(str1);   File[] movefoldersList=movefolders.listFiles();   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;movefoldersList.length;k++)&#123;       <span class="hljs-keyword">if</span>(movefoldersList[k].isDirectory())&#123;           ArrayList&lt;String&gt;folderList=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();           folderList.add(movefoldersList[k].getPath());           ArrayList&lt;String&gt;folderList2=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();           folderList2.add(str2+<span class="hljs-string">&quot;/&quot;</span>+movefoldersList[k].getName());           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;folderList.length;j++)&#123;                (<span class="hljs-keyword">new</span> File(folderList2.get(j))).mkdirs(); <span class="hljs-comment">//如果文件夹不存在 则建立新文件夹   </span>             File folders=<span class="hljs-keyword">new</span> File(folderList.get(j));                String[] file=folders.list();                File temp=<span class="hljs-keyword">null</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; file.length; i++) &#123;                        <span class="hljs-keyword">if</span>(folderList.get(j).endsWith(File.separator))&#123;                            temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                        &#125;                        <span class="hljs-keyword">else</span>&#123;                            temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+File.separator+file[i]);                        &#125;                        FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                        <span class="hljs-keyword">if</span>(temp.isFile())&#123;                            FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);                            FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(folderList2.get(j) + <span class="hljs-string">&quot;/&quot;</span> + (temp.getName()).toString());                            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];                            <span class="hljs-keyword">int</span> len;                            <span class="hljs-keyword">while</span> ( (len = input.read(b)) != -<span class="hljs-number">1</span>) &#123;                                output.write(b, <span class="hljs-number">0</span>, len);                            &#125;                            output.flush();                            output.close();                            input.close();                            temp.delete();                        &#125;                        <span class="hljs-keyword">if</span>(temp.isDirectory())&#123;<span class="hljs-comment">//如果是子文件夹   </span>                         folderList.add(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                            folderList2.add(folderList2.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">catch</span> (Exception e) &#123;                    System.out.println(<span class="hljs-string">&quot;复制整个文件夹内容操作出错&quot;</span>);                    e.printStackTrace();                &#125;           &#125;           movefoldersList[k].delete();       &#125;   &#125;     <span class="hljs-comment">//17.以一个文件夹的框架在另一个目录创建文件夹和空文件   </span><span class="hljs-comment">//import java.io.*;   </span><span class="hljs-comment">//import java.util.*;   </span><span class="hljs-keyword">boolean</span> b=<span class="hljs-keyword">false</span>;<span class="hljs-comment">//不创建空文件   </span>ArrayList&lt;String&gt;folderList=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();   folderList.add(str1);   ArrayList&lt;String&gt;folderList2=<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();   folderList2.add(str2);   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;folderList.length;j++)&#123;       (<span class="hljs-keyword">new</span> File(folderList2.get(j))).mkdirs(); <span class="hljs-comment">//如果文件夹不存在 则建立新文件夹   </span>    File folders=<span class="hljs-keyword">new</span> File(folderList.get(j));       String[] file=folders.list();       File temp=<span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; file.length; i++) &#123;               <span class="hljs-keyword">if</span>(folderList.get(j).endsWith(File.separator))&#123;                   temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);               &#125;               <span class="hljs-keyword">else</span>&#123;                   temp=<span class="hljs-keyword">new</span> File(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+File.separator+file[i]);               &#125;               FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(temp);               <span class="hljs-keyword">if</span>(temp.isFile())&#123;                   <span class="hljs-keyword">if</span> (b) temp.createNewFile();               &#125;               <span class="hljs-keyword">if</span>(temp.isDirectory())&#123;<span class="hljs-comment">//如果是子文件夹   </span>                folderList.add(folderList.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);                   folderList2.add(folderList2.get(j)+<span class="hljs-string">&quot;/&quot;</span>+file[i]);               &#125;           &#125;       &#125;       <span class="hljs-keyword">catch</span> (Exception e) &#123;           System.out.println(<span class="hljs-string">&quot;复制整个文件夹内容操作出错&quot;</span>);           e.printStackTrace();       &#125;   &#125;     <span class="hljs-comment">//18.复制文件   </span><span class="hljs-comment">//import java.io.*;   </span> <span class="hljs-keyword">int</span> bytesum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> byteread = <span class="hljs-number">0</span>;    File oldfile = <span class="hljs-keyword">new</span> File(str1);    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (oldfile.exists()) &#123; <span class="hljs-comment">//文件存在时   </span> FileInputStream inStream = <span class="hljs-keyword">new</span> FileInputStream(oldfile); <span class="hljs-comment">//读入原文件   </span> FileOutputStream fs = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(str2,oldfile.getName()));    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];    <span class="hljs-keyword">int</span> length;    <span class="hljs-keyword">while</span> ( (byteread = inStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;    bytesum += byteread; <span class="hljs-comment">//字节数 文件大小   </span> System.out.println(bytesum);    fs.write(buffer, <span class="hljs-number">0</span>, byteread);    &#125;    inStream.close();    &#125;    &#125;    <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.println(<span class="hljs-string">&quot;复制单个文件操作出错&quot;</span>);    e.printStackTrace();    &#125;      <span class="hljs-comment">//19.复制一个文件夹下所有的文件到另一个目录   </span><span class="hljs-comment">//import java.io.*;   </span>File copyfiles=<span class="hljs-keyword">new</span> File(str1);   File[] files=copyfiles.listFiles();   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;files.length;i++)&#123;       <span class="hljs-keyword">if</span>(!files[i].isDirectory())&#123;           <span class="hljs-keyword">int</span> bytesum = <span class="hljs-number">0</span>;           <span class="hljs-keyword">int</span> byteread = <span class="hljs-number">0</span>;           <span class="hljs-keyword">try</span> &#123;               InputStream inStream = <span class="hljs-keyword">new</span> FileInputStream(files[i]); <span class="hljs-comment">//读入原文件   </span>            FileOutputStream fs = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(str2,files[i].getName());               <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5120</span>];               <span class="hljs-keyword">int</span> length;               <span class="hljs-keyword">while</span> ( (byteread = inStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;                   bytesum += byteread; <span class="hljs-comment">//字节数 文件大小   </span>                System.out.println(bytesum);                   fs.write(buffer, <span class="hljs-number">0</span>, byteread);               &#125;               inStream.close();           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               System.out.println(<span class="hljs-string">&quot;复制单个文件操作出错&quot;</span>);               e.printStackTrace();           &#125;       &#125;   &#125;      <span class="hljs-comment">//提取扩展名   </span>String str2=str1.substring(str1.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>)+<span class="hljs-number">1</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>03-IO操作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-数据结构总结</title>
    <link href="/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <url>/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h1><table><thead><tr><th>名称</th><th>特点</th><th>实现</th></tr></thead><tbody><tr><td>Array</td><td>难插易查</td><td>Vector、Stack、ArrayList</td></tr><tr><td>Linked</td><td>易插难查</td><td>LinkedList</td></tr><tr><td>Stack</td><td>后入先出</td><td></td></tr></tbody></table><p><img src="../images/2019-12-24-16-13-44.png"></p><h2 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h2><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>]；data[<span class="hljs-number">0</span>]  = <span class="hljs-number">1</span>;</code></pre><ul><li>优点： <ol><li>按照索引查询元素速度快 </li><li>按照索引遍历数组方便</li></ol></li><li>缺点： <ol><li>数组的大小固定后就无法扩容了 </li><li>数组只能存储一种类型的数据 </li><li>添加，删除的操作慢，因为要移动其他的元素。</li></ol></li><li>适用场景： <ol><li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li></ol></li></ul><h2 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h2><p><img src="../images/2019-12-24-16-14-02.png"></p><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。 </p><p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p><h2 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h2><p><img src="../images/2019-12-24-16-14-24.png"></p><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下： </p><p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p><h2 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h2><p><img src="../images/2019-12-24-16-14-59.png"></p><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 </p><p>链表的优点：<br>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；<br>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</p><ul><li>缺点： <ol><li>因为含有大量的指针域，占用空间较大； </li><li>查找元素需要遍历链表来查找，非常耗时。</li></ol></li><li>适用场景： <ol><li>数据量较小，需要频繁增加，删除操作的场景</li></ol></li></ul><h2 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h2><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。 </p><p><img src="../images/2019-12-24-16-15-26.png"></p><p>二叉树是树的特殊一种，具有如下特点：</p><p>1、每个结点最多有两颗子树，结点的度最大为2。<br>2、左子树和右子树是有顺序的，次序不能颠倒。<br>3、即使某结点只有一个子树，也要区分左右子树。</p><p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p><p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p><h2 id="6、散列表"><a href="#6、散列表" class="headerlink" title="6、散列表"></a>6、散列表</h2><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><p>记录的存储位置=f(key)</p><p><img src="../images/2019-12-24-16-15-46.png"></p><p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p><p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下： </p><p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，<strong>找到正确的链表，再从链表中找出这个元素</strong>。</p><p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p><h2 id="7、堆"><a href="#7、堆" class="headerlink" title="7、堆"></a>7、堆</h2><p><img src="../images/2019-12-24-16-15-59.png"></p><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><p>堆中某个节点的值总是不大于或不小于其父节点的值；</p><p>堆总是一棵完全二叉树。</p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p><p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下： </p><p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p><h2 id="8、图"><a href="#8、图" class="headerlink" title="8、图"></a>8、图</h2><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p><p>按照顶点指向的方向可分为无向图和有向图： </p><p><img src="../images/2019-12-24-16-16-16.png"></p><p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构.</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>10-数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-图</title>
    <link href="/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03-%E5%9B%BE/"/>
    <url>/01-Java/01-JavaSE/10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p><img src="../images/2019-12-26-11-06-57.png"></p><ul><li>BFS广度：使用队列实现 ABFCIGEDH</li><li>DFS深度：（使用树的思想，先左后右）ABCDEFGHI</li></ul><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p><img src="../images/2019-12-26-11-14-32.png"></p><ul><li>BFS广度：12435</li><li>DFS深度：12453</li></ul><p><a href="https://www.jianshu.com/p/5c676d76f3a3">数据结构(深度优先遍历，广度优先遍历）</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>10-数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-BIO NIO AIO</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/01-BIO%20NIO%20AIO/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/01-BIO%20NIO%20AIO/</url>
    
    <content type="html"><![CDATA[<h1 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO NIO AIO"></a>BIO NIO AIO</h1><ol><li>BIO 就是传统的 java.io 包 BlockingIO <strong>同步、阻塞</strong><br>它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包 <strong>同步非阻塞</strong><br>提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包 <strong>异步非阻塞</strong><br>是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ol><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO基于流模型实现的</p><ul><li>InputStream 字节流</li><li>OutputStream 字节流</li><li>Reader 字符流</li><li>Writer 字符流</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO也叫<code>New I/O</code>，也可以叫<code>Non-bloking I/O</code>。</p><h3 id="java-nio-Channel"><a href="#java-nio-Channel" class="headerlink" title="java.nio.Channel"></a>java.nio.Channel</h3><p>Channel是一个双向通道，与传统IO操作只允许单向的读写不同的是，NIO的Channel允许在一个通道上进行读和写的操作。且Cannel是非阻塞的,只能通过Buffer来进行读写</p><ul><li>FileChannel 文件</li><li>DatagramChannel UDP</li><li>SocketChannel TCP</li><li>ServerSocketChannel TCP</li></ul><h3 id="java-nio-Buffer"><a href="#java-nio-Buffer" class="headerlink" title="java.nio.Buffer"></a>java.nio.Buffer</h3><p>Buffer是读取和写入Channel的唯一方式。</p><p>Buffer是一块连续数组内存区域，Java提供了一些属性和方法来操作这块内存区域。</p><ul><li>ByteBuffer</li><li>IntBuffer</li><li>FloatBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>ShortBuffer</li><li>LongBuffer</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 用于标记一个特定的position位置，调用reset()可以恢复position位置</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 写模式下：                     默认0 写入长度为100 position=100 </span><span class="hljs-comment">// 读模式下：从写模式切换到读模式 回到默认0 读取长度为100 position=100 </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<span class="hljs-comment">// 写模式下：limit表示最多能写入多少数据，limit=capacity</span><span class="hljs-comment">// 读模式下：limit表示最多能读出多少数据，limit=position</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<span class="hljs-comment">// buffer的大小，一旦Buffer满了，需要将其清空（通过读数据或者清楚数据）才能继续写数据。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;</code></pre><pre><code class="hljs java">ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">10</span>);</code></pre><p><img src="../images/2019-12-26-09-32-50.png"></p><pre><code class="hljs java">buffer.put(<span class="hljs-string">&quot;abc&quot;</span>.getBytes(StandardCharsets.UTF_8));</code></pre><p><img src="../images/2019-12-26-09-33-37.png"></p><pre><code class="hljs java">buffer.flip();</code></pre><p><img src="../images/2019-12-26-09-34-19.png"></p><pre><code class="hljs java">buffer.get();</code></pre><p><img src="../images/2019-12-26-09-35-49.png"></p><pre><code class="hljs java">buffer.mark();</code></pre><p><img src="../images/2019-12-26-09-37-07.png"></p><pre><code class="hljs java">buffer.get();buffer.reset();</code></pre><p><img src="../images/2019-12-26-09-37-25.png"></p><pre><code class="hljs java">buffer.clear();</code></pre><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector是NIO中能够检测1-n个通道，并能够知晓通道是否为读写事件做好准备的组件，通过它一个线程就能够管理多个channel，从而管理多个网络链接。</p><pre><code class="hljs java"><span class="hljs-comment">// 创建Selector</span>Selector selector = Selector.open();<span class="hljs-comment">// 注册channel到selector（注册读事件）</span>SelectionKey selectionKey = channel.register(selector, SelectionKey.OP_READ);<span class="hljs-comment">// 阻塞等待channel有就绪事件发生</span><span class="hljs-keyword">int</span> selectNum = selector.select();<span class="hljs-comment">// 获取SelectionKey集合</span>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</code></pre><p>四种就绪状态</p><ul><li>OP_READ</li><li>OP_WRITE</li><li>OP_CONNECT</li><li>OP_ACCEPT</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>04-NIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-NIO文件读写</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/02-NIO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/02-NIO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="NIO文件读写"><a href="#NIO文件读写" class="headerlink" title="NIO文件读写"></a>NIO文件读写</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><pre><code class="hljs java"><span class="hljs-comment">// 添加文件</span>FileWriter fileWriter = <span class="hljs-keyword">new</span> FileWriter(filePath, <span class="hljs-keyword">true</span>);fileWriter.write(Content);fileWriter.close();<span class="hljs-comment">// 读取文件</span>FileReader fileReader = <span class="hljs-keyword">new</span> FileReader(filePath);BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(fileReader);StringBuffer bf = <span class="hljs-keyword">new</span> StringBuffer();String str;<span class="hljs-keyword">while</span> ((str = bufferedReader.readLine()) != <span class="hljs-keyword">null</span>) &#123;    bf.append(str + <span class="hljs-string">&quot;\n&quot;</span>);&#125;bufferedReader.close();fileReader.close();System.out.println(bf.toString());</code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><pre><code class="hljs java"><span class="hljs-comment">// 写入文件（追加方式：StandardOpenOption.APPEND）</span>Files.write(Paths.get(filePath), Content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);<span class="hljs-comment">// 读取文件</span><span class="hljs-keyword">byte</span>[] data = Files.readAllBytes(Paths.get(filePath));System.out.println(<span class="hljs-keyword">new</span> String(data, StandardCharsets.UTF_8));</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>04-NIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-NIO网络编程模型</title>
    <link href="/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/03-NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/01-Java/01-JavaSE/03-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93/04-NIO/03-NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="NIO网络编程模型"><a href="#NIO网络编程模型" class="headerlink" title="NIO网络编程模型"></a>NIO网络编程模型</h1><h2 id="BIO网络编程模型"><a href="#BIO网络编程模型" class="headerlink" title="BIO网络编程模型"></a>BIO网络编程模型</h2><p><img src="../images/2019-12-25-15-54-50.png"></p><p>缺点：在并发量大的情况下，会有特别多的线程阻塞在等待客户端的响应，导致服务器压力过大。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> port = <span class="hljs-number">4343</span>; <span class="hljs-comment">//端口号</span><span class="hljs-comment">// Socket 服务器端（简单的响应&quot;hello world!&quot;信息）</span>Thread sThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// 等待连接</span>                Socket socket = serverSocket.accept();                <span class="hljs-comment">// ⚠️服务端多线程</span>                Thread sHandlerThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-keyword">try</span> (PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(socket.getOutputStream())) &#123;                            printWriter.println(<span class="hljs-string">&quot;hello world！&quot;</span>);                            printWriter.flush();                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;);                sHandlerThread.start();            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;);sThread.start();<span class="hljs-comment">// Socket 客户端（接收信息并打印）</span><span class="hljs-keyword">try</span> (Socket cSocket = <span class="hljs-keyword">new</span> Socket(InetAddress.getLocalHost(), port)) &#123;    BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(cSocket.getInputStream()));    bufferedReader.lines().forEach(s -&gt; System.out.println(<span class="hljs-string">&quot;客户端：&quot;</span> + s));&#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><p><img src="../images/2019-12-26-11-26-19.png"></p><h2 id="NIO网络编程模型-1"><a href="#NIO网络编程模型-1" class="headerlink" title="NIO网络编程模型"></a>NIO网络编程模型</h2><p><img src="../images/2019-12-25-16-04-25.png"></p><p>优点：通过selector来管理连接时间，使用单线程来实现多个client的请求</p><pre><code class="hljs java"><span class="hljs-comment">// NIO 多路复用</span>ThreadPoolExecutor threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>,        <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> (Selector selector = Selector.open();             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();) &#123;            serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-comment">// ⚠️服务端单线程</span>                selector.select(); <span class="hljs-comment">// 阻塞等待就绪的Channel</span>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-keyword">try</span> (SocketChannel channel = ((ServerSocketChannel) key.channel()).accept()) &#123;                        channel.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;你好，世界&quot;</span>));                    &#125;                    iterator.remove();                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;);<span class="hljs-comment">// Socket 客户端（接收信息并打印）</span><span class="hljs-keyword">try</span> (Socket cSocket = <span class="hljs-keyword">new</span> Socket(InetAddress.getLocalHost(), port)) &#123;    BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(cSocket.getInputStream()));    bufferedReader.lines().forEach(s -&gt; System.out.println(<span class="hljs-string">&quot;NIO 客户端：&quot;</span> + s));&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><p><img src="../images/2019-12-26-11-27-18.png"></p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><pre><code class="hljs java"><span class="hljs-comment">// AIO线程复用版</span>Thread sThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ⚠️异步</span>        AsynchronousChannelGroup group = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(<span class="hljs-number">4</span>));            AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(<span class="hljs-keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));            server.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment)</span> </span>&#123;                    server.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>); <span class="hljs-comment">// 接收下一个请求</span>                    <span class="hljs-keyword">try</span> &#123;                        Future&lt;Integer&gt; f = result.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;你好，世界&quot;</span>));                        f.get();                        System.out.println(<span class="hljs-string">&quot;服务端发送时间：&quot;</span> + <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> Date()));                        result.close();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, AsynchronousServerSocketChannel attachment)</span> </span>&#123;                &#125;            &#125;);            group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);        &#125; <span class="hljs-keyword">catch</span> (IOException | InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;);sThread.start();<span class="hljs-comment">// Socket 客户端</span>AsynchronousSocketChannel client = AsynchronousSocketChannel.open();Future&lt;Void&gt; future = client.connect(<span class="hljs-keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));future.get();ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">100</span>);client.read(buffer, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, Void&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, Void attachment)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;客户端打印：&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array()));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, Void attachment)</span> </span>&#123;        exc.printStackTrace();        <span class="hljs-keyword">try</span> &#123;            client.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;);Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>03-核心类库</category>
      
      <category>04-NIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-commons-beanutils</title>
    <link href="/01-Java/01-JavaSE/07-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/01-Apache-comments/01-commons-beanutils/"/>
    <url>/01-Java/01-JavaSE/07-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/01-Apache-comments/01-commons-beanutils/</url>
    
    <content type="html"><![CDATA[<h1 id="commons-beanutils"><a href="#commons-beanutils" class="headerlink" title="commons-beanutils"></a>commons-beanutils</h1><ul><li>阿里巴巴编程规范强制建议不使用这个工具类，有严重的性能问题</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 目标对象</span>User user = <span class="hljs-keyword">new</span> User();<span class="hljs-comment">// 源对象</span>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;czm&quot;</span>);map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">12</span>);map.put(<span class="hljs-string">&quot;bornDate&quot;</span>,<span class="hljs-string">&quot;2019-01-01&quot;</span>);<span class="hljs-comment">// 对字符串类型的日期进行格式化</span>DateConverter dateConverter = <span class="hljs-keyword">new</span> DateConverter(<span class="hljs-keyword">null</span>);dateConverter.setPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);ConvertUtils.register(dateConverter,Date.class);BeanUtils.copyProperties(user,map);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>07-常用工具包</category>
      
      <category>01-Apache-comments</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Lambda表达式</title>
    <link href="/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/02-jdk8/01-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/01-Java/01-JavaSE/09-%E8%AF%AD%E8%A8%80%E6%96%B0%E7%89%B9%E6%80%A7/02-jdk8/01-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>函数式编程，函数可以作为变量存储/参数传递，从而达到更佳清晰的表达</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>初衷是用于解决在JAVA中，在函数中调用函数的时候需要使用匿名内部类实现</p><pre><code class="hljs java">List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;czm&quot;</span>,<span class="hljs-number">12</span>));list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;czm1&quot;</span>,<span class="hljs-number">32</span>));list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;czm2&quot;</span>,<span class="hljs-number">123</span>));<span class="hljs-comment">// 需求，对List&lt;Map&lt;String,Integer&gt;&gt;进行排序</span><span class="hljs-comment">// list.sort(Comparator&lt;T&gt; c);</span><span class="hljs-comment">// 传统方法 - 通过匿名内部类实现</span>list.sort(<span class="hljs-keyword">new</span> Comparator&lt;User&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User o1, User o2)</span> </span>&#123;        <span class="hljs-keyword">return</span> Integer.compare(o1.getAge(),o2.getAge());    &#125;&#125;);<span class="hljs-comment">// lambda表达式，(参数列表) -&gt; 实现类中真正要执行的方法</span>list.sort((o1, o2) -&gt; Integer.compare(o1.getAge(),o2.getAge()));</code></pre><h3 id="什么方法能够使用函数式编程"><a href="#什么方法能够使用函数式编程" class="headerlink" title="什么方法能够使用函数式编程"></a>什么方法能够使用函数式编程</h3><p>含有注解<code>@FunctionalInterface</code></p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>01-JavaSE</category>
      
      <category>09-语言新特性</category>
      
      <category>02-jdk8</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Spring框架的概览</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/01-Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A6%82%E8%A7%88/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/01-Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架的核心"><a href="#Spring框架的核心" class="headerlink" title="Spring框架的核心"></a>Spring框架的核心</h1><p>Spring是一个用于简化企业及开发的框架，核心思想是依赖注入和面向切面编程</p><h2 id="1-简化Java开发"><a href="#1-简化Java开发" class="headerlink" title="1. 简化Java开发"></a>1. 简化Java开发</h2><h3 id="1-1-1-Pojo是什么"><a href="#1-1-1-Pojo是什么" class="headerlink" title="1.1.1 Pojo是什么"></a>1.1.1 Pojo是什么</h3><p>名词解释：</p><ul><li>POJO:普通的JavaBean,也就是说不是一个复杂的Java对象，不会有业务代码，提供getter和setter方法</li><li>EJB:<a href="https://baike.baidu.com/item/EJB">百度百科</a></li></ul><p>Spring基于POJO的最小侵入性编程:Spring不会要求你继承/实现固定的接口才能使用，也即是Spring希望使用普通的Java对象就可以搞定这个问题，因为EJB真的很复杂</p><h3 id="1-1-2-依赖注入（Dependiency-Injection-DI）"><a href="#1-1-2-依赖注入（Dependiency-Injection-DI）" class="headerlink" title="1.1.2 依赖注入（Dependiency Injection, DI）"></a>1.1.2 依赖注入（Dependiency Injection, DI）</h3><p>依赖注入实现了这样一件事情，通过<code>xml</code>或者<code>java</code>注解开发的方式实现了依赖装配<code>(wiring)</code>，使得我们直接操作接口工作，我们在代码上不关心是什么实现类实现的，就更不关心注入的实现类了</p><p>那么我们也就是需要写好接口，写好实现类，然后进行装配，再去执行<br>这样做的好处有</p><ul><li>解耦：不需要各种接口和继承，耦合性大大降低，你是与世无关的独立存在</li><li>单元测试： 每个人负责好自己的东西，跟任何人否没有关系</li></ul><p><strong>详情看P11</strong>，<strong>只有装配文件才知道谁是执行者</strong>，跟执行者无关，这就是DI依赖注入的精髓了</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 传统的做法</span><span class="hljs-comment">*/</span>HelloService helloService = <span class="hljs-keyword">new</span> HelloServiceImpl();<span class="hljs-comment">/******************************** 分界线 **************************************/</span><span class="hljs-comment">/**</span><span class="hljs-comment">*  使用依赖注入 DI</span><span class="hljs-comment">* </span><span class="hljs-comment">* 使用者只知道自己要用这个服务，但不知道是谁提供，也不知道具体的实现细节，Spring会通过xml文件或注解进行装配</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Autowrite</span>HelloService helloService;</code></pre><h3 id="1-1-3-面向切面编程-AOP-aspect-oriented-programing-–-基于DI"><a href="#1-1-3-面向切面编程-AOP-aspect-oriented-programing-–-基于DI" class="headerlink" title="1.1.3 面向切面编程 AOP (aspect-oriented programing) – 基于DI"></a>1.1.3 面向切面编程 AOP (aspect-oriented programing) – 基于DI</h3><p>将贯穿整个程序的重复的功能单独出来作为可重用的组件，这些组件需要参与到代码中，但是又于核心业务无关</p><p>如<strong>日志管理</strong>、<strong>安全验证模块</strong>等，<strong>Spring声明式事务是</strong>典型的AOP</p><blockquote><p>最差的做法，不断重复地实现<code>System.out.print(&quot;[Info]&quot; + new Time().now() + &quot; e.getMessage());</code><br>任然比较差的做法，一处实现多处调用<code>logger.info(e.getMessgae());</code> 这个时候，任务的执行类依然担任了管理日志的功能，这个是不应该的，这样会使得任务的执行类变得更累赘，还要关心日志对象是否实例化的(logger可能为null)<br>最好的做法，将所有的管理操作放在AOP配置中，在任务执行前执行xxx，在任务的执行后执行xxx。如将入口和出口都通过AOP的方式打印日志，这样就不用自己写了</p></blockquote><p>这时候我们来理解切面的意思，就像三明治一样，切开，放入我们前后需要的东西后才组成完整的执行流程。</p><p><strong>详情看P15</strong>，这个时候任然只有配置文件知道切面的存在，而实际担任切面的也不知道自己被当作切面了(毕竟就是个简单的POJO)</p><pre><code class="hljs java"><span class="hljs-comment">// 以日志监控为需求</span><span class="hljs-comment">/**</span><span class="hljs-comment">* 传统的做法</span><span class="hljs-comment">*/</span>Logger logger = <span class="hljs-keyword">new</span> Logger();logger.requestLog();sayHello();             <span class="hljs-comment">// 被切方法</span>logger.responseLog();<span class="hljs-comment">/******************************** 分界线 **************************************/</span><span class="hljs-comment">/**</span><span class="hljs-comment">* 配置切点</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Pointcut(&quot;execution(* org.springframework.security.oauth2.provider.endpoint.TokenEndpoint.*(..))&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 切点执行前</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Before(&quot;sayHello()&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLog</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 切点返回后</span><span class="hljs-comment">*/</span><span class="hljs-meta">@AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;handle()&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">responseLog</span><span class="hljs-params">(Object ret)</span></span>&#123;&#125;</code></pre><h3 id="1-1-4-使用模板消除板式代码"><a href="#1-1-4-使用模板消除板式代码" class="headerlink" title="1.1.4. 使用模板消除板式代码"></a>1.1.4. 使用模板消除板式代码</h3><p>什么是板式代码，<br>举个例子，JDBC 你需要</p><ol><li>配置数据库</li><li>连接数据库</li><li><strong>真正的查询</strong></li><li>获取异常、处理异常、处理异常还要判断异常</li><li>关闭数据库连接</li></ol><p>而模板嘛，没啥新技术，就是将你写的那些重复的代码写好，剩下核心业务你自己写。如：JdbcTemplate</p><h2 id="1-2-Spring容器"><a href="#1-2-Spring容器" class="headerlink" title="1.2 Spring容器"></a>1.2 Spring容器</h2><p>Spring<strong>创建容器</strong>，<strong>装配容器</strong>，容器是用来装多个Bean的工具，并负责管理<strong>容器的生命周期</strong></p><p>容器的两种实现</p><ol><li>BeanFactory工厂实现（简单，低级，不直接使用）</li><li>应用上下文（ApplicationContext接口定义） 基于<code>BeanFactory</code>实现</li></ol><h3 id="1-2-1-应用上下文"><a href="#1-2-1-应用上下文" class="headerlink" title="1.2.1 应用上下文"></a>1.2.1 应用上下文</h3><p>Spring的应用上下文, 用于装配上文提到的DI/AOP操作中的各种Bean</p><ul><li>AnnotationConfigApplicationContext : 基于注解类的Spring上下文</li><li>AnnotationConfigWebApplicationContext : 基于Java类的Spring Web上下文</li><li>ClassPathXmlApplicationContext : 类路径下的xml文件(所有包含.jar的路径)</li><li>FileSystemXmlApplicationContext : 文件系统配置xml</li><li>XmlWebApplicationContext ： web应用路径下的上下文</li></ul><p>eg:</p><pre><code class="hljs java"><span class="hljs-comment">// 获得应用上下文</span><span class="hljs-comment">// FileSystemXmlApplicationContext</span>ApplcationContext applicationContext = <span class="hljs-keyword">new</span> FileSystemXmlApplicationContext(<span class="hljs-string">&quot;/home/czm/xxx.xml&quot;</span>);<span class="hljs-comment">// ClassPathXmlApplicationContext</span>ApplcationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;xxx.xml&quot;</span>);<span class="hljs-comment">// AnnotationConfigApplicationContext</span>ApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(xx.xxx.xxxx.xxxx.Xxxxx.class);<span class="hljs-comment">// 获取Bean</span>applicationContext.getBean();</code></pre><h3 id="1-2-2-bean生命周期"><a href="#1-2-2-bean生命周期" class="headerlink" title="1.2.2 bean生命周期"></a>1.2.2 bean生命周期</h3><p>传统模式下，bean的生命周期，由<code>new</code>开始，指导该对象没有被引用，等待GC回收。<br>在Spring中，Bean由BeanFactory负责生产，和管理生命周期</p><ol><li>Spring对bean进行实例化;</li><li>Spring将值和bean的引用注入到bean对应的属性中;</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法;</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入;</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的 引用传入进来;</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法; </li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-<br>method声明了初始化方法，该方法也会被调用;</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法;</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁;</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销 毁方法，该方法也会被调用。</li></ol><p>总结来说：<strong>使用xml/注解等方式，利用DI的思想，通过应用上下文，将Bean实例化并装配到容器中管理和使用</strong></p><h2 id="Spring框架核心概览"><a href="#Spring框架核心概览" class="headerlink" title="Spring框架核心概览"></a>Spring框架核心概览</h2><p>[Github-spring-framework]<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p><img src="../images/2019-07-24-16-06-28.png"><br><img src="../images/2019-07-24-16-07-27.png"></p><h3 id="Spring核心容器"><a href="#Spring核心容器" class="headerlink" title="Spring核心容器"></a>Spring核心容器</h3><p>容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。</p><h3 id="Spring的-AOP模块"><a href="#Spring的-AOP模块" class="headerlink" title="Spring的 AOP模块"></a>Spring的 AOP模块</h3><p>在AOP模块中，Spring对面向切面编程提供了丰富的支持。</p><h3 id="数据访问与集成"><a href="#数据访问与集成" class="headerlink" title="数据访问与集成"></a>数据访问与集成</h3><p>Spring的JDBC和 DAO(Data Access Object)模块抽象了这些样板式代码</p><p>对于那些更喜欢ORM(Object-Relational Mapping)工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的事务管理支持所有的ORM框架以及JDBC。</p><h3 id="Web与远程调用"><a href="#Web与远程调用" class="headerlink" title="Web与远程调用"></a>Web与远程调用</h3><p>MVC(Model-View-Controller)Spring的MVC框架</p><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h3><p>Spring的Instrumentation模块提供了为JVM添加代理(agent)的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>该模块为加载Spring 应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。</p><h2 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h2><p><a href="https://spring.io/projects">Spring官网</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Spring定时任务</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/03-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/03-Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring定时任务"><a href="#Spring定时任务" class="headerlink" title="Spring定时任务"></a>Spring定时任务</h1><p>定时执行某个方法</p><ol><li>类注解<code>@Component</code></li><li>方法注解<code>@Scheduled(fixedRate = 5000)/@Scheduled(cron=&quot;. . .&quot;)</code></li><li>Application类注解<code>EnableScheduling</code></li></ol><p><code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gs-scheduling-tasks<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p><code>ScheduledTasks.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTasks</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ScheduledTasks.class);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);    <span class="hljs-comment">// 支持@Scheduled(cron=&quot;. . .&quot;)使用corn表达式</span>    <span class="hljs-meta">@Scheduled(fixedRate = 5000)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportCurrentTime</span><span class="hljs-params">()</span> </span>&#123;        log.info(<span class="hljs-string">&quot;The time is now &#123;&#125;&quot;</span>, dateFormat.format(<span class="hljs-keyword">new</span> Date()));    &#125;&#125;</code></pre><p><code>Application.java</code></p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// 需要启动定时任务</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SpringApplication.run(Application.class);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-配置问题详解</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/06-%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/06-%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h1><h2 id="在哪里看"><a href="#在哪里看" class="headerlink" title="在哪里看"></a>在哪里看</h2><p>这个配置文件允许有三种，我们可以在<code>pom.xml</code>中的<code>&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</code>中看到这个信息如下</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span></code></pre><p>此处说明了在工程中的任意文佳夹下的所有以<code>application</code>开头，以<code>yml</code>、<code>yaml</code>、<code>properties</code>的配置均为Spring可识别的配置文件</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-文件上传和下载</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/04-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/04-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><ul><li>注意，这里用到了<code>thymeleaf</code>模板引擎</li></ul><p><code>pom.xml</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><code>applacation.yml</code></p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">freemarker:</span>    <span class="hljs-attr">template-loader-path:</span> <span class="hljs-string">classpath:/templates</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">multipart:</span>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">20MB</span>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span></code></pre><p><code>resources/templates/uploadForm.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;fileUpLoad.action&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>            文件：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><code>UpLoadController.java</code>上传文件的主类</p><ol><li>通过模板引擎返回上传界面的页面</li><li>模板引擎中进行跳转到<code>fileUpLoad.action</code></li><li>拦截<code>fileUpLoad.action</code>，接受参数<code>MultipartFile file</code></li><li>对file进行处理</li></ol><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpLoadController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;uploadForm&quot;</span>;    &#125;    <span class="hljs-meta">@RequestMapping(&quot;/fileUpLoad.action&quot;)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upLoadFile</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IllegalStateException, IOException </span>&#123;        BufferedOutputStream stream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (!file.isEmpty()) &#123;            System.out.println(file.getOriginalFilename());            String path = <span class="hljs-string">&quot;c:/other&quot;</span>;            File newFile = <span class="hljs-keyword">new</span> File(path + <span class="hljs-string">&quot;/&quot;</span> + file.getOriginalFilename());            <span class="hljs-keyword">if</span> (!newFile.exists()) &#123;                newFile.createNewFile();            &#125;            BufferedOutputStream out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(newFile));            out.write(file.getBytes());            out.flush();            out.close();            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上传成功&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;上传失败&quot;</span>;    &#125;&#125;</code></pre><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 读取本地文件（例如pdf，jpg）,这里设置的是预览</span><span class="hljs-comment">    * pdf 的contentType为&quot;&quot;application/pdf&quot;&quot;</span><span class="hljs-comment">    * jpg 的contentType为&quot;image/jpeg&quot;</span><span class="hljs-comment">    * png 的contentType为&quot;image/png&quot;</span><span class="hljs-comment">    */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">(HttpServletResponse response, String fileName, String contentType)</span> </span>&#123;        <span class="hljs-comment">// 填充outputStream</span>    <span class="hljs-keyword">try</span> &#123;        response.reset();        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">int</span> len;        OutputStream outputStream = response.getOutputStream();        <span class="hljs-keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;            outputStream.write(buffer, <span class="hljs-number">0</span>, len);        &#125;        outputStream.write(inputStream.read());        outputStream.flush();        readFile(response, fileName, contentType);    &#125; <span class="hljs-keyword">finally</span> &#123;        IOUtil.close(inputStream);    &#125;    response.setContentType(contentType);    response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>,<span class="hljs-string">&quot;inline; filename= &quot;</span> + fileName);&#125;</code></pre><h2 id="文件过滤"><a href="#文件过滤" class="headerlink" title="文件过滤"></a>文件过滤</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * FilterUtil 通过</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019-08-19</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对文件进行规则检查</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file        规则检查的文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> andMatchers 必须的规则，区分小大写</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orMatchers  存在的规则，不区分大小写</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLegalFile</span><span class="hljs-params">(File file, String[] andMatchers, String[] orMatchers)</span> </span>&#123;        AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();        String absolutePath = file.getAbsolutePath();        <span class="hljs-keyword">boolean</span> andLegal = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (andMatchers != <span class="hljs-keyword">null</span> &amp;&amp; andMatchers.length != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 任意一个不满足则为false</span>            <span class="hljs-keyword">for</span> (String andMatcher : andMatchers) &#123;                <span class="hljs-keyword">if</span> (!antPathMatcher.match(andMatcher, absolutePath)) &#123;                    andLegal = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">boolean</span> orLegal = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (orMatchers != <span class="hljs-keyword">null</span> &amp;&amp; orMatchers.length != <span class="hljs-number">0</span>) &#123;            orLegal = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// 任意一个满足则为true</span>            <span class="hljs-keyword">for</span> (String orMatcher : orMatchers) &#123;                <span class="hljs-keyword">if</span> (antPathMatcher.match(orMatcher.toLowerCase(), absolutePath.toLowerCase())) &#123;                    orLegal = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> andLegal &amp;&amp; orLegal;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09-AntMatchers</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/09-AntMatchers/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/09-AntMatchers/</url>
    
    <content type="html"><![CDATA[<h1 id="AntMatchers"><a href="#AntMatchers" class="headerlink" title="AntMatchers"></a>AntMatchers</h1><ul><li>？匹配一个字符(matches one character)。</li><li>*  匹配0个或者多个字符 ( matches zero or more characters)。</li><li>** 匹配url中的0个或多个子目录 (matches zero or more directories in a path)</li></ul><h2 id="AntMatchers用在Security"><a href="#AntMatchers用在Security" class="headerlink" title="AntMatchers用在Security"></a>AntMatchers用在Security</h2><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.authorizeRequests()        .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/images/**&quot;</span>).permitAll();&#125;</code></pre><h2 id="AntMatchers用在文件路径过滤"><a href="#AntMatchers用在文件路径过滤" class="headerlink" title="AntMatchers用在文件路径过滤"></a>AntMatchers用在文件路径过滤</h2><pre><code class="hljs java">AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();antPathMatcher.isPattern(<span class="hljs-string">&quot;/user/001&quot;</span>); <span class="hljs-comment">// 返回 false</span>antPathMatcher.isPattern(<span class="hljs-string">&quot;/user/*&quot;</span>);  <span class="hljs-comment">// 返回 true</span>antPathMatcher.match(<span class="hljs-string">&quot;/user/001&quot;</span>,<span class="hljs-string">&quot;/user/001&quot;</span>); <span class="hljs-comment">// 返回 true</span>antPathMatcher.match(<span class="hljs-string">&quot;/user/001&quot;</span>,<span class="hljs-string">&quot;/user/001&quot;</span>); <span class="hljs-comment">// 返回 true</span>antPathMatcher.match(<span class="hljs-string">&quot;/**/*.png&quot;</span>,<span class="hljs-string">&quot;/user/home/asdas/001.png&quot;</span>); <span class="hljs-comment">// 返回 true 匹配文件格式png</span>antPathMatcher.match(<span class="hljs-string">&quot;/user/**&quot;</span>,<span class="hljs-string">&quot;/user/home/asdas/001.png&quot;</span>); <span class="hljs-comment">// 返回 true 匹配/user/下的任意文件夹下的任意文件</span>antPathMatcher.matchStart(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;/user/001&quot;</span>); <span class="hljs-comment">// 返回 true</span>antPathMatcher.matchStart(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;/user&quot;</span>); <span class="hljs-comment">// 返回 true</span>antPathMatcher.matchStart(<span class="hljs-string">&quot;/user/*&quot;</span>,<span class="hljs-string">&quot;/user001&quot;</span>); <span class="hljs-comment">// 返回 false</span>antPathMatcher.extractPathWithinPattern(<span class="hljs-string">&quot;uc/profile*&quot;</span>,<span class="hljs-string">&quot;uc/profile.html&quot;</span>); <span class="hljs-comment">// 返回 profile.html</span>antPathMatcher.combine(<span class="hljs-string">&quot;uc/*.html&quot;</span>,<span class="hljs-string">&quot;uc/profile.html&quot;</span>); <span class="hljs-comment">// uc/profile.html</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Spring mvc是什么</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/01-Spring%20mvc%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/01-Spring%20mvc%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h1><h2 id="Spring的整体架构"><a href="#Spring的整体架构" class="headerlink" title="Spring的整体架构"></a>Spring的整体架构</h2><p><img src="../images/00-01.png"></p><ul><li>IOC Inversion of Control 反转控制器:把创建对象的权力交给框架，包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fr=aladdin&fromid=4853&fromtitle=ioc">IOC介绍</a>，实现把创建对象的权力交给框架，工程模式也可以实现，但是不是真正的解耦和，而IOC是工厂模式的升华；IOC：使用XML文件，通过一个容器把需要的接口实现注入到依赖的类中（依赖注入）。</li><li>AOP Aspect Oriented Programming 面向切面编程：可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术</li><li>DAO(Data Access Object) 数据访问对象是一个面向对象的数据库接口</li><li>ORM (Object Relational Mapping) 对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换</li></ul><h2 id="Spring-mvc-是什么"><a href="#Spring-mvc-是什么" class="headerlink" title="Spring mvc 是什么"></a>Spring mvc 是什么</h2><p>Spring MVC是Spring框架的一个模块，Spring和SpringMVC是无需中间层进行整合</p><h3 id="MVC是什么"><a href="#MVC是什么" class="headerlink" title="MVC是什么"></a>MVC是什么</h3><p>mvc是一种设计模式，jsp的封装，将整个逻辑解耦</p><h3 id="MVC在B-S系统下的应用-Brower-Server"><a href="#MVC在B-S系统下的应用-Brower-Server" class="headerlink" title="MVC在B-S系统下的应用(Brower/Server)"></a>MVC在B-S系统下的应用(Brower/Server)</h3><ul><li>controller</li><li>model:<ol><li>pojo(简单Jav对象) == JAVABean</li><li>atcion</li><li>service</li><li>dao(访问数据库接口)</li></ol></li><li>view</li></ul><h3 id="SpringMVC的框架-03Spring-MVC框架"><a href="#SpringMVC的框架-03Spring-MVC框架" class="headerlink" title="[SpringMVC的框架](03Spring MVC框架/)"></a>[SpringMVC的框架](03Spring MVC框架/)</h3>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-spring-mvc入门程序</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/02-spring-mvc%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/02-spring-mvc%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h1><h2 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h2><p>这里创建一个普通类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cenzhongman.spring;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.name);    &#125;&#125;</code></pre><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 1. 实例化对象</span>        HelloWorld helloWorld = <span class="hljs-keyword">new</span> HelloWorld();        <span class="hljs-comment">// 2. 设置值</span>        helloWorld.setName(<span class="hljs-string">&quot;CZM&quot;</span>);        <span class="hljs-comment">// 3.使用对象调用该方法</span>        helloWorld.sayHello();    &#125;&#125;</code></pre><h3 id="使用Spring"><a href="#使用Spring" class="headerlink" title="使用Spring"></a>使用Spring</h3><p>new &gt; XML Configuration file &gt; Spring config</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cenzhongman.spring.HelloWorld&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;CZM&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">// 1. 创建一个Spring的IOC容器对象</span>        ApplicationContext context= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;spring-config.xml&quot;</span>);<span class="hljs-comment">// 在这个地方就new对象，并且调用setter方法</span>        <span class="hljs-comment">// 2. 从IOC容器中获取Bean实例</span>        HelloWorld helloWorld = (HelloWorld) context.getBean(<span class="hljs-string">&quot;helloWorld&quot;</span>);        <span class="hljs-comment">// 3. 调用sayHello()方法</span>        helloWorld.sayHello();    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的例子可以得出结论，Spring到底帮我们做了什么，当我们没有使用Spring的时候，调用sayHello()方法需要3步：</p><ol><li>创建一个HelloWorld的实例对象</li><li>设置实例对象的name属性</li><li>调用对象的sayHello()方法</li></ol><p>后来也需要3步：</p><ol><li>创建一个Spring的IOC容器对象</li><li>从IOC容器中获取Bean实例</li><li>调用sayHello()方法</li></ol><p>然后我们探究了什么时候new的helloWorld对象，我们可以看出，Spring帮我们完成了前2步，也就是创建实例对象以及设置对象的属性，也就是说我们可以<strong>把对象的创建和管理工作交给Spring去完成</strong>，不需要自己去new对象，也不要去设置对象的属性，只要写好Spring的配置文件，Spring就可以帮我们去做，当我们需要对象的时候，直接去找Spring去要就行。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-Spring入门案例--依赖包版本</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/04-Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B--%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/04-Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B--%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC-入门案例"><a href="#Spring-MVC-入门案例" class="headerlink" title="Spring MVC 入门案例"></a>Spring MVC 入门案例</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Mysql<ol><li>Host:119.28.61.108</li><li>user:root</li><li>passwd:ubuntu</li></ol></li><li>SpringMVC</li><li>Eclipse oxygen.2</li><li>JDK1.8.0_152</li></ul><h2 id="使用Eclipse创建工程"><a href="#使用Eclipse创建工程" class="headerlink" title="使用Eclipse创建工程"></a>使用Eclipse创建工程</h2><h3 id="修改编码格式"><a href="#修改编码格式" class="headerlink" title="修改编码格式"></a>修改编码格式</h3><p>windows –&gt; Preferences –&gt; General -–&gt; Workspace</p><h3 id="创建Working-Set"><a href="#创建Working-Set" class="headerlink" title="创建Working Set"></a>创建Working Set</h3><p><img src="../images/04-01.png"><br><img src="../images/04-02.png"><br><img src="../images/04-03.png"><br><img src="../images/04-04.png"></p><h3 id="创建动态web工程"><a href="#创建动态web工程" class="headerlink" title="创建动态web工程"></a>创建动态web工程</h3><p><img src="../images/04-05.png"><br><img src="../images/04-06.png"><br><img src="../images/04-07.png"><br><img src="../images/04-08.png"><br><img src="../images/04-09.png"></p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>下载所有的mvc依赖包复制到<code>FirstEclipseSpringAPP\WebRoot\WEB-INF\lib</code>路径下</p><p>下载地址：<a href="http://sourceforge.net/projects/springframework/">http://sourceforge.net/projects/springframework/</a></p><p>参考博客：<br><a href="http://blog.csdn.net/shymi1991/article/details/48085955?yyue=a21bo.50862.201879">用Eclipse创建第一个Spring项目（最最入门级）</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Spring MVC框架再次入门</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/03-Spring%20MVC%E6%A1%86%E6%9E%B6%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/03-Spring%20MVC%E6%A1%86%E6%9E%B6%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC学习"><a href="#Spring-MVC学习" class="headerlink" title="Spring MVC学习"></a>Spring MVC学习</h1><p><img src="../images/03-05.png"></p><ol><li>前端控制器 DisPatchServletController (<strong>无需开发</strong>)：接受请求，分发请求，响应请求</li><li>处理器映射器 handlerMapping         (<strong>无需开发</strong>)：根据URL寻找handler</li><li>处理器适配器 handlerAdapter         (<strong>无需开发</strong>)：执行handler</li><li>后端控制器 handler                  (<strong>需开发</strong>)：需要按照handlerAdapter的规范进行开发</li><li>视图解析器 ViewResorler              (<strong>无需开发</strong>)：解析视图，返回View</li><li>视图 View                            (<strong>需开发</strong>)：渲染视图，View是一个Interface</li></ol><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>mode-view-Controller</p><h2 id="spring如何实现MVC"><a href="#spring如何实现MVC" class="headerlink" title="spring如何实现MVC"></a>spring如何实现MVC</h2><ul><li>整体架构</li></ul><p><img src="../images/03-00.png"></p><ul><li><strong>前端控制器</strong>:使用<code>Dispatcherservlet</code>来实现</li></ul><p><code>Dispatcherservlet</code>负责接受用户的请求，将请求转给合适的控制器，用于生成module和view</p><p><img src="../images/03-01.png"></p><ul><li><p><strong>controller</strong>:控制器</p></li><li><p><strong>HandlerAdapter</strong></p></li></ul><p><code>Dispatcherservlet</code>需要使用<code>HandlerAdapter</code>,因为Java中并不提供一个<code>cotrollor</code>接口，需要使用一个HAndler来得到controller</p><ul><li><strong>HandlerInterceptor</strong></li></ul><p>这是一个接口，提供三个方法<code>afterCompletion</code>,<code>postHandler</code>,<code>preHandler</code>，用于在Handler调用前后和页面呈现完成后实现特定的功能。</p><ul><li><strong>HandlerMapping</strong></li></ul><ol><li>帮助<code>DispatcherServlet</code>映射到正确的<code>controller</code></li><li>Wrap controller with HandlerIntrtceptor</li></ol><ul><li><strong>HandlerExecutionChain</strong></li></ul><p><img src="../images/03-02.png"></p><ul><li><strong>ModelAndView</strong></li></ul><p>Spring框架中的model类，无论是使用Model还是Map实现的Model统一转成<code>ModelAndView</code></p><ul><li><strong>ViewResolver</strong>视图解析器</li></ul><p>帮助Dispatch Servlet找到呈现的视图</p><ul><li><p><strong>view</strong></p></li><li><p>完整访问过程</p></li></ul><p><img src="../images/03-03.png"></p><p><img src="../images/03-04.png"></p><h2 id="创建一个工程的实际步骤"><a href="#创建一个工程的实际步骤" class="headerlink" title="创建一个工程的实际步骤"></a>创建一个工程的实际步骤</h2><h3 id="创建一个maven的java-web项目"><a href="#创建一个maven的java-web项目" class="headerlink" title="创建一个maven的java-web项目"></a>创建一个maven的java-web项目</h3><ol><li>处理好依赖关系</li><li>DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC</li><li>HandlerMapping 的配置，从而将请求映射到处理器</li><li>HandlerAdapter 的配置，从而支持多种类型的处理器</li><li>ViewResolver 的配置，从而将逻辑视图名解析为具体视图技术</li><li>处理器（页面控制器）的配置，从而进行功能处理</li></ol><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-framework-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h4 id="2-DispatcherServlet-在-web-xml-中的部署描述，从而拦截请求到-Spring-Web-MVC"><a href="#2-DispatcherServlet-在-web-xml-中的部署描述，从而拦截请求到-Spring-Web-MVC" class="headerlink" title="2.DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC"></a>2.DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 说明配置文件位置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><span class="hljs-comment">&lt;!-- 拦截请求 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 启动容器的时候启动这个servlet --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>默认 DispatcherServlet 会加<br>载 WEB-INF/[DispatcherServlet的Servlet名字]-servlet.xml配置文件。本项目会加载<code>WEB-INF/dispatcher-servlet.xml</code></p><h4 id="3-HandlerMapping-的配置，从而将请求映射到处理器"><a href="#3-HandlerMapping-的配置，从而将请求映射到处理器" class="headerlink" title="3.HandlerMapping 的配置，从而将请求映射到处理器"></a>3.HandlerMapping 的配置，从而将请求映射到处理器</h4><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HandlerMapping --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- HandlerAdapter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></code></pre><ol><li>HandlerAdapter 的配置，从而支持多种类型的处理器</li><li>ViewResolver 的配置，从而将逻辑视图名解析为具体视图技术</li><li>处理器（页面控制器）的配置，从而进行功能处理</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-非注解的处理器映射器和适配器</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/06-%E9%9D%9E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/06-%E9%9D%9E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="非注解的处理器映射器和适配器"><a href="#非注解的处理器映射器和适配器" class="headerlink" title="非注解的处理器映射器和适配器"></a>非注解的处理器映射器和适配器</h1><h2 id="非注解的处理器映射器"><a href="#非注解的处理器映射器" class="headerlink" title="非注解的处理器映射器"></a>非注解的处理器映射器</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="非注解的处理器适配器"><a href="#非注解的处理器适配器" class="headerlink" title="非注解的处理器适配器"></a>非注解的处理器适配器</h2>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-Spring入门案例--maven版本</title>
    <link href="/01-Java/03-Spring/02-SpringMVC/05-Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B--maven%E7%89%88%E6%9C%AC/"/>
    <url>/01-Java/03-Spring/02-SpringMVC/05-Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B--maven%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC-入门案例"><a href="#Spring-MVC-入门案例" class="headerlink" title="Spring MVC 入门案例"></a>Spring MVC 入门案例</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Mysql<ol><li>Host:119.28.61.108</li><li>user:root</li><li>passwd:ubuntu</li></ol></li><li>SpringMVC</li><li>Eclipse oxygen.2</li><li>JDK1.8.0_152</li></ul><h2 id="使用Eclipse创建工程"><a href="#使用Eclipse创建工程" class="headerlink" title="使用Eclipse创建工程"></a>使用Eclipse创建工程</h2><h3 id="修改编码格式"><a href="#修改编码格式" class="headerlink" title="修改编码格式"></a>修改编码格式</h3><p>windows –&gt; Preferences –&gt; General -–&gt; Workspace</p><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><p><img src="../images/05-01.png"><br><img src="../images/05-02.png"><br><img src="../images/05-03.png"><br><img src="../images/05-04.png"></p><p>其中，有一个报错信息，是因为没有Sevlet的包，两种解决方式：</p><ul><li>通过Pom.xml文件添加</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ul><li>通过增加Tomcat的目录解决</li></ul><p><img src="../images/05-05.png"><br><img src="../images/05-06.png"><br><img src="../images/05-07.png"></p><h3 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h3><ol><li>windows -&gt; perferences-&gt;maven 选项<ul><li>Download Artifact Sources</li><li>DownloadArtifact JavaDOC</li></ul></li><li>右键项目 找到maven -&gt; update project</li></ol><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>4.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h2 id="使用Spring-MVC"><a href="#使用Spring-MVC" class="headerlink" title="使用Spring MVC"></a>使用Spring MVC</h2><h3 id="1-配置前端控制器"><a href="#1-配置前端控制器" class="headerlink" title="1.配置前端控制器"></a>1.配置前端控制器</h3><p>根据<code>servlet</code>的原理，我们知道使用<code>servlet</code>和<code>servlet-mapping</code>进行拦截，使得全部的网址请求都转发给Spring框架处理</p><ol><li>在web-app中配置一个servlet-name,servlet-class</li><li>在servlet中配置<strong>前端控制器配置文件位置</strong>，这是一个参数</li><li>配置<code>servlet-mapping</code>拦截全部URL<ol><li><code>*.action</code>:以.action结尾的都交由<code>DispatcherServlet</code>处理</li><li><code>/</code>:所有地址都由<code>DispatcherServlet</code>处理，这样会导致某些静态文件需要配置不需要<code>DispatcherServlet</code>解析，这样实现的可以实现RESTFUL风格的URL</li><li><code>/*</code>:这种方式是不正确的，jsp页面最后还会经过<code>DispatcherServlet</code>，导致不能获取到handler报错</li></ol></li></ol><p>在web.xml中配置前端控制器和url拦截</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1. 在web-app中添加SpringMVC 前端控制器的servlet的name和class --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 2. 前端控制器的配置文件的位置（contextConfigLocation）， 包括handelerMapping handlerAdapter的配置--&gt;</span>        <span class="hljs-comment">&lt;!-- 这个参数可以从上述DispatcherServlet的源码文件中查看，搜索 init-param --&gt;</span>        <span class="hljs-comment">&lt;!-- 若不配置此项，默认读取位置为 WRB-INF/$SERVELET_NAME-servlet.xml 这在框架复杂之后不建议这样做  --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml/<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 文件在工程路径下的resources/springmvc.xml --&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3. servlet-mappring 拦截所有需要经过DispatcherServlet处理的url --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.action<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre><h3 id="2-配置处理器适配器handlerAdapter"><a href="#2-配置处理器适配器handlerAdapter" class="headerlink" title="2. 配置处理器适配器handlerAdapter"></a>2. 配置处理器适配器handlerAdapter</h3><p>修改配置文件<code>config/springmvc.xml</code>，关于``</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 所有的处理器适配器都是实现了HandlerAdapter接口 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span> /&gt;</span></code></pre><p>我们的<code>Handler</code>设计是需要符合<code>HandlerAdapter</code>的规范的，通过源码发现<code>HandlerAdapter</code>接口的<code>supports</code>方法就是支持的改适配器支持的<code>Handler</code></p><pre><code class="hljs java"><span class="hljs-comment">// org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 的源码</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;        <span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> Controller);    &#125;</code></pre><p>这里支持的Handler就是Controller的实例，我们继续看Controller接口</p><pre><code class="hljs java"><span class="hljs-comment">// Controller接口的源码</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Controller</span> </span>&#123;    <span class="hljs-function">ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre><p>上述源码说明，我们的<code>Handler</code>只要实现了<code>Controller</code>接口就能被<code>SimpleControllerHandlerAdapter</code>支持。</p><h3 id="3-编写handler"><a href="#3-编写handler" class="headerlink" title="3. 编写handler"></a>3. 编写handler</h3><p>需求：我们的<code>Handler</code>只要实现了<code>Controller</code>接口就能被<code>SimpleControllerHandlerAdapter</code>支持</p><p>在<code>src/main/java/</code>下创建Handler类<code>com.cenzhongman.ssm.controller.MyController.java</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 我的Handler，实现Controller接口</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 34566</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 这里写实现逻辑,我们这里模拟一个数据</span>        String s = <span class="hljs-string">&quot;你好，Spring!&quot;</span>;        <span class="hljs-comment">// 指定返回的ModelAndView</span>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();        modelAndView.addObject(<span class="hljs-string">&quot;text&quot;</span>, s);<span class="hljs-comment">// 这是model,在jsp页面中通过text取出数据</span>        modelAndView.setViewName(<span class="hljs-string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>);<span class="hljs-comment">// 这是View</span>        <span class="hljs-keyword">return</span> modelAndView;    &#125;&#125;</code></pre><h3 id="4-View的编写"><a href="#4-View的编写" class="headerlink" title="4. View的编写"></a>4. View的编写</h3><p>这里就是JSP的知识了，我们需要创建<code>/WEB-INF/jsp/test.jsp</code>文件，并从里面获取来自controller的数据。</p><h3 id="5-配置处理器映射器handlerMapping"><a href="#5-配置处理器映射器handlerMapping" class="headerlink" title="5. 配置处理器映射器handlerMapping"></a>5. 配置处理器映射器handlerMapping</h3><p>修改配置文件<code>config/springmvc.xml</code>,由上文定义可知（需自己创建）</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> /&gt;</span></code></pre><p>这个时候，需要再配置我们的Handler和url的映射，也就是一个Bean</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/test.action&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cenzhongman.ssm.controller.MyController&quot;</span>/&gt;</span></code></pre><h3 id="6-配置视图解析器ViewResorler"><a href="#6-配置视图解析器ViewResorler" class="headerlink" title="6. 配置视图解析器ViewResorler"></a>6. 配置视图解析器ViewResorler</h3><p>修改配置文件<code>config/springmvc.xml</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--　解析JSP视图的解析器　默认使用jstl标签，需有jstl的包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>/&gt;</span></code></pre><h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="../images/05-08.png"></p><p>访问<a href="http://localhost:8080/firstEclipseMavenSpringAPP/test.action">http://localhost:8080/firstEclipseMavenSpringAPP/test.action</a></p><h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><h3 id="关于DispatchServlet的配置文件位置问题"><a href="#关于DispatchServlet的配置文件位置问题" class="headerlink" title="关于DispatchServlet的配置文件位置问题"></a>关于DispatchServlet的配置文件位置问题</h3><ul><li>描述：不建议自己增加目录，而是使用resources目录</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml/<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-comment">&lt;!-- xml文件在工程路径下的resources/springmvc.xml --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></code></pre><h3 id="关于servlet-xml文件的schema问题"><a href="#关于servlet-xml文件的schema问题" class="headerlink" title="关于servlet.xml文件的schema问题"></a>关于servlet.xml文件的schema问题</h3><ul><li>描述：请参考<code>spring-mvc3.x.xml</code>等文件</li></ul><h3 id="关于上一个问题中加入了schema后依然报错"><a href="#关于上一个问题中加入了schema后依然报错" class="headerlink" title="关于上一个问题中加入了schema后依然报错"></a>关于上一个问题中加入了schema后依然报错</h3><ul><li>描述：有可能是project或maven没有刷新的问题</li><li>解决：<ol><li>project -&gt; clean..</li><li>右键<code>pom.xml</code>，Run As -&gt; Maven clean</li></ol></li></ul><h3 id="关于找不到类的问题"><a href="#关于找不到类的问题" class="headerlink" title="关于找不到类的问题"></a>关于找不到类的问题</h3><ul><li>描述：提示找不到类</li><li>解决：其实是spring.xml文件没有在BuildPath里面<ol><li>把config添加到build Path</li><li>或者把springmvc.xml移动带resource文件夹</li></ol></li></ul><p>参考博客：<br><a href="https://www.cnblogs.com/qixing/p/qixing.html">在eclipse中使用maven创建springMVC项目</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>02-SpringMVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-JSP-EL</title>
    <link href="/01-Java/02-JavaEE/02-JSP/02-JSP-EL/"/>
    <url>/01-Java/02-JavaEE/02-JSP/02-JSP-EL/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是EL，用来做什么"><a href="#什么是EL，用来做什么" class="headerlink" title="什么是EL，用来做什么"></a>什么是EL，用来做什么</h1><hr><p>!!<strong>绝对不应该在jsp中放java代码</strong></p><hr><p>因此，我们先禁用在jsp中的脚本</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp-config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jsp-property-group</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scripting-invalid</span>&gt;</span>            true        <span class="hljs-tag">&lt;/<span class="hljs-name">scripting-invalid</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">jsp-property-group</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">jsp-config</span>&gt;</span></code></pre><h2 id="使用EL代替脚本"><a href="#使用EL代替脚本" class="headerlink" title="使用EL代替脚本"></a>使用EL代替脚本</h2><p>在servlet中的设置各种属性：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    foo.Person p = <span class="hljs-keyword">new</span> foo.Person();    p.setName(“Evan”);    foo.Dog dog = <span class="hljs-keyword">new</span> foo.Dog();    dog.setName(“Spike”);    p.setDog(dog);    request.setAttribute(“person”, p);    RequestDispatcher view = request.getRequestDispatcher(“result.jsp”);    view.forward(request, response);&#125;</code></pre><ul><li>使用EL</li></ul><pre><code class="hljs jsp">Dog’s name is: $&#123;person.dog.name&#125;</code></pre><ul><li>使用脚本</li></ul><pre><code class="hljs jsp">&lt;%= ((foo.Person) request.getAttribute(“person”)).getDog().getName() %&gt;</code></pre><ul><li>使用标准动作</li></ul><pre><code class="hljs jsp">&lt;jsp:useBean id=”person” <span class="hljs-class"><span class="hljs-keyword">class</span></span>=”foo.Person” scope=”request” /&gt;Dog’s name is: &lt;jsp:getProperty name=”person” property=”dog” /&gt;&lt;!-- 但是这样输出的其实是一个dog对象，而不是对象的属性（Dog’s name is: foo.Dog@<span class="hljs-number">799338</span> --&gt;</code></pre><h2 id="EL表达说明"><a href="#EL表达说明" class="headerlink" title="EL表达说明"></a>EL表达说明</h2><h3 id="使用-连接"><a href="#使用-连接" class="headerlink" title="使用.连接"></a>使用<code>.</code>连接</h3><pre><code class="hljs jsp">$&#123;EL隐式对象/属性.映射键/bean性质&#125;$&#123;persion.name&#125;</code></pre><p><img src="../images/04-01.png"></p><h3 id="使用-表述"><a href="#使用-表述" class="headerlink" title="使用[]表述"></a>使用<code>[]</code>表述</h3><pre><code class="hljs jsp">$&#123;persion[<span class="hljs-string">&quot;name&quot;</span>]</code></pre><p><img src="../images/04-02.png"></p><h3 id="各种隐式对象"><a href="#各种隐式对象" class="headerlink" title="各种隐式对象"></a>各种隐式对象</h3><table><thead><tr><th>隐式对象</th><th>备注</th></tr></thead><tbody><tr><td>pageScope</td><td>作用域参数的map</td></tr><tr><td>requestScope</td><td>作用域参数的map</td></tr><tr><td>sessionScope</td><td>作用域参数的map</td></tr><tr><td>applicationScope</td><td>作用域参数的map</td></tr><tr><td>param</td><td>请求参数的map</td></tr><tr><td>paramValues</td><td>请求参数的map</td></tr><tr><td>header</td><td>请求首部的map</td></tr><tr><td>headerValues</td><td>请求首部的map</td></tr><tr><td>cookie</td><td>??</td></tr><tr><td>initParam</td><td>上下文初始化参数的map</td></tr><tr><td>pageContext</td><td>pageContext的引用</td></tr></tbody></table><h3 id="EL函数"><a href="#EL函数" class="headerlink" title="EL函数"></a>EL函数</h3>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>02-JSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-持久化框架对比</title>
    <link href="/01-Java/02-JavaEE/05-Mybatis/01-%E6%8C%81%E4%B9%85%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <url>/01-Java/02-JavaEE/05-Mybatis/01-%E6%8C%81%E4%B9%85%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="持久化框架对比"><a href="#持久化框架对比" class="headerlink" title="持久化框架对比"></a>持久化框架对比</h1><h2 id="1-持久层是什么"><a href="#1-持久层是什么" class="headerlink" title="1.持久层是什么"></a>1.持久层是什么</h2><p><img src="../images/01-01%E7%B3%BB%E7%BB%9F%E5%8F%98%E8%BF%81%E8%BF%87%E7%A8%8B.png"></p><p>持久层对数据访问逻辑进行了抽象，使得开发人员从底层操作中解放出来。</p><h3 id="1-1持久层的实现，对象关系映射ORM"><a href="#1-1持久层的实现，对象关系映射ORM" class="headerlink" title="1.1持久层的实现，对象关系映射ORM"></a>1.1持久层的实现，对象关系映射ORM</h3><p>在没有持久层的系统中，访问数据库需要通过JDBC实现，操作数据库需要同时操作对象（JAVABean）和关系数据库。</p><p>为了使用面向对象的思想操作数据库，持久层框架应运而生，<strong>对象关系映射ORM</strong>就是解决这种问题的技术，实现这种技术的框架有<code>Hibernate</code>和<code>Mybats</code>等，本文将对两者进行分析。</p><h2 id="2-Hibernate是什么"><a href="#2-Hibernate是什么" class="headerlink" title="2.Hibernate是什么"></a>2.Hibernate是什么</h2><p>Hibernate是一个持久化技术框架，Hibernate主要是讲关系型数据库的。</p><p><img src="../images/01-02Hibernate%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><p>配置文件可以用两种</p><ul><li>hibernate.properties</li><li>hibernate.cfg.xml（推荐）</li></ul><h3 id="2-1-Hibernate工作原理"><a href="#2-1-Hibernate工作原理" class="headerlink" title="2.1 Hibernate工作原理"></a>2.1 Hibernate工作原理</h3><p><img src="../images/01-03hibernate%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><ol><li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li><li>由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息</li><li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li><li>Session session = sf.openSession();//打开Sesssion</li><li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li><li>persistent operate操作数据，持久化操作</li><li>tx.commit();//提交事务</li><li>关闭Session</li><li>关闭SesstionFactory</li></ol><h3 id="2-2-开发步骤"><a href="#2-2-开发步骤" class="headerlink" title="2.2 开发步骤"></a>2.2 开发步骤</h3><ol><li>搭建好环境<ol><li>引入hibernate最小的jar包</li><li>准备Hibernate.cfg.xml启动配置文件</li></ol></li><li>写实体类(pojo)</li><li>为实体类写映射文件”User.hbm.xml”<ol><li>在hibernate.cfg.xml添加映射的实体</li></ol></li><li>创建库表</li><li>写测试类<ol><li>获得Configuration</li><li>创建SessionFactory</li><li>打开Session</li><li>开启事务</li><li>使用session操作数据</li><li>提交事务</li><li>关闭资源</li></ol></li></ol><h2 id="3-myBatis是什么"><a href="#3-myBatis是什么" class="headerlink" title="3.myBatis是什么"></a>3.myBatis是什么</h2><p>跟上述差不多的</p><h2 id="4-两者的区别"><a href="#4-两者的区别" class="headerlink" title="4. 两者的区别"></a>4. 两者的区别</h2><p><a href="https://www.zhihu.com/question/21104468">MyBatis和Hibernate相比，优势在哪里？</a></p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/u010197033/article/details/47276891">hibernate工作原理及作用</a></li><li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis入门教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>05-Mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-MyBatis敏捷开发入门教程</title>
    <link href="/01-Java/02-JavaEE/05-Mybatis/02-MyBatis%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/01-Java/02-JavaEE/05-Mybatis/02-MyBatis%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis入门"><a href="#MyBatis入门" class="headerlink" title="MyBatis入门"></a>MyBatis入门</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>创建数据库</li><li>创建表（注意主键，因为会影响生成的代码）</li></ul><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在<code>pom.xml</code>种添加依赖和代码自动生成工具<code>generator</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- mybatis --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- mybatis 阿里巴巴的druid连接池 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-comment">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="在resource文件夹创建一个application-yml配置文件，作为SpringBoot的配置文件"><a href="#在resource文件夹创建一个application-yml配置文件，作为SpringBoot的配置文件" class="headerlink" title="在resource文件夹创建一个application.yml配置文件，作为SpringBoot的配置文件"></a>在<code>resource</code>文件夹创建一个application.yml配置文件，作为SpringBoot的配置文件</h2><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>    <span class="hljs-attr">datasource:</span>        <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://119.28.61.108:3306/test</span>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>        <span class="hljs-attr">password:</span> <span class="hljs-string">ubuntu</span>        <span class="hljs-comment"># 使用druid数据源</span>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>        <span class="hljs-attr">filters:</span> <span class="hljs-string">stat</span>        <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>        <span class="hljs-attr">initialSize:</span> <span class="hljs-number">1</span>        <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>        <span class="hljs-attr">minIdle:</span> <span class="hljs-number">1</span>        <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>        <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>        <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">select</span> <span class="hljs-string">&#x27;x&#x27;</span>        <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>        <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>        <span class="hljs-attr">maxOpenPreparedStatements:</span> <span class="hljs-number">20</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapping/*.xml</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.winter.model</span></code></pre><h2 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h2><ol><li>配置pom.xml中generator 插件所对应的配置文件 ${basedir}/src/main/resources/generator/generatorConfig.xml</li></ol><p><strong>注意替换包名和JDBC文件路径，可以在maven的本地库中找到</strong>。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">classPathEntry</span>  <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;C:\Users\34566\.m2\repository\mysql\mysql-connector-java\5.1.46\mysql-connector-java-5.1.46.jar&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span>  <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>            <span class="hljs-comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span>        <span class="hljs-comment">&lt;!--数据库链接URL，用户名、密码 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://119.28.61.108:3306/test&quot;</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;ubuntu&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 生成模型的包名和位置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.winter.model&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 生成映射文件的包名和位置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;mapping&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 生成DAO的包名和位置--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.winter.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;tag&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Tag&quot;</span> <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useActualColumnNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span></code></pre><ol start="2"><li>点击run-Edit Configurations</li></ol><p><img src="../images/02-01.png"></p><p><img src="../images/02-02.png"></p><p><img src="../images/02-03.png"></p><p>此时将会生成3个文件夹和n个文件</p><p><img src="../images/02-04.png"></p><h2 id="生成的文件"><a href="#生成的文件" class="headerlink" title="生成的文件"></a>生成的文件</h2><ul><li>接口:通过映射到<code>XxxMapping.xml</code>文件来实现。不需要自己实现，由框架实现</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlanMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer planid)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Plan record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(Plan record)</span></span>;    <span class="hljs-function">Plan <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer planid)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(Plan record)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Plan record)</span></span>;    <span class="hljs-comment">// 此处为本人添加的方法</span>    <span class="hljs-function">List&lt;Plan&gt; <span class="hljs-title">selectByLimit</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;offset&quot;)</span> <span class="hljs-keyword">int</span> offset, <span class="hljs-meta">@Param(&quot;limit&quot;)</span> <span class="hljs-keyword">int</span> limit)</span></span>;<span class="hljs-comment">// 这是一种传参方式，其他传参方式看文末链接</span>&#125;</code></pre><ul><li>模型:根据设计的数据库自动生成的JAVABean</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>&#123;    <span class="hljs-keyword">private</span> String planID;    <span class="hljs-keyword">private</span> String planName;    <span class="hljs-keyword">private</span> String createTime;    <span class="hljs-keyword">private</span> String deadLine;    <span class="hljs-keyword">private</span> String checkTime;    <span class="hljs-keyword">private</span> String status;    List&lt;Store&gt; storeList;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPlanID</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> planID;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPlanID</span><span class="hljs-params">(String planID)</span> </span>&#123;        <span class="hljs-keyword">this</span>.planID = planID;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPlanName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> planName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPlanName</span><span class="hljs-params">(String planName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.planName = planName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(String createTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createTime = createTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDeadLine</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> deadLine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDeadLine</span><span class="hljs-params">(String deadLine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.deadLine = deadLine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCheckTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> checkTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCheckTime</span><span class="hljs-params">(String checkTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.checkTime = checkTime;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> status;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;        <span class="hljs-keyword">this</span>.status = status;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Store&gt; <span class="hljs-title">getStoreList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> storeList;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStoreList</span><span class="hljs-params">(List&lt;Store&gt; storeList)</span> </span>&#123;        <span class="hljs-keyword">this</span>.storeList = storeList;    &#125;&#125;</code></pre><p>xml文件：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.mapper.PlanMapper&quot;</span> &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;planID&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;planid&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;planName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;planname&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createTime&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createtime&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TIMESTAMP&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;deadLine&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deadline&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TIMESTAMP&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;checkTime&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;checktime&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TIMESTAMP&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> &gt;</span>    planID, planName, status, createTime, deadLine, checkTime  <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 个人添加的查询方法，需要注意定义返回类型 resultType = &quot;具体类&quot;，这个实际返回类型是list&lt;Plan&gt;，不太懂 / resultMap=&quot;BaseResultMap&quot;?自动适配？ --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByLimit&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span>&gt;</span>    SELECT    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 第一种传参方式 --&gt;</span>    FROM plan LIMIT #&#123;offset&#125;,#&#123;limit&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 第二种传参方式 parameterType 表示传入参数类型 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByPrimaryKey&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> &gt;</span>    select    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span>    from plan    where planID = #&#123;planid,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> &gt;</span>    delete from plan    where planID = #&#123;planid,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span> &gt;</span>    insert into plan (planID, planName, status,       createTime, deadLine, checkTime      )    values (#&#123;planid,jdbcType=INTEGER&#125;, #&#123;planname,jdbcType=VARCHAR&#125;, #&#123;status,jdbcType=INTEGER&#125;,       #&#123;createtime,jdbcType=TIMESTAMP&#125;, #&#123;deadline,jdbcType=TIMESTAMP&#125;, #&#123;checktime,jdbcType=TIMESTAMP&#125;      )  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertSelective&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span> &gt;</span>    insert into plan    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;planid != null&quot;</span> &gt;</span>        planID,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;planname != null&quot;</span> &gt;</span>        planName,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span> &gt;</span>        status,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createtime != null&quot;</span> &gt;</span>        createTime,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deadline != null&quot;</span> &gt;</span>        deadLine,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;checktime != null&quot;</span> &gt;</span>        checkTime,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;values (&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;planid != null&quot;</span> &gt;</span>        #&#123;planid,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;planname != null&quot;</span> &gt;</span>        #&#123;planname,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span> &gt;</span>        #&#123;status,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createtime != null&quot;</span> &gt;</span>        #&#123;createtime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deadline != null&quot;</span> &gt;</span>        #&#123;deadline,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;checktime != null&quot;</span> &gt;</span>        #&#123;checktime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateByPrimaryKeySelective&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span> &gt;</span>    update plan    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;planname != null&quot;</span> &gt;</span>        planName = #&#123;planname,jdbcType=VARCHAR&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span> &gt;</span>        status = #&#123;status,jdbcType=INTEGER&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createtime != null&quot;</span> &gt;</span>        createTime = #&#123;createtime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deadline != null&quot;</span> &gt;</span>        deadLine = #&#123;deadline,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;checktime != null&quot;</span> &gt;</span>        checkTime = #&#123;checktime,jdbcType=TIMESTAMP&#125;,      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    where planID = #&#123;planid,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.datainisghts.libai.winter.model.Plan&quot;</span> &gt;</span>    update plan    set planName = #&#123;planname,jdbcType=VARCHAR&#125;,      status = #&#123;status,jdbcType=INTEGER&#125;,      createTime = #&#123;createtime,jdbcType=TIMESTAMP&#125;,      deadLine = #&#123;deadline,jdbcType=TIMESTAMP&#125;,      checkTime = #&#123;checktime,jdbcType=TIMESTAMP&#125;    where planID = #&#123;planid,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h2 id="调用查询数据库"><a href="#调用查询数据库" class="headerlink" title="调用查询数据库"></a>调用查询数据库</h2><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlanController</span> </span>&#123;    <span class="hljs-meta">@Autowired(required = false)</span>    <span class="hljs-keyword">private</span> PlanMapper planMapper;    List&lt;Plan&gt; planList = planMapper.selectByLimit(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;</code></pre><h2 id="在Application中添加注解"><a href="#在Application中添加注解" class="headerlink" title="在Application中添加注解"></a>在Application中添加注解</h2><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@MapperScan(&quot;com.datainisghts.libai.winter.mapper&quot;)</span><span class="hljs-comment">//扫描的类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application.class, args);    &#125;&#125;</code></pre><h2 id="采坑日记"><a href="#采坑日记" class="headerlink" title="采坑日记"></a>采坑日记</h2><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><ul><li>错误:A query was run and no Result Maps were found for the Mapped Statement</li><li>原因：在xml中没有设置返回类型</li><li>解决，设置访回类型<code>resultType=&quot;com.datainisghts.libai.winter.model.Plan&quot;</code></li></ul><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><ul><li>描述：启动后发现，没有什么变化</li><li>解决：检查注解，是否设置了扫描<code>@MapperScan(&quot;com.datainisghts.libai.winter.mapper&quot;)</code></li></ul><h3 id="知识盲区"><a href="#知识盲区" class="headerlink" title="知识盲区"></a>知识盲区</h3><ul><li>描述：get如何传递多个参数</li><li>解决：</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> PlanResponse <span class="hljs-title">getPlan</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;index&quot;, defaultValue = &quot;0&quot;)</span> String index,</span></span><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-meta">@RequestParam(value = &quot;step&quot;, defaultValue = &quot;10&quot;)</span> String step)</span> </span>&#123;&#125;</code></pre><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/winter_chen001/article/details/77249029">Spring boot Mybatis 整合</a></p><p><a href="https://blog.csdn.net/tylai520/article/details/6936064">mybatis limit的使用</a></p><p><a href="https://blog.csdn.net/qq_29842929/article/details/53607096">MyBatis传递参数的3种方式</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>05-Mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Spring-DI</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/02-Spring-DI/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/02-Spring-DI/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-DI-依赖注入-Dependiency-Injection"><a href="#Spring-DI-依赖注入-Dependiency-Injection" class="headerlink" title="Spring-DI 依赖注入 Dependiency Injection"></a>Spring-DI 依赖注入 Dependiency Injection</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>wiring 装配</li><li></li></ul><h2 id="wiring"><a href="#wiring" class="headerlink" title="wiring"></a>wiring</h2><ol><li>隐式自动发现和自动装配</li><li>基于JAVA的显示装配</li><li>基于xml的显示装配</li></ol><p>建议使用顺序（支持混合使用）</p><blockquote><p>隐式自动发现和自动装配 &gt; 基于JAVA的显示装配 &gt; 基于xml的显示装配</p></blockquote><h3 id="自动wiring"><a href="#自动wiring" class="headerlink" title="自动wiring"></a>自动wiring</h3><pre><code class="hljs java"></code></pre><h3 id="java-wiring"><a href="#java-wiring" class="headerlink" title="java wiring"></a>java wiring</h3><h3 id="xml-wiring"><a href="#xml-wiring" class="headerlink" title="xml wiring"></a>xml wiring</h3>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-全局异常拦截</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/07-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/07-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="全局异常拦截"><a href="#全局异常拦截" class="headerlink" title="全局异常拦截"></a>全局异常拦截</h1><p>异常类</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(&quot;/err&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);    &#125;&#125;</code></pre><p>异常拦截器</p><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">exceptionHandler</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">            HttpServletResponse response,</span></span><span class="hljs-function"><span class="hljs-params">            Exception e)</span> </span>&#123;        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;Exception&quot;</span>,e.getMessage());        map.put(<span class="hljs-string">&quot;Url&quot;</span>,request.getRequestURI());        map.put(<span class="hljs-string">&quot;Character&quot;</span>,response.getCharacterEncoding());        <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre><p>ajax异常拦截</p><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AjaxExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ajaxExceptionHandler</span><span class="hljs-params">(Exception e)</span><span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//todo</span>        System.out.println(e.getMessage());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08-跨域请求</title>
    <link href="/01-Java/03-Spring/01-SpringFramwork/08-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <url>/01-Java/03-Spring/01-SpringFramwork/08-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot跨域请求"><a href="#SpringBoot跨域请求" class="headerlink" title="SpringBoot跨域请求"></a>SpringBoot跨域请求</h1><p><code>CorsFilter.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.datainisghts.libai;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> javax.servlet.*;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletResponse response = (HttpServletResponse) res;        HttpServletRequest reqs = (HttpServletRequest) req;        <span class="hljs-comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;,reqs.getHeader(&quot;Origin&quot;));</span>        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, GET, PATCH, DELETE, PUT&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>);        response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Origin, X-Requested-With, Content-Type, Accept&quot;</span>);        chain.doFilter(req, res);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>01-SpringFramwork</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-SpringData入门</title>
    <link href="/01-Java/03-Spring/05-SpringData/01-SpringData%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/03-Spring/05-SpringData/01-SpringData%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData入门"><a href="#SpringData入门" class="headerlink" title="SpringData入门"></a>SpringData入门</h1><h2 id="SpringData是什么"><a href="#SpringData是什么" class="headerlink" title="SpringData是什么"></a>SpringData是什么</h2><p>Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。举个栗子，数据有时同时存在ES和数据库中，作为JAVA程序员，需要重复操作持久层。<strong>SpringData可以通过简单的配置，减少持久层的开发难度和工作量。</strong></p><h2 id="没有SpringData之前怎么做"><a href="#没有SpringData之前怎么做" class="headerlink" title="没有SpringData之前怎么做"></a>没有SpringData之前怎么做</h2><h3 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1. JDBC"></a>1. JDBC</h3><ol><li><p>添加依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>创建数据库和表</p></li><li><p>配置jdbc.properties</p><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span> = <span class="hljs-string">jdbc:mysql:///springdata</span> <span class="hljs-meta">jdbc.username</span> = <span class="hljs-string">root</span> <span class="hljs-meta">jdbc.password</span> = <span class="hljs-string">123456</span> <span class="hljs-meta">jdbc.driverClass</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre></li><li><p>获得/释放数据库连接对象的类</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 根据properties获取数据库连接</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        InputStream resourceAsStream = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);        Properties properties = <span class="hljs-keyword">new</span> Properties();        properties.load(resourceAsStream);        String url = properties.getProperty(<span class="hljs-string">&quot;jdbc.url&quot;</span>);        String userName = properties.getProperty(<span class="hljs-string">&quot;jdbc.username&quot;</span>);        String password = properties.getProperty(<span class="hljs-string">&quot;jdbc.password&quot;</span>);        String dirverClass = properties.getProperty(<span class="hljs-string">&quot;jdbc.driverClass&quot;</span>);        Class.forName(dirverClass);        Connection connection = DriverManager.getConnection(url, userName, password);        <span class="hljs-keyword">return</span> connection;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 释放数据库连接的相关对象</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> resultSet</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> statement</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> connection</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(ResultSet resultSet , Statement statement , Connection connection)</span></span>&#123;        <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                resultSet.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span>(statement != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                statement.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span>(connection != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                connection.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>编写POJO</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age ;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></li><li><p>编写Dao层（接口）</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentDao</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 查询所有的学生信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectAllStudent</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li><li><p>编写Dao层接口的实现类，获取链接对象，实现持久层操作，释放链接对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">selectAllStudent</span><span class="hljs-params">()</span> </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        PreparedStatement statement = <span class="hljs-keyword">null</span>;        ResultSet resultSet = <span class="hljs-keyword">null</span>;        ArrayList&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">try</span> &#123;            String sql = <span class="hljs-string">&quot;select * from Student &quot;</span>;            connection = JDBCUtil.getConnection();            statement = connection.prepareStatement(sql);            resultSet = statement.executeQuery();            Student student = <span class="hljs-keyword">null</span> ;            <span class="hljs-keyword">while</span>(resultSet.next())&#123;                <span class="hljs-keyword">int</span> id = resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);                String name = resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);                <span class="hljs-keyword">int</span> age = resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>);                student = <span class="hljs-keyword">new</span> Student();                student.setId(id);                student.setName(name);                student.setAge(age);                students.add(student);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            JDBCUtil.release(resultSet,statement , connection);        &#125;        <span class="hljs-keyword">return</span> students;    &#125;&#125;</code></pre></li></ol><ul><li>总结：啥都要自己做<ul><li>数据库创建</li><li>数据库连接</li><li>POJO的创建</li><li>DAO接口</li><li>DAO的实现</li></ul></li><li>缺点：<ul><li>过程繁琐，连接还要自己关</li><li>数据库就是爸爸，修改数据库意味着<code>POJO</code>, <code>DAO</code>, <code>DAO实现类</code>都可能要改</li></ul></li></ul><h3 id="2-JDBCTemplate"><a href="#2-JDBCTemplate" class="headerlink" title="2. JDBCTemplate"></a>2. JDBCTemplate</h3><ol><li><p>添加依赖</p> <pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring-jdbc 为了获取jdbtTemplete的处理--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- spring 为了进行spring的配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>创建数据库和数据表</p></li><li><p>编写配置文件<code>applicationcontext.xml</code></p> <pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns:xsi</span> = <span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span> = <span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///springdata&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!--让操作数据库的对象由spring进行管理--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplateStudentDaoImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hnu.scw.spring.jdbctemplate.dao.impl.JDBCTemplateStudentDaoImpl&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></li><li><p>编写POJO</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age ;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></li><li><p>编写Dao层接口代码</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JDBCTemplateStudentDao</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 查询所有的学生数据</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectAllStudent</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li><li><p>编写Dao层实体类代码</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCTemplateStudentDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JDBCTemplateStudentDao</span></span>&#123;    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate ;    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">getJdbcTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> jdbcTemplate;    &#125;    <span class="hljs-comment">//注入JdbcTemplate</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJdbcTemplate</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;        <span class="hljs-keyword">this</span>.jdbcTemplate = jdbcTemplate;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 进行jdbctemplate模板来操作数据库</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">selectAllStudent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> ArrayList&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        String sql = <span class="hljs-string">&quot;select * from student&quot;</span>;        jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowCallbackHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRow</span><span class="hljs-params">(ResultSet resultSet)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;                <span class="hljs-keyword">int</span> id = resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);                String name = resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);                <span class="hljs-keyword">int</span> age = resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);                Student student = <span class="hljs-keyword">new</span> Student();                student.setAge(age);                student.setName(name);                student.setId(id);                students.add(student);            &#125;        &#125;);        <span class="hljs-keyword">return</span> students;    &#125;&#125;</code></pre></li></ol><ul><li>总结：比起JDBC，少了<strong>数据库连接</strong>的步骤<ul><li>数据库创建</li><li>POJO的创建</li><li>DAO接口</li><li>DAO的实现</li></ul></li><li>缺点：<ul><li>过程繁琐，实现类不好写</li><li>数据库就是爸爸，修改数据库意味着<code>POJO</code>, <code>DAO</code>, <code>DAO实现类</code>都可能要改</li></ul></li></ul><h3 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3. Mybatis"></a>3. Mybatis</h3><ol><li>添加依赖</li><li>添加数据库连接配置</li><li>添加自动生成POJO配置</li><li>自动生成POJO和DAO接口和mapping文件</li></ol><ul><li>总结：轻量，比起JDBCTemplate，少了<strong>DAO实现类</strong>的步骤，POJO和DAO接口用的插件也能用到其他方法中去<ul><li>数据库创建</li><li>POJO的创建</li><li>DAO接口</li></ul></li><li>缺点：<ul><li>数据库就是爸爸，修改数据库意味着<code>POJO</code>, <code>DAO</code>, <code>mapping文件</code>都可能要改</li></ul></li></ul><h3 id="4-Hibernate"><a href="#4-Hibernate" class="headerlink" title="4. Hibernate"></a>4. Hibernate</h3><p>JPA: Java Persistence API （Java持久层接口），使得应用程序使用相同的接口来访问持久层</p><p>hibernate: 是JPA的一种实现，JPA只是一种ORM规范</p><h2 id="SpringData怎么做"><a href="#SpringData怎么做" class="headerlink" title="SpringData怎么做"></a>SpringData怎么做</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-创建数据库，可以不用建表-会根据POJO自动创建"><a href="#2-创建数据库，可以不用建表-会根据POJO自动创建" class="headerlink" title="2. 创建数据库，可以不用建表(会根据POJO自动创建)"></a>2. 创建数据库，可以不用建表(会根据POJO自动创建)</h3><h3 id="3-添加数据库配置application-properties"><a href="#3-添加数据库配置application-properties" class="headerlink" title="3. 添加数据库配置application.properties"></a>3. 添加数据库配置<code>application.properties</code></h3><pre><code class="hljs properties"><span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">create</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/db_example</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">Data*2018*</span></code></pre><h3 id="4-编写POJO"><a href="#4-编写POJO" class="headerlink" title="4. 编写POJO"></a>4. 编写POJO</h3><ul><li>注意，Entity是javax包下的</li></ul><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.persistence.Column;<span class="hljs-keyword">import</span> javax.persistence.Entity;<span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<span class="hljs-keyword">import</span> javax.persistence.Id;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Entity(name = &quot;User&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column(length = 255, nullable = true)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Getter Setter方法省略</span><span class="hljs-comment">     */</span>&#125;</code></pre><h3 id="5-DAO层接口，继承CrudRepository接口"><a href="#5-DAO层接口，继承CrudRepository接口" class="headerlink" title="5. DAO层接口，继承CrudRepository接口"></a>5. DAO层接口，继承CrudRepository接口</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><h3 id="6-无需实现，即可调用"><a href="#6-无需实现，即可调用" class="headerlink" title="6. 无需实现，即可调用"></a>6. 无需实现，即可调用</h3><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>    <span class="hljs-comment">// This means that this class is a Controller</span><span class="hljs-meta">@RequestMapping(path = &quot;/demo&quot;)</span> <span class="hljs-comment">// This means URL&#x27;s start with /demo (after Application path)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">// This means to get the bean called userRepository</span>    <span class="hljs-comment">// Which is auto-generated by Spring, we will use it to handle the data</span>    <span class="hljs-keyword">private</span> UserRepository userRepository;    <span class="hljs-meta">@GetMapping(path = &quot;/add&quot;)</span> <span class="hljs-comment">// Map ONLY GET Requests</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function">String <span class="hljs-title">addNewUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name)</span> </span>&#123;        <span class="hljs-comment">// @ResponseBody means the returned String is the response, not a view name</span>        <span class="hljs-comment">// @RequestParam means it is a parameter from the GET or POST request</span>        User n = <span class="hljs-keyword">new</span> User(name);        userRepository.save(n);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Saved&quot;</span>;    &#125;    <span class="hljs-meta">@GetMapping(path = &quot;/all&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function">Iterable&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// This returns a JSON or XML with the users</span>        <span class="hljs-keyword">return</span> userRepository.findAll();    &#125;&#125;</code></pre><ul><li>总结：比起JDBCTemplate，少了<strong>Dao的实现，数据表的创建</strong>的步骤<ul><li>数据库创建（无需建表）</li><li>POJO的创建</li><li>DAO接口</li></ul></li><li>优点：<ul><li>POJO一统江湖，实现类根本就不存在的</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Cs_hnu_scw/article/details/80786161">手把手教你如何玩转Spring Data</a></p><p><a href="https://spring.io/guides/gs/accessing-data-mysql/">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-SpringData-Repository详解</title>
    <link href="/01-Java/03-Spring/05-SpringData/02-SpringData-Repository%E8%AF%A6%E8%A7%A3/"/>
    <url>/01-Java/03-Spring/05-SpringData/02-SpringData-Repository%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData-Repository详解"><a href="#SpringData-Repository详解" class="headerlink" title="SpringData-Repository详解"></a>SpringData-Repository详解</h1><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们先看看源码中的<code>Repository</code>接口</p><pre><code class="hljs java"><span class="hljs-meta">@Indexed</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>&#123;&#125;</code></pre><p><strong>Repository</strong>是个空接口，是一个标记接口，类似于序列化接口，用于标记该类作为DAO接口</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="使用命名规范的方法"><a href="#使用命名规范的方法" class="headerlink" title="使用命名规范的方法"></a>使用命名规范的方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 方式一：继承接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;&#125;<span class="hljs-comment">// 方式二：注解</span><span class="hljs-meta">@RepositoryDefinition(domainClass=User.class,IdClass=Integer.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> </span>&#123;    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findByName</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre><p>若我们定义的接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean，纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法。IOC容器中实际存放了继承了Repository的接口的实现类，而这个实现类由spring帮助完成 。</p><p>而接口中的方法不需要实现类，但是接口中的方法需要遵守[Spring Data定义的规范](../03-Spring Data定义的规范/)</p><h4 id="使用自定义的方法"><a href="#使用自定义的方法" class="headerlink" title="使用自定义的方法"></a>使用自定义的方法</h4><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select t from Teacher t where t.name = ?1&quot;)</span><span class="hljs-function">Teacher <span class="hljs-title">queryTeacherByName</span><span class="hljs-params">(String name)</span></span>;</code></pre><h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><p>我们之前都是写的查询操作，那么如果进行更新和删除操作，是不是也是一样的？</p><p>然而，请注意，并不是的，而且特别要注意下面两点：</p><ol><li>对于更新和删除操作，必须在接口的方法上面添加@Modifying注解，这样就用于标识这是一个修改的操作</li><li>必须在调用这个接口方法的地方（一般就是service层）使用事务，即用@Transactional注解进行标识。</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 根据老师表的id进行修改对应数据的老师名字</span><span class="hljs-comment">* 必须要添加<span class="hljs-doctag">@Modifying</span>注解，并且要在调用的方法上添加事务注解<span class="hljs-doctag">@Transactional</span></span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Modifying</span><span class="hljs-meta">@Query(&quot;update Teacher  t set t.name = ?1 where t.id = ?2&quot;)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateTeacherById</span><span class="hljs-params">(String name , Integer id)</span></span>;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringDataService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TeacherRepository teacherRepository;     <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TeacherCrudRespository teacherCrudRespository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据id进行修改老师的名字</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateTeacher</span><span class="hljs-params">(String name , Integer id)</span></span>&#123;        teacherRepository.updateTeacherById(name , id);    &#125;&#125;</code></pre><h2 id="Repository的其他接口"><a href="#Repository的其他接口" class="headerlink" title="Repository的其他接口"></a>Repository的其他接口</h2><h3 id="CrudRepository"><a href="#CrudRepository" class="headerlink" title="CrudRepository"></a>CrudRepository</h3><p><img src="../images/2019-03-19-22-14-24.png"></p><h3 id="JpaRepository"><a href="#JpaRepository" class="headerlink" title="JpaRepository"></a>JpaRepository</h3><p><img src="../images/2019-03-19-22-21-01.png"> </p><h3 id="PagingAndSortingRepository"><a href="#PagingAndSortingRepository" class="headerlink" title="PagingAndSortingRepository"></a>PagingAndSortingRepository</h3><p><img src="../images/2019-03-19-22-26-03.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Cs_hnu_scw/article/details/80786161">手把手教你如何玩转Spring Data</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-SpringData-Mysql(JPA)</title>
    <link href="/01-Java/03-Spring/05-SpringData/03-SpringData-Mysql(JPA)/"/>
    <url>/01-Java/03-Spring/05-SpringData/03-SpringData-Mysql(JPA)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData-Mysql-JPA"><a href="#SpringData-Mysql-JPA" class="headerlink" title="SpringData-Mysql(JPA)"></a>SpringData-Mysql(JPA)</h1><ol><li><p>pom.xml</p> <pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>application.properties</p> <pre><code class="hljs properties"><span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">create</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/db_example</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">Data*2018*</span></code></pre></li><li><p>pojo.User.java</p> <pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.persistence.Column;<span class="hljs-keyword">import</span> javax.persistence.Entity;<span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<span class="hljs-keyword">import</span> javax.persistence.Id;<span class="hljs-meta">@Entity(name = &quot;User&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column(length = 255, nullable = true)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></li><li><p>dao.UserRepositury.java</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepositury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre></li><li><p>test.UserReposituryTest.java</p> <pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> UserRepositury userRepositury;userRepositury.save(<span class="hljs-keyword">new</span> User(name));</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-SpringData-JPA方法规范</title>
    <link href="/01-Java/03-Spring/05-SpringData/04-SpringData-JPA%E6%96%B9%E6%B3%95%E8%A7%84%E8%8C%83/"/>
    <url>/01-Java/03-Spring/05-SpringData/04-SpringData-JPA%E6%96%B9%E6%B3%95%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData-JPA方法规范"><a href="#SpringData-JPA方法规范" class="headerlink" title="SpringData-JPA方法规范"></a>SpringData-JPA方法规范</h1><table><thead><tr><th>关键字</th><th>方法命名</th><th>sql where字句</th></tr></thead><tbody><tr><td>And</td><td>findByNameAndPwd</td><td>where name= ? and pwd =?</td></tr><tr><td>Or</td><td>findByNameOrSex</td><td>where name= ? or sex=?</td></tr><tr><td>Is,Equals</td><td>findById,findByIdEquals</td><td>where id= ?</td></tr><tr><td>Between</td><td>findByIdBetween</td><td>where id between ? and ?</td></tr><tr><td>LessThan</td><td>findByIdLessThan</td><td>where id &lt; ?</td></tr><tr><td>LessThanEquals</td><td>findByIdLessThanEquals</td><td>where id &lt;= ?</td></tr><tr><td>GreaterThan</td><td>findByIdGreaterThan</td><td>where id &gt; ?</td></tr><tr><td>GreaterThanEquals</td><td>findByIdGreaterThanEquals</td><td>where id &gt; = ?</td></tr><tr><td>After</td><td>findByIdAfter</td><td>where id &gt; ?</td></tr><tr><td>Before</td><td>findByIdBefore</td><td>where id &lt; ?</td></tr><tr><td>IsNull</td><td>findByNameIsNull</td><td>where name is null</td></tr><tr><td>isNotNull,NotNull</td><td>findByNameNotNull</td><td>where name is not null</td></tr><tr><td>Like</td><td>findByNameLike</td><td>where name like ?</td></tr><tr><td>NotLike</td><td>findByNameNotLike</td><td>where name not like ?</td></tr><tr><td>StartingWith</td><td>findByNameStartingWith</td><td>where name like ‘?%’</td></tr><tr><td>EndingWith</td><td>findByNameEndingWith</td><td>where name like ‘%?’</td></tr><tr><td>Containing</td><td>findByNameContaining</td><td>where name like ‘%?%’</td></tr><tr><td>OrderBy</td><td>findByIdOrderByXDesc</td><td>where id=? order by x desc</td></tr><tr><td>Not</td><td>findByNameNot</td><td>where name &lt;&gt; ?</td></tr><tr><td>In</td><td>findByIdIn(Collection&lt;?&gt; c)</td><td>where id in (?)</td></tr><tr><td>NotIn</td><td>findByIdNotIn(Collection&lt;?&gt; c)</td><td>where id not  in (?)</td></tr><tr><td>True</td><td>findByAaaTuewhere aaa = true</td><td></td></tr><tr><td>False</td><td>findByAaaFalse</td><td>where aaa = false</td></tr><tr><td>IgnoreCase</td><td>findByNameIgnoreCase</td><td>where UPPER(name)=UPPER(?)</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Cs_hnu_scw/article/details/80786161">手把手教你如何玩转Spring Data</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-SpringData-ES</title>
    <link href="/01-Java/03-Spring/05-SpringData/05-SpringData-ES/"/>
    <url>/01-Java/03-Spring/05-SpringData/05-SpringData-ES/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData-ES"><a href="#SpringData-ES" class="headerlink" title="SpringData-ES"></a>SpringData-ES</h1><ol><li><p>pom.xml</p> <pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>application.properties</p> <pre><code class="hljs properties"><span class="hljs-meta">spring.data.elasticsearch.repositories.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.data.elasticsearch.cluster-name</span>=<span class="hljs-string">docker-cluster</span><span class="hljs-meta">spring.data.elasticsearch.cluster-nodes</span>=<span class="hljs-string">localhost:9300</span></code></pre></li><li><p>pojo.User.java</p> <pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;<span class="hljs-keyword">import</span> org.springframework.data.elasticsearch.annotations.CompletionField;<span class="hljs-keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;<span class="hljs-meta">@Document(indexName = &quot;spring_data_index_example&quot;, type = &quot;_doc&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@CompletionField(analyzer = &quot;text&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre></li><li><p>dao.EsUserRepositury.java</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepositury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchCrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre></li><li><p>test.UserReposituryTest.java</p> <pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> UserRepositury userRepositury;userRepositury.save(<span class="hljs-keyword">new</span> User(name));</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-SpringData-MutualModel</title>
    <link href="/01-Java/03-Spring/05-SpringData/07-SpringData-MutualModel/"/>
    <url>/01-Java/03-Spring/05-SpringData/07-SpringData-MutualModel/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringData-MutualModel"><a href="#SpringData-MutualModel" class="headerlink" title="SpringData-MutualModel"></a>SpringData-MutualModel</h1><p><a href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.multiple-modules">官方文档</a><br><a href="https://www.jianshu.com/p/27e1d583aafb">简书翻译</a></p><h2 id="错误的尝试"><a href="#错误的尝试" class="headerlink" title="错误的尝试"></a>错误的尝试</h2><h3 id="一个POJO？不行"><a href="#一个POJO？不行" class="headerlink" title="一个POJO？不行"></a>一个POJO？<strong>不行</strong></h3><p>我们肯定想着，既然这样，是不是说，我们可以只使用一个POJO就能完成持久化了呢？</p><p>比如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JpaPersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">Person</span>, <span class="hljs-title">Long</span>&gt; </span>&#123; …&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MongoDBPersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">Person</span>, <span class="hljs-title">Long</span>&gt; </span>&#123; …&#125;<span class="hljs-meta">@Entity</span><span class="hljs-meta">@Document</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  …&#125;</code></pre><p><strong>是不可以的</strong>，实际测试同时使用，只有一个会生效</p><h3 id="两个POJO，一个Repositury？不行"><a href="#两个POJO，一个Repositury？不行" class="headerlink" title="两个POJO，一个Repositury？不行"></a>两个POJO，一个Repositury？<strong>不行</strong></h3><p>如果，我有了两个POJO</p><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;  …&#125;<span class="hljs-meta">@Document</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsUser</span> </span>&#123;  …&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 直接报错，两个参数不同</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepositury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt;,<span class="hljs-title">ElasticsearchCrudRepository</span>&lt;<span class="hljs-title">EsUser</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;<span class="hljs-comment">// 既然一个POJO都不行了，这个自然也是不行的。。。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepositury</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt;,<span class="hljs-title">ElasticsearchCrudRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre><h2 id="唯一的做法"><a href="#唯一的做法" class="headerlink" title="唯一的做法"></a>唯一的做法</h2><p>两个POJO 两个Repositury</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">Person</span>, <span class="hljs-title">Long</span>&gt; </span>&#123; …&#125;<span class="hljs-meta">@Entity</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;  …&#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Long</span>&gt; </span>&#123; …&#125;<span class="hljs-meta">@Document</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;  …&#125;</code></pre><p>同时在配置上</p><pre><code class="hljs java"><span class="hljs-meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span><span class="hljs-meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationConfiguration</span> </span>&#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-SpringBoot实现RestAPI</title>
    <link href="/01-Java/03-Spring/03-SpringBoot/01-SpringBoot%E5%AE%9E%E7%8E%B0RestAPI/"/>
    <url>/01-Java/03-Spring/03-SpringBoot/01-SpringBoot%E5%AE%9E%E7%8E%B0RestAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><p><a href="https://spring.io/guides/gs/rest-service/">入门指南</a></p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>直接创建一个maven工程，并添加以下内容。</p><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>json-path<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span></code></pre><p>Application.java</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cenzhongman.spring;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明这是一个SpringBootApplication，提供程序的入口，剩下的会根据各种@去找程序的其他部分</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 启动一个Application</span>        SpringApplication.run(Application.class, args);    &#125;&#125;</code></pre><p>模型类<code>Greeting.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cenzhongman.spring;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 普通的数据类型定义</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String content;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, String content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.content = content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> content;    &#125;&#125;</code></pre><p>控制器类<code>GreetingController.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cenzhongman.spring;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<span class="hljs-meta">@RestController</span><span class="hljs-comment">// 告诉系统这是一个RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String template = <span class="hljs-string">&quot;Hello,%s!&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong counter = <span class="hljs-keyword">new</span> AtomicLong();<span class="hljs-comment">// 创建一个自增长的数</span>    <span class="hljs-meta">@RequestMapping(&quot;/greeting&quot;)</span>    <span class="hljs-comment">// 地址映射</span>    <span class="hljs-comment">// RequestParam用于get传参</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Greeting <span class="hljs-title">greeting</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Greeting(counter.incrementAndGet(), String.format(template, name));        <span class="hljs-comment">// 返回的对象将被自动封装成json,作为response</span>    &#125;&#125;</code></pre><p>这个程序将会使用Spring boot创建一个Tomcat容器，在<a href="http://localhost:8080/greeting/">http://localhost:8080/greeting/</a>返回json数据。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>03-SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-springBoot的热部署问题</title>
    <link href="/01-Java/03-Spring/03-SpringBoot/02-springBoot%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/"/>
    <url>/01-Java/03-Spring/03-SpringBoot/02-springBoot%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="热部署是什么"><a href="#热部署是什么" class="headerlink" title="热部署是什么"></a>热部署是什么</h1><p>热部署即不停止服务器进行版本升级迭代等信息，但是这个只是在开发的时候监控类的变化，即使变更而已，然而并不是在生产环境中进行热部署。因此，然并卵。。。</p><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><ol><li>修改<code>pom.xml</code>文件</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ol start="2"><li>增加配置文件</li></ol><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>    <span class="hljs-comment"># 有页面的时候关闭缓存，几时刷新</span>    <span class="hljs-attr">thymeleaf:</span>        <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 打开热部署</span>    <span class="hljs-attr">devtools:</span>        <span class="hljs-attr">restart:</span>            <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><ol start="3"><li>打开idea自动构建项目</li></ol><p><img src="../images/04-01.png"></p><ol start="4"><li>设置运行自动构建</li></ol><p>组合键：“Shift+Ctrl+Alt+/” ，选择 “Registry” ，选中打勾 “compiler.automake.allow.when.app.running”<br><a href="https://www.cnblogs.com/leeIndex/p/8659967.html">参考博客</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>03-SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-将资源文件的属性配置映射到实体类</title>
    <link href="/01-Java/03-Spring/03-SpringBoot/03-%E5%B0%86%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <url>/01-Java/03-Spring/03-SpringBoot/03-%E5%B0%86%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="将资源文件中的属性配置映射到实体类"><a href="#将资源文件中的属性配置映射到实体类" class="headerlink" title="将资源文件中的属性配置映射到实体类"></a>将资源文件中的属性配置映射到实体类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>什么意思？就是比如说，我在资源文件中配置了数据库信息，怎么才能映射到一个实体的javaBean中，实现资源的读取</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>1.添加依赖</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><blockquote><p>2.先我们需要一个资源文件，注意不是配置文件</p></blockquote><ul><li>resource.properties</li></ul><pre><code class="hljs properties"><span class="hljs-meta">com.cenzhongman.example.database</span>=<span class="hljs-string">user</span><span class="hljs-meta">com.cenzhongman.example.userName</span>=<span class="hljs-string">root</span><span class="hljs-meta">com.cenzhongman.example.passwd</span>=<span class="hljs-string">ubuntu</span><span class="hljs-meta">com.cenzhongman.example.url</span>=<span class="hljs-string">mysql://localhost:3306</span></code></pre><blockquote><p>3.这时候我们要去<strong>注入</strong>这个文件了，那么注入到哪里去呢，我们需要一个对应的类</p></blockquote><ul><li>Database.java</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// 设置前缀</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;com.cenzhongman.example&quot;)</span><span class="hljs-comment">// 设置文件路径</span><span class="hljs-meta">@PropertySource(value = &quot;classpath:resource.properties&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Database</span> </span>&#123;    <span class="hljs-keyword">private</span> String database;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String passwd;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDatabase</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> database;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDatabase</span><span class="hljs-params">(String database)</span> </span>&#123;        <span class="hljs-keyword">this</span>.database = database;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userName = userName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPasswd</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> passwd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPasswd</span><span class="hljs-params">(String passwd)</span> </span>&#123;        <span class="hljs-keyword">this</span>.passwd = passwd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUrl</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> url;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUrl</span><span class="hljs-params">(String url)</span> </span>&#123;        <span class="hljs-keyword">this</span>.url = url;    &#125;&#125;</code></pre><blockquote><p>4.此时我们的配置和类已经映射起来了，我们使用个Controller来体验一下</p></blockquote><ul><li>HelloController.java</li></ul><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Database database;    <span class="hljs-meta">@RequestMapping(&quot;/getDatabaseInfo&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDatabaseInfo</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(database.getDatabase());        System.out.println(database.getPasswd());        System.out.println(database.getUrl());        System.out.println(database.getUserName());    &#125;&#125;</code></pre><p>此时，通过<code>@Autowired</code>已经完成将资源文件中的属性配置映射到实体类的任务。。。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>03-SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>00-日志框架大一统</title>
    <link href="/01-Java/99-Others/01-Log/00-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A4%A7%E4%B8%80%E7%BB%9F/"/>
    <url>/01-Java/99-Others/01-Log/00-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%A4%A7%E4%B8%80%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="日志框架大一统"><a href="#日志框架大一统" class="headerlink" title="日志框架大一统"></a>日志框架大一统</h1><p>在 sun 开发 logger 前，apache 开发了功能强大的 log4j 日志工具，并向 sun 推荐将其纳入到 jdk 的一部分，可是 sun 拒绝了 apache 的提议，sun 后来自己开发了一套记录日志的工具，即JUL。log4j 已经成了事实上的标准，但由于又有一部分开发者在使用 sun logger，因此 apache 才推出 Apache Commons Logging。</p><p>log4j存在一定的效率问题，于是有了log4j2；log4j的创始人自己又搞了一套logback；slf4j也知道大家在头疼日志问题，于是搞了slf4j</p><h2 id="各个框架包含的内容"><a href="#各个框架包含的内容" class="headerlink" title="各个框架包含的内容"></a>各个框架包含的内容</h2><ol><li>log4j – 一个鼻祖级别的日志框架<ul><li>log4j1的全部内容</li></ul></li><li>log4j2 – log4j升级版<ul><li>log4j-api:log4j2定义的API</li><li>log4j-core:log4j2上述API的实现</li></ul></li><li>logback – log4j的创始人觉得log4j不好，于是搞了logback<ul><li>logback-core:logback的核心包</li><li>logback-classic：logback实现了slf4j的API</li></ul></li><li>jul – JDK自带Log</li><li>jcl – JAVA-commons-logging Apache实现的日志框架大一统<ul><li>commons-logging:commons-logging的原生全部内容</li><li>log4j-jcl:commons-logging到log4j2的桥梁</li><li>jcl-over-slf4j：commons-logging到slf4j的桥梁</li></ul></li><li>slf4j – 自己不实现日志，作为一个桥的作用<ul><li>slf4j-jdk14：slf4j到jdk-logging的桥梁</li><li>slf4j-log4j12：slf4j到log4j1的桥梁</li><li>log4j-slf4j-impl：slf4j到log4j2的桥梁</li><li>logback-classic：slf4j到logback的桥梁</li><li>slf4j-jcl：slf4j到commons-logging的桥梁</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这么多日志框架，我们作为一个开发者，需要开发一个应用必须依赖各种项目，就会导致日志混乱，必然要使用大一统框架，<code>jcl</code>和<code>slf4j</code>都实现了大一统，那到底用谁呢</p><p><strong><strong><strong><em>划重点</em></strong></strong></strong></p><blockquote><p><code>jcl</code>有自己的日志实现，支持<code>log4j</code>、<code>slf4j</code>、<code>jul</code>，不支持logback和log4j2<br><code>slf4j</code>没有自己的日志实现，必须使用其他的日志框架，支持<code>log4j</code>、<code>log4j2</code>、 <code>logback</code>、<code>jul</code>、<code>jcl</code></p></blockquote><p>使用建议：</p><p>使用<code>slf4j</code>作为日志大一统框架，然后使用一个自己顺手的框架，如<code>slf4j2</code>、<code>logback</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  =================================================  --&gt;</span><span class="hljs-comment">&lt;!--  日志及相关依赖（用slf4j+logback代替jcl+log4j）          --&gt;</span><span class="hljs-comment">&lt;!--  =================================================  --&gt;</span><span class="hljs-comment">&lt;!-- 引入logback --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 引入slf4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 将log4j2转到slf4j中来 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 将log4j转到slf4j中来 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 将jcl转到slf4j中来 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 将jul转到slf4j中来 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jul-to-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="最终的样子"><a href="#最终的样子" class="headerlink" title="最终的样子"></a>最终的样子</h2><p>slf4j官方图<br><img src="../images/2019-01-22-10-25-25.png"><br>自己画的图<br><img src="../images/2019-01-22-10-45-22.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.slf4j.org/manual.html">slf4j官方文档–很短</a><br><a href="https://my.oschina.net/pingpangkuangmo/blog/410224">slf4j、jcl、jul、log4j1、log4j2、logback大总结</a><br><a href="http://www.importnew.com/21486.html">混乱的 Java 日志体系</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>01-Log</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-log4j</title>
    <link href="/01-Java/99-Others/01-Log/01-log4j/"/>
    <url>/01-Java/99-Others/01-Log/01-log4j/</url>
    
    <content type="html"><![CDATA[<h1 id="Log4j使用教程"><a href="#Log4j使用教程" class="headerlink" title="Log4j使用教程"></a>Log4j使用教程</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><pre><code class="hljs sh"><span class="hljs-comment">### 设置日志的级别###</span>log4j.rootLogger=debug,stdout,D,E<span class="hljs-comment">### 输出信息到控制抬 ###</span>log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n<span class="hljs-comment">### 输出DEBUG 级别以上的日志到文件 ###</span>log4j.appender.D=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File=log4j.loglog4j.appender.D.Append=<span class="hljs-literal">true</span>log4j.appender.D.Threshold=DEBUGlog4j.appender.D.layout=org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n<span class="hljs-comment">### 输出ERROR 级别以上的日志到文件 ###</span>log4j.appender.E=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File=log4j.loglog4j.appender.E.Append=<span class="hljs-literal">true</span>log4j.appender.E.Threshold=ERRORlog4j.appender.E.layout=org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</code></pre><p><code>log4j.properties</code>文件放在<code>src\main\resources</code>路径下</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.log4j.Logger;Logger logger = Logger.getLogger(Xxx.class);logger.info(<span class="hljs-string">&quot;日志测试&quot;</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>01-Log</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-junit4和junit5的注解区别</title>
    <link href="/01-Java/99-Others/02-Junit/02-junit4%E5%92%8Cjunit5%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8C%BA%E5%88%AB/"/>
    <url>/01-Java/99-Others/02-Junit/02-junit4%E5%92%8Cjunit5%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="junit4和junit5的注解区别"><a href="#junit4和junit5的注解区别" class="headerlink" title="junit4和junit5的注解区别"></a>junit4和junit5的注解区别</h1><table><thead><tr><th>JUnit4</th><th>JUnit5</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>@Test</td><td>表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖</td></tr><tr><td>@BeforeClass</td><td>@BeforeAll</td><td>表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行；</td></tr><tr><td>@AfterClass</td><td>@AfterAll</td><td>表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；</td></tr><tr><td>@Before</td><td>@BeforeEach</td><td>表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行</td></tr><tr><td>@After</td><td>@AfterEach</td><td>表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行</td></tr><tr><td>@Ignore</td><td>@Disabled</td><td>用于禁用一个测试类或测试方法</td></tr><tr><td>@Category</td><td>@Tag</td><td>用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。</td></tr><tr><td>@Parameters</td><td>@ParameterizedTest</td><td>表示该方法是一个参数化测试</td></tr><tr><td>@RunWith</td><td>@ExtendWith</td><td>@Runwith就是放在测试类名之前，用来确定这个类怎么运行的</td></tr><tr><td>@Rule</td><td>@ExtendWith</td><td>Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力</td></tr><tr><td>@ClassRule</td><td>@ExtendWith</td><td>@ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>02-Junit</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-xml语言</title>
    <link href="/01-Java/99-Others/04-XML/01-xml%E8%AF%AD%E8%A8%80/"/>
    <url>/01-Java/99-Others/04-XML/01-xml%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="XML语言"><a href="#XML语言" class="headerlink" title="XML语言"></a>XML语言</h1><p>关于xml语言的一些属性和特征，因为xml没有定义，因此我们各个公司定义这个schema，这个时候就需要类型定义语言了，这里主要用到DTD和XSD两种</p><h2 id="各种类型定义语言"><a href="#各种类型定义语言" class="headerlink" title="各种类型定义语言"></a>各种类型定义语言</h2><ul><li>xml Schema 是DTD的替代品</li><li>DTD 类型定义语言</li><li>xmlns XML nameSpaces XML命名空间</li><li>XSD (XML Schema Definition)</li></ul><h2 id="xmlns-xml命名空间"><a href="#xmlns-xml命名空间" class="headerlink" title="xmlns xml命名空间"></a>xmlns xml命名空间</h2><p>举个栗子</p><p>当我们一个xml中用<code>table</code>来描述<strong>表格</strong>，又用来描述<strong>桌子</strong>的时候，我们这两个就会出现混乱的情况，这时候就需要命名空间了，就像我们在<code>word</code>文档中就经常使用（用于区别表格的标题和文章的标题）</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><span class="hljs-comment">&lt;!-- 第一行：为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。它的语法如下  xmlns=&quot;namespaceURI&quot; --&gt;</span><span class="hljs-comment">&lt;!-- 第二行：命名空间声明的语法如下。xmlns:前缀=&quot;URI&quot;。 --&gt;</span><span class="hljs-comment">&lt;!-- 第三行：声明这个命名空间语法的位置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.4&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span></code></pre><ul><li>值得我们注意的是，第一行和第二行的url并不是一定需要可访问的，只是用于说明唯一性而已，但是很多公司会让它可访问</li></ul><h2 id="DTD-类型定义和合规"><a href="#DTD-类型定义和合规" class="headerlink" title="DTD 类型定义和合规"></a>DTD 类型定义和合规</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">note</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;Note.dtd&quot;</span>&gt;</span></code></pre><p>DOCTYPE 声明是对外部 DTD 文件的引用。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>04-XML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Junit4</title>
    <link href="/01-Java/99-Others/02-Junit/01-Junit4/"/>
    <url>/01-Java/99-Others/02-Junit/01-Junit4/</url>
    
    <content type="html"><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-comment">// 单元测试方法</span><span class="hljs-meta">@Before</span><span class="hljs-comment">// 每个测试方法执行前执行该方法</span><span class="hljs-meta">@after</span><span class="hljs-comment">// 每个测试方法执行后执行该方法</span><span class="hljs-meta">@Ignore</span><span class="hljs-comment">// 不测试该方法</span><span class="hljs-meta">@BeforeClass</span><span class="hljs-comment">// 初始化方法，只执行一次</span><span class="hljs-meta">@AfterClass</span><span class="hljs-comment">// 结束方法，只执行一次</span></code></pre><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><pre><code class="hljs java"><span class="hljs-comment">// message表示断言失败时的提示信息</span>Assert.assertEquals(message,expected,actual);   <span class="hljs-comment">// 断言值相同</span>Assert.assertSame(message,expected,actual);     <span class="hljs-comment">// 断言地址相同</span>Assert.assertTrue(message,expected);            <span class="hljs-comment">// 断言为真</span>Assert.assertNull(message,expected);            <span class="hljs-comment">// 断言为空</span><span class="hljs-meta">@Test(expected = IOException.class)</span>             <span class="hljs-comment">// 断言抛出异常</span><span class="hljs-meta">@Test(timeout = 300)</span>                            <span class="hljs-comment">// 断言执行时间少于300ms</span>``` ## 经典的数据库测试方法```java<span class="hljs-meta">@BeforeClass</span><span class="hljs-comment">// 链接数据库</span><span class="hljs-meta">@Before</span><span class="hljs-comment">// 创建数据库测试数据，如用户A</span><span class="hljs-meta">@After</span><span class="hljs-comment">// 删除用户A的信息，保证了下次执行的单例测试环境不受之前操作的影响</span><span class="hljs-meta">@Test</span><span class="hljs-comment">// 增加用户</span><span class="hljs-meta">@Test</span><span class="hljs-comment">// 删除用户</span><span class="hljs-meta">@Test</span><span class="hljs-comment">// 修改用户信息</span><span class="hljs-meta">@Test</span><span class="hljs-comment">// 获得用户信息</span><span class="hljs-meta">@AfterClass</span><span class="hljs-comment">// 断开数据库链接，删除表</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>02-Junit</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-DOM操作XML</title>
    <link href="/01-Java/99-Others/04-XML/02-DOM%E6%93%8D%E4%BD%9CXML/"/>
    <url>/01-Java/99-Others/04-XML/02-DOM%E6%93%8D%E4%BD%9CXML/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">element</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">element_tag</span> <span class="hljs-attr">attr</span>=<span class="hljs-string">&quot;attr_value&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">element_tag</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span></code></pre><h2 id="xml读取"><a href="#xml读取" class="headerlink" title="xml读取"></a>xml读取</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.w3c.dom.*;<span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilder;<span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;<span class="hljs-keyword">import</span> javax.xml.parsers.ParserConfigurationException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParserConfigurationException, IOException, SAXException </span>&#123;        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(<span class="hljs-string">&quot;/Users/cenzhongman/Programs/cenzhongman/demo/pom.xml&quot;</span>);        <span class="hljs-comment">// 获得根元素</span>        Element element = document.getDocumentElement();        <span class="hljs-comment">// 获得元素的属性attr</span>        Attr attr = element.getAttributeNode(<span class="hljs-string">&quot;attr&quot;</span>);        <span class="hljs-comment">// 获得元素的Text</span>        String text = document.getTextContent();        System.out.println((<span class="hljs-string">&quot;dependency&quot;</span>));        <span class="hljs-comment">// 根据ID去查</span>        Element id = document.getElementById(<span class="hljs-string">&quot;id&quot;</span>);        <span class="hljs-comment">// 根据TAG去查</span>        Element tag = (Element) document.getElementsByTagName(<span class="hljs-string">&quot;tag&quot;</span>).item(<span class="hljs-number">0</span>);    &#125;&#125;</code></pre><h2 id="xml写入"><a href="#xml写入" class="headerlink" title="xml写入"></a>xml写入</h2><p>xml第一次读取直接读入内存，因此写入操作需要执行同步操作，修改才能<strong>同步</strong>到xml文件中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParserConfigurationException, IOException, SAXException, TransformerException </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/cenzhongman/Programs/cenzhongman/demo/pom.xml&quot;</span>);        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(file);        <span class="hljs-comment">// 获得根元素</span>        Element element = document.getDocumentElement();        Node artifactId = document.getElementsByTagName(<span class="hljs-string">&quot;artifactId&quot;</span>).item(<span class="hljs-number">0</span>);        artifactId.setTextContent(<span class="hljs-string">&quot;my-demo&quot;</span>);        <span class="hljs-comment">// 使用同步转换器实现同步 将内存源中的数据同步到文件目标中</span>        Transformer transformer = TransformerFactory.newInstance().newTransformer();        Source xmlSource = <span class="hljs-keyword">new</span> DOMSource(document);             <span class="hljs-comment">// 内存源</span>        Result outputTarget = <span class="hljs-keyword">new</span> StreamResult(file);           <span class="hljs-comment">// 文件目标</span>        transformer.transform(xmlSource, outputTarget);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>04-XML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-PageProcessor</title>
    <link href="/01-Java/99-Others/05-webMagic/01-PageProcessor/"/>
    <url>/01-Java/99-Others/05-webMagic/01-PageProcessor/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>05-webMagic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Scheduler</title>
    <link href="/01-Java/99-Others/05-webMagic/02-Scheduler/"/>
    <url>/01-Java/99-Others/05-webMagic/02-Scheduler/</url>
    
    <content type="html"><![CDATA[<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>shceduler是用于URL去重的，属于URL Manager的部分，共有四种实现，分别是<code>FileCacheQueueScheduler</code>、<code>PriorityScheduler</code>、<code>QueueQuScheduler</code>、<code>RedisScheduler</code></p><p>其中最重要的两个方法是push和poll，用于将request/URL放入或从资源池中取出，以及isDuplicate方法用于评定一个Request是否符合新URL的要求</p><p>本文目的是为了查找一个能够在POST情况下使用的Scheduler</p><h2 id="QueueScheduler"><a href="#QueueScheduler" class="headerlink" title="QueueScheduler"></a>QueueScheduler</h2><pre><code class="hljs java"><span class="hljs-comment">// 将整个request放入队列，这是我们要找的方法呀，但是，，，不能持久化，劝退</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushWhenNoDuplicate</span><span class="hljs-params">(Request request, Task task)</span> </span>&#123;  queue.add(request);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">poll</span><span class="hljs-params">(Task task)</span> </span>&#123;  <span class="hljs-keyword">return</span> queue.poll();&#125;</code></pre><h2 id="FileCacheQueueScheduler"><a href="#FileCacheQueueScheduler" class="headerlink" title="FileCacheQueueScheduler"></a>FileCacheQueueScheduler</h2><pre><code class="hljs java"><span class="hljs-comment">// poll 方法可以看出其是QueueSchedule的拓展使用</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Request <span class="hljs-title">poll</span><span class="hljs-params">(Task task)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!inited.get()) &#123;    init(task);  &#125;  fileCursorWriter.println(cursor.incrementAndGet());  <span class="hljs-keyword">return</span> queue.poll();&#125;</code></pre><p>然而</p><pre><code class="hljs java"><span class="hljs-comment">// 这里重载了isDuplicate()方法，使用了Set&lt;String&gt; urls作为是否加入资源池的标准，，，，算了，劝退</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initDuplicateRemover</span><span class="hljs-params">()</span> </span>&#123;  setDuplicateRemover(    <span class="hljs-keyword">new</span> DuplicateRemover() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDuplicate</span><span class="hljs-params">(Request request, Task task)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!inited.get()) &#123;          init(task);        &#125;        <span class="hljs-keyword">return</span> !urls.add(request.getUrl());      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetDuplicateCheck</span><span class="hljs-params">(Task task)</span> </span>&#123;        urls.clear();      &#125;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotalRequestsCount</span><span class="hljs-params">(Task task)</span> </span>&#123;        <span class="hljs-keyword">return</span> urls.size();      &#125;    &#125;);&#125;</code></pre><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><pre><code class="hljs java"><span class="hljs-comment">// 又是一个队列，无界有序的阻塞队列，简单是简单了，但是，，，又不能持久化</span></code></pre><h2 id="RedisScheduler-绝不能放POST请求"><a href="#RedisScheduler-绝不能放POST请求" class="headerlink" title="RedisScheduler(绝不能放POST请求)"></a>RedisScheduler(绝不能放POST请求)</h2><pre><code class="hljs java"><span class="hljs-comment">// 这个就比较屌了，在Redis中只保存URL，然后自己组成Request</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Request <span class="hljs-title">poll</span><span class="hljs-params">(Task task)</span> </span>&#123;  Jedis jedis = pool.getResource();  <span class="hljs-keyword">try</span> &#123;    String url = jedis.lpop(getQueueKey(task));    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    String key = ITEM_PREFIX + task.getUUID();    String field = DigestUtils.shaHex(url);    <span class="hljs-keyword">byte</span>[] bytes = jedis.hget(key.getBytes(), field.getBytes());    <span class="hljs-keyword">if</span> (bytes != <span class="hljs-keyword">null</span>) &#123;      Request o = JSON.parseObject(<span class="hljs-keyword">new</span> String(bytes), Request.class);      <span class="hljs-keyword">return</span> o;    &#125;    Request request = <span class="hljs-keyword">new</span> Request(url);    <span class="hljs-keyword">return</span> request;  &#125; <span class="hljs-keyword">finally</span> &#123;    pool.returnResource(jedis);  &#125;&#125;</code></pre><p>总结，需要持久化，只有File和Redis两种选择，然而，两者均只保存了URL，因此对一POST方式的Request请求无效。</p><p>而使用非持久化的队列在生产环境是肯定行不通的，因此，剩下两条路可以走</p><ol><li>改造依样画葫芦，重新写一个支持Request的redis或者FileScheduler</li><li>在加入Request的时进行过滤（使用Elasticsearch查找ID的方法）</li><li>在二的前提下实现持续爬取，某网友提出的在URL上加上随机数（如请求体的md5值），如果这个参数不会导致接口功能变化的话，加上能够实现断点爬取（gsxt刚好符合）</li></ol><p>由于考虑到公示系统的爬虫复杂性，1.IP会随时更换，2.即使是相同的公司pripid也会随时间变化而URL进行更换，因此，即使依样画葫芦实现了支持持久化且支持POST方法的Request，对于公示系统的需求任无法去重。</p><p>因此采用方法二最为合理。</p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>05-webMagic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-Proxypool代理</title>
    <link href="/01-Java/99-Others/05-webMagic/03-Proxypool%E4%BB%A3%E7%90%86/"/>
    <url>/01-Java/99-Others/05-webMagic/03-Proxypool%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Proxypool代理"><a href="#Proxypool代理" class="headerlink" title="Proxypool代理"></a>Proxypool代理</h1><h2 id="1-获得一个代理库"><a href="#1-获得一个代理库" class="headerlink" title="1. 获得一个代理库"></a>1. 获得一个代理库</h2><p><a href="https://github.com/Python3WebSpider/ProxyPool">github-proxypool</a></p><p>这个库是实现了爬虫各种提供免费代理的网址，提供可用的代理</p><h2 id="2-在Web-Magic中设置代理"><a href="#2-在Web-Magic中设置代理" class="headerlink" title="2. 在Web Magic中设置代理"></a>2. 在Web Magic中设置代理</h2><pre><code class="hljs java">HttpClientDownloader httpClientDownloader = <span class="hljs-keyword">new</span> HttpClientDownloader();httpClientDownloader.setProxyProvider(SimpleProxyProvider.from(        <span class="hljs-keyword">new</span> Proxy(<span class="hljs-string">&quot;host1&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>),        <span class="hljs-keyword">new</span> Proxy(<span class="hljs-string">&quot;host2&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>),        <span class="hljs-keyword">new</span> Proxy(<span class="hljs-string">&quot;host3&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>),        ...        <span class="hljs-keyword">new</span> Proxy(<span class="hljs-string">&quot;host4&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>)));spider.setDownloader(httpClientDownloader);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>05-webMagic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-EhCache</title>
    <link href="/01-Java/99-Others/06-EhCache/01-EhCache/"/>
    <url>/01-Java/99-Others/06-EhCache/01-EhCache/</url>
    
    <content type="html"><![CDATA[<h1 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h1><p><a href="http://www.ehcache.org/documentation/3.7/getting-started.html">官方Getting Started</a></p><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>pom.xml</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><ul><li>EhCacheUtils.java</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * EhCache 缓存工具类</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cenzhongman</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019/8/29</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EhCacheUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CACHE = <span class="hljs-string">&quot;defaultCache&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SIMPLE_CACHE = <span class="hljs-string">&quot;simpleCache&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CacheManager cacheManager;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">// 配置一级缓存</span>        cacheManager = CacheManagerBuilder.newCacheManagerBuilder().withCache(DEFAULT_CACHE,                CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class, ResourcePoolsBuilder.heap(<span class="hljs-number">10</span>)))                .build();        cacheManager.init();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cache&lt;String, String&gt; <span class="hljs-title">getCache</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getCache(SIMPLE_CACHE);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cache&lt;String, String&gt; <span class="hljs-title">getCache</span><span class="hljs-params">(String cacheAlias)</span> </span>&#123;        Cache&lt;String, String&gt; cache = cacheManager.getCache(cacheAlias, String.class, String.class);        <span class="hljs-comment">// 配置二级缓存</span>        <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span>) &#123;            cache = cacheManager.createCache(cacheAlias,                    CacheConfigurationBuilder.newCacheConfigurationBuilder(String.class, String.class, ResourcePoolsBuilder.heap(<span class="hljs-number">10</span>)));        &#125;        <span class="hljs-keyword">return</span> cache;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        getCache().put(key, value);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> getCache().get(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key, String defaultValue)</span> </span>&#123;        String cacheValue = getCache().get(key);        <span class="hljs-keyword">if</span> (cacheValue == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> defaultValue;        &#125;        <span class="hljs-keyword">return</span> cacheValue;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span> </span>&#123;        remove(SIMPLE_CACHE, key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(String cacheAlias, String key)</span> </span>&#123;        getCache(cacheAlias).remove(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCache</span><span class="hljs-params">()</span> </span>&#123;        cacheManager.removeCache(SIMPLE_CACHE);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCache</span><span class="hljs-params">(String cacheAlias)</span> </span>&#123;        cacheManager.removeCache(cacheAlias);    &#125;&#125;</code></pre><ul><li>EhCacheUtilsTest.java</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EhCacheUtilsTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCache</span><span class="hljs-params">()</span> </span>&#123;        Cache&lt;String, String&gt; cache = EhCacheUtils.getCache();        cache.put(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);        System.out.println(cache.get(<span class="hljs-string">&quot;key&quot;</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">()</span> </span>&#123;        EhCacheUtils.put(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);        System.out.println(EhCacheUtils.get(<span class="hljs-string">&quot;key&quot;</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(EhCacheUtils.get(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>99-Others</category>
      
      <category>06-EhCache</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-spring-data-elasticsearch</title>
    <link href="/01-Java/03-Spring/05-SpringData/spring-data-elasticsearch/01-spring-data-elasticsearch/"/>
    <url>/01-Java/03-Spring/05-SpringData/spring-data-elasticsearch/01-spring-data-elasticsearch/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-data-elasticsearch"><a href="#Spring-data-elasticsearch" class="headerlink" title="Spring-data-elasticsearch"></a>Spring-data-elasticsearch</h1><p>这里分成两个部分讲</p><ol><li>RestHighLevelClient</li><li>Spring-data</li></ol><h2 id="RestHighLevelClient"><a href="#RestHighLevelClient" class="headerlink" title="RestHighLevelClient"></a>RestHighLevelClient</h2><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-nosql.html#boot-features-connecting-to-elasticsearch-rest">官方文档</a></li></ul><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.yml</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># Elasticsearch RestHighLevelClient Configuration</span>  <span class="hljs-attr">elasticsearch:</span>    <span class="hljs-attr">rest:</span>      <span class="hljs-attr">uris:</span> <span class="hljs-string">http://localhost:9200</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestHighLevelClient client;System.out.println(client.indices());</code></pre><h2 id="Spring-data"><a href="#Spring-data" class="headerlink" title="Spring-data"></a>Spring-data</h2><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>application.yml</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># Elasticsearch spring data configuration</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">elasticsearch:</span>      <span class="hljs-attr">repositories:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">docker-cluster</span>      <span class="hljs-attr">cluster-nodes:</span> <span class="hljs-string">localhost:9300,192.168.10.39:9300</span></code></pre><p>ElasticsearchConfig.java</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties(ElasticsearchProperties.class)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticsearchConfig</span> </span>&#123;&#125;</code></pre><p>CompanyRepository.java</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompanySearchRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">Company</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;&#125;</code></pre><p>CompanyRepositoryTest.java</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanyRepositoryTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CompanySearchRepository companySearchRepository;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        Company company = <span class="hljs-keyword">new</span> Company();        company.setId(<span class="hljs-number">1L</span>);        company.setChineseName(<span class="hljs-string">&quot;Haha&quot;</span>);        companySearchRepository.index(company);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>03-Spring</category>
      
      <category>05-SpringData</category>
      
      <category>spring-data-elasticsearch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-JSP入门</title>
    <link href="/01-Java/02-JavaEE/02-JSP/01-JSP%E5%85%A5%E9%97%A8/"/>
    <url>/01-Java/02-JavaEE/02-JSP/01-JSP%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP是什么"><a href="#JSP是什么" class="headerlink" title="JSP是什么"></a>JSP是什么</h2><p>JSP JAVA Server Page其实原则上是一个基于Servlet的文件，执行过程如下：</p><ol><li>JSP文件</li><li>Servlet文件</li><li>class文件</li><li>Servlet实例</li></ol><h2 id="JSP包括什么"><a href="#JSP包括什么" class="headerlink" title="JSP包括什么"></a>JSP包括什么</h2><ul><li>HTML</li><li>JSP注释</li><li>JSP指令</li><li>JSP脚本元素</li><li>JSP动作元素</li></ul><h3 id="一、JSP注释"><a href="#一、JSP注释" class="headerlink" title="一、JSP注释"></a>一、JSP注释</h3><p>注释有三种</p><pre><code class="hljs sh">&lt;%--这里是注释的内容--%&gt;使用这种注释，查看源码是没有这个注释的。&lt;!--这里是注释内容--&gt;使用这种注释，源码中是由注释内容的。&lt;%    // 这里是JAVA注释%&gt;</code></pre><h3 id="二、JSP指令"><a href="#二、JSP指令" class="headerlink" title="二、JSP指令"></a>二、JSP指令</h3><ol><li>page指令</li><li>include指令</li><li>taglib</li></ol><pre><code class="hljs jsp">&lt;!-- 使用page导包 还有其他功能，如继承，缓冲区，错误处理，自动刷新，页面类型等--&gt;&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;com.cenzhongman.model.MySQL,com.cenzhongman.web&quot;</span> %&gt;&lt;!-- 使用taglib导入标记库 可用于导入前缀--&gt;&lt;%@ taglib uri=http:<span class="hljs-comment">//asdfasdf.sun,com prefx=&quot;h&quot; %&gt;</span>&lt;!-- 使用include包含可以重用的文件 可以在任意位置使用--&gt;&lt;%@ include file=”wickedHeader.html” %&gt;</code></pre><h3 id="三、JSP脚本元素"><a href="#三、JSP脚本元素" class="headerlink" title="三、JSP脚本元素"></a>三、JSP脚本元素</h3><table><thead><tr><th>脚本元素</th><th>标识符</th><th>举例</th><th>说明</th><th>困惑</th></tr></thead><tbody><tr><td>JSP声明语句</td><td>&lt;%!  &gt;</td><td>&lt;%! int a = 1 &gt;</td><td>变量或方法定义</td><td>这跟不用<code>!</code>的区别在?</td></tr><tr><td>JSP表达式</td><td>&lt;%=  %&gt;</td><td>&lt;%= “This is an Expression!” %&gt;</td><td>使用个JSP表达式输出</td><td>还有什么JSP表达式</td></tr><tr><td>JSP Scriptlets</td><td>&lt;%  %&gt;</td><td>&lt;% 任意JAVA代码 %&gt; ｜</td><td></td><td></td></tr></tbody></table><h4 id="1-JSP声明语句"><a href="#1-JSP声明语句" class="headerlink" title="1. JSP声明语句"></a>1. JSP声明语句</h4><pre><code class="hljs java">&lt;%!    <span class="hljs-comment">// 定义变量</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a;    <span class="hljs-comment">// 定义方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">printIntA</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> a.toString();    &#125;%&gt;</code></pre><h4 id="2-JSP表达式"><a href="#2-JSP表达式" class="headerlink" title="2. JSP表达式"></a>2. JSP表达式</h4><pre><code class="hljs jsp">&lt;%    out.print(<span class="hljs-string">&quot;This is a Scriptlet!&quot;</span>);%&gt;&lt;!-- 等效于,并不需要; --&gt;&lt;%= <span class="hljs-string">&quot;This is an Expression!&quot;</span> %&gt;</code></pre><h4 id="3-JSP-Scriptlets"><a href="#3-JSP-Scriptlets" class="headerlink" title="3. JSP Scriptlets"></a>3. JSP Scriptlets</h4><p>这个就没什么好解释的了</p><h4 id="四、动作元素"><a href="#四、动作元素" class="headerlink" title="四、动作元素"></a>四、动作元素</h4><p>JSP动作元素用来控制JSP的行为，执行一些页面动作。如动态插入文件，重用JAVABean组件，自定义标签等</p><ul><li>jsp:include&gt;</li><li>jsp:forward&gt;</li><li>jsp:param&gt;</li><li>jsp:plugin&gt;</li><li>jsp:usrBean&gt;</li><li>jsp:setProperty&gt;</li><li>jsp:getProperty&gt;</li></ul><h2 id="隐式（内置）对象"><a href="#隐式（内置）对象" class="headerlink" title="隐式（内置）对象"></a>隐式（内置）对象</h2><p>在JSP中可以直接使用的隐式对象：</p><table><thead><tr><th>API</th><th>隐式对象</th><th>备注</th></tr></thead><tbody><tr><td>JspWriter</td><td>out</td><td>JSPWrirter是具有缓冲的PrintWriter</td></tr><tr><td>HttpServletRequest</td><td>request</td><td></td></tr><tr><td>HttpServletResponse</td><td>response</td><td></td></tr><tr><td>HttpSession</td><td>session</td><td></td></tr><tr><td>ServletContext</td><td>application</td><td></td></tr><tr><td>ServletConfg</td><td>cionfig</td><td></td></tr><tr><td>JspExpection</td><td>expection</td><td>指定错误</td></tr><tr><td>PageContext</td><td>pageContext</td><td>用于获取全局属性，就是非单个servlet中的属性</td></tr><tr><td>Object</td><td>page</td><td></td></tr></tbody></table><pre><code class="hljs java">&lt;% application.setAttribute(<span class="hljs-string">&quot;a&quot;</span>, value); %&gt;&lt;%= application.getAttribute(<span class="hljs-string">&quot;a&quot;</span>) %&gt;</code></pre><h2 id="JSP跟Servlet之间是怎么转化的"><a href="#JSP跟Servlet之间是怎么转化的" class="headerlink" title="JSP跟Servlet之间是怎么转化的"></a>JSP跟Servlet之间是怎么转化的</h2><p>index.jsp</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">int</span> <span class="hljs-attr">i</span> = <span class="hljs-string">0;</span> %&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">%!</span> <span class="hljs-attr">int</span> <span class="hljs-attr">j</span> = <span class="hljs-string">0;%</span>&gt;</span>        the int i is :        <span class="hljs-tag">&lt;<span class="hljs-name">%=</span> ++<span class="hljs-attr">i</span> %&gt;</span>        the int i is :        <span class="hljs-tag">&lt;<span class="hljs-name">%=</span> ++<span class="hljs-attr">j</span> %&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>转换成的Servlet</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">basicCounter_jsp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeSpecialHttpServlet</span> </span>&#123;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                            HttpServletResponse response)</span><span class="hljs-keyword">throws</span> java.io.IOException,ServletException </span>&#123;        PrintWriter out = response.getWriter();        response.setContentType(“text/html”);        out.write(“&lt;html&gt;&lt;body&gt;”);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        out.write(“The page i is now:”);        out.print( ++i );        out.write(“The page j is now:”);        out.print( ++j );        out.write(“&lt;/body&gt;&lt;/html&gt;”);    &#125;&#125;</code></pre><p>像这样，out其实是<code>response</code>的输出，每次get请求就会执行一次<code>ServletException</code>中的代码，因此<code>++i</code>的任务无效的。因为<code>i</code>是一个局部变量。而<code>j</code>是个类变量。</p><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><pre><code class="hljs java">req.setAttribute(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;测试1&quot;</span>);req.getRequestDispatcher(<span class="hljs-string">&quot;/resources/nlp/emotion.jsp&quot;</span>).forward(req, resp); <span class="hljs-comment">// 注意顺序</span></code></pre><pre><code class="hljs jsp">&lt;%String[] example = (String[])request.getAttribute(<span class="hljs-string">&quot;exampleList&quot;</span>);%&gt;&lt;script&gt;setText(&#x27;&lt;%= example[0] %&gt;&#x27;)&lt;/script&gt;</code></pre><h2 id="编程实战"><a href="#编程实战" class="headerlink" title="编程实战"></a>编程实战</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>index_jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">jsp-file</span>&gt;</span>/index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">jsp-file</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>av<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>index_jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/index<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><pre><code class="hljs jsp">&lt;html&gt;    &lt;body&gt;    &lt;%!        String value;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span> </span>&#123;            ServletConfig servletConfig = getServletConfig();            value = servletConfig.getInitParameter(<span class="hljs-string">&quot;a&quot;</span>);        &#125;    %&gt;    &lt;% application.setAttribute(<span class="hljs-string">&quot;a&quot;</span>, value); %&gt;    &lt;%= application.getAttribute(<span class="hljs-string">&quot;a&quot;</span>) %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>02-JSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-使用payara部署springboot应用</title>
    <link href="/01-Java/02-JavaEE/03-Payara/01-%E4%BD%BF%E7%94%A8payara%E9%83%A8%E7%BD%B2springboot%E5%BA%94%E7%94%A8/"/>
    <url>/01-Java/02-JavaEE/03-Payara/01-%E4%BD%BF%E7%94%A8payara%E9%83%A8%E7%BD%B2springboot%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="使用payara运行Springboot应用"><a href="#使用payara运行Springboot应用" class="headerlink" title="使用payara运行Springboot应用"></a>使用payara运行Springboot应用</h1><p><a href="https://blog.payara.fish/creating-rest-web-services-with-spring-boot-hosted-on-payara-micro">参考文档</a></p><h2 id="1-更改依赖"><a href="#1-更改依赖" class="headerlink" title="1. 更改依赖"></a>1. 更改依赖</h2><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 增加exclusion tomcat --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 增加servlet依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 增加stax2依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.woodstox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>stax2-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="2-修改打包方式"><a href="#2-修改打包方式" class="headerlink" title="2. 修改打包方式"></a>2. 修改打包方式</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>biz.datainsights<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>payara-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h2 id="3-增加配置文件"><a href="#3-增加配置文件" class="headerlink" title="3. 增加配置文件"></a>3. 增加配置文件</h2><p>${project}/src/main/webapp/WEB-INF/glassfish-web.xml</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">glassfish-web-app</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//GlassFish.org//DTDGlassFish Application Server 3.1 Servlet 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://glassfish.org/dtds/glassfish-web-app_3_0-1.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">glassfish-web-app</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置跟路径为“/” --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-root</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">context-root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">glassfish-web-app</span>&gt;</span></code></pre><h2 id="4-部署方式"><a href="#4-部署方式" class="headerlink" title="4. 部署方式"></a>4. 部署方式</h2><pre><code class="hljs sh"><span class="hljs-comment"># 方式1：复制war包到项目文件夹</span><span class="hljs-comment"># 方式2</span>java -jar payara-micro-4.1.153.jar --deploy %PATH_TO%/payara-micro-with-spring-boot-rest-1.0.war<span class="hljs-comment"># docker</span>docker run -p 8080:8080 -p 4848:4848 --rm -v ~/payara-micro/applications:/opt/payara/deployments payara/micro --deploy /opt/payara/deployments/payara-demo-1.0.war<span class="hljs-comment"># jenkins</span></code></pre><h2 id="5-监控及其他"><a href="#5-监控及其他" class="headerlink" title="5. 监控及其他"></a>5. 监控及其他</h2><p><a href="http://localhost:4848/">可视化监控</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>03-Payara</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-servlet是什么</title>
    <link href="/01-Java/02-JavaEE/01-Servlet/01-servlet%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/01-Java/02-JavaEE/01-Servlet/01-servlet%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet是什么"><a href="#Servlet是什么" class="headerlink" title="Servlet是什么"></a>Servlet是什么</h1><p>servlet并不是什么高大上的东西，其实就是一个属于 Java EE 的 Java 类。运用在服务器上的Java程序用于接受和处理HTTP请求。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>右击我的电脑–&gt;属性–&gt;高级–&gt;环境变量–&gt;添加一个系统变量,名称为classpath,值为:<br>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</p><p>##　一个标准的目录是怎样的</p><p><img src="../images/01-01.png"></p><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><h3 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h3><ol><li>Servlet是一个接口，必须首先实现这个接口。</li><li>在web.xml中配置</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        servletResponse.getWriter().println(<span class="hljs-string">&quot;Hello lady!&quot;</span>);    &#125;&#125;</code></pre><h3 id="配置web-xml中的映射"><a href="#配置web-xml中的映射" class="headerlink" title="配置web.xml中的映射"></a>配置web.xml中的映射</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-comment">&lt;!-- servlet name --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 类名全路径 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.cenzhongman.servlet.ServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!-- servlet map(name &gt; url) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 要跟上面的name对应 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 访问地址 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/ServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><p>访问<a href="http://localhost:8080/ServletDemo">http://localhost:8080/ServletDemo</a></p><h2 id="Tomcat为什么是容器"><a href="#Tomcat为什么是容器" class="headerlink" title="Tomcat为什么是容器"></a>Tomcat为什么是容器</h2><p>从上述程序我们发现，servlet中并没有main函数，因为main函数在Tomcat中，Tomcat作为容器封装和调用servlet程序。</p><p>容器做的事情</p><ul><li>通信支持：使得我们不用关心socket，和监听端口问题</li><li>生命周期管理：什么时候实例化servlet类，垃圾回收等</li><li>多线程支持：有了容器能够支持多终端访问，不用关心多线程问题</li><li>额外的声明：可以无需修改代码就能修改配置</li><li>JSP支持：将JSP翻译成Java代码就是容器实现的</li></ul><p>容器的执行步骤</p><ol><li>容器接受请求</li><li>创建两个对象(HttpServletRequest HttpServletResponst)</li><li>根据URL找到相应的Servlet并创建线程接受两个对象</li><li>调用servlet接口的service方法处理请求并封装响应 &gt; 线程结束</li><li>容器把响应封装成HTTP响应，并删除两个对象</li></ol><h2 id="关于请求和响应"><a href="#关于请求和响应" class="headerlink" title="关于请求和响应"></a>关于请求和响应</h2><h3 id="关于生命周期和初始化对象"><a href="#关于生命周期和初始化对象" class="headerlink" title="关于生命周期和初始化对象"></a>关于生命周期和初始化对象</h3><ul><li><p>init()      初始化servlet，为什么不在构造函数中初始化呢，因为构造函数是用来实例化对象的。在构造函数和init()之间是呈现薛定谔状态的</p></li><li><p>service()   每一个请求新建一个进程执行service函数</p></li><li><p>destroy()   进程结束前调用这个函数</p></li><li><p>ServleRequest    请求对象</p></li><li><p>ServletResponse  响应对象</p></li><li><p>ServletConfit    配置对象，用于读取<code>ServletContext</code>中自己的那个<code>servlet</code>中的信息，并向servlet传递这个信息，每个servlet一个，jsp也拥有自己的ServletConfig</p></li><li><p>ServletContext   访问web应用参数，每个应用一个，<strong>jsp能够访问</strong></p></li></ul><h3 id="关于Response的类型"><a href="#关于Response的类型" class="headerlink" title="关于Response的类型"></a>关于Response的类型</h3><p>每次只能设置一种类型，不能中间改变，<strong>必须先设置类型然后才是调用输出流</strong></p><p>常见的MIME类型</p><ul><li>text/html</li><li>application/pdf</li><li>video/quicktime</li><li>application/java</li><li>image/jpeg</li><li>application/jar</li><li>application/octet-stream</li><li>application/x-zip</li></ul><h3 id="输出的类型"><a href="#输出的类型" class="headerlink" title="输出的类型"></a>输出的类型</h3><p>println()写到PrintWriter          处理字符数据，其实是输出流的上层封装<br>write()写到ServletOutputStream    处理字节数据，使用outputStream</p><h3 id="setHeader和addHeader"><a href="#setHeader和addHeader" class="headerlink" title="setHeader和addHeader"></a>setHeader和addHeader</h3><p>add 会增加一个值，<br>set 不存在则创建，存在则替换</p><h2 id="在web-xml中添加自定义初始化参数"><a href="#在web-xml中添加自定义初始化参数" class="headerlink" title="在web.xml中添加自定义初始化参数"></a>在web.xml中添加自定义初始化参数</h2><h3 id="servlet初始化参数-只针对当前servlet"><a href="#servlet初始化参数-只针对当前servlet" class="headerlink" title="servlet初始化参数(只针对当前servlet)"></a>servlet初始化参数(只针对当前servlet)</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.cenzhongman.web.ServletDemo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myEmail<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>cenzhongman@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></code></pre><pre><code class="hljs java">getServletConfig().getInitParameter(<span class="hljs-string">&quot;myEmail&quot;</span>)</code></pre><h3 id="上下文初始化参数-针对整个应用的参数"><a href="#上下文初始化参数-针对整个应用的参数" class="headerlink" title="上下文初始化参数(针对整个应用的参数)"></a>上下文初始化参数(针对整个应用的参数)</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>myMane<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>cenzhongman<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre><pre><code class="hljs java">getServletContext().getInitParameter(<span class="hljs-string">&quot;myName&quot;</span>);</code></pre><h2 id="各种各样的监听器"><a href="#各种各样的监听器" class="headerlink" title="各种各样的监听器"></a>各种各样的监听器</h2><h3 id="ServletContextListener类"><a href="#ServletContextListener类" class="headerlink" title="ServletContextListener类"></a>ServletContextListener类</h3><p>这个类能够监听上下文初始化时得到通知，并在这个上下文撤销时得到通知，这样就能监听context的状态，进而进行如数据库连接之类的操作。</p><p>下面这个例子展示了怎么使用ServletContextListener类封装一个对象到Context中</p><pre><code class="hljs java"><span class="hljs-comment">// MyServletContextListener.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletContextListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">// 初始化逻辑（创建一个全局的基于对象的属性）</span>        System.out.println(<span class="hljs-string">&quot;这里是初始化代码块&quot;</span>);        ServletContext servletContext = sce.getServletContext();<span class="hljs-comment">// 得到ServletContext</span>        MySQL mySQL = <span class="hljs-keyword">new</span> MySQL();        mySQL.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);        mySQL.setPort(<span class="hljs-string">&quot;3306&quot;</span>);        servletContext.setAttribute(<span class="hljs-string">&quot;mysql&quot;</span>,mySQL);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;        <span class="hljs-comment">// 结束逻辑，这里的执行逻辑要到整个服务停止才会加载，几乎是没有用到的</span>        System.out.println(<span class="hljs-string">&quot;这里是结束代码块&quot;</span>);        ServletContext servletContext = sce.getServletContext();        MySQL mysql = (MySQL) servletContext.getAttribute(<span class="hljs-string">&quot;mysql&quot;</span>);        System.out.println(mysql.getHost());    &#125;&#125;</code></pre><p>在这里我们发现了<code>getAttribute</code>方法，跟上文中的<code>getInitParameter</code>是不同的，第一个返回的<strong>属性</strong>是一个<code>object</code>对象，而第二个返回<strong>参数</strong>是<code>String</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// MySQL.java</span><span class="hljs-keyword">package</span> com.cenzhongman.model;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQL</span> </span>&#123;    <span class="hljs-keyword">private</span> String host;    <span class="hljs-keyword">private</span> String port;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> host;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHost</span><span class="hljs-params">(String host)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(String port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySQL</span><span class="hljs-params">(String host, String port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySQL</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.cenzhongman.web.MyServletContextListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre><h3 id="其他监听器"><a href="#其他监听器" class="headerlink" title="其他监听器"></a>其他监听器</h3><table><thead><tr><th>场景</th><th>接口</th><th>事件类型</th></tr></thead><tbody><tr><td>监听上下文属性变化</td><td>javax.servlet.ServletContextAttributeListener</td><td>ServletContextAttributeEvent</td></tr><tr><td>并发监听</td><td>javax.servlet.http.HttpSessionListener</td><td>HttpSessionEvent</td></tr><tr><td>每次请求到达监听</td><td>javax.servlet.ServletRequestListener</td><td>ServletRequestEvent</td></tr><tr><td>请求属性变化监听</td><td>javax.servlet.ServletRequestAttributeListener attributeAdded</td><td>ServletRequestAttributeEvent</td></tr><tr><td>属性类绑定和解绑监听</td><td>javax.servlet.http.HttpSessionBindingListener</td><td>HttpSessionBindingEvent</td></tr><tr><td>会话属性变化监听</td><td>javax.servlet.http.HttpSessionAttributeListener</td><td>HttpSessionBindingEvent</td></tr><tr><td>上下文创建或撤销监听</td><td>javax.servlet.ServletContextListener</td><td>ServletContextEvent</td></tr><tr><td>属性类绑定的会话迁移到另一个JVM时</td><td>javax.servlet.http.HttpSessionActivationListener</td><td>HttpSessionEvent</td></tr></tbody></table><h2 id="3个属性作用域"><a href="#3个属性作用域" class="headerlink" title="3个属性作用域"></a>3个属性作用域</h2><p>属性作用域有三个</p><p>| 名称                  | 可访问性              | 作用域(存活时间)                     | 适用于                           |<br>| ——————— | ——————— | ———————————— |<br>| 上下文 ServletContext | 全局访问，线程不安全  | Destroy之前,也就是整个应用的生命周期 | 需要传递的应用资源，如数据库连接 |<br>| 请求 ServletRequest   | Servlet访问，线程安全 | 线程周期                             | 将模型数据传递给视图             |<br>| 会话 HttpSession      | 全局访问，线程不安全  | 会话周期                             | 一个客户的资源和数据             |</p><p>相同的方法</p><ul><li>getAttribute()</li><li>setAttribute() </li><li>removeAttribute() </li><li>getAttribute()</li></ul><h3 id="属性和参数的区别"><a href="#属性和参数的区别" class="headerlink" title="属性和参数的区别"></a>属性和参数的区别</h3><ol><li><strong>属性</strong>返回的是一个<code>object</code>对象，而<strong>参数</strong>返回的是<code>String</code></li><li>属性能set，参数在一开始就固定了，不能设置</li><li>获取方法不同<code>getAttribute</code>方法，跟上文中的<code>getInitParameter</code>是不同的</li></ol><h3 id="属性的缺陷"><a href="#属性的缺陷" class="headerlink" title="属性的缺陷"></a>属性的缺陷</h3><h4 id="属性上下文作用域是线程不安全的"><a href="#属性上下文作用域是线程不安全的" class="headerlink" title="属性上下文作用域是线程不安全的"></a>属性上下文作用域是线程不安全的</h4><p>属性上下文作用域是线程不安全的，因为是个线程都能改。因此我们要给属性加<strong>同步锁</strong></p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(getServletContext())&#123;    getServletContext().setAttribute(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)    getServletContext().getAttribute(<span class="hljs-string">&quot;A&quot;</span>)&#125;<span class="hljs-comment">// 这样就得到了锁,从而保护了上下文对象，直到锁释放这个上下文对象才能被其他线程访问</span></code></pre><h4 id="属性上下文属性是线程不安全的"><a href="#属性上下文属性是线程不安全的" class="headerlink" title="属性上下文属性是线程不安全的"></a>属性上下文属性是线程不安全的</h4><p>一个用户可能同时发起多个线程访问服务器，这时候属性可能被修改。</p><pre><code class="hljs java">HttpSession session = req.getSession();<span class="hljs-keyword">synchronized</span> (session)&#123;    session.setAttribute(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);    session.getAttribute(<span class="hljs-string">&quot;key&quot;</span>);&#125;</code></pre><p>多嘴几句，除了<code>final</code>定义的，否则千万不能使用实例变量(类变量)，因为这是线程不安全的。</p><p><strong>只有局部变量和请求属性是线程安全的</strong></p><h2 id="如何将数据发给JSP"><a href="#如何将数据发给JSP" class="headerlink" title="如何将数据发给JSP"></a>如何将数据发给JSP</h2><p>JSP是一种可以同时调用JAVA代码和HTML的一种语言规范。</p><pre><code class="hljs jsp">&lt;%<span class="hljs-comment">// 这里放java代码，这段可以放在HTML中的body中是没有问题的</span>%&gt;</code></pre><h3 id="调用JSP"><a href="#调用JSP" class="headerlink" title="调用JSP"></a>调用JSP</h3><pre><code class="hljs java"><span class="hljs-comment">// 实例化请求分派器</span>RequestDispatcher view = servletRequest.getRequestDispatcher(<span class="hljs-string">&quot;jspTest.jsp&quot;</span>);<span class="hljs-comment">// 指定Request和Respond</span>view.forward(servletRequest,servletResponse);</code></pre><h3 id="将数据发给jsp"><a href="#将数据发给jsp" class="headerlink" title="将数据发给jsp"></a>将数据发给jsp</h3><p>Servlet在model中得到数据，数据不应该存放在<code>Context</code>和<code>Session</code>的<code>Attribute</code>中，因为数据是针对当前<code>Servlet</code>的，不应该全局访问，因此应该放在<code>Requset</code>的<code>Attribute</code>中。</p><pre><code class="hljs java"><span class="hljs-comment">// 得到数据</span>XXX xxx = <span class="hljs-keyword">new</span> XXX();ArrayList result = XXX.getResult();<span class="hljs-comment">// 封装数据</span>req.setAttribute(<span class="hljs-string">&quot;Style&quot;</span>,result);<span class="hljs-comment">// 实例化请求分派器</span>RequestDispatcher view = req.getRequestDispatcher(<span class="hljs-string">&quot;result.jsp&quot;</span>);view.forward(req, resp);</code></pre><h3 id="关于请求分发器RequestDispatcher"><a href="#关于请求分发器RequestDispatcher" class="headerlink" title="关于请求分发器RequestDispatcher"></a>关于请求分发器RequestDispatcher</h3><p><code>RequestDispatcher</code>只有两个方法<code>forward()</code>和<code>include()</code></p><p>一般来说，只会用到第一个。</p><p>得到<code>RequestDispatcher</code>的两种方法</p><pre><code class="hljs java"><span class="hljs-comment">// 通过Request获得,可以知道是哪一个servlet的，因此可以使用相对路径</span>requset.getRequestDispatcher(<span class="hljs-string">&quot;result.jsp&quot;</span>);<span class="hljs-comment">// 通过上下文获得，这种情况下servlet是不确定的，因此必须使用“/”开头</span>getSevletContext().getRequestDispatcher(<span class="hljs-string">&quot;/result.jsp&quot;</span>);</code></pre><h3 id="关于重定向和路径问题"><a href="#关于重定向和路径问题" class="headerlink" title="关于重定向和路径问题"></a>关于重定向和路径问题</h3><p>状态码301</p><p>要么自己响应，要么跳转，只能选其一，不能自己响应之后还去跳转，这个做法会报错。</p><p>往输出流写数据，调用用<code>outputStream.flush()</code>方法将导致响应，表示立即写出。</p><pre><code class="hljs java">response.sendRedirect(<span class="hljs-string">&quot;这是是url&quot;</span>);<span class="hljs-comment">// URL可以是绝对的，也可以是相对的</span><span class="hljs-comment">// URL使用相对地址的注意事项</span><span class="hljs-comment">// 如果使用不带斜杠开头，默认是同一个web应用路径下的</span><span class="hljs-comment">// 如果使用/开头表示新的WEB应用的路径</span></code></pre><h2 id="踩坑日记"><a href="#踩坑日记" class="headerlink" title="踩坑日记"></a>踩坑日记</h2><h3 id="1-缺少源码，直接去官网下一个zip回来即可"><a href="#1-缺少源码，直接去官网下一个zip回来即可" class="headerlink" title="1.缺少源码，直接去官网下一个zip回来即可"></a>1.缺少源码，直接去官网下一个zip回来即可</h3><p><a href="https://tomcat.apache.org/download-80.cgi">传送门</a></p><h3 id="在Web应用中怎么添加项目依赖包，或者说使用maven管理依赖？"><a href="#在Web应用中怎么添加项目依赖包，或者说使用maven管理依赖？" class="headerlink" title="在Web应用中怎么添加项目依赖包，或者说使用maven管理依赖？"></a>在Web应用中怎么添加项目依赖包，或者说使用maven管理依赖？</h3><ul><li>解决:使用maven项目模板<code>archetype-webapp</code>开发</li><li>参考:<a href="http://blog.csdn.net/myarrow/article/details/50824793">使用maven创建java web项目</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>01-Servlet</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Session&amp;Cookie</title>
    <link href="/01-Java/02-JavaEE/01-Servlet/02-Session&amp;Cookie/"/>
    <url>/01-Java/02-JavaEE/01-Servlet/02-Session&amp;Cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h1><h2 id="Cookie类"><a href="#Cookie类" class="headerlink" title="Cookie类"></a>Cookie类</h2><p>Cookie是Servlet API中的一部分</p><h3 id="Creating-a-new-Cookie"><a href="#Creating-a-new-Cookie" class="headerlink" title="Creating a new Cookie"></a>Creating a new Cookie</h3><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(“username”, name);</code></pre><h3 id="Setting-how-long-a-cookie-will-live-on-the-client"><a href="#Setting-how-long-a-cookie-will-live-on-the-client" class="headerlink" title="Setting how long a cookie will live on the client"></a>Setting how long a cookie will live on the client</h3><pre><code class="hljs java"><span class="hljs-comment">// 单位为秒</span>cookie.setMaxAge(<span class="hljs-number">30</span>*<span class="hljs-number">60</span>);</code></pre><h3 id="Sending-the-cookie-to-the-client"><a href="#Sending-the-cookie-to-the-client" class="headerlink" title="Sending the cookie to the client"></a>Sending the cookie to the client</h3><pre><code class="hljs java">response.addCookie(cookie);</code></pre><h3 id="Getting-the-cookie-s-from-the-client-request"><a href="#Getting-the-cookie-s-from-the-client-request" class="headerlink" title="Getting the cookie(s) from the client request"></a>Getting the cookie(s) from the client request</h3><pre><code class="hljs java">Cookie[] cookies = request.getCookies();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cookies.length; i++) &#123;        Cookie cookie = cookies[i];        <span class="hljs-keyword">if</span> (cookie.getName().equals(“username”)) &#123;            String userName = cookie.getValue();            out.println(“Hello “ + userName);        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p>通过上述的操作，就可以在客户主机上添加cookie信息，并设置了保存的时间长度。</p><pre><code class="hljs java">Cookie[] cookies = req.getCookies();<span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;        <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">&quot;usernamer&quot;</span>)) &#123;            String username = cookie.getValue();            <span class="hljs-comment">// 得到名字的处理逻辑</span>        &#125;    &#125;&#125;</code></pre><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>实现会话就是有状态服务。</p><p>由于请求时无状态的，HTTP请求不会长时间保持，也不能要求客户一定要登陆，用户的IP也不一定是唯一的。因此，需要一个唯一的会话ID，对于不持有ID的请求将返回一个ID，之后的请求带ID请求以认证同一个会话。</p><h3 id="在客户端，cookie就是用于存储会话信息的。"><a href="#在客户端，cookie就是用于存储会话信息的。" class="headerlink" title="在客户端，cookie就是用于存储会话信息的。"></a>在客户端，cookie就是用于存储会话信息的。</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在第一次响应中添加 --&gt;</span>Set-Cookie:JSESSIONID=asdasdasdasd<span class="hljs-comment">&lt;!-- 在第二次以后的请求中 --&gt;</span>Cookie:JSESSIONIS=asdasdasdasd</code></pre><h3 id="在服务端"><a href="#在服务端" class="headerlink" title="在服务端"></a>在服务端</h3><h4 id="你只要创建一个会话cookie就行了，发送Cooike"><a href="#你只要创建一个会话cookie就行了，发送Cooike" class="headerlink" title="你只要创建一个会话cookie就行了，发送Cooike"></a>你只要创建一个会话cookie就行了，发送Cooike</h4><pre><code class="hljs java">HttpSession session = request.getSession();</code></pre><p>就这样，cookie信息已经封装好，会自己响应给客户端</p><p>容器做了这些事情，你完全不用操心</p><ul><li>创建了HttpSession对象</li><li>生成了唯一的会话ID</li><li>创建了新的Cooike对象</li><li>关联Cookie对象和会话ID</li><li>在响应中设置Cooike信息</li></ul><h4 id="从请求中得到会话ID"><a href="#从请求中得到会话ID" class="headerlink" title="从请求中得到会话ID"></a>从请求中得到会话ID</h4><pre><code class="hljs java"><span class="hljs-comment">// 跟发送代码是一毛一样的</span>HttpSession session = request.getSession();</code></pre><h4 id="实际的代码要这么写"><a href="#实际的代码要这么写" class="headerlink" title="实际的代码要这么写"></a>实际的代码要这么写</h4><p>普通逻辑(常用)</p><pre><code class="hljs java">HttpSession session = request.getSession();<span class="hljs-keyword">if</span> (session.isNew()) &#123;    <span class="hljs-comment">// 新会话的逻辑</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 旧会话的逻辑</span>&#125;</code></pre><p>禁止创建新的会话的逻辑</p><pre><code class="hljs java">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 禁止创建会话，新的会话将会返回null</span><span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-comment">// 这是没有会话的</span>&#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 这是有会话的</span>&#125;</code></pre><h3 id="对于那些禁用了cookie的人类们"><a href="#对于那些禁用了cookie的人类们" class="headerlink" title="对于那些禁用了cookie的人类们"></a>对于那些禁用了cookie的人类们</h3><p>对于禁用了cookie信息是没人会告诉你的，也不会报任何的错</p><p>对于这种人，我们是这么做的—-拖出去灌屎</p><p>在URL的后面加上客户的SessionID</p><pre><code class="hljs java"><span class="hljs-comment">// 可以使用</span>response.encodeUrl(<span class="hljs-string">&quot;asdasd&quot;</span>);<span class="hljs-comment">// 来将原本的URL编码成带Id的样子，但是这样做是需要代码是动态生成的，这样是有代价的</span></code></pre><h3 id="什么时候关闭会话"><a href="#什么时候关闭会话" class="headerlink" title="什么时候关闭会话"></a>什么时候关闭会话</h3><p>Http可没有告诉我客户是不是睡着了。</p><p>会话有三种死法</p><ul><li>超时</li><li>你在代码中调用了invalide()</li><li>应用结束</li></ul><p>针对全局的设置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 这里的时间是分钟 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre><p>针对会话的设置</p><pre><code class="hljs java"><span class="hljs-comment">// 这里是以秒为单位</span><span class="hljs-comment">// 只有调用了这个方法的会话才会受到这个设置的影响</span>session.setMaxInactiveInterval(<span class="hljs-number">20</span>*<span class="hljs-number">60</span>);</code></pre><h2 id="里程碑和相应的监听器"><a href="#里程碑和相应的监听器" class="headerlink" title="里程碑和相应的监听器"></a>里程碑和相应的监听器</h2><h3 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h3><ul><li>创建会话</li><li>撤销会话</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 可用于统计会话创建数目，监听Web的活动</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHttpSessionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> activeSession;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getActiveSession</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> activeSession;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        activeSession++;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        activeSession--;    &#125;&#125;</code></pre><p>还需要在xml中配置listener-class属性</p><h3 id="HttpSessionAttritubeListener"><a href="#HttpSessionAttritubeListener" class="headerlink" title="HttpSessionAttritubeListener"></a>HttpSessionAttritubeListener</h3><ul><li>属性增加</li><li>属性删除</li><li>属性替换</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 监听会话的属性变化，并且可通过event获得name和value</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHttpSessionAttributeListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionAttributeListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeAdded</span><span class="hljs-params">(HttpSessionBindingEvent se)</span> </span>&#123;        String name = se.getName();        Object object = se.getValue();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeRemoved</span><span class="hljs-params">(HttpSessionBindingEvent se)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attributeReplaced</span><span class="hljs-params">(HttpSessionBindingEvent se)</span> </span>&#123;    &#125;&#125;</code></pre><p>还需要在xml中配置listener-class属性</p><h3 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h3><ul><li>会话准备钝化</li><li>会话已经激活</li></ul><p>对于分布式的集群的情况，只有<code>HttpSession</code>和它的<code>Attribute</code>会从一个VM迁移到另一个VM。<br>而<code>ServletConfig</code>和<code>ServletContext</code>是直接复制的，也就是说重复存在的。然而在集群中是单一存在的，需要迁移。从VM1中迁移出来叫做<strong>钝化</strong>，从VM2中<strong>激活</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionActivationListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionWillPassivate</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        <span class="hljs-comment">// 准备钝化代码</span>        <span class="hljs-comment">// 将非Serializable的字段设置为某种状态以便顺利迁移</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDidActivate</span><span class="hljs-params">(HttpSessionEvent se)</span> </span>&#123;        <span class="hljs-comment">// 代码用于恢复字段，反向钝化过程</span>    &#125;&#125;</code></pre><p>还需要在xml中配置listener-class属性</p><h3 id="还有一个HttpSessionBindingListener"><a href="#还有一个HttpSessionBindingListener" class="headerlink" title="还有一个HttpSessionBindingListener"></a>还有一个HttpSessionBindingListener</h3><p>用于监听Model是否被会话绑定和解绑，<strong>这个监听器无需在DD中注册</strong>，其他监听器需要注册。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionBindingListener</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">valueBound</span><span class="hljs-params">(HttpSessionBindingEvent event)</span> </span>&#123;        <span class="hljs-comment">// 在会话中时执行的代码</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">valueUnbound</span><span class="hljs-params">(HttpSessionBindingEvent event)</span> </span>&#123;        <span class="hljs-comment">// 离开会话是执行的代码</span>    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>01-Servlet</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-I18n国际化</title>
    <link href="/01-Java/02-JavaEE/99-Others/01-I18n%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <url>/01-Java/02-JavaEE/99-Others/01-I18n%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="I18n国际化"><a href="#I18n国际化" class="headerlink" title="I18n国际化"></a>I18n国际化</h1><p>i18n: Internationalization的简称</p><p>无需导入外部包，使用的是Java原生的ResourceBundle的概念实现的。</p><h2 id="Java使用"><a href="#Java使用" class="headerlink" title="Java使用"></a>Java使用</h2><p>引入多个国际化文件在<code>resources/i18n</code>目录下</p><p>messages.proerties</p><pre><code class="hljs properties"><span class="hljs-meta">error.title</span>=<span class="hljs-string">Your request cannot be processed</span></code></pre><p>messages_en.properties</p><pre><code class="hljs properties"><span class="hljs-meta">error.title</span>=<span class="hljs-string">Your request cannot be processed</span></code></pre><p>messages_zh_CN.properties</p><pre><code class="hljs properties"><span class="hljs-meta">error.title</span>=<span class="hljs-string">您的请求无法被处理</span></code></pre><p>I18nTest.java</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I18nTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        ResourceBundle resourceBundle;        resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">&quot;i18n/messages&quot;</span>, Locale.CHINA);        System.out.println(resourceBundle.getString(<span class="hljs-string">&quot;error.title&quot;</span>));    &#125;&#125;</code></pre><h2 id="Spring中使用"><a href="#Spring中使用" class="headerlink" title="Spring中使用"></a>Spring中使用</h2><p>application.yml</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">messages:</span>    <span class="hljs-attr">basename:</span> <span class="hljs-string">i18n/messages</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">I18nTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MessageSource messageSource;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 此方法的第二个参数，用于传递参数 name: &#123;0&#125; </span>        System.out.println(messageSource.getMessage(<span class="hljs-string">&quot;error.title&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;&#125;,Locale.CHINA));    &#125;&#125;</code></pre><p>Locale可以通过下述代码获得实时</p><p>自动从Request中获得配置</p><p>LocaleConfig.java</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocaleConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认解析器 其中locale表示默认语言</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;        SessionLocaleResolver localeResolver = <span class="hljs-keyword">new</span> SessionLocaleResolver();        localeResolver.setDefaultLocale(Locale.US);        <span class="hljs-keyword">return</span> localeResolver;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认拦截器 其中lang表示切换语言的参数名</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">localeInterceptor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;                LocaleChangeInterceptor localeInterceptor = <span class="hljs-keyword">new</span> LocaleChangeInterceptor();                localeInterceptor.setParamName(<span class="hljs-string">&quot;lang&quot;</span>);                registry.addInterceptor(localeInterceptor);            &#125;        &#125;;    &#125;&#125;</code></pre><p>获得实时的Locale</p><pre><code class="hljs java">LocaleContextHolder.getLocale()</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>02-JavaEE</category>
      
      <category>99-Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Dubbo的设计理念</title>
    <link href="/01-Java/05-MicroService/02-Dubbo/01-Dubbo%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/"/>
    <url>/01-Java/05-MicroService/02-Dubbo/01-Dubbo%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo的设计理念"><a href="#Dubbo的设计理念" class="headerlink" title="Dubbo的设计理念"></a>Dubbo的设计理念</h1><h2 id="网站进化史"><a href="#网站进化史" class="headerlink" title="网站进化史"></a>网站进化史</h2><p><img src="../images/2018-12-05-22-56-06.png"></p><ul><li>单一应用架构：简化增删改查工作量的数据访问框架(ORM)</li><li>垂直应用架构：将前后端和服务端分离开来，MVC是范例</li><li>分布式服务架构：分布式服务框架(RPC)提高业务复用 – 微服务</li><li>流动计算架构：资源调度和治理中心(SOA)实时调整集群中的容器</li></ul><h2 id="Dubbo能做的事"><a href="#Dubbo能做的事" class="headerlink" title="Dubbo能做的事"></a>Dubbo能做的事</h2><ol><li>服务注册和发现中心，统一URL配置和管理</li><li>自动重现复杂的依赖关系图</li><li>容器的动态权重调整</li></ol><h2 id="Dubbo的架构设计"><a href="#Dubbo的架构设计" class="headerlink" title="Dubbo的架构设计"></a>Dubbo的架构设计</h2><p>这张图一点都不难看懂，慢慢看</p><p><img src="../images/2018-12-05-23-13-14.png"></p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><ol start="0"><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址<strong>列表</strong>给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>02-Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-Nacos</title>
    <link href="/01-Java/05-MicroService/03-Nacos/01-Nacos/"/>
    <url>/01-Java/05-MicroService/03-Nacos/01-Nacos/</url>
    
    <content type="html"><![CDATA[<p><a href="https://nacos.io/zh-cn/">官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>03-Nacos</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-Dubbo的入门实战</title>
    <link href="/01-Java/05-MicroService/02-Dubbo/02-Dubbo%E7%9A%84%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"/>
    <url>/01-Java/05-MicroService/02-Dubbo/02-Dubbo%E7%9A%84%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo的实战"><a href="#Dubbo的实战" class="headerlink" title="Dubbo的实战"></a>Dubbo的实战</h1><h2 id="1-注册中心Zookeeper"><a href="#1-注册中心Zookeeper" class="headerlink" title="1. 注册中心Zookeeper"></a>1. 注册中心Zookeeper</h2><h3 id="1-1-zookeeper"><a href="#1-1-zookeeper" class="headerlink" title="1.1 zookeeper"></a>1.1 zookeeper</h3><p>已经有zookeeper在运行了，zookeeper将作为注册中心</p><ol><li><strong>提供者</strong>(provider)将到zookeeper中<code>注册</code>自己提供的服务</li><li><strong>消费者</strong>(consumer)将到zookeeper中<code>发现</code>自己需要的服务</li></ol><h2 id="2-创建一个服务提供者"><a href="#2-创建一个服务提供者" class="headerlink" title="2. 创建一个服务提供者"></a>2. 创建一个服务提供者</h2><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-2-添加provider配置文件"><a href="#2-2-添加provider配置文件" class="headerlink" title="2.2 添加provider配置文件"></a>2.2 添加<strong>provider</strong>配置文件</h3><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">dubbo-demo-server</span><span class="hljs-comment"># Base packages to scan Dubbo Component: @com.alibaba.dubbo.config.annotation.Service</span><span class="hljs-comment"># 定义扫描的服务的路径</span><span class="hljs-meta">dubbo.scan.basePackages</span>=<span class="hljs-string">com.cenzhongman.dubbo.demo.provider</span><span class="hljs-comment">## RegistryConfig Bean</span><span class="hljs-comment"># 这个服务在zookeeper中的组</span><span class="hljs-meta">dubbo.registry.id</span>=<span class="hljs-string">my-registry</span><span class="hljs-comment"># zookeeper的地址和IP</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://localhost:2181?client=curator</span><span class="hljs-meta">dubbo.application.qosEnable</span>=<span class="hljs-string">false</span></code></pre><h3 id="2-3-创建一个服务"><a href="#2-3-创建一个服务" class="headerlink" title="2.3 创建一个服务"></a>2.3 创建一个服务</h3><pre><code class="hljs java"><span class="hljs-comment">// 注意这里的Service是com.alibaba.dubbo.config.annotation.Service; version用于识别不同的版本的接口，提供者和消费者必须一致</span><span class="hljs-meta">@Service(version = &quot;1.0.0&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;    &#125;&#125;</code></pre><h3 id="2-4-Run-Application"><a href="#2-4-Run-Application" class="headerlink" title="2.4 Run Application"></a>2.4 Run Application</h3><pre><code class="hljs log">[DUBBO] The service ready on spring started. service: com.cenzhongman.dubbo.demo.DemoService, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Export dubbo service com.cenzhongman.dubbo.demo.DemoService to local registry, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Export dubbo service com.cenzhongman.dubbo.demo.DemoService to url dubbo:&#x2F;&#x2F;192.168.1.101:20880&#x2F;com.cenzhongman.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;dubbo-demo-server&amp;bind.ip&#x3D;192.168.1.101&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.cenzhongman.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;293964&amp;qos.enable&#x3D;false&amp;side&#x3D;provider&amp;timestamp&#x3D;1544112045900, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Register dubbo service com.cenzhongman.dubbo.demo.DemoService url dubbo:&#x2F;&#x2F;192.168.1.101:20880&#x2F;com.cenzhongman.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;dubbo-demo-server&amp;bind.ip&#x3D;192.168.1.101&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.cenzhongman.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;293964&amp;qos.enable&#x3D;false&amp;side&#x3D;provider&amp;timestamp&#x3D;1544112045900 to registry registry:&#x2F;&#x2F;localhost:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;dubbo-demo-server&amp;client&#x3D;curator&amp;dubbo&#x3D;2.6.2&amp;pid&#x3D;293964&amp;qos.enable&#x3D;false&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1544112045896, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Start NettyServer bind &#x2F;0.0.0.0:20880, export &#x2F;192.168.1.101:20880, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Load registry store file C:\Users\34566\.dubbo\dubbo-registry-dubbo-demo-server-localhost:2181.cache, data: &#123;com.cenzhongman.dubbo.demo.DemoService:1.0.0&#x3D;empty:&#x2F;&#x2F;192.168.1.101:20880&#x2F;com.cenzhongman.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;dubbo-demo-server&amp;category&#x3D;configurators&amp;check&#x3D;false&amp;dubbo&#x3D;2.6.2&amp;generic&#x3D;false&amp;interface&#x3D;com.cenzhongman.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;286984&amp;revision&#x3D;1.0.0&amp;side&#x3D;provider&amp;timestamp&#x3D;1544111680848&amp;version&#x3D;1.0.0&#125;, dubbo version: 2.6.2, current host: 192.168.1.101</code></pre><p>日志中可以见到在服务中心注册了<code>com.cenzhongman.dubbo.demo.DemoService</code>的<code>sayHello</code>方法，接口版本<code>1.0.0</code>，提供者的地址是<code>192.168.1.101:20880</code></p><p>20880为Dubbo的默认RPC通信端口</p><h2 id="3-创建一个服务消费者"><a href="#3-创建一个服务消费者" class="headerlink" title="3. 创建一个服务消费者"></a>3. 创建一个服务消费者</h2><h3 id="3-1-添加依赖"><a href="#3-1-添加依赖" class="headerlink" title="3.1 添加依赖"></a>3.1 添加依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="3-2-添加consumer配置文件"><a href="#3-2-添加consumer配置文件" class="headerlink" title="3.2 添加consumer配置文件"></a>3.2 添加<strong>consumer</strong>配置文件</h3><p>比服务提供者少了一些东西</p><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">dubbo-demo-client</span><span class="hljs-comment">## RegistryConfig Bean</span><span class="hljs-meta">dubbo.registry.id</span>=<span class="hljs-string">my-registry</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://localhost:2181?client=curator</span><span class="hljs-meta">dubbo.application.qosEnable</span>=<span class="hljs-string">false</span></code></pre><p>当然，一个程序既可以是提供者的同时也可以是消费者，因此提供者的配置可以作为消费者使用</p><h3 id="3-3-消费一个服务"><a href="#3-3-消费一个服务" class="headerlink" title="3.3 消费一个服务"></a>3.3 消费一个服务</h3><pre><code class="hljs java"><span class="hljs-comment">// 注意:1. 这个Service是一个SpringBoot的 Service 是Spring bean注解：org.springframework.stereotype.Service; Dubbo的注解@Service只能作为微服务提供，不能@Autowired</span><span class="hljs-comment">// 2. 也可以是Component，Component是Spring bean注解</span><span class="hljs-comment">// 2. 这里不能是Controller，Controller初始化时候不会初始化Reference中的内容，导致空指针异常 -- ***dubbo注解只会在spring bean中被识别***</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span></span>&#123;    <span class="hljs-comment">// version必须与提供者一致，url建议不写，会自己去zookeeper中找已经注册的服务，本地调试可以写一下，这样就不会找注册中心了</span>    <span class="hljs-meta">@Reference(version = &quot;1.0.0&quot;,url = &quot;dubbo://localhost:20880&quot;)</span>    <span class="hljs-keyword">private</span> DemoService demoService;<span class="hljs-comment">// 注意一定不能写static的</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> demoService.sayHello(<span class="hljs-string">&quot;Dubbo&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>注意：</p><ol><li>需要消费的服务必须和提供的服务是相同全限定名的</li><li>url是不必须的，注册中心将负责服务自动发现</li><li>version是唯一必须的，即使在配置文件中全局配置也需要填写</li></ol></blockquote><h3 id="3-4-Run-Application"><a href="#3-4-Run-Application" class="headerlink" title="3.4 Run Application"></a>3.4 Run Application</h3><pre><code class="hljs log">[DUBBO] Successed connect to server &#x2F;192.168.1.101:20880 from NettyClient 192.168.1.101 using dubbo version 2.6.2, channel is NettyChannel [channel&#x3D;[id: 0x27dc79f7, &#x2F;192.168.1.101:3732 &#x3D;&gt; &#x2F;192.168.1.101:20880]], dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Start NettyClient cen-Hpbook&#x2F;192.168.1.101 connect to the server &#x2F;192.168.1.101:20880, dubbo version: 2.6.2, current host: 192.168.1.101[DUBBO] Refer dubbo service com.cenzhongman.dubbo.demo.DemoService from url dubbo:&#x2F;&#x2F;localhost:20880&#x2F;com.cenzhongman.dubbo.demo.DemoService?application&#x3D;dubbo-demo-client&amp;dubbo&#x3D;2.6.2&amp;interface&#x3D;com.cenzhongman.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;8092&amp;qos.enable&#x3D;false&amp;register.ip&#x3D;192.168.1.101&amp;revision&#x3D;1.0.0&amp;side&#x3D;consumer&amp;timestamp&#x3D;1544113374113&amp;version&#x3D;1.0.0, dubbo version: 2.6.2, current host: 192.168.1.101</code></pre><p>日志说，我们成功连接到了<code>192.168.1.101:20880</code>，并且找到服务接口<code>interface=com.cenzhongman.dubbo.demo.DemoService</code>和方法<code>methods=sayHello</code></p><h2 id="值得一看的博客"><a href="#值得一看的博客" class="headerlink" title="值得一看的博客"></a>值得一看的博客</h2><p><a href="https://cloud.tencent.com/developer/article/1056200">Spring-boot:5分钟整合Dubbo构建分布式服务</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>02-Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-SpringBoot与Dubbo的区别</title>
    <link href="/01-Java/05-MicroService/01-SpringCloud/01-SpringBoot%E4%B8%8EDubbo%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/01-Java/05-MicroService/01-SpringCloud/01-SpringBoot%E4%B8%8EDubbo%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/scode2/p/8819944.html">Java 微服务框架选型（Dubbo 和 Spring Cloud？）</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>01-SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-SpringCloud入门实战</title>
    <link href="/01-Java/05-MicroService/01-SpringCloud/02-SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"/>
    <url>/01-Java/05-MicroService/01-SpringCloud/02-SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringClioud入门实战"><a href="#SpringClioud入门实战" class="headerlink" title="SpringClioud入门实战"></a>SpringClioud入门实战</h1><h2 id="1-服务注册中心eureka-server"><a href="#1-服务注册中心eureka-server" class="headerlink" title="1. 服务注册中心eureka-server"></a>1. 服务注册中心eureka-server</h2><p>Dubbo使用了Zookeeper作为服务注册中心，我们需要创建一个Zookeeper</p><p>SpringCloud支持<code>Netflix Eureka</code>、<code>Consul</code>、<code>Zookeeper</code>等，但不推荐使用zookeeper，而阿里也很快会抛弃Zookeeper了，改用<code>Nacos</code>，原因是看<a href="https://www.jianshu.com/p/87ef94edaf5a">这个</a>，简单来说，就是zookeeper在出现问题时不会返回服务列表，导致找不到服务</p><p>我们这里使用<code>Netflix Eureka</code>，Netflix Eureka也是一个SpringBoot应用</p><h3 id="1-1-添加pom-xml依赖"><a href="#1-1-添加pom-xml依赖" class="headerlink" title="1.1 添加pom.xml依赖"></a>1.1 添加<code>pom.xml</code>依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Greenwich.M3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 重点在这里 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><h3 id="1-2-添加Application-properties配置"><a href="#1-2-添加Application-properties配置" class="headerlink" title="1.2 添加Application.properties配置"></a>1.2 添加<code>Application.properties</code>配置</h3><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">eureka-server</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8761</span><span class="hljs-meta">eureka.instance.hostname</span>=<span class="hljs-string">localhost</span><span class="hljs-comment"># 禁用eureka的客户端注册行为</span><span class="hljs-meta">eureka.client.register-with-eureka</span>=<span class="hljs-string">false</span><span class="hljs-meta">eureka.client.fetch-registry</span>=<span class="hljs-string">false</span></code></pre><h3 id="1-3-在Application中注解-EnableEurekaServer"><a href="#1-3-在Application中注解-EnableEurekaServer" class="headerlink" title="1.3 在Application中注解@EnableEurekaServer"></a>1.3 在Application中注解@EnableEurekaServer</h3><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringcloudDemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(SpringcloudDemoApplication.class, args);    &#125;&#125;</code></pre><p>访问<a href="http://localhost:8761/">http://localhost:8761/</a></p><p>即可看到你的注册中心啦</p><p><img src="../images/2018-12-07-11-51-12.png"></p><h2 id="2-服务提供者eureka-provider"><a href="#2-服务提供者eureka-provider" class="headerlink" title="2. 服务提供者eureka-provider"></a>2. 服务提供者eureka-provider</h2><h3 id="2-1-pom-xml添加依赖"><a href="#2-1-pom-xml添加依赖" class="headerlink" title="2.1 pom.xml添加依赖"></a>2.1 <code>pom.xml</code>添加依赖</h3><p>同1.1</p><h3 id="2-2-添加Application-properties配置"><a href="#2-2-添加Application-properties配置" class="headerlink" title="2.2 添加Application.properties配置"></a>2.2 添加<code>Application.properties</code>配置</h3><pre><code class="hljs properties"><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">eureka-client</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-comment"># 注册中心的IP和Port &quot;eureka&quot;是默认路径，不能乱改</span><span class="hljs-meta">eureka.client.serviceUrl.defaultZone</span>=<span class="hljs-string">http://localhost:8761/eureka/</span></code></pre><h3 id="2-3-在Application说明这是一个服务提供者-EnableDiscoveryClient"><a href="#2-3-在Application说明这是一个服务提供者-EnableDiscoveryClient" class="headerlink" title="2.3 在Application说明这是一个服务提供者@EnableDiscoveryClient"></a>2.3 在Application说明这是一个服务提供者@EnableDiscoveryClient</h3><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootCloudProviderApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> SpringApplicationBuilder(                SpringBootCloudProviderApplication.class)                .web(<span class="hljs-keyword">true</span>).run(args);    &#125;&#125;</code></pre><h3 id="2-4-创建一个服务"><a href="#2-4-创建一个服务" class="headerlink" title="2.4 创建一个服务"></a>2.4 创建一个服务</h3><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HelloService helloService;    <span class="hljs-meta">@RequestMapping(&quot;/sayHello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> helloService.sayHello();    &#125;&#125;</code></pre><p>这玩意不是就是一个RestController吗，没错，这就是一个RestController 可以直接在外部通过<code>http://localhost:8081/sayHello</code>访问</p><h3 id="2-5-运行Application"><a href="#2-5-运行Application" class="headerlink" title="2.5 运行Application"></a>2.5 运行Application</h3><pre><code class="hljs log">Registered instance EUREKA-CLIENT&#x2F;cen-MibookPro.mshome.net:eureka-client:2001 with status UP (replication&#x3D;false)</code></pre><p>这个日志在会出现在1. eureka-provider 2. eureka-server</p><p>同时在界面上也会出现</p><p><img src="../images/2018-12-07-14-34-11.png"></p><h2 id="3-服务消费者eureka-consumer"><a href="#3-服务消费者eureka-consumer" class="headerlink" title="3. 服务消费者eureka-consumer"></a>3. 服务消费者eureka-consumer</h2><h3 id="3-1-添加pom-xml依赖"><a href="#3-1-添加pom-xml依赖" class="headerlink" title="3.1 添加pom.xml依赖"></a>3.1 添加<code>pom.xml</code>依赖</h3><p>同1.1</p><h3 id="3-2-添加Application-properties配置"><a href="#3-2-添加Application-properties配置" class="headerlink" title="3.2 添加Application.properties配置"></a>3.2 添加<code>Application.properties</code>配置</h3><p>同2.2</p><h3 id="3-3-在Application说明这是一个服务提供者-EnableDiscoveryClient"><a href="#3-3-在Application说明这是一个服务提供者-EnableDiscoveryClient" class="headerlink" title="3.3 在Application说明这是一个服务提供者@EnableDiscoveryClient"></a>3.3 在Application说明这是一个服务提供者@EnableDiscoveryClient</h3><p>同2.3</p><h3 id="3-4-消费一个服务"><a href="#3-4-消费一个服务" class="headerlink" title="3.4 消费一个服务"></a>3.4 消费一个服务</h3><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;    <span class="hljs-meta">@GetMapping(&quot;/consumer&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 在注册中心找名为&quot;eureka-client&quot;的服务提供者，loadBalancerClient将负责负载均衡</span>        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">&quot;eureka-client&quot;</span>);        <span class="hljs-comment">// 拼接URL</span>        String url = <span class="hljs-string">&quot;http://&quot;</span> + serviceInstance.getHost() + <span class="hljs-string">&quot;:&quot;</span> + serviceInstance.getPort() + <span class="hljs-string">&quot;/sayHello&quot;</span>;        <span class="hljs-comment">// 使用RestTemplate进行get请求返回对象</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate().getForObject(url, String.class);    &#125;&#125;</code></pre><p>这种方式将实现对象的传递，与Dubbo不同的是，SpringCloud使用的是Json的方式实现的对象传递，而Dubbo使用的序列化的技术，这样导致了SpringCloud在宽带的占用上稍大于Dubbo，但更加直观</p><h3 id="2-5-运行Application-1"><a href="#2-5-运行Application-1" class="headerlink" title="2.5 运行Application"></a>2.5 运行Application</h3><p>这样我们就消费成功了</p><h3 id="2-6-使用Ribbon作为负载均衡工具"><a href="#2-6-使用Ribbon作为负载均衡工具" class="headerlink" title="2.6 使用Ribbon作为负载均衡工具"></a>2.6 使用Ribbon作为负载均衡工具</h3><h4 id="2-6-1-添加依赖"><a href="#2-6-1-添加依赖" class="headerlink" title="2.6.1 添加依赖"></a>2.6.1 添加依赖</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="2-6-2-在Application中添加配置"><a href="#2-6-2-在Application中添加配置" class="headerlink" title="2.6.2 在Application中添加配置"></a>2.6.2 在Application中添加配置</h4><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre><h4 id="2-6-3-消费一个服务"><a href="#2-6-3-消费一个服务" class="headerlink" title="2.6.3 消费一个服务"></a>2.6.3 消费一个服务</h4><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@GetMapping(&quot;/ribbon&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">ribbon</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 通过反射获得对象</span>    <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://eureka-client/sayHello&quot;</span>, String.class);&#125;</code></pre><p>使用 Ribbon 的好处在于，Ribbon 会自动根据 生产者的服务名，在Eureka中找到对应的服务地址与端口。我们可以发现，这个写法短很多</p><h2 id="值得一看的博客"><a href="#值得一看的博客" class="headerlink" title="值得一看的博客"></a>值得一看的博客</h2><p><a href="https://cloud.tencent.com/developer/article/1056207">Spring-Boot:Spring Cloud构建微服务架构</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>01-SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-通过IDEA创建SpringCloud程序</title>
    <link href="/01-Java/05-MicroService/01-SpringCloud/03-%E9%80%9A%E8%BF%87IDEA%E5%88%9B%E5%BB%BASpringCloud%E7%A8%8B%E5%BA%8F/"/>
    <url>/01-Java/05-MicroService/01-SpringCloud/03-%E9%80%9A%E8%BF%87IDEA%E5%88%9B%E5%BB%BASpringCloud%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="通过IDEA创建Spring-Cloud程序"><a href="#通过IDEA创建Spring-Cloud程序" class="headerlink" title="通过IDEA创建Spring Cloud程序"></a>通过IDEA创建Spring Cloud程序</h1><p><img src="../images/2018-12-07-12-06-26.png"></p><p><img src="../images/2018-12-07-12-07-55.png"></p><p><img src="../images/2018-12-07-12-08-24.png"></p><p><img src="../images/2018-12-07-12-08-39.png"></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>01-SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-SpringRestTemplate</title>
    <link href="/01-Java/05-MicroService/01-SpringCloud/04-SpringRestTemplate/"/>
    <url>/01-Java/05-MicroService/01-SpringCloud/04-SpringRestTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring从RestAPI中生成类"><a href="#Spring从RestAPI中生成类" class="headerlink" title="Spring从RestAPI中生成类"></a>Spring从RestAPI中生成类</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol><li>使用<code>RestTemplate</code>对象进行一个get请求，它同时支持Post\Put\Delete等操作</li></ol><p><code>Test.java</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 从一个请求中将数据存储成对象</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();    <span class="hljs-comment">// 使用restTemplate进行一个get请求，它同时支持Post\Put\Delete等操作</span>    Object obj = restTemplate.getForObject(<span class="hljs-string">&quot;http://gturnquist-quoters.cfapps.io/api/random&quot;</span>, Object.class);    System.out.println(<span class="hljs-keyword">new</span> Gson().toJson(obj));&#125;</code></pre><h2 id="强化使用"><a href="#强化使用" class="headerlink" title="强化使用"></a>强化使用</h2><ol><li>配置类注解<code>@Configuration</code></li><li>注解<code>@Bean</code>，用于后面的注入做准备</li><li>注解<code>@Autowired</code>进行注入<code>RestTemplate restTemplate;</code></li><li>使用<code>restTemplate</code>进行花样请求</li></ol><p><code>RestTemplateConfig.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.http.client.ClientHttpRequestFactory;<span class="hljs-keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * RestTemplate配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">(ClientHttpRequestFactory factory)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(factory);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpRequestFactory <span class="hljs-title">simpleClientHttpRequestFactory</span><span class="hljs-params">()</span></span>&#123;        SimpleClientHttpRequestFactory factory = <span class="hljs-keyword">new</span> SimpleClientHttpRequestFactory();        factory.setReadTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span>        factory.setConnectTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span>        <span class="hljs-keyword">return</span> factory;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-comment">// get</span>JSONObject json = restTemplate.getForEntity(url, JSONObject.class);<span class="hljs-comment">// post</span>JSONObject json = restTemplate.postForEntity(url, postData, JSONObject.class);<span class="hljs-comment">// 设置请求头</span>HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();MediaType type = MediaType.parseMediaType(<span class="hljs-string">&quot;application/json; charset=UTF-8&quot;</span>);headers.setContentType(type);headers.add(<span class="hljs-string">&quot;Accept&quot;</span>, MediaType.APPLICATION_JSON.toString());JSONObject jsonObj = JSONObject.parseObject(paras);HttpEntity&lt;String&gt; formEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;String&gt;(jsonObj.toString(), headers);String result = restTemplate.postForObject(url, formEntity, String.class);</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>01-SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-consul-下载和安装</title>
    <link href="/01-Java/05-MicroService/04-Consul/01-consul-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <url>/01-Java/05-MicroService/04-Consul/01-consul-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="consul下载和安装"><a href="#consul下载和安装" class="headerlink" title="consul下载和安装"></a>consul下载和安装</h1><h2 id="下载consul"><a href="#下载consul" class="headerlink" title="下载consul"></a>下载consul</h2><pre><code class="hljs sh">wget https://releases.hashicorp.com/consul/1.5.0/consul_1.5.0_darwin_amd64.zip</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs sh"><span class="hljs-comment"># 解压，得到一个consul文件</span>unzip consul_1.5.0_darwin_amd64.zip<span class="hljs-comment"># 配置环境变量/软连接等方式变得可执行就好了,Mac如下</span>mv consul /usr/bin/consul</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="hljs sh">cenzhongman@MiBook-Pro:~$ consulUsage: consul [--version] [--<span class="hljs-built_in">help</span>] &lt;<span class="hljs-built_in">command</span>&gt; [&lt;args&gt;]Available commands are:    acl            Interact with Consul<span class="hljs-string">&#x27;s ACLs</span><span class="hljs-string">    agent          Runs a Consul agent</span><span class="hljs-string">    ...</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-consul运行</title>
    <link href="/01-Java/05-MicroService/04-Consul/02-consul%E8%BF%90%E8%A1%8C/"/>
    <url>/01-Java/05-MicroService/04-Consul/02-consul%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><ul><li>启动一个开发者模式的服务（单节点）</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># node 不指定的情况下，默认使用hostname，不能带有.</span>consul agent -dev [-node my-mac]==&gt; Starting Consul agent...==&gt; Consul agent running!           Version: <span class="hljs-string">&#x27;v1.5.0&#x27;</span>           Node ID: <span class="hljs-string">&#x27;1ce14793-5242-c689-397c-45e0cec57263&#x27;</span>         Node name: <span class="hljs-string">&#x27;my-mac&#x27;</span>        Datacenter: <span class="hljs-string">&#x27;dc1&#x27;</span> (Segment: <span class="hljs-string">&#x27;&lt;all&gt;&#x27;</span>)            Server: <span class="hljs-literal">true</span> (Bootstrap: <span class="hljs-literal">false</span>)       Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)           Encrypt: Gossip: <span class="hljs-literal">false</span>, TLS-Outgoing: <span class="hljs-literal">false</span>, TLS-Incoming: <span class="hljs-literal">false</span></code></pre><h2 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h2><pre><code class="hljs sh"><span class="hljs-comment"># 通过client查看成员</span>consul members [-detailed]Node    Address         Status  Type    Build  Protocol  DC   Segmentmy-mac  127.0.0.1:8301  alive   server  1.5.0  2         dc1  &lt;all&gt;<span class="hljs-comment"># 通过HTTP API查看成员</span>curl localhost:8500/v1/catalog/nodes[    &#123;        <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-string">&quot;1ce14793-5242-c689-397c-45e0cec57263&quot;</span>,        <span class="hljs-string">&quot;Node&quot;</span>: <span class="hljs-string">&quot;my-mac&quot;</span>,        <span class="hljs-string">&quot;Address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,        <span class="hljs-string">&quot;Datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,        <span class="hljs-string">&quot;TaggedAddresses&quot;</span>: &#123;            <span class="hljs-string">&quot;lan&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,            <span class="hljs-string">&quot;wan&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>        &#125;,        <span class="hljs-string">&quot;Meta&quot;</span>: &#123;            <span class="hljs-string">&quot;consul-network-segment&quot;</span>: <span class="hljs-string">&quot;&quot;</span>        &#125;,        <span class="hljs-string">&quot;CreateIndex&quot;</span>: 9,        <span class="hljs-string">&quot;ModifyIndex&quot;</span>: 10    &#125;]<span class="hljs-comment"># 通过DNS服务查看成员</span>dig @127.0.0.1 -p 8600 my-mac.node.consul;; ANSWER SECTION:my-mac.node.consul.0INA127.0.0.1</code></pre><p>通过访问UI来查看成员<a href="localhost:8500">sonsul-ui</a></p>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-consul-服务注册</title>
    <link href="/01-Java/05-MicroService/04-Consul/03-consul-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <url>/01-Java/05-MicroService/04-Consul/03-consul-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h1><h2 id="使用配置文件进行服务注册"><a href="#使用配置文件进行服务注册" class="headerlink" title="使用配置文件进行服务注册"></a>使用配置文件进行服务注册</h2><h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><ol><li>创建一个配置文件夹，在linux系统中认为<code>.d</code>是一组配置文件的意思<br><code>mkdir consul.d</code></li><li>创建一个配置文件,参考<a href="https://www.consul.io/api/agent/service.html">官方文档</a><br><code>echo &#39;&#123;&quot;service&quot;:&#123;&quot;name&quot;:&quot;web&quot;,&quot;tags&quot;:[&quot;rails&quot;],&quot;port&quot;:80&#125;&#125;&#39; &gt;&gt; consul.d/web.json</code></li><li>运行agent<br><code>consul agent -dev -config-dir=./consul.d -node=my-mac</code></li></ol><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><ol><li><p>通过<a href="localhost:8500">sonsul-ui</a>界面查询</p><p> <img src="../images/2019-05-09-11-27-01.png" alt="UI图片"></p></li><li><p>通过DNS API查询</p> <pre><code class="hljs sh"><span class="hljs-comment"># DNS中的域名规则为，NAME.service.consul，这是一条A记录</span>dig @127.0.0.1 -p 8600 web.service.consul;; ANSWER SECTION:web.service.consul.0INA127.0.0.1说明了web.service.consul指向127.0.0.1<span class="hljs-comment"># 通过SRV来对地址进行定位（会顺带返回A地址）</span>dig @127.0.0.1 -p 8600 web.service.consul SRV;; ANSWER SECTION:web.service.consul.0INSRV1 1 80 my-mac.node.dc1.consul.说明了web.service.consul 的80 端口是my-mac.node.dc1.consul这个节点上运行的;; ADDITIONAL SECTION:my-mac.node.dc1.consul.0INA127.0.0.1my-mac.node.dc1.consul.0INTXT<span class="hljs-string">&quot;consul-network-segment=&quot;</span>  <span class="hljs-comment"># 通过tag对服务进行查找，TAG.NAME.service.consul</span>dig @127.0.0.1 -p 8600 rails.web.service.consul;; QUESTION SECTION:;rails.web.service.consul.INA;; ANSWER SECTION:rails.web.service.consul. 0INA127.0.0.1</code></pre></li><li><p>通过HTTP API查询</p> <pre><code class="hljs sh"><span class="hljs-comment"># 查询节点</span>curl http://localhost:8500/v1/catalog/service/web[    &#123;        <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-string">&quot;3e6e76c2-9bde-fef5-8b8b-8ed83f17b52e&quot;</span>,        <span class="hljs-string">&quot;Node&quot;</span>: <span class="hljs-string">&quot;my-mac&quot;</span>,        <span class="hljs-string">&quot;Address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,        <span class="hljs-string">&quot;Datacenter&quot;</span>: <span class="hljs-string">&quot;dc1&quot;</span>,        <span class="hljs-string">&quot;TaggedAddresses&quot;</span>: &#123;            <span class="hljs-string">&quot;lan&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,            <span class="hljs-string">&quot;wan&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>        &#125;,        <span class="hljs-string">&quot;NodeMeta&quot;</span>: &#123;            <span class="hljs-string">&quot;consul-network-segment&quot;</span>: <span class="hljs-string">&quot;&quot;</span>        &#125;,        <span class="hljs-string">&quot;ServiceKind&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ServiceID&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>,        <span class="hljs-string">&quot;ServiceName&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>,        <span class="hljs-string">&quot;ServiceTags&quot;</span>: [            <span class="hljs-string">&quot;rails&quot;</span>        ],        <span class="hljs-string">&quot;ServiceAddress&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ServiceWeights&quot;</span>: &#123;            <span class="hljs-string">&quot;Passing&quot;</span>: 1,            <span class="hljs-string">&quot;Warning&quot;</span>: 1        &#125;,        <span class="hljs-string">&quot;ServiceMeta&quot;</span>: &#123;&#125;,        <span class="hljs-string">&quot;ServicePort&quot;</span>: 80,        <span class="hljs-string">&quot;ServiceEnableTagOverride&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;ServiceProxyDestination&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ServiceProxy&quot;</span>: &#123;&#125;,        <span class="hljs-string">&quot;ServiceConnect&quot;</span>: &#123;&#125;,        <span class="hljs-string">&quot;CreateIndex&quot;</span>: 10,        <span class="hljs-string">&quot;ModifyIndex&quot;</span>: 10    &#125;]<span class="hljs-comment"># 同时查询服务健康状态</span>curl <span class="hljs-string">&#x27;http://localhost:8500/v1/health/service/web?passing&#x27;</span><span class="hljs-string">&quot;Checks&quot;</span>: [    &#123;        <span class="hljs-string">&quot;Node&quot;</span>: <span class="hljs-string">&quot;my-mac&quot;</span>,        <span class="hljs-string">&quot;CheckID&quot;</span>: <span class="hljs-string">&quot;serfHealth&quot;</span>,        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Serf Health Status&quot;</span>,        <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;passing&quot;</span>,        <span class="hljs-string">&quot;Notes&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;Output&quot;</span>: <span class="hljs-string">&quot;Agent alive and reachable&quot;</span>,        <span class="hljs-string">&quot;ServiceID&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ServiceName&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ServiceTags&quot;</span>: [],        <span class="hljs-string">&quot;Definition&quot;</span>: &#123;&#125;,        <span class="hljs-string">&quot;CreateIndex&quot;</span>: 9,        <span class="hljs-string">&quot;ModifyIndex&quot;</span>: 9    &#125;]</code></pre></li></ol><h3 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h3><p>在修改配置之后，可以通过更新配置实现不停机重载</p><pre><code class="hljs sh">consul reload</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-consul-connect-TSL代理</title>
    <link href="/01-Java/05-MicroService/04-Consul/04-consul-connect-TSL%E4%BB%A3%E7%90%86/"/>
    <url>/01-Java/05-MicroService/04-Consul/04-consul-connect-TSL%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="sonsul-TSL-proxy"><a href="#sonsul-TSL-proxy" class="headerlink" title="sonsul TSL proxy"></a>sonsul TSL proxy</h1><p><strong>生产环境</strong>需要负载均衡，本节仅做实验参考，请参照<a href="https://www.consul.io/docs/guides/connect-production.html">Connect生产指南</a></p><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>consul提供了两个应用程序之间无感的TSL安全服务，通过代理实现安全校验</p><p><img src="../images/2019-05-09-11-59-55.png"></p><p>我们使用的两个应用程序为<code>socat</code>和<code>netcat</code>，他们本来是使用TCP进行通信的</p><p>不需要服务注册和发现的时候是这样的</p><pre><code class="hljs sh">socat -v tcp<span class="hljs-_">-l</span>:8181,fork <span class="hljs-built_in">exec</span>:<span class="hljs-string">&quot;/bin/cat&quot;</span>nc 127.0.0.1 8181Hello world!Hello world!</code></pre><h2 id="使用STL"><a href="#使用STL" class="headerlink" title="使用STL"></a>使用STL</h2><h3 id="每个组件启动的原始方式"><a href="#每个组件启动的原始方式" class="headerlink" title="每个组件启动的原始方式"></a>每个组件启动的原始方式</h3><ol><li><p>注册服务提供者<code>socat</code></p><p> 运行服务提供者</p> <pre><code class="hljs sh">socat -v tcp<span class="hljs-_">-l</span>:8181,fork <span class="hljs-built_in">exec</span>:<span class="hljs-string">&quot;/bin/cat&quot;</span></code></pre><p> 注册服务提供者</p> <pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;service&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;socat&quot;</span>,        <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">8181</span>,        <span class="hljs-attr">&quot;connect&quot;</span>: &#123;            <span class="hljs-attr">&quot;sidecar_service&quot;</span>: &#123;&#125;        &#125;    &#125;&#125;</code></pre><p> 这样就声明了要求一个<code>proxy</code>，socat-sidecar-proxy</p></li><li><p>提供一个sidecar proxy</p> <pre><code class="hljs sh">consul connect proxy -sidecar-for socat</code></pre></li><li><p>此时，我们可以看到socat依然在8181端口提供服务，还是没有加密</p> <pre><code class="hljs sh">nc 127.0.0.1 8181</code></pre></li><li><p>【与5冲突】创建一个本地代理服务，转发原来的socat =&gt; :9191</p> <pre><code class="hljs sh">consul connect proxy -service web -upstream socat:9191nc 127.0.0.1 9191</code></pre></li><li><p>【与4冲突】消费者服务</p><p> 可以通过注册一个消费者服务来消费TSL通信的服务，转发原来的socat =&gt; :9191</p> <pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;service&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>,        <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">8080</span>,        <span class="hljs-attr">&quot;connect&quot;</span>: &#123;        <span class="hljs-attr">&quot;sidecar_service&quot;</span>: &#123;            <span class="hljs-attr">&quot;proxy&quot;</span>: &#123;            <span class="hljs-attr">&quot;upstreams&quot;</span>: [&#123;                <span class="hljs-attr">&quot;destination_name&quot;</span>: <span class="hljs-string">&quot;socat&quot;</span>,                <span class="hljs-attr">&quot;local_bind_port&quot;</span>: <span class="hljs-number">9191</span>            &#125;]            &#125;        &#125;        &#125;    &#125;&#125;</code></pre></li></ol><h2 id="使用intention控制通断"><a href="#使用intention控制通断" class="headerlink" title="使用intention控制通断"></a>使用<code>intention</code>控制通断</h2><pre><code class="hljs sh"><span class="hljs-comment"># 创建intention，拒绝web链接到socat</span>consul intention create -deny web socat<span class="hljs-comment"># 删除intention</span>consul intention delete web socat</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06-consul-健康检查</title>
    <link href="/01-Java/05-MicroService/04-Consul/06-consul-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <url>/01-Java/05-MicroService/04-Consul/06-consul-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="consul健康检查"><a href="#consul健康检查" class="headerlink" title="consul健康检查"></a>consul健康检查</h1><p>consul支持多种健康检查</p><ol><li>脚本检查，需要在服务端开启<code>enable_script_checks=true</code></li><li>TTL健康检查</li></ol><h2 id="脚本检查"><a href="#脚本检查" class="headerlink" title="脚本检查"></a>脚本检查</h2><h3 id="主机级检查"><a href="#主机级检查" class="headerlink" title="主机级检查"></a>主机级检查</h3><p>定义一个主机级检查服务,</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;check&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;ping&quot;</span>,        <span class="hljs-attr">&quot;args&quot;</span>: [            <span class="hljs-string">&quot;ping&quot;</span>,<span class="hljs-string">&quot;-c1&quot;</span>,<span class="hljs-string">&quot;google.com&quot;</span>        ],        <span class="hljs-attr">&quot;interval&quot;</span>: <span class="hljs-string">&quot;30s&quot;</span>    &#125;&#125;</code></pre><h3 id="服务间健康检查"><a href="#服务间健康检查" class="headerlink" title="服务间健康检查"></a>服务间健康检查</h3><p>定义在</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;service&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>,        <span class="hljs-attr">&quot;tags&quot;</span>: [            <span class="hljs-string">&quot;rails&quot;</span>        ],        <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">80</span>,        <span class="hljs-attr">&quot;check&quot;</span>: &#123;            <span class="hljs-attr">&quot;args&quot;</span>: [                <span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;localhost&quot;</span>            ],            <span class="hljs-attr">&quot;interval&quot;</span>: <span class="hljs-string">&quot;10s&quot;</span>        &#125;    &#125;&#125;</code></pre><h3 id="查询健康检查"><a href="#查询健康检查" class="headerlink" title="查询健康检查"></a>查询健康检查</h3><pre><code class="hljs sh">curl http://localhost:8500/v1/health/state/critical[&#123;<span class="hljs-string">&quot;Node&quot;</span>:<span class="hljs-string">&quot;agent-two&quot;</span>,<span class="hljs-string">&quot;CheckID&quot;</span>:<span class="hljs-string">&quot;service:web&quot;</span>,<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-string">&quot;Service &#x27;web&#x27; check&quot;</span>,<span class="hljs-string">&quot;Status&quot;</span>:<span class="hljs-string">&quot;critical&quot;</span>,<span class="hljs-string">&quot;Notes&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;ServiceID&quot;</span>:<span class="hljs-string">&quot;web&quot;</span>,<span class="hljs-string">&quot;ServiceName&quot;</span>:<span class="hljs-string">&quot;web&quot;</span>,<span class="hljs-string">&quot;ServiceTags&quot;</span>:[<span class="hljs-string">&quot;rails&quot;</span>]&#125;]</code></pre><h2 id="TTL健康检查"><a href="#TTL健康检查" class="headerlink" title="TTL健康检查"></a>TTL健康检查</h2>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05-consul-集群模式</title>
    <link href="/01-Java/05-MicroService/04-Consul/05-consul-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/01-Java/05-MicroService/04-Consul/05-consul-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="consul集群模式"><a href="#consul集群模式" class="headerlink" title="consul集群模式"></a>consul集群模式</h1><h2 id="第一个节点-Server"><a href="#第一个节点-Server" class="headerlink" title="第一个节点(Server)"></a>第一个节点(Server)</h2><pre><code class="hljs sh">consul agent \    -server \    <span class="hljs-comment"># 以server模式运行</span>    -bootstrap-expect=1 \    <span class="hljs-comment"># 预期的服务数量（不包括自己），这个数量在达到之前，</span>    -data-dir=/tmp/consul \    -node=agent-one \    -<span class="hljs-built_in">bind</span>=172.20.20.10 \    <span class="hljs-comment"># 指定服务监听的地址</span>    -<span class="hljs-built_in">enable</span>-script-checks=<span class="hljs-literal">true</span> \    -config-dir=/etc/consul.d</code></pre><h2 id="第二个节点-Client"><a href="#第二个节点-Client" class="headerlink" title="第二个节点(Client)"></a>第二个节点(Client)</h2><pre><code class="hljs sh">consul agent \    -data-dir=/tmp/consul \    -node=agent-two \    -<span class="hljs-built_in">bind</span>=172.20.20.11 \    -<span class="hljs-built_in">enable</span>-script-checks=<span class="hljs-literal">true</span> \    -config-dir=/etc/consul.d \    -join=172.20.20.10    <span class="hljs-comment"># 配置自动加入集群的地址</span></code></pre><h2 id="手动加入集群"><a href="#手动加入集群" class="headerlink" title="手动加入集群"></a>手动加入集群</h2><pre><code class="hljs sh"><span class="hljs-comment"># server 加入 client</span>consul join 172.20.20.11</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07-consul-KV数据</title>
    <link href="/01-Java/05-MicroService/04-Consul/07-consul-KV%E6%95%B0%E6%8D%AE/"/>
    <url>/01-Java/05-MicroService/04-Consul/07-consul-KV%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="KV数据"><a href="#KV数据" class="headerlink" title="KV数据"></a>KV数据</h1><p>这是一个全局都能访问的键值对</p><pre><code class="hljs sh"><span class="hljs-comment"># put</span>consul kv put redis/config/minconns 1Success! Data written to: redis/config/minconns<span class="hljs-comment"># put with falg</span>consul kv put -flags=42 redis/config/users/admin abcd1234Success! Data written to: redis/config/users/admin<span class="hljs-comment"># get</span>consul kv get redis/config/minconns1<span class="hljs-comment"># delete</span>consul kv get redis/config/minconns<span class="hljs-comment"># 获取详细信息</span>consul kv get -detailed redis/config/users/adminCreateIndex      207Flags            42Key              redis/config/users/adminLockIndex        0ModifyIndex      207Session          -Value            abcd1234</code></pre><h2 id="recurse"><a href="#recurse" class="headerlink" title="-recurse"></a>-recurse</h2><pre><code class="hljs sh"><span class="hljs-comment"># get all</span>consul kv get -recurse<span class="hljs-comment"># delete 所有前缀相同的</span>consul kv delete -recurse redis</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-生产者</title>
    <link href="/01-Java/05-MicroService/04-Consul/11-%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <url>/01-Java/05-MicroService/04-Consul/11-%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h1 id="consul生产者"><a href="#consul生产者" class="headerlink" title="consul生产者"></a>consul生产者</h1><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>Application.java</p><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span></code></pre><p>XxxController.java</p><pre><code class="hljs java">正常写RestController就行</code></pre><p>application.yml</p><pre><code class="hljs java">spring:  cloud:    consul:      host: <span class="hljs-number">192.168</span>.<span class="hljs-number">10.82</span>      port: <span class="hljs-number">8500</span>      discovery:        service-name: company-server        healthCheckInterval: <span class="hljs-number">15</span>s        instance-id: company-server        heartbeat:          enabled: <span class="hljs-keyword">true</span>  application:    name: company-server</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10-consul-架构</title>
    <link href="/01-Java/05-MicroService/04-Consul/10-consul-%E6%9E%B6%E6%9E%84/"/>
    <url>/01-Java/05-MicroService/04-Consul/10-consul-%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="../images/2019-05-09-17-43-42.png"></p><p>这里对涉及到的概念进行解析</p><ul><li>agent: consul的应用程序的意思，能以Client/Server的形式运行，提供微服务的节点必须运行agent,进行服务发现、操作KV不需要运行agent</li><li>client: 客户端，能够作为节点的入口，进行服务注册的转发，自身状态检测等</li><li>server: 服务端，服务端提供主节点选举，数据交换，服务的注册等</li><li>datacenter: 在相同的网络环境下的一个集群，不同的数据中心能够通过互联网实现连接</li></ul>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-消费者</title>
    <link href="/01-Java/05-MicroService/04-Consul/12-%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <url>/01-Java/05-MicroService/04-Consul/12-%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    
    <content type="html"><![CDATA[<h1 id="consul消费者"><a href="#consul消费者" class="headerlink" title="consul消费者"></a>consul消费者</h1><p>其实使用的是</p><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>XxxService.java</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(serviceId = &quot;company-server&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConsumerService</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(value = &quot;/company/youpat/&#123;id&#125;&quot;, method = RequestMethod.GET)</span>    <span class="hljs-function">String <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;&#125;</code></pre><p>XxxController.java</p><pre><code class="hljs java">正常调用Service就好，可能会存在IDEA报Bean不存在异常</code></pre>]]></content>
    
    
    <categories>
      
      <category>01-Java</category>
      
      <category>05-MicroService</category>
      
      <category>04-Consul</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch-datanode.yml</title>
    <link href="/08-Elasticsearch/images/config/elasticsearch-datanode.yml/"/>
    <url>/08-Elasticsearch/images/config/elasticsearch-datanode.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># es分布式多节点的从节点配置文件</span><span class="hljs-comment"># 集群名，master和slave要相同</span><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">docker-cluster</span><span class="hljs-comment"># 节点名</span><span class="hljs-comment"># node.name: es-datanode</span><span class="hljs-comment"># 主节点</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># 不作为数据节点</span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 服务监听的范围，所有</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-comment"># 设置主节点的数量和主机</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># discovery.zen.ping.unicast.hosts: [&quot;es_master:9300&quot;]</span><span class="hljs-attr">gateway.recover_after_nodes:</span> <span class="hljs-number">2</span><span class="hljs-attr">gateway.recover_after_time:</span> <span class="hljs-string">5m</span><span class="hljs-attr">gateway.expected_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 搜索机制</span><span class="hljs-comment">#script.engine.groovy.inline.search: on</span><span class="hljs-comment">#script.engine.groovy.inline.aggs: on</span><span class="hljs-attr">indices.recovery.max_bytes_per_sec:</span> <span class="hljs-string">20mb</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>images</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch-master.yml</title>
    <link href="/08-Elasticsearch/images/config/elasticsearch-master.yml/"/>
    <url>/08-Elasticsearch/images/config/elasticsearch-master.yml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs yml"><span class="hljs-comment"># es分布式多节点的主节点配置文件</span><span class="hljs-comment"># 集群名，master和slave要相同</span><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">docker-cluster</span><span class="hljs-comment"># 节点名</span><span class="hljs-attr">node.name:</span> <span class="hljs-string">es-master</span><span class="hljs-comment"># 主节点</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 不作为数据节点</span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># 服务监听的范围，所有</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-comment"># 设置主节点的数量和主机</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment">#discovery.zen.ping.unicast.hosts: [&quot;es_datanode1:9300&quot;,&quot;es_datanode2:9300&quot;,&quot;es_datanode3:9300&quot;,&quot;es_master:9300&quot;]</span><span class="hljs-attr">gateway.recover_after_nodes:</span> <span class="hljs-number">2</span><span class="hljs-attr">gateway.recover_after_time:</span> <span class="hljs-string">5m</span><span class="hljs-attr">gateway.expected_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 搜索机制</span><span class="hljs-comment">#script.engine.groovy.inline.search: on</span><span class="hljs-comment">#script.engine.groovy.inline.aggs: on</span><span class="hljs-attr">indices.recovery.max_bytes_per_sec:</span> <span class="hljs-string">20mb</span><span class="hljs-comment"># 安全机制</span><span class="hljs-comment">## 允许跨域请求</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>08-Elasticsearch</category>
      
      <category>images</category>
      
      <category>config</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-神奇的变音</title>
    <link href="/99-Others/14-%E6%97%A5%E8%AF%AD/03-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%98%E9%9F%B3/"/>
    <url>/99-Others/14-%E6%97%A5%E8%AF%AD/03-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%98%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="神奇的变音"><a href="#神奇的变音" class="headerlink" title="神奇的变音"></a>神奇的变音</h1><h2 id="1-元音清化"><a href="#1-元音清化" class="headerlink" title="1. 元音清化"></a>1. 元音清化</h2><p>在一定条件下，元音保留口型和舌位但不发声</p><ul><li>原则<ul><li>元音<strong>い</strong>和<strong>う</strong>较容易发生清化</li><li>夹在<strong>“かさたはぱ”</strong>行中间的元音 如：きた kita い清化</li></ul></li></ul><table><thead><tr><th>元音未清化</th><th>元音清化</th></tr></thead><tbody><tr><td>かた【型】 kata （模型）</td><td>きた【北】 kita（北方）</td></tr><tr><td>かち【勝ち】kachi（胜利）</td><td>きち【基地】kichi（基地）</td></tr><tr><td>ほし【星】 hoshi（星星）</td><td>ふし【節】 fushi（节日）</td></tr><tr><td>せき【席】 seki （座位）</td><td>すき【好き】suki（喜欢）</td></tr></tbody></table><ul><li><p><strong>“かさたはぱ”</strong>行 <strong>い</strong>和<strong>う</strong>段结尾的元音</p><p>みます【見ます】mimasu（看）</p></li></ul><ul><li>发音变化举例</li></ul><p>すき【好き】suki（喜欢）<br>suki　→　ski</p><h2 id="2-清音浊化"><a href="#2-清音浊化" class="headerlink" title="2. 清音浊化"></a>2. 清音浊化</h2><p>做助词的时候，清音浊化。</p><p>助词在日语里是作为名词的体现 </p><h2 id="3-音调"><a href="#3-音调" class="headerlink" title="3. 音调"></a>3. 音调</h2><ul><li><p>原则</p><ul><li>第一个音节和第二个音节高低不同</li><li>一个单词要么没有下降 要么只有一处下降</li></ul></li><li><p>书写</p><ul><li><p>数字表记法 标记最后一个高读音节</p><pre><code class="hljs sh">あい　①</code></pre></li><li><p>横线表记法</p><pre><code class="hljs sh">＿　　あい</code></pre></li></ul></li></ul><p>在遇到下降后，就认为一个词结束了，复合词也只有一次下降</p><p>如：</p><pre><code class="hljs plain">にほんこ【日文】　きょういく【教育】にほんこきょういく【日文教育】</code></pre><h2 id="4-送气音-不送气音"><a href="#4-送气音-不送气音" class="headerlink" title="4. 送气音 不送气音"></a>4. 送气音 不送气音</h2><p>か　た　ぱ行根据位置不同有两种发音（自然发音就好）</p><ol><li><p>词头 送气音</p><p>かお「顔」　たこ「章魚」</p></li><li><p>词中或词尾 不送气音</p><p>つくえ「机」　たつ「立つ」</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>14-日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-openDial</title>
    <link href="/06-AI/01-NLP/04-FAQ/01-OnpenDial/01-openDial/"/>
    <url>/06-AI/01-NLP/04-FAQ/01-OnpenDial/01-openDial/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是OpenDial"><a href="#什么是OpenDial" class="headerlink" title="什么是OpenDial"></a>什么是OpenDial</h1><p><a href="http://www.opendial-toolkit.net/user-manual/getting-started">官方文档</a></p><p>OpenDial是一个开发对话系统的工具包，使用Java语言开发，架构上分为中央信息处理模块和外部插件</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="bin安装"><a href="#bin安装" class="headerlink" title="bin安装"></a>bin安装</h3><p>系统要求</p><ul><li>java</li><li>gradle/maven</li></ul><p><a href="http://www.opendial-toolkit.net/download">下载</a></p><p>解压，进入<code>scripts</code>执行可执行文件。。。</p><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>也可以使用源码编译，去<a href="https://github.com/plison/opendial">github</a>下载源码，使用<code>gradle</code></p><ol><li>安装好<code>gradle</code></li><li>运行<code>gradle compile</code>编译，这应该在几秒钟内编译源代码。您可以通过运行Opendial的单元测试来验证一切正常工作：</li><li>运行<code>gradle test</code>进行测试</li><li>编译完成后，您可以通过上述脚本（./scripts/opendial或。\scripts\opendial.bat）运行OpenDial 。  </li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="打开测试范例"><a href="#打开测试范例" class="headerlink" title="打开测试范例"></a>打开测试范例</h3><ul><li>新建文件<code>Domain &gt; new</code></li><li>打开范例<code>Domain &gt; Open File</code> -&gt; <code>domains/examples/example-step-by-step_fixed.xml</code></li></ul><p>界面有三个窗口<code>交互界面</code>,<code>状态监控器</code>,<code>域编辑器</code></p><p>在输入框输入<code>move left</code>，即可测试系统，在<code>状态监视器</code>里面看到的是<strong>贝叶斯网络</strong>，域编辑器存的是当前的XML文件</p><h3 id="设置记录的状态"><a href="#设置记录的状态" class="headerlink" title="设置记录的状态"></a>设置记录的状态</h3><blockquote><p>todo这是要干嘛</p></blockquote><p><code>Options &gt; Record Intermediate States</code></p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>04-FAQ</category>
      
      <category>01-OnpenDial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02-一个例子</title>
    <link href="/06-AI/01-NLP/04-FAQ/01-OnpenDial/02-%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <url>/06-AI/01-NLP/04-FAQ/01-OnpenDial/02-%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><ul><li>_u:User</li><li>_m:Machine</li><li>a:Action</li><li>u_u：用户对话</li><li>a_u：用户对话行为（也就是意图）</li><li>U_M：机器对话</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="第一个规则"><a href="#第一个规则" class="headerlink" title="第一个规则"></a>第一个规则</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">domain</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 定义一个模型，触发器为用户对话 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;u_u&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turn left&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 设置作用效用为1 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OK, turning left!&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span></code></pre><h3 id="带语言理解的模型"><a href="#带语言理解的模型" class="headerlink" title="带语言理解的模型"></a>带语言理解的模型</h3><p>上述代码只能实现精准匹配，我们知道肯定是不行的啦，下面展示的是猜测用户的意图 -&gt; 这样我们会得到a_u</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;u_u&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 增加 与和或 逻辑 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">condition</span> <span class="hljs-attr">operator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turn * left&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;contains&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;move * left&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;contains&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;go * left&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;contains&quot;</span>/&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 设置 用户动作 的概率为1 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">prob</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Request(Left)&quot;</span> /&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span></code></pre><h3 id="得到a-u之后，变成机器意识-gt-a-m"><a href="#得到a-u之后，变成机器意识-gt-a-m" class="headerlink" title="得到a_u之后，变成机器意识 -&gt; a_m"></a>得到a_u之后，变成机器意识 -&gt; a_m</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;a_u&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Request(Left)&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Move(Left)&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span></code></pre><h3 id="得到a-m之后，变成机器语言-gt-u-m"><a href="#得到a-m之后，变成机器语言-gt-u-m" class="headerlink" title="得到a_m之后，变成机器语言 -&gt; u_m"></a>得到a_m之后，变成机器语言 -&gt; u_m</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;a_m&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Move(Left)&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Ok, turning left!&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span></code></pre><h3 id="提高鲁棒性"><a href="#提高鲁棒性" class="headerlink" title="提高鲁棒性"></a>提高鲁棒性</h3><p>上文提到的所有概率都是1，这不科学啊（不然要这概率有何用）]</p><ul><li>批量配置概率</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 将所有的Move（*）动作的效用减少0.5，此时，高于概率的才会执行 机器动作 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;-0.5&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Move(*)&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre><ul><li>添加既定系统动作（请求复述）</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;0.2&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AskRepeat&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 为a_m添加u_m --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AskRepeat&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Sorry, could you repeat?&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre><h3 id="复述概率的问题"><a href="#复述概率的问题" class="headerlink" title="复述概率的问题"></a>复述概率的问题</h3><p>这时候有这种问题</p><p>问：左移（0.6）</p><p>答：请重复</p><p>问：左移（0.6）</p><p>这个时候再回复<code>请重复</code>就很智障了，所以,我们可以设置 下一个a_U(a_U^P) </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">model</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;a_m&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AskRepeat&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 我们评估出现这种情况的概率为95% --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">prob</span>=<span class="hljs-string">&quot;0.95&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!-- a_u^p：下一个用户动作  &#123;a_u&#125; 当前 用户动作 这个变量的值 --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_u^p&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;a_u&#125;&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">model</span>&gt;</span></code></pre><p>这里的语法的意思是说 我们设置用户说这句话再说一次的概率为95%？</p><p>//todo不知道这样理解是不是对的，有待考究</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_u&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Request(&#123;X&#125;)&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Move(&#123;X&#125;)&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre><p>这里的{X}是一个变量的意思</p><h3 id="使用更加严谨的参数"><a href="#使用更加严谨的参数" class="headerlink" title="使用更加严谨的参数"></a>使用更加严谨的参数</h3><p>我们这里使用的参数都是没经过科学验证的人工参数，这样是不合理的，这里可以使用均分和高斯分布、迪利克雷分布</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 高斯~N(0,5) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;theta_repeat&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">distrib</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;gaussian&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mean</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">mean</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">variance</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">variance</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">distrib</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">variable</span>&gt;</span><span class="hljs-comment">&lt;!-- 迪利克雷分布 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;theta_repeatpredict&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">distrib</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;dirichlet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">alpha</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">alpha</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">distrib</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">variable</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">util</span>=<span class="hljs-string">&quot;theta_repeat&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AskRepeat&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">case</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">condition</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AskRepeat&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">condition</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">effect</span> <span class="hljs-attr">prob</span>=<span class="hljs-string">&quot;theta_repeatpredict[0]&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;a_u^p&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;a_u&#125;&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">effect</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre><p>由于Dirichlets是多变量分布，所以第二个规则的参数必须对分布的维数（在这种情况下为第一维：[0]）进行索引。</p><h2 id="概率规则"><a href="#概率规则" class="headerlink" title="概率规则"></a>概率规则</h2><h3 id="1-概率规则"><a href="#1-概率规则" class="headerlink" title="1.概率规则"></a>1.概率规则</h3><p>P(O|I)</p><h3 id="2-效用规则"><a href="#2-效用规则" class="headerlink" title="2.效用规则"></a>2.效用规则</h3><p>U(A|I)</p>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>04-FAQ</category>
      
      <category>01-OnpenDial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03-机场例子</title>
    <link href="/06-AI/01-NLP/04-FAQ/01-OnpenDial/03-%E6%9C%BA%E5%9C%BA%E4%BE%8B%E5%AD%90/"/>
    <url>/06-AI/01-NLP/04-FAQ/01-OnpenDial/03-%E6%9C%BA%E5%9C%BA%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="机场例子"><a href="#机场例子" class="headerlink" title="机场例子"></a>机场例子</h1><h2 id="更高级的匹配"><a href="#更高级的匹配" class="headerlink" title="更高级的匹配"></a>更高级的匹配</h2><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义 包含 关系，符合正则使用 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;u_u&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;contains&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;(to|from)? &#123;Airport&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 定义 拥有 关系 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;Airport&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;in&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;[Oslo,Bergen,Trondheim, </span></span><span class="hljs-tag"><span class="hljs-string">    Stavanger,Moss,Sandefjord,Tromsø,Bodø,Kristiansand,Ålesund]&quot;</span>/&gt;</span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>06-AI</category>
      
      <category>01-NLP</category>
      
      <category>04-FAQ</category>
      
      <category>01-OnpenDial</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04-小李赴日</title>
    <link href="/99-Others/14-%E6%97%A5%E8%AF%AD/04-%E5%B0%8F%E6%9D%8E%E8%B5%B4%E6%97%A5/"/>
    <url>/99-Others/14-%E6%97%A5%E8%AF%AD/04-%E5%B0%8F%E6%9D%8E%E8%B5%B4%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="小李赴日"><a href="#小李赴日" class="headerlink" title="小李赴日"></a>小李赴日</h1><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>中国</td><td>ちゅうごく</td></tr><tr><td>中国人</td><td>ちゅうごくじん</td></tr><tr><td>日本</td><td>にほん</td></tr><tr><td>日本人</td><td>にほんじん</td></tr><tr><td>学生</td><td>がくせい</td></tr><tr><td>企画</td><td>きかく</td></tr><tr><td>社員</td><td>しゃいん</td></tr><tr><td>森</td><td>もり</td></tr><tr><td>林</td><td>はやし</td></tr><tr><td>李</td><td>り</td></tr></tbody></table><h2 id="肯定句"><a href="#肯定句" class="headerlink" title="肯定句"></a>肯定句</h2><blockquote><p>李さんは　中国人です<br>森さんは　学生では　あぃません　＝　森さんは　学生じゃないです<br>林さんは　日本人ですか<br>李さんは　JC企画の　社員です</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>99-Others</category>
      
      <category>14-日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的梦想是世界和平!</title>
    <link href="/99-Others/about/"/>
    <url>/99-Others/about/</url>
    
    <content type="html"><![CDATA[<html><body>    <script>Date.prototype.format = function (fmt) { var o = { "y+": this.getFullYear, "M+": this.getMonth() + 1, "d+": this.getDate(), "h+": this.getHours(), "m+": this.getMinutes(), "s+": this.getSeconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt; }; setInterval("document.getElementById('dateTime').innerHTML = (new Date()).format('yyyy-MM-dd hh:mm:ss');", 1000);</script>    <div id="board" style="background-color:#fff; margin: 0 auto; max-width: 1200px; ">        <p            style="position: relative; z-index: 1; background-color: #fff; margin: 0px auto; min-height: 135px; border-radius: 0.5rem;" />        <p style="position: relative; text-align: center; z-index: 2;font-size: 18px; margin: -68px auto;">数字的世界 很复杂            也很简单</p>        <div id="dateTime"            style="position: relative; text-align: center; font-size: 23px;  z-index: 2; margin: 10px auto;  ">        </div>        <div style="position: relative; max-width: 500px; margin: -430px auto 0 auto;transform:scale(0.80)">            <p></p><iframe name="I1" src="https://www.worldometers.info/cn/" height="3480" width="135%" border="0"                marginwidth="0" frameborder="no" marginheight="0" scrolling="no" allowtransparency="no"                 style="margin-left: -23%;"></iframe></p>            <div style="margin: 10% auto; text-align: center;"> <a                    href="https://www.worldometers.info/">Worldometers</a> </div>        </div>    </div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
